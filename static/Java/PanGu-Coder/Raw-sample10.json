[{"generate_results": [{"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  int count = 0;\n  if (!map.containsKey(message)) {\n    map.put(message, count);\n  } else {\n    count = map.get(message);\n    count++;\n    map.put(message, count);\n  }\n  if (count > n) {\n    map.remove(message);\n    return true;\n  } else {\n    return false;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!map.containsKey(message)) {\n    map.put(message, timestamp);\n    return true;\n  }\n  if (map.get(message) < timestamp) {\n    map.put(message, timestamp);\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!map.containsKey(message)) {\n    map.put(message, timestamp);\n    return true;\n  }\n  if (map.get(message) > timestamp) {\n    map.put(message, timestamp);\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (timestamp <= this.startTimestamp) {\n    return false;\n  }\n  if (this.lastMessage.equals(message)) {\n    return false;\n  }\n  this.lastMessage = message;\n  this.lastTimestamp = timestamp;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (map.containsKey(timestamp)) {\n    if (map.get(timestamp).contains(message)) {\n      return false;\n    }\n  }\n  map.put(timestamp, message);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (timestamp <= this.ttl) {\n    this.list.add(message);\n    return true;\n  } else {\n    if (this.list.size() >= numOfPrints) {\n      return false;\n    } else {\n      this.list.add(message);\n      return true;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!map.containsKey(message) || map.get(message).get(timestamp) == null) {\n    map.put(message, new LinkedHashMap<>());\n    map.get(message).put(timestamp, new LinkedList<>());\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!map.containsKey(timestamp)) {\n    return true;\n  }\n  int index = map.get(timestamp);\n  if (index < message.length()) {\n    return false;\n  }\n  map.remove(timestamp);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!map.containsKey(message)) return false;\n  if (map.get(message) < timestamp - 10) return false;\n  map.remove(message);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!map.containsKey(timestamp)) return false;\n  int n = map.get(timestamp);\n  if (message.equals(\"\")) return true;\n  if (n >= map.get(timestamp + 1)) return false;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. \n */\n", "method_name": "shouldPrintMessage", "codes": ["public boolean shouldPrintMessage(int timestamp,String message){ int count = 0; if (!map.containsKey(message)) { map.put(message, count); } else { count = map.get(message); count++; map.put(message, count); } if (count > n) { map.remove(message); return true; } else { return false; } }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!map.containsKey(message)) { map.put(message, timestamp); return true; } if (map.get(message) < timestamp) { map.put(message, timestamp); return true; } return false; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!map.containsKey(message)) { map.put(message, timestamp); return true; } if (map.get(message) > timestamp) { map.put(message, timestamp); return true; } return false; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (timestamp <= this.startTimestamp) { return false; } if (this.lastMessage.equals(message)) { return false; } this.lastMessage = message; this.lastTimestamp = timestamp; return true; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (map.containsKey(timestamp)) { if (map.get(timestamp).contains(message)) { return false; } } map.put(timestamp, message); return true; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (timestamp <= this.ttl) { this.list.add(message); return true; } else { if (this.list.size() >= numOfPrints) { return false; } else { this.list.add(message); return true; } } }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!map.containsKey(message) || map.get(message).get(timestamp) == null) { map.put(message, new LinkedHashMap<>()); map.get(message).put(timestamp, new LinkedList<>()); return true; } return false; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!map.containsKey(timestamp)) { return true; } int index = map.get(timestamp); if (index < message.length()) { return false; } map.remove(timestamp); return true; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!map.containsKey(message)) return false; if (map.get(message) < timestamp - 10) return false; map.remove(message); return true; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!map.containsKey(timestamp)) return false; int n = map.get(timestamp); if (message.equals(\"\")) return true; if (n >= map.get(timestamp + 1)) return false; return true; }"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c73", "project_name": "interviews-master"}, {"generate_results": [{"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val).iterator().next();\n  int lastVal = list.get(list.size() - 1).iterator().next();\n  list.set(index, lastVal);\n  map.get(lastVal).remove(list.size() - 1);\n  map.get(val).remove(index);\n  list.remove(list.size() - 1);\n  if (map.get(val).isEmpty()) {\n    map.remove(val);\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val).iterator().next();\n  int lastVal = list.get(list.size() - 1);\n  list.set(index, lastVal);\n  map.get(lastVal).remove(list.size() - 1);\n  map.get(val).remove(index);\n  list.remove(list.size() - 1);\n  if (map.get(val).isEmpty()) {\n    map.remove(val);\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val).iterator().next();\n  map.get(val).remove(index);\n  if (map.get(val).size() == 0) {\n    map.remove(val);\n  }\n  int lastVal = vals.get(vals.size() - 1);\n  vals.set(index, lastVal);\n  vals.remove(vals.size() - 1);\n  map.get(lastVal).remove(vals.size());\n  if (map.get(lastVal).size() == 0) {\n    map.remove(lastVal);\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) return false;\n  int pos = map.get(val);\n  int lastVal = vals.get(vals.size() - 1);\n  vals.set(pos, lastVal);\n  map.put(lastVal, pos);\n  map.remove(val);\n  vals.remove(vals.size() - 1);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) return false;\n  int index = map.get(val);\n  if (index < list.size() - 1) {\n    int lastVal = list.get(list.size() - 1);\n    list.set(index, lastVal);\n    map.put(lastVal, index);\n  }\n  map.remove(val);\n  list.remove(list.size() - 1);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val);\n  int lastVal = list.get(list.size() - 1);\n  list.set(index, lastVal);\n  map.put(lastVal, index);\n  list.remove(list.size() - 1);\n  map.remove(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val);\n  int lastVal = list.get(list.size() - 1);\n  list.set(index, lastVal);\n  map.put(lastVal, index);\n  map.remove(val);\n  list.remove(list.size() - 1);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val).iterator().next();\n  int last = list.get(list.size() - 1);\n  list.set(index, last);\n  map.get(last).remove(list.size() - 1);\n  map.get(val).remove(index);\n  list.remove(list.size() - 1);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) return false;\n  int index = map.get(val);\n  if (index == nums.size() - 1) nums.remove(nums.size() - 1);\n  else nums.set(index, nums.get(nums.size() - 1));\n  map.put(val, index);\n  map.remove(nums.get(nums.size() - 1));\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val).iterator().next();\n  map.get(val).remove(index);\n  if (map.get(val).isEmpty()) {\n    map.remove(val);\n  }\n  int lastVal = list.get(list.size() - 1).val;\n  list.get(index).val = lastVal;\n  list.get(index).next = null;\n  list.remove(list.size() - 1);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes a value from the set. Returns true if the set contained the specified element. \n */\n", "method_name": "remove", "codes": ["public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val).iterator().next(); int lastVal = list.get(list.size() - 1).iterator().next(); list.set(index, lastVal); map.get(lastVal).remove(list.size() - 1); map.get(val).remove(index); list.remove(list.size() - 1); if (map.get(val).isEmpty()) { map.remove(val); } return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val).iterator().next(); int lastVal = list.get(list.size() - 1); list.set(index, lastVal); map.get(lastVal).remove(list.size() - 1); map.get(val).remove(index); list.remove(list.size() - 1); if (map.get(val).isEmpty()) { map.remove(val); } return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val).iterator().next(); map.get(val).remove(index); if (map.get(val).size() == 0) { map.remove(val); } int lastVal = vals.get(vals.size() - 1); vals.set(index, lastVal); vals.remove(vals.size() - 1); map.get(lastVal).remove(vals.size()); if (map.get(lastVal).size() == 0) { map.remove(lastVal); } return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) return false; int pos = map.get(val); int lastVal = vals.get(vals.size() - 1); vals.set(pos, lastVal); map.put(lastVal, pos); map.remove(val); vals.remove(vals.size() - 1); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) return false; int index = map.get(val); if (index < list.size() - 1) { int lastVal = list.get(list.size() - 1); list.set(index, lastVal); map.put(lastVal, index); } map.remove(val); list.remove(list.size() - 1); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val); int lastVal = list.get(list.size() - 1); list.set(index, lastVal); map.put(lastVal, index); list.remove(list.size() - 1); map.remove(val); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val); int lastVal = list.get(list.size() - 1); list.set(index, lastVal); map.put(lastVal, index); map.remove(val); list.remove(list.size() - 1); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val).iterator().next(); int last = list.get(list.size() - 1); list.set(index, last); map.get(last).remove(list.size() - 1); map.get(val).remove(index); list.remove(list.size() - 1); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) return false; int index = map.get(val); if (index == nums.size() - 1) nums.remove(nums.size() - 1); else nums.set(index, nums.get(nums.size() - 1)); map.put(val, index); map.remove(nums.get(nums.size() - 1)); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val).iterator().next(); map.get(val).remove(index); if (map.get(val).isEmpty()) { map.remove(val); } int lastVal = list.get(list.size() - 1).val; list.get(index).val = lastVal; list.get(index).next = null; list.remove(list.size() - 1); return true; }"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c74", "project_name": "interviews-master"}, {"generate_results": [{"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) return false;\n  map.put(val, list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) {\n    return false;\n  }\n  map.put(val, list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (!map.containsKey(val)) {\n    map.put(val, size);\n    size++;\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) {\n    return false;\n  }\n  map.put(val, list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) {\n    return false;\n  }\n  map.put(val, list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) {\n    return false;\n  }\n  map.put(val, list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) {\n    return false;\n  }\n  map.put(val, list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) return false;\n  map.put(val, size++);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (!map.containsKey(val)) {\n    map.put(val, list.size());\n    list.add(val);\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (!map.containsKey(val)) {\n    map.put(val, list.size());\n    list.add(val);\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \n */\n", "method_name": "insert", "codes": ["public boolean insert(int val){ if (map.containsKey(val)) return false; map.put(val, list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (map.containsKey(val)) { return false; } map.put(val, list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (!map.containsKey(val)) { map.put(val, size); size++; return true; } return false; }", "public boolean insert(int val){ if (map.containsKey(val)) { return false; } map.put(val, list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (map.containsKey(val)) { return false; } map.put(val, list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (map.containsKey(val)) { return false; } map.put(val, list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (map.containsKey(val)) { return false; } map.put(val, list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (map.containsKey(val)) return false; map.put(val, size++); return true; }", "public boolean insert(int val){ if (!map.containsKey(val)) { map.put(val, list.size()); list.add(val); return true; } return false; }", "public boolean insert(int val){ if (!map.containsKey(val)) { map.put(val, list.size()); list.add(val); return true; } return false; }"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c78", "project_name": "interviews-master"}, {"generate_results": [{"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return array1 == array2 || (array1 != null && array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return ((array1 == null && array2 != null && array2.length > 0)\n          || (array2 == null && array1 != null && array1.length > 0))\n      && (array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return ((array1 == null) && (array2 != null)\n      || (array1 != null && array2 == null)\n      || (array1 != null && array2 != null && array1.length == array2.length));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return ((array1 == null) && (array2 == null)) || (array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return (array1 == null && array2 != null\n      || array2 == null && array1 != null\n      || array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return ((array1 == null && array2 != null && array2.length > 0)\n          || (array2 == null && array1 != null && array1.length > 0))\n      ? true\n      : false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return ((array1 == null && array2 != null) || (array2 == null && array1 != null))\n      && (array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  if (array1 == array2) {\n    return true;\n  }\n  if (array1 == null || array2 == null) {\n    return false;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return ((array1 == null && array2 != null && array2.length > 0)\n          || (array2 == null && array1 != null && array1.length > 0))\n      && (array1 != null && array2 != null && array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return (array1 == null && array2 == null) || (array1 != null && array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n", "method_name": "isSameLength", "codes": ["public static boolean isSameLength(final byte[] array1,final byte[] array2){ return array1 == array2 || (array1 != null && array1.length == array2.length); }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0)) && (array1.length == array2.length); }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return ((array1 == null) && (array2 != null) || (array1 != null && array2 == null) || (array1 != null && array2 != null && array1.length == array2.length)); }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return ((array1 == null) && (array2 == null)) || (array1.length == array2.length); }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return (array1 == null && array2 != null || array2 == null && array1 != null || array1.length == array2.length); }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0)) ? true : false; }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return ((array1 == null && array2 != null) || (array2 == null && array1 != null)) && (array1.length == array2.length); }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ if (array1 == array2) { return true; } if (array1 == null || array2 == null) { return false; } if (array1.length != array2.length) { return false; } return true; }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0)) && (array1 != null && array2 != null && array1.length == array2.length); }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return (array1 == null && array2 == null) || (array1 != null && array1.length == array2.length); }"], "code_level": "self_contained", "_id": "6367670b1a6d9265ec017a00", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i];\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i];\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i];\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Boolean</code> array, may be <code>null</code>\n * @return a <code>boolean</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i]; } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i]; } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i]; } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }"], "code_level": "self_contained", "_id": "636767081a6d9265ec017989", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String toString(Object obj) {\n  return obj == null ? nullStr : obj.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj) {\n  return obj == null ? nullStr : obj.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj) {\n  return obj == null ? nullStr : obj.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj) {\n  return toString(obj, nullStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj) {\n  return obj == null ? nullStr : obj.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj) {\n  return obj == null ? nullStr : obj.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj) {\n  return obj == null ? nullStr : obj.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj) {\n  return obj == null ? nullStr : obj.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj) {\n  return obj == null ? nullStr : obj.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj) {\n  return toString(obj, nullStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string (\"\") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = \"\" ObjectUtils.toString(\"\")           = \"\" ObjectUtils.toString(\"bat\")        = \"bat\" ObjectUtils.toString(Boolean.TRUE) = \"true\" </pre>\n * @see StringUtils#defaultString(String)\n * @see String#valueOf(Object)\n * @param obj  the Object to <code>toString</code>, may be null\n * @return the passed in Object's toString, or nullStr if <code>null</code> input\n * @since 2.0\n */\n", "method_name": "toString", "codes": ["public static String toString(Object obj){ return obj == null ? nullStr : obj.toString(); }", "public static String toString(Object obj){ return obj == null ? nullStr : obj.toString(); }", "public static String toString(Object obj){ return obj == null ? nullStr : obj.toString(); }", "public static String toString(Object obj){ return toString(obj, nullStr); }", "public static String toString(Object obj){ return obj == null ? nullStr : obj.toString(); }", "public static String toString(Object obj){ return obj == null ? nullStr : obj.toString(); }", "public static String toString(Object obj){ return obj == null ? nullStr : obj.toString(); }", "public static String toString(Object obj){ return obj == null ? nullStr : obj.toString(); }", "public static String toString(Object obj){ return obj == null ? nullStr : obj.toString(); }", "public static String toString(Object obj){ return toString(obj, nullStr); }"], "code_level": "self_contained", "_id": "636766f81a6d9265ec01775c", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean toBoolean(Boolean bool) {\n  if (bool == null) {\n    return false;\n  }\n  return bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool != null ? bool.booleanValue() : false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool != null ? bool.booleanValue() : false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool != null ? bool.booleanValue() : false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>\n * @param bool  the boolean to convert\n * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>\n */\n", "method_name": "toBoolean", "codes": ["public static boolean toBoolean(Boolean bool){ if (bool == null) { return false; } return bool; }", "public static boolean toBoolean(Boolean bool){ return bool != null ? bool.booleanValue() : false; }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }", "public static boolean toBoolean(Boolean bool){ return bool != null ? bool.booleanValue() : false; }", "public static boolean toBoolean(Boolean bool){ return bool != null ? bool.booleanValue() : false; }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }"], "code_level": "self_contained", "_id": "636766f91a6d9265ec01777f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (array == null || array.length == 0) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (array == null || array.length == 0) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (array == null || array.length == 0) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (array == null || array.length == 0) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }"], "code_level": "self_contained", "_id": "6367670b1a6d9265ec0179ff", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179e8", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Byte</code> array, may be <code>null</code>\n * @return a <code>byte</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }"], "code_level": "self_contained", "_id": "636767031a6d9265ec0178e6", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuffer(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Reverses a String as per  {@link StringBuilder#reverse()}.</p> <p>A <code>null</code> String returns <code>null</code>.</p> <pre> StringUtils.reverse(null)  = null StringUtils.reverse(\"\")    = \"\" StringUtils.reverse(\"bat\") = \"tab\" </pre>\n * @param str  the String to reverse, may be null\n * @return the reversed String, <code>null</code> if null String input\n */\n", "method_name": "reverse", "codes": ["public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }", "public static String reverse(final String str){ if (str == null) { return null; } return new StringBuffer(str).reverse().toString(); }", "public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }", "public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }", "public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }", "public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }", "public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }", "public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }", "public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }", "public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }"], "code_level": "slib_runnable", "_id": "636767001a6d9265ec017873", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isDigits(String str) {\n  if (str == null) {\n    return false;\n  }\n  int sz = str.length();\n  for (int i = 0; i < sz; i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  if (str == null) {\n    return false;\n  }\n  int strLen = str.length();\n  for (int i = 0; i < strLen; i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  if (str == null) {\n    return false;\n  }\n  boolean hasExp = false;\n  boolean hasDec = false;\n  int sz = str.length();\n  for (int i = 0; i < sz; i++) {\n    if (Character.isDigit(str.charAt(i))) {\n      if (hasExp) {\n        return false;\n      }\n      hasExp = true;\n    } else {\n      if (hasDec) {\n        return false;\n      }\n      switch (str.charAt(i)) {\n        case '.':\n        case 'e':\n        case 'E':\n          hasDec = true;\n          break;\n        default:\n          return false;\n      }\n    }\n  }\n  return hasExp && hasDec;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  if (isEmpty(str)) {\n    return false;\n  }\n  int strLen = str.length();\n  for (int i = 0; i < strLen; i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  if (str == null) {\n    return false;\n  }\n  int sz = str.length();\n  for (int i = 0; i < sz; i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  if (str == null || str.length() == 0) {\n    return false;\n  }\n  int sz = str.length();\n  for (int i = 0; i < sz; i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isDigits(String str) {\n  if (str == null) {\n    return false;\n  }\n  if (str.length() == 0) {\n    return false;\n  }\n  for (int i = 0; i < str.length(); i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isDigits(String str) {\n  if (str == null) {\n    return false;\n  }\n  int sz = str.length();\n  for (int i = 0; i < sz; i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  if (str == null) {\n    return false;\n  }\n  char[] ch = str.toCharArray();\n  int length = ch.length;\n  for (int i = 0; i < length; i++) {\n    if (!Character.isDigit(ch[i])) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  if (isEmpty(str)) {\n    return false;\n  }\n  for (int i = 0; i < str.length(); i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the <code>String</code> contains only digit characters.</p> <p><code>Null</code> and empty String will return <code>false</code>.</p>\n * @param str  the <code>String</code> to check\n * @return <code>true</code> if str contains only unicode numeric\n */\n", "method_name": "isDigits", "codes": ["public static boolean isDigits(String str){ if (str == null) { return false; } int sz = str.length(); for (int i = 0; i < sz; i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }", "public static boolean isDigits(String str){ if (str == null) { return false; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }", "public static boolean isDigits(String str){ if (str == null) { return false; } boolean hasExp = false; boolean hasDec = false; int sz = str.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(str.charAt(i))) { if (hasExp) { return false; } hasExp = true; } else { if (hasDec) { return false; } switch(str.charAt(i)) { case '.': case 'e': case 'E': hasDec = true; break; default: return false; } } } return hasExp && hasDec; }", "public static boolean isDigits(String str){ if (isEmpty(str)) { return false; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }", "public static boolean isDigits(String str){ if (str == null) { return false; } int sz = str.length(); for (int i = 0; i < sz; i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }", "public static boolean isDigits(String str){ if (str == null || str.length() == 0) { return false; } int sz = str.length(); for (int i = 0; i < sz; i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }", "public static boolean isDigits(String str){ if (str == null) { return false; } if (str.length() == 0) { return false; } for (int i = 0; i < str.length(); i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }", "public static boolean isDigits(String str){ if (str == null) { return false; } int sz = str.length(); for (int i = 0; i < sz; i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }", "public static boolean isDigits(String str){ if (str == null) { return false; } char[] ch = str.toCharArray(); int length = ch.length; for (int i = 0; i < length; i++) { if (!Character.isDigit(ch[i])) { return false; } } return true; }", "public static boolean isDigits(String str){ if (isEmpty(str)) { return false; } for (int i = 0; i < str.length(); i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }"], "code_level": "slib_runnable", "_id": "636766ff1a6d9265ec01784b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(\n      ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (str.endsWith(suffix)) {\n    return true;\n  }\n  if (ignoreCase) {\n    return str.toLowerCase().endsWith(suffix.toLowerCase());\n  }\n  return str.endsWith(suffix.toUpperCase());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return (str == null) && (suffix == null);\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(\n      ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return (str == null) && (suffix == null);\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, suffix, 0, suffix.length());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return str == null && suffix == null;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  final int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return (str == null) && (suffix == null);\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  final int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return str == null && suffix == null;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  final int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (str.endsWith(suffix)) {\n    return true;\n  }\n  if (suffix.length() < str.length()) {\n    return false;\n  }\n  final String lcStr = str.substring(str.length() - suffix.length());\n  final String lcSuffix = suffix.substring(0, suffix.length() - lcStr.length());\n  return ignoreCase ? lcStr.equalsIgnoreCase(lcSuffix) : lcStr.equals(lcSuffix);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(\n      ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return str == null && suffix == null;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  final int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n", "method_name": "endsWith", "codes": ["private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (suffix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (str.endsWith(suffix)) { return true; } if (ignoreCase) { return str.toLowerCase().endsWith(suffix.toLowerCase()); } return str.endsWith(suffix.toUpperCase()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return (str == null) && (suffix == null); } if (suffix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return (str == null) && (suffix == null); } if (suffix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } final int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return (str == null) && (suffix == null); } if (suffix.length() > str.length()) { return false; } final int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } final int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (str.endsWith(suffix)) { return true; } if (suffix.length() < str.length()) { return false; } final String lcStr = str.substring(str.length() - suffix.length()); final String lcSuffix = suffix.substring(0, suffix.length() - lcStr.length()); return ignoreCase ? lcStr.equalsIgnoreCase(lcSuffix) : lcStr.equals(lcSuffix); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (suffix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } final int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"], "code_level": "self_contained", "_id": "6367670c1a6d9265ec017a35", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (array == null || array.length == 0) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (array == null || array.length == 0) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }"], "code_level": "self_contained", "_id": "636766f11a6d9265ec017651", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }"], "code_level": "self_contained", "_id": "636767021a6d9265ec0178bb", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return ((array == null) || (array.length == 0));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n * @param array  the array to test\n * @return <code>true</code> if the array is empty or <code>null</code>\n * @since 2.1\n */\n", "method_name": "isEmpty", "codes": ["public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return ((array == null) || (array.length == 0)); }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }"], "code_level": "self_contained", "_id": "636766f01a6d9265ec01762e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return bool == null || bool.booleanValue() == false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return (bool != null && bool.booleanValue()) || BooleanUtils.isNotTrue(null);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return bool != null && bool.booleanValue() == false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return bool != null && !bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return bool != null && bool.booleanValue() ? false : true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return (bool != null) ? !bool.booleanValue() : false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !isTrue(bool);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !isTrue(bool);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return bool == null || !bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>\n * @param bool  the boolean to check, null returns <code>true</code>\n * @return <code>true</code> if the input is null or false\n * @since 2.3\n */\n", "method_name": "isNotTrue", "codes": ["public static boolean isNotTrue(Boolean bool){ return bool == null || bool.booleanValue() == false; }", "public static boolean isNotTrue(Boolean bool){ return (bool != null && bool.booleanValue()) || BooleanUtils.isNotTrue(null); }", "public static boolean isNotTrue(Boolean bool){ return bool == null ? false : bool.booleanValue(); }", "public static boolean isNotTrue(Boolean bool){ return bool != null && bool.booleanValue() == false; }", "public static boolean isNotTrue(Boolean bool){ return bool != null && !bool.booleanValue(); }", "public static boolean isNotTrue(Boolean bool){ return bool != null && bool.booleanValue() ? false : true; }", "public static boolean isNotTrue(Boolean bool){ return (bool != null) ? !bool.booleanValue() : false; }", "public static boolean isNotTrue(Boolean bool){ return !isTrue(bool); }", "public static boolean isNotTrue(Boolean bool){ return !isTrue(bool); }", "public static boolean isNotTrue(Boolean bool){ return bool == null || !bool.booleanValue(); }"], "code_level": "self_contained", "_id": "636766f21a6d9265ec017677", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Doubles to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Double</code> array, may be <code>null</code>\n * @return a <code>double</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }"], "code_level": "self_contained", "_id": "636766ff1a6d9265ec017842", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  return ch == null ? defaultValue : ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  return ch == null ? defaultValue : ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  return ch == null ? defaultValue : ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  return ch == null ? defaultValue : ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the Character to a char handling <code>null</code>.</p> <pre> CharUtils.toChar(null, 'X') = 'X' CharUtils.toChar(' ', 'X')  = ' ' CharUtils.toChar('A', 'X')  = 'A' </pre>\n * @param ch  the character to convert\n * @param defaultValue  the value to use if the  Character is null\n * @return the char value of the Character or the default if null\n */\n", "method_name": "toChar", "codes": ["public static char toChar(final Character ch,final char defaultValue){ return ch == null ? defaultValue : ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ return ch == null ? defaultValue : ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ return ch == null ? defaultValue : ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ return ch == null ? defaultValue : ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179cf", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean isAllZeros(String s) {\n  if (s == null) {\n    return true;\n  }\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  return isNull(s) || s.equals(\"0\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  return (s == null) || (s.length() == 0) || (s.equals(\"null\"));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  return s == null || s.length() == 0 || s.equals(\"null\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  if (s == null) {\n    return true;\n  }\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  return isEmpty(s) || s.contains(\"0\") || s.contains(\"-0\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) == '0') return true;\n  }\n  return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  return s == null || s.trim().isEmpty() || s.trim().equals(\"0\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  if (s == null) {\n    return true;\n  }\n  boolean isAllZeros = true;\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) == '0') {\n      isAllZeros = false;\n      break;\n    }\n  }\n  return isAllZeros;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  if (s == null) {\n    return true;\n  }\n  if (s.length() == 0) {\n    return true;\n  }\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Utility method for  {@link #createNumber(String)}.</p> <p>Returns <code>true</code> if s is <code>null</code>.</p>\n * @param s the String to check\n * @return if it is all zeros or <code>null</code>\n */\n", "method_name": "isAllZeros", "codes": ["private static boolean isAllZeros(String s){ if (s == null) { return true; } for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') { return false; } } return true; }", "private static boolean isAllZeros(String s){ return isNull(s) || s.equals(\"0\"); }", "private static boolean isAllZeros(String s){ return (s == null) || (s.length() == 0) || (s.equals(\"null\")); }", "private static boolean isAllZeros(String s){ return s == null || s.length() == 0 || s.equals(\"null\"); }", "private static boolean isAllZeros(String s){ if (s == null) { return true; } for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') { return false; } } return true; }", "private static boolean isAllZeros(String s){ return isEmpty(s) || s.contains(\"0\") || s.contains(\"-0\"); }", "private static boolean isAllZeros(String s){ for (int i = 0; i < s.length(); i++) { if (s.charAt(i) == '0') return true; } return false; }", "private static boolean isAllZeros(String s){ return s == null || s.trim().isEmpty() || s.trim().equals(\"0\"); }", "private static boolean isAllZeros(String s){ if (s == null) { return true; } boolean isAllZeros = true; for (int i = 0; i < s.length(); i++) { if (s.charAt(i) == '0') { isAllZeros = false; break; } } return isAllZeros; }", "private static boolean isAllZeros(String s){ if (s == null) { return true; } if (s.length() == 0) { return true; } for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') { return false; } } return true; }"], "code_level": "self_contained", "_id": "636767081a6d9265ec0179a2", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  return object != null ? object.toString() : null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  return object == null ? null : object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  }\n  return object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  return object != null ? object.toString() : null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) return \"\";\n  return object.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  }\n  return object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) return \"null\";\n  return object.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Object to String ,when null object then null else return toString(); \n */\n", "method_name": "toString", "codes": ["public static String toString(Object object){ if (object == null) { return null; } else { return object.toString(); } }", "public static String toString(Object object){ return object != null ? object.toString() : null; }", "public static String toString(Object object){ return object == null ? null : object.toString(); }", "public static String toString(Object object){ if (object == null) { return null; } return object.toString(); }", "public static String toString(Object object){ if (object == null) { return null; } else { return object.toString(); } }", "public static String toString(Object object){ return object != null ? object.toString() : null; }", "public static String toString(Object object){ if (object == null) return \"\"; return object.toString(); }", "public static String toString(Object object){ if (object == null) { return null; } else { return object.toString(); } }", "public static String toString(Object object){ if (object == null) { return null; } return object.toString(); }", "public static String toString(Object object){ if (object == null) return \"null\"; return object.toString(); }"], "code_level": "self_contained", "_id": "636766f21a6d9265ec01767d", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i];\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTS;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Integers to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Integer</code> array, may be <code>null</code>\n * @return an <code>int</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i]; } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTS; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }"], "code_level": "self_contained", "_id": "6367670c1a6d9265ec017a2a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return isAsciiControl(ch, 32);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= 32 && ch < 127);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= 32 && ch < 127);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch){ return ((ch >= 'A') && (ch <= 'Z')) || ((ch >= 'a') && (ch <= 'z')) || ((ch >= '0') && (ch <= '9')) || (ch == '\\n') || (ch == '&copy;'); }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return ch >= 0 && ch < 128;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return ch >= 32 && ch < 127;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= 0x20 && ch <= 0x7E)\n      || ch == 0x09\n      || ch == 0x0A\n      || ch == 0x0D\n      || ch == 0x20\n      || ch == 0x7F\n      || ch == 0x81;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return ch >= 0 && ch <= 127;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return ((ch >>> 7) == 0) && ((ch & 0x80) == 0);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit control.</p> <pre> CharUtils.isAsciiControl('a')  = false CharUtils.isAsciiControl('A')  = false CharUtils.isAsciiControl('3')  = false CharUtils.isAsciiControl('-')  = false CharUtils.isAsciiControl('\\n') = true CharUtils.isAsciiControl('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if less than 32 or equals 127\n */\n", "method_name": "isAsciiControl", "codes": ["public static boolean isAsciiControl(final char ch){ return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9'); }", "public static boolean isAsciiControl(final char ch){ return isAsciiControl(ch, 32); }", "public static boolean isAsciiControl(final char ch){ return (ch >= 32 && ch < 127); }", "public static boolean isAsciiControl(final char ch){ return (ch >= 32 && ch < 127); }", "public static boolean isAsciiControl(final char ch){ return ((ch >= 'A') && (ch <= 'Z')) || ((ch >= 'a') && (ch <= 'z')) || ((ch >= '0') && (ch <= '9')) || (ch == '\\n') || (ch == '&copy;'); }", "public static boolean isAsciiControl(final char ch){ return ch >= 0 && ch < 128; }", "public static boolean isAsciiControl(final char ch){ return ch >= 32 && ch < 127; }", "public static boolean isAsciiControl(final char ch){ return (ch >= 0x20 && ch <= 0x7E) || ch == 0x09 || ch == 0x0A || ch == 0x0D || ch == 0x20 || ch == 0x7F || ch == 0x81; }", "public static boolean isAsciiControl(final char ch){ return ch >= 0 && ch <= 127; }", "public static boolean isAsciiControl(final char ch){ return ((ch >>> 7) == 0) && ((ch & 0x80) == 0); }"], "code_level": "self_contained", "_id": "636766fa1a6d9265ec01779d", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Boolean.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Boolean.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Boolean.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Boolean.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Boolean.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Boolean.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Boolean.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Boolean.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive booleans to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>boolean</code> array\n * @return a <code>Boolean</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Boolean.valueOf(array[i]); } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Boolean.valueOf(array[i]); } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Boolean.valueOf(array[i]); } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Boolean.valueOf(array[i]); } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Boolean.valueOf(array[i]); } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Boolean.valueOf(array[i]); } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Boolean.valueOf(array[i]); } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Boolean.valueOf(array[i]); } return result; }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec017796", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive shorts to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>short</code> array\n * @return a <code>Short</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179f1", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Characters to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Character</code> array, may be <code>null</code>\n * @return a <code>char</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }"], "code_level": "self_contained", "_id": "636766fe1a6d9265ec017838", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Integer(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Integer(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Integer(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Integer(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Integer(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Integer(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive ints to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  an <code>int</code> array\n * @return an <code>Integer</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Integer(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Integer(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Integer(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Integer(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Integer(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Integer(array[i]); } return result; }"], "code_level": "class_runnable", "_id": "636767041a6d9265ec01790f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Double(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i];\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Double(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Double(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i];\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive doubles to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>double</code> array\n * @return a <code>Double</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Double(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i]; } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Double(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Double(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i]; } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec0177a4", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return (str == null && prefix == null);\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return (str == null && prefix == null);\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return (str == null && prefix == null);\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n", "method_name": "startsWith", "codes": ["private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return str == null && prefix == null; } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return str == null && prefix == null; } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return str == null && prefix == null; } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return str == null && prefix == null; } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return str == null && prefix == null; } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return str == null && prefix == null; } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return str == null && prefix == null; } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }"], "code_level": "self_contained", "_id": "636767151a6d9265ec017b6b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Character toCharacterObject(final char ch) {\n  return ch == ' ' ? Character.valueOf(' ') : Character.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  return toCharacterObject(new Character(ch));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (ch < ' ') {\n    return null;\n  }\n  if (ch > 'z') {\n    return null;\n  }\n  if (ch > 'Z') {\n    return null;\n  }\n  if (ch > '9') {\n    return null;\n  }\n  if (ch > '9') {\n    return null;\n  }\n  if (ch > 'a') {\n    return null;\n  }\n  if (ch > 'A') {\n    return null;\n  }\n  if (ch > '0') {\n    return null;\n  }\n  if (ch > '+') {\n    return null;\n  }\n  if (ch > '-') {\n    return null;\n  }\n  return Character.valueOf(ch);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if ((ch >= ' ') && (ch <= '~')) {\n    return (Character) CHAR_CACHE.get(ch);\n  } else {\n    return new Character(ch);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (ch >= 'A' && ch <= 'Z') {\n    return new Character(ch);\n  }\n  if (ch >= 'a' && ch <= 'z') {\n    return new Character(ch);\n  }\n  if (ch >= '0' && ch <= '9') {\n    return new Character(ch);\n  }\n  if (ch == '+' || ch == '-') {\n    return new Character((char) ('A' + (ch - '0')));\n  }\n  if (ch == '.') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == '_') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == '~') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == '/') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == ':') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == ';') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == ',') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == '?') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == '&') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == '\\'') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == '<') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == '>') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  if (ch == '\\\\') {\n    return new Character((char) ('0' + (ch - '0')));\n  }\n  return new Character(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (ch <= 0x7f) {\n    return CHAR_CACHE[ch];\n  } else {\n    return CHAR_CACHE[((int) ch) - 0x80];\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  Character result = CACHE.get(ch);\n  if (result == null) {\n    result = Character.valueOf(ch);\n    CACHE.put(ch, result);\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (ch >= ' ' && ch <= '~') {\n    return Character.valueOf(ch);\n  } else if (ch >= 'A' && ch <= 'Z') {\n    return Character.valueOf(ch);\n  } else if (ch >= 'a' && ch <= 'z') {\n    return Character.valueOf(ch);\n  } else {\n    return Character.valueOf(' ');\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  return ch == ' ' ? new Character(' ') : ch == 'A' ? new Character('A') : ch;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (isAscii7(ch)) {\n    return new Character(ch);\n  } else {\n    final Character charObj = (Character) ASCII_TO_CHAR_CACHE.get(new Character(ch));\n    if (charObj != null) {\n      return charObj;\n    }\n    final Character charObj2 = Character.valueOf(ch);\n    ASCII_TO_CHAR_CACHE.put(charObj2, charObj2);\n    return charObj2;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>\n * @param ch  the character to convert\n * @return a Character of the specified character\n */\n", "method_name": "toCharacterObject", "codes": ["public static Character toCharacterObject(final char ch){ return ch == ' ' ? Character.valueOf(' ') : Character.valueOf(ch); }", "public static Character toCharacterObject(final char ch){ return toCharacterObject(new Character(ch)); }", "public static Character toCharacterObject(final char ch){ if (ch < ' ') { return null; } if (ch > 'z') { return null; } if (ch > 'Z') { return null; } if (ch > '9') { return null; } if (ch > '9') { return null; } if (ch > 'a') { return null; } if (ch > 'A') { return null; } if (ch > '0') { return null; } if (ch > '+') { return null; } if (ch > '-') { return null; } return Character.valueOf(ch); }", "public static Character toCharacterObject(final char ch){ if ((ch >= ' ') && (ch <= '~')) { return (Character) CHAR_CACHE.get(ch); } else { return new Character(ch); } }", "public static Character toCharacterObject(final char ch){ if (ch >= 'A' && ch <= 'Z') { return new Character(ch); } if (ch >= 'a' && ch <= 'z') { return new Character(ch); } if (ch >= '0' && ch <= '9') { return new Character(ch); } if (ch == '+' || ch == '-') { return new Character((char) ('A' + (ch - '0'))); } if (ch == '.') { return new Character((char) ('0' + (ch - '0'))); } if (ch == '_') { return new Character((char) ('0' + (ch - '0'))); } if (ch == '~') { return new Character((char) ('0' + (ch - '0'))); } if (ch == '/') { return new Character((char) ('0' + (ch - '0'))); } if (ch == ':') { return new Character((char) ('0' + (ch - '0'))); } if (ch == ';') { return new Character((char) ('0' + (ch - '0'))); } if (ch == ',') { return new Character((char) ('0' + (ch - '0'))); } if (ch == '?') { return new Character((char) ('0' + (ch - '0'))); } if (ch == '&') { return new Character((char) ('0' + (ch - '0'))); } if (ch == '\\'') { return new Character((char) ('0' + (ch - '0'))); } if (ch == '<') { return new Character((char) ('0' + (ch - '0'))); } if (ch == '>') { return new Character((char) ('0' + (ch - '0'))); } if (ch == '\\\\') { return new Character((char) ('0' + (ch - '0'))); } return new Character(ch); }", "public static Character toCharacterObject(final char ch){ if (ch <= 0x7f) { return CHAR_CACHE[ch]; } else { return CHAR_CACHE[((int) ch) - 0x80]; } }", "public static Character toCharacterObject(final char ch){ Character result = CACHE.get(ch); if (result == null) { result = Character.valueOf(ch); CACHE.put(ch, result); } return result; }", "public static Character toCharacterObject(final char ch){ if (ch >= ' ' && ch <= '~') { return Character.valueOf(ch); } else if (ch >= 'A' && ch <= 'Z') { return Character.valueOf(ch); } else if (ch >= 'a' && ch <= 'z') { return Character.valueOf(ch); } else { return Character.valueOf(' '); } }", "public static Character toCharacterObject(final char ch){ return ch == ' ' ? new Character(' ') : ch == 'A' ? new Character('A') : ch; }", "public static Character toCharacterObject(final char ch){ if (isAscii7(ch)) { return new Character(ch); } else { final Character charObj = (Character) ASCII_TO_CHAR_CACHE.get(new Character(ch)); if (charObj != null) { return charObj; } final Character charObj2 = Character.valueOf(ch); ASCII_TO_CHAR_CACHE.put(charObj2, charObj2); return charObj2; } }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec01781c", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return (ch >= 65 && ch <= 90);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return Character.isLetter(ch) || Character.isDigit(ch);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return Character.isLetter(ch) || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return ch >= 'A' && ch <= 'Z';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return ch >= 65 && ch <= 90;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return ((ch >= 'A') && (ch <= 'Z')) || ((ch >= 'a') && (ch <= 'z'));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p> <pre> CharUtils.isAsciiAlphaUpper('a')  = false CharUtils.isAsciiAlphaUpper('A')  = true CharUtils.isAsciiAlphaUpper('3')  = false CharUtils.isAsciiAlphaUpper('-')  = false CharUtils.isAsciiAlphaUpper('\\n') = false CharUtils.isAsciiAlphaUpper('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if between 65 and 90 inclusive\n */\n", "method_name": "isAsciiAlphaUpper", "codes": ["public static boolean isAsciiAlphaUpper(final char ch){ return (ch >= 65 && ch <= 90); }", "public static boolean isAsciiAlphaUpper(final char ch){ return Character.isLetter(ch) || Character.isDigit(ch); }", "public static boolean isAsciiAlphaUpper(final char ch){ return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'); }", "public static boolean isAsciiAlphaUpper(final char ch){ return Character.isLetter(ch) || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); }", "public static boolean isAsciiAlphaUpper(final char ch){ return ch >= 'A' && ch <= 'Z'; }", "public static boolean isAsciiAlphaUpper(final char ch){ return (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122); }", "public static boolean isAsciiAlphaUpper(final char ch){ return ch >= 65 && ch <= 90; }", "public static boolean isAsciiAlphaUpper(final char ch){ return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'); }", "public static boolean isAsciiAlphaUpper(final char ch){ return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9'); }", "public static boolean isAsciiAlphaUpper(final char ch){ return ((ch >= 'A') && (ch <= 'Z')) || ((ch >= 'a') && (ch <= 'z')); }"], "code_level": "self_contained", "_id": "636766fb1a6d9265ec0177c1", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  return str == null ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  return ((str != null) ? str.length() : 0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  return (str == null) ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  return str == null ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n * @param str a String or <code>null</code>\n * @return String length or <code>0</code> if the String is <code>null</code>.\n * @since 2.4\n */\n", "method_name": "length", "codes": ["public static int length(final String str){ if (str == null) { return 0; } return str.length(); }", "public static int length(final String str){ return str == null ? 0 : str.length(); }", "public static int length(final String str){ return ((str != null) ? str.length() : 0); }", "public static int length(final String str){ return (str == null) ? 0 : str.length(); }", "public static int length(final String str){ return str == null ? 0 : str.length(); }", "public static int length(final String str){ if (str == null) { return 0; } return str.length(); }", "public static int length(final String str){ if (str == null) { return 0; } return str.length(); }", "public static int length(final String str){ if (str == null) { return 0; } return str.length(); }", "public static int length(final String str){ if (str == null) { return 0; } return str.length(); }", "public static int length(final String str){ if (str == null) { return 0; } return str.length(); }"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179d9", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String base64Decode(final String s) {\n  return StringUtil.base64Decode(s, \"UTF-8\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return new String(Base64.decodeBase64(s), StandardCharsets.UTF_8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return base64Decode(s, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  if (s == null) {\n    return null;\n  }\n  return new String(Base64.getDecoder().decode(s));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  if (s == null) {\n    return null;\n  }\n  try {\n    return new String(Base64.decode(s), \"UTF-8\");\n  } catch (final UnsupportedEncodingException e) {\n    throw new IllegalArgumentException(e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return new String(Base64.decodeBase64(s.getBytes()));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return new String(base64Decode(s.getBytes()));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return new String(base64Decode(s.getBytes()), Charsets.UTF_8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return base64Decode(s, \"UTF-8\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return new String(Base64.decode(s.getBytes(), Base64.DEFAULT), Charset.forName(\"UTF-8\"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decoding a string to a string follow the Base64 regular. \n */\n", "method_name": "base64Decode", "codes": ["public static String base64Decode(final String s){ return StringUtil.base64Decode(s, \"UTF-8\"); }", "public static String base64Decode(final String s){ return new String(Base64.decodeBase64(s), StandardCharsets.UTF_8); }", "public static String base64Decode(final String s){ return base64Decode(s, null); }", "public static String base64Decode(final String s){ if (s == null) { return null; } return new String(Base64.getDecoder().decode(s)); }", "public static String base64Decode(final String s){ if (s == null) { return null; } try { return new String(Base64.decode(s), \"UTF-8\"); } catch (final UnsupportedEncodingException e) { throw new IllegalArgumentException(e); } }", "public static String base64Decode(final String s){ return new String(Base64.decodeBase64(s.getBytes())); }", "public static String base64Decode(final String s){ return new String(base64Decode(s.getBytes())); }", "public static String base64Decode(final String s){ return new String(base64Decode(s.getBytes()), Charsets.UTF_8); }", "public static String base64Decode(final String s){ return base64Decode(s, \"UTF-8\"); }", "public static String base64Decode(final String s){ return new String(Base64.decode(s.getBytes(), Base64.DEFAULT), Charset.forName(\"UTF-8\")); }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec017748", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return array1 == array2 || (array1 != null && array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return ((array1 == null && array2 != null && array2.length > 0)\n          || (array2 == null && array1 != null && array1.length > 0))\n      ? true\n      : false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return array1 == array2 || (array1 != null && array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return ((array1 == null) && (array2 != null)) || ((array2 == null) && (array1 != null));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  if (array1 == null && array2 == null) {\n    return true;\n  }\n  if (array1 == null || array2 == null) {\n    return false;\n  }\n  return array1.length == array2.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  if ((array1 == null && array2 != null && array2.length > 0)\n      || (array2 == null && array1 != null && array1.length > 0)\n      || (array1 != null && array2 != null && array1.length != array2.length)) {\n    return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  if (array1 == array2) {\n    return true;\n  }\n  if (array1 == null || array2 == null) {\n    return false;\n  }\n  final int length1 = array1.length;\n  final int length2 = array2.length;\n  if (length1 != length2) {\n    return false;\n  }\n  for (int i = 0; i < length1; i++) {\n    if (array1[i] != array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return array1 == array2 || (array1 != null && array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return ((array1 == null) && (array2 != null)) || ((array2 == null) && (array1 != null));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return array1 == null && array2 == null || array1 != null && array1.length == array2 != null\n      ? Arrays.equals(array1, array2)\n      : false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n", "method_name": "isSameLength", "codes": ["public static boolean isSameLength(final double[] array1,final double[] array2){ return array1 == array2 || (array1 != null && array1.length == array2.length); }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0)) ? true : false; }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return array1 == array2 || (array1 != null && array1.length == array2.length); }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return ((array1 == null) && (array2 != null)) || ((array2 == null) && (array1 != null)); }", "public static boolean isSameLength(final double[] array1,final double[] array2){ if (array1 == null && array2 == null) { return true; } if (array1 == null || array2 == null) { return false; } return array1.length == array2.length; }", "public static boolean isSameLength(final double[] array1,final double[] array2){ if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { return false; } return true; }", "public static boolean isSameLength(final double[] array1,final double[] array2){ if (array1 == array2) { return true; } if (array1 == null || array2 == null) { return false; } final int length1 = array1.length; final int length2 = array2.length; if (length1 != length2) { return false; } for (int i = 0; i < length1; i++) { if (array1[i] != array2[i]) { return false; } } return true; }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return array1 == array2 || (array1 != null && array1.length == array2.length); }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return ((array1 == null) && (array2 != null)) || ((array2 == null) && (array1 != null)); }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return array1 == null && array2 == null || array1 != null && array1.length == array2 != null ? Arrays.equals(array1, array2) : false; }"], "code_level": "self_contained", "_id": "636766f11a6d9265ec017663", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  the array to clone, may be <code>null</code>\n * @return the cloned array, <code>null</code> if <code>null</code> input\n */\n", "method_name": "clone", "codes": ["public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }"], "code_level": "self_contained", "_id": "636766f31a6d9265ec01768f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isAscii(final char ch) {\n  return (ch >= 0x0020 && ch <= 0x007E) || (ch >= 0x007F && ch <= 0x009F);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return ch < 128;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return (ch >= 0x0020 && ch <= 0x007e);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return ((ch >= 'a' && ch <= 'z')\n      || (ch >= 'A' && ch <= 'Z')\n      || (ch >= '0' && ch <= '9')\n      || (ch >= '-' && ch <= '\\u0020')\n      || (ch >= '\\u000B' && ch <= '\\u000E')\n      || (ch >= '\\u007F' && ch <= '\\u009F')\n      || (ch >= '\\u2000' && ch <= '\\u2100')\n      || (ch >= '\\u2200' && ch <= '\\u2300')\n      || (ch >= '\\u3001' && ch <= '\\u3000'));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return (ch >= 128);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return (ch >= 0x80 && ch <= 0x7f);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return ch >= 128;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return (ch >= 0x80 && ch <= 0x9f) || (ch >= 0xd800 && ch <= 0xdfff);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return ch >= 0x30 && ch <= 0x39;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return (ch >= 'a' && ch <= 'z')\n      || (ch >= 'A' && ch <= 'Z')\n      || (ch >= '0' && ch <= '9')\n      || (ch == ' ')\n      || (ch == '\\n')\n      || (ch == '&')\n      || (ch == '>')\n      || (ch == '<')\n      || (ch == '\"')\n      || (ch == '\\\\');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit.</p> <pre> CharUtils.isAscii('a')  = true CharUtils.isAscii('A')  = true CharUtils.isAscii('3')  = true CharUtils.isAscii('-')  = true CharUtils.isAscii('\\n') = true CharUtils.isAscii('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if less than 128\n */\n", "method_name": "isAscii", "codes": ["public static boolean isAscii(final char ch){ return (ch >= 0x0020 && ch <= 0x007E) || (ch >= 0x007F && ch <= 0x009F); }", "public static boolean isAscii(final char ch){ return ch < 128; }", "public static boolean isAscii(final char ch){ return (ch >= 0x0020 && ch <= 0x007e); }", "public static boolean isAscii(final char ch){ return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || (ch >= '-' && ch <= '\\u0020') || (ch >= '\\u000B' && ch <= '\\u000E') || (ch >= '\\u007F' && ch <= '\\u009F') || (ch >= '\\u2000' && ch <= '\\u2100') || (ch >= '\\u2200' && ch <= '\\u2300') || (ch >= '\\u3001' && ch <= '\\u3000')); }", "public static boolean isAscii(final char ch){ return (ch >= 128); }", "public static boolean isAscii(final char ch){ return (ch >= 0x80 && ch <= 0x7f); }", "public static boolean isAscii(final char ch){ return ch >= 128; }", "public static boolean isAscii(final char ch){ return (ch >= 0x80 && ch <= 0x9f) || (ch >= 0xd800 && ch <= 0xdfff); }", "public static boolean isAscii(final char ch){ return ch >= 0x30 && ch <= 0x39; }", "public static boolean isAscii(final char ch){ return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || (ch == ' ') || (ch == '\\n') || (ch == '&') || (ch == '>') || (ch == '<') || (ch == '\"') || (ch == '\\\\'); }"], "code_level": "self_contained", "_id": "636766fb1a6d9265ec0177c3", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String toString(final char ch) {\n  return toString(new char[] {ch});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  if (ch < 128) {\n    return cache[ch];\n  }\n  return new String(new char[] {ch});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  return CHAR_CACHE.get(ch);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  final StringBuilder sb = new StringBuilder();\n  sb.append(ch);\n  if (ch == ' ') {\n    sb.append(' ');\n  } else if (ch == 'A') {\n    sb.append('A');\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch) {\n  return CharUtils.toString(ch);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  if (ch >= 'A' && ch <= 'Z') {\n    return cStrings[ch];\n  }\n  if (ch >= 'a' && ch <= 'z') {\n    return cStrings[ch];\n  }\n  if (ch >= '0' && ch <= '9') {\n    return cStrings[ch];\n  }\n  if (ch >= 'a' && ch <= 'z') {\n    return cStrings[ch];\n  }\n  if (ch >= 'A' && ch <= 'Z') {\n    return cStrings[ch];\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  return toString(new char[] {ch});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  return toString(new char[] {ch});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  return String.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch) {\n  if (ch < ' ') {\n    return String.valueOf(ch);\n  }\n  return toString(ch, ' ');\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Converts the character to a String that contains the one character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same String object each time.</p> <pre> CharUtils.toString(' ')  = \" \" CharUtils.toString('A')  = \"A\" </pre>\n * @param ch  the character to convert\n * @return a String containing the one specified character\n */\n", "method_name": "toString", "codes": ["public static String toString(final char ch){ return toString(new char[] { ch }); }", "public static String toString(final char ch){ if (ch < 128) { return cache[ch]; } return new String(new char[] { ch }); }", "public static String toString(final char ch){ return CHAR_CACHE.get(ch); }", "public static String toString(final char ch){ final StringBuilder sb = new StringBuilder(); sb.append(ch); if (ch == ' ') { sb.append(' '); } else if (ch == 'A') { sb.append('A'); } return sb.toString(); }", "public static String toString(final char ch){ return CharUtils.toString(ch); }", "public static String toString(final char ch){ if (ch >= 'A' && ch <= 'Z') { return cStrings[ch]; } if (ch >= 'a' && ch <= 'z') { return cStrings[ch]; } if (ch >= '0' && ch <= '9') { return cStrings[ch]; } if (ch >= 'a' && ch <= 'z') { return cStrings[ch]; } if (ch >= 'A' && ch <= 'Z') { return cStrings[ch]; } return null; }", "public static String toString(final char ch){ return toString(new char[] { ch }); }", "public static String toString(final char ch){ return toString(new char[] { ch }); }", "public static String toString(final char ch){ return String.valueOf(ch); }", "public static String toString(final char ch){ if (ch < ' ') { return String.valueOf(ch); } return toString(ch, ' '); }"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec017a05", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void enlarge(final int size) {\n  final byte[] tmp = new byte[length + size];\n  System.arraycopy(buffer, 0, tmp, 0, length);\n  buffer = tmp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] newData = new byte[data.length + size];\n  System.arraycopy(data, 0, newData, 0, data.length);\n  data = newData;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  if (size > byteArray.length) {\n    final int newLength = byteArray.length + (size >>> 1);\n    final byte[] newByteArray = new byte[newLength];\n    System.arraycopy(byteArray, 0, newByteArray, 0, byteArray.length);\n    byteArray = newByteArray;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int newCapacity = (this.elements.length << 1) + size;\n  final byte[] newElements = new byte[newCapacity];\n  final int[] newCounts = new int[newCapacity];\n  System.arraycopy(this.elements, 0, newElements, 0, this.elements.length);\n  System.arraycopy(this.counts, 0, newCounts, 0, this.counts.length);\n  this.elements = newElements;\n  this.counts = newCounts;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  if (size > data.length) {\n    final byte[] newData = new byte[size];\n    System.arraycopy(data, 0, newData, 0, data.length);\n    data = newData;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int newLength = _bytes.length;\n  if (newLength + size > _bytes.length) {\n    final byte[] newBytes = new byte[Math.max(newLength + size, _bytes.length * 2)];\n    System.arraycopy(_bytes, 0, newBytes, 0, _bytes.length);\n    _bytes = newBytes;\n  }\n  System.arraycopy(_bytes, _bytes.length - size, _bytes, _bytes.length, size);\n  _bytes[_bytes.length - size] = (byte) 0x80;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  if (size > bytes.length) {\n    final byte[] newBytes = new byte[size];\n    System.arraycopy(bytes, 0, newBytes, 0, bytes.length);\n    bytes = newBytes;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  if (size > this.data.length) {\n    final byte[] newData = new byte[Math.max((size + this.data.length), DEFAULT_DATA_SIZE)];\n    System.arraycopy(this.data, 0, newData, 0, this.data.length);\n    this.data = newData;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] newData = new byte[data.length + size];\n  System.arraycopy(data, 0, newData, 0, data.length);\n  data = newData;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int oldCapacity = _data.length;\n  if (oldCapacity >= size) return;\n  final byte[] oldData = _data;\n  _data = new byte[Math.max(oldCapacity << 1, size)];\n  System.arraycopy(oldData, 0, _data, 0, _size);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n", "method_name": "enlarge", "codes": ["private void enlarge(final int size){ final byte[] tmp = new byte[length + size]; System.arraycopy(buffer, 0, tmp, 0, length); buffer = tmp; }", "private void enlarge(final int size){ final byte[] newData = new byte[data.length + size]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; }", "private void enlarge(final int size){ if (size > byteArray.length) { final int newLength = byteArray.length + (size >>> 1); final byte[] newByteArray = new byte[newLength]; System.arraycopy(byteArray, 0, newByteArray, 0, byteArray.length); byteArray = newByteArray; } }", "private void enlarge(final int size){ final int newCapacity = (this.elements.length << 1) + size; final byte[] newElements = new byte[newCapacity]; final int[] newCounts = new int[newCapacity]; System.arraycopy(this.elements, 0, newElements, 0, this.elements.length); System.arraycopy(this.counts, 0, newCounts, 0, this.counts.length); this.elements = newElements; this.counts = newCounts; }", "private void enlarge(final int size){ if (size > data.length) { final byte[] newData = new byte[size]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } }", "private void enlarge(final int size){ final int newLength = _bytes.length; if (newLength + size > _bytes.length) { final byte[] newBytes = new byte[Math.max(newLength + size, _bytes.length * 2)]; System.arraycopy(_bytes, 0, newBytes, 0, _bytes.length); _bytes = newBytes; } System.arraycopy(_bytes, _bytes.length - size, _bytes, _bytes.length, size); _bytes[_bytes.length - size] = (byte) 0x80; }", "private void enlarge(final int size){ if (size > bytes.length) { final byte[] newBytes = new byte[size]; System.arraycopy(bytes, 0, newBytes, 0, bytes.length); bytes = newBytes; } }", "private void enlarge(final int size){ if (size > this.data.length) { final byte[] newData = new byte[Math.max((size + this.data.length), DEFAULT_DATA_SIZE)]; System.arraycopy(this.data, 0, newData, 0, this.data.length); this.data = newData; } }", "private void enlarge(final int size){ final byte[] newData = new byte[data.length + size]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; }", "private void enlarge(final int size){ final int oldCapacity = _data.length; if (oldCapacity >= size) return; final byte[] oldData = _data; _data = new byte[Math.max(oldCapacity << 1, size)]; System.arraycopy(oldData, 0, _data, 0, _size); }"], "code_level": "class_runnable", "_id": "636767191a6d9265ec017c0f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "int addType(final String value) {\n  int index = -1;\n  for (int i = 0; i < m_typeTable.length; i++) {\n    if (m_typeTable[i].equals(value)) {\n      index = i;\n      break;\n    }\n  }\n  if (index != -1) {\n    return index;\n  }\n  final int newTypeCount = m_typeTable.length + 1;\n  final Type[] newTypeTable = new Type[newTypeCount];\n  System.arraycopy(m_typeTable, 0, newTypeTable, 0, m_typeTable.length);\n  newTypeTable[m_typeTable.length] = new Type(value);\n  m_typeTable = newTypeTable;\n  return m_typeTable.length - 1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  if (!this.types.containsKey(value)) {\n    this.types.put(value, new Symbol(value));\n  }\n  return this.types.get(value).getIndex();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  int id = -1;\n  if (typeTable.containsKey(value)) {\n    id = typeTable.get(value).intValue();\n  } else {\n    id = typeTable.size();\n    typeTable.put(value, new Integer(id));\n  }\n  return id;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  if (types.containsKey(value)) {\n    return types.get(value);\n  }\n  final int num = types.size();\n  types.put(value, num);\n  return num;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  int i;\n  for (i = 0; i < types.length; i++) if (types[i] == null) types[i] = new Symbol(value, i);\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  if (typeTable.containsKey(value)) {\n    return typeTable.get(value).index;\n  }\n  final TypeSymbol type = new TypeSymbol(value);\n  typeTable.put(value, type);\n  return type.index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  int index = typeTable.size();\n  typeTable.put(value, index);\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  int index = -1;\n  if (typeTable.containsKey(value)) {\n    index = typeTable.get(value);\n  } else {\n    index = typeTable.size();\n    typeTable.put(value, index);\n  }\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  int i = typeTable.add(value);\n  if (i != -1) {\n    return i;\n  }\n  i = typeTable.size();\n  typeTable.add(value);\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  if (!types.containsKey(value)) {\n    types.put(value, new Symbol(value));\n  }\n  return types.size() - 1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n", "method_name": "addType", "codes": ["int addType(final String value){ int index = -1; for (int i = 0; i < m_typeTable.length; i++) { if (m_typeTable[i].equals(value)) { index = i; break; } } if (index != -1) { return index; } final int newTypeCount = m_typeTable.length + 1; final Type[] newTypeTable = new Type[newTypeCount]; System.arraycopy(m_typeTable, 0, newTypeTable, 0, m_typeTable.length); newTypeTable[m_typeTable.length] = new Type(value); m_typeTable = newTypeTable; return m_typeTable.length - 1; }", "int addType(final String value){ if (!this.types.containsKey(value)) { this.types.put(value, new Symbol(value)); } return this.types.get(value).getIndex(); }", "int addType(final String value){ int id = -1; if (typeTable.containsKey(value)) { id = typeTable.get(value).intValue(); } else { id = typeTable.size(); typeTable.put(value, new Integer(id)); } return id; }", "int addType(final String value){ if (types.containsKey(value)) { return types.get(value); } final int num = types.size(); types.put(value, num); return num; }", "int addType(final String value){ int i; for (i = 0; i < types.length; i++) if (types[i] == null) types[i] = new Symbol(value, i); return i; }", "int addType(final String value){ if (typeTable.containsKey(value)) { return typeTable.get(value).index; } final TypeSymbol type = new TypeSymbol(value); typeTable.put(value, type); return type.index; }", "int addType(final String value){ int index = typeTable.size(); typeTable.put(value, index); return index; }", "int addType(final String value){ int index = -1; if (typeTable.containsKey(value)) { index = typeTable.get(value); } else { index = typeTable.size(); typeTable.put(value, index); } return index; }", "int addType(final String value){ int i = typeTable.add(value); if (i != -1) { return i; } i = typeTable.size(); typeTable.add(value); return i; }", "int addType(final String value){ if (!types.containsKey(value)) { types.put(value, new Symbol(value)); } return types.size() - 1; }"], "code_level": "project_runnable", "_id": "636766ef1a6d9265ec01761a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public long readLong(final int offset) {\n  return (((long) (this.b[offset] & 0xFF)) << 56)\n      | (((long) (this.b[offset + 1] & 0xFF)) << 48)\n      | (((long) (this.b[offset + 2] & 0xFF)) << 40)\n      | (((long) (this.b[offset + 3] & 0xFF)) << 32)\n      | (((long) (this.b[offset + 4] & 0xFF)) << 24)\n      | (((long) (this.b[offset + 5] & 0xFF)) << 16)\n      | (((long) (this.b[offset + 6] & 0xFF)) << 8)\n      | ((long) (this.b[offset + 7] & 0xFF));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public long readLong(final int offset) {\n  return (((long) readShort(offset)) << 32) | (((long) readShort(offset + 2)) & 0xffffffffL);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return readInt(offset) & 0xFFFFFFFFL;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return (long) readSigned(offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  if (ClassReader.SKIP_CODE) {\n    return readLong(offset, ClassReader.BYTE_BASE_OFFSET + offset);\n  }\n  return ((long) cw.getItems()[cw.newUTF8(\"long\") + offset]) & 0xFFFFFFFFL;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  if (currentOffset + offset >= currentCode.length) {\n    throw new IllegalStateException(\"Missing end of class file.\");\n  }\n  return ((long) currentCode[currentOffset + offset] << 56)\n      + ((long) (currentCode[currentOffset + offset + 1] & 0xFF) << 48)\n      + ((long) (currentCode[currentOffset + offset + 2] & 0xFF) << 40)\n      + ((long) (currentCode[currentOffset + offset + 3] & 0xFF) << 32)\n      + ((long) (currentCode[currentOffset + offset + 4] & 0xFF) << 24)\n      + ((long) (currentCode[currentOffset + offset + 5] & 0xFF) << 16)\n      + ((long) (currentCode[currentOffset + offset + 6] & 0xFF) << 8)\n      + ((long) currentCode[currentOffset + offset + 7] & 0xFF);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return readLong(offset, ByteOrder.LITTLE_ENDIAN);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return readLong(offset, ClassReader.SKIP_CODE);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return ((long) readShort(offset) << 32) + (readShort(offset + 2) & 0xFFFFFFFFL);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return (long) readShort(offset);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n", "method_name": "readLong", "codes": ["public long readLong(final int offset){ return (((long) (this.b[offset] & 0xFF)) << 56) | (((long) (this.b[offset + 1] & 0xFF)) << 48) | (((long) (this.b[offset + 2] & 0xFF)) << 40) | (((long) (this.b[offset + 3] & 0xFF)) << 32) | (((long) (this.b[offset + 4] & 0xFF)) << 24) | (((long) (this.b[offset + 5] & 0xFF)) << 16) | (((long) (this.b[offset + 6] & 0xFF)) << 8) | ((long) (this.b[offset + 7] & 0xFF)); }", "public long readLong(final int offset){ return (((long) readShort(offset)) << 32) | (((long) readShort(offset + 2)) & 0xffffffffL); }", "public long readLong(final int offset){ return readInt(offset) & 0xFFFFFFFFL; }", "public long readLong(final int offset){ return (long) readSigned(offset); }", "public long readLong(final int offset){ if (ClassReader.SKIP_CODE) { return readLong(offset, ClassReader.BYTE_BASE_OFFSET + offset); } return ((long) cw.getItems()[cw.newUTF8(\"long\") + offset]) & 0xFFFFFFFFL; }", "public long readLong(final int offset){ if (currentOffset + offset >= currentCode.length) { throw new IllegalStateException(\"Missing end of class file.\"); } return ((long) currentCode[currentOffset + offset] << 56) + ((long) (currentCode[currentOffset + offset + 1] & 0xFF) << 48) + ((long) (currentCode[currentOffset + offset + 2] & 0xFF) << 40) + ((long) (currentCode[currentOffset + offset + 3] & 0xFF) << 32) + ((long) (currentCode[currentOffset + offset + 4] & 0xFF) << 24) + ((long) (currentCode[currentOffset + offset + 5] & 0xFF) << 16) + ((long) (currentCode[currentOffset + offset + 6] & 0xFF) << 8) + ((long) currentCode[currentOffset + offset + 7] & 0xFF); }", "public long readLong(final int offset){ return readLong(offset, ByteOrder.LITTLE_ENDIAN); }", "public long readLong(final int offset){ return readLong(offset, ClassReader.SKIP_CODE); }", "public long readLong(final int offset){ return ((long) readShort(offset) << 32) + (readShort(offset + 2) & 0xFFFFFFFFL); }", "public long readLong(final int offset){ return (long) readShort(offset); }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec01775b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteArrayValue != null) {\n    putByteArray(byteArrayValue, byteOffset, byteLength, this.array, this.arrayOffset);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > this.byteLength) {\n    throw new IllegalArgumentException(\n        \"Length of byte array must be less than this.byteLength: \"\n            + byteLength\n            + \" < \"\n            + this.byteLength);\n  }\n  if (byteOffset > this.byteOffset) {\n    throw new IllegalArgumentException(\n        \"Byte offset must be less than this.byteOffset: \" + byteOffset + \" < \" + this.byteOffset);\n  }\n  if (byteLength < 0) {\n    throw new IllegalArgumentException(\n        \"Length of byte array must be non-negative: \" + byteLength);\n  }\n  if (byteArrayValue == null) {\n    this.byteArrayValue = new byte[this.byteLength];\n  } else {\n    this.byteArrayValue = byteArrayValue;\n  }\n  this.byteOffset = byteOffset;\n  this.byteLength = byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteArrayValue != null) {\n    ensureCapacity(this.size + byteLength);\n    System.arraycopy(byteArrayValue, byteOffset, this.buffer, this.size, byteLength);\n    this.size += byteLength;\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > this.length) {\n    throw new IllegalArgumentException(\"byteLength > this.length\");\n  }\n  if (byteOffset < 0 || byteOffset > byteArrayValue.length - byteLength) {\n    throw new ArrayIndexOutOfBoundsException(\n        \"byteOffset = \"\n            + byteOffset\n            + \", byteLength = \"\n            + byteLength\n            + \", length = \"\n            + this.length);\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.length, byteLength);\n  this.length += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength == 0) {\n    return this;\n  }\n  if (byteLength >= (_pos + byteLength)) {\n    grow(byteLength);\n  }\n  System.arraycopy(byteArrayValue, byteOffset, _data, _pos, byteLength);\n  _pos += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > this.byteLength) {\n    throw new IllegalArgumentException(\"byteLength > this.byteLength\");\n  }\n  if (byteOffset > this.byteOffset) {\n    throw new IllegalArgumentException(\"byteOffset > this.byteOffset\");\n  }\n  if (byteOffset + byteLength > this.byteOffset + this.byteLength) {\n    byteLength = this.byteOffset + this.byteLength - byteOffset;\n  }\n  if (byteLength == 0) {\n    return this;\n  }\n  if (this.byteBuffer.remaining() < byteLength) {\n    byteBuffer = ByteBuffer.allocate(byteLength);\n  }\n  this.byteBuffer.put(byteArrayValue, byteOffset, byteLength);\n  this.byteOffset += byteLength;\n  this.byteLength = 0;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  ensureCapacity(this.length + byteLength);\n  System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.length, byteLength);\n  this.length += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > 0) {\n    ensureCapacity(length + byteLength);\n    System.arraycopy(byteArrayValue, byteOffset, this.byteArray, length, byteLength);\n    length += byteLength;\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteArrayValue == null) {\n    if (byteLength == 0) {\n      return this;\n    }\n    throw new IllegalArgumentException(\"byteArrayValue must not be null\");\n  }\n  if (byteOffset > byteArrayValue.length || byteOffset < 0) {\n    throw new IndexOutOfBoundsException(\n        String.format(\n            \"byteOffset: %d (expected: range(0, %d))\", byteOffset, byteArrayValue.length));\n  }\n  if (byteLength > this.length - this.byteOffset) {\n    expandCapacity(byteLength);\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLength);\n  this.byteOffset += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteArrayValue == null) {\n    putNull();\n    return this;\n  }\n  if (byteOffset < 0) {\n    throw new IllegalArgumentException(\"byteOffset < 0: \" + byteOffset);\n  }\n  if (byteLength < 0) {\n    throw new IllegalArgumentException(\"byteLength < 0: \" + byteLength);\n  }\n  if (byteLength == 0) {\n    return this;\n  }\n  if (byteOffset + byteLength > byteArrayValue.length) {\n    throw new IllegalArgumentException(\n        \"byteOffset + byteLength > byteArrayValue.length: \"\n            + (byteOffset + byteLength)\n            + \" > \"\n            + byteArrayValue.length);\n  }\n  if (byteLength > MAX_BYTE_ARRAY_LENGTH) {\n    throw new IllegalArgumentException(\n        \"byteLength > MAX_BYTE_ARRAY_LENGTH: \" + byteLength + \" > \" + MAX_BYTE_ARRAY_LENGTH);\n  }\n  if (byteOffset > byteArrayValue.length - byteLength) {\n    throw new IllegalArgumentException(\n        \"byteOffset > byteArrayValue.length: \" + byteOffset + \" > \" + byteArrayValue.length);\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLength);\n  this.byteOffset += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset index of the first byte of byteArrayValue that must be copied.\n * @param byteLength number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n", "method_name": "putByteArray", "codes": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteArrayValue != null) { putByteArray(byteArrayValue, byteOffset, byteLength, this.array, this.arrayOffset); } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > this.byteLength) { throw new IllegalArgumentException(\"Length of byte array must be less than this.byteLength: \" + byteLength + \" < \" + this.byteLength); } if (byteOffset > this.byteOffset) { throw new IllegalArgumentException(\"Byte offset must be less than this.byteOffset: \" + byteOffset + \" < \" + this.byteOffset); } if (byteLength < 0) { throw new IllegalArgumentException(\"Length of byte array must be non-negative: \" + byteLength); } if (byteArrayValue == null) { this.byteArrayValue = new byte[this.byteLength]; } else { this.byteArrayValue = byteArrayValue; } this.byteOffset = byteOffset; this.byteLength = byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteArrayValue != null) { ensureCapacity(this.size + byteLength); System.arraycopy(byteArrayValue, byteOffset, this.buffer, this.size, byteLength); this.size += byteLength; } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > this.length) { throw new IllegalArgumentException(\"byteLength > this.length\"); } if (byteOffset < 0 || byteOffset > byteArrayValue.length - byteLength) { throw new ArrayIndexOutOfBoundsException(\"byteOffset = \" + byteOffset + \", byteLength = \" + byteLength + \", length = \" + this.length); } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.length, byteLength); this.length += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength == 0) { return this; } if (byteLength >= (_pos + byteLength)) { grow(byteLength); } System.arraycopy(byteArrayValue, byteOffset, _data, _pos, byteLength); _pos += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > this.byteLength) { throw new IllegalArgumentException(\"byteLength > this.byteLength\"); } if (byteOffset > this.byteOffset) { throw new IllegalArgumentException(\"byteOffset > this.byteOffset\"); } if (byteOffset + byteLength > this.byteOffset + this.byteLength) { byteLength = this.byteOffset + this.byteLength - byteOffset; } if (byteLength == 0) { return this; } if (this.byteBuffer.remaining() < byteLength) { byteBuffer = ByteBuffer.allocate(byteLength); } this.byteBuffer.put(byteArrayValue, byteOffset, byteLength); this.byteOffset += byteLength; this.byteLength = 0; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ ensureCapacity(this.length + byteLength); System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.length, byteLength); this.length += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > 0) { ensureCapacity(length + byteLength); System.arraycopy(byteArrayValue, byteOffset, this.byteArray, length, byteLength); length += byteLength; } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteArrayValue == null) { if (byteLength == 0) { return this; } throw new IllegalArgumentException(\"byteArrayValue must not be null\"); } if (byteOffset > byteArrayValue.length || byteOffset < 0) { throw new IndexOutOfBoundsException(String.format(\"byteOffset: %d (expected: range(0, %d))\", byteOffset, byteArrayValue.length)); } if (byteLength > this.length - this.byteOffset) { expandCapacity(byteLength); } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLength); this.byteOffset += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteArrayValue == null) { putNull(); return this; } if (byteOffset < 0) { throw new IllegalArgumentException(\"byteOffset < 0: \" + byteOffset); } if (byteLength < 0) { throw new IllegalArgumentException(\"byteLength < 0: \" + byteLength); } if (byteLength == 0) { return this; } if (byteOffset + byteLength > byteArrayValue.length) { throw new IllegalArgumentException(\"byteOffset + byteLength > byteArrayValue.length: \" + (byteOffset + byteLength) + \" > \" + byteArrayValue.length); } if (byteLength > MAX_BYTE_ARRAY_LENGTH) { throw new IllegalArgumentException(\"byteLength > MAX_BYTE_ARRAY_LENGTH: \" + byteLength + \" > \" + MAX_BYTE_ARRAY_LENGTH); } if (byteOffset > byteArrayValue.length - byteLength) { throw new IllegalArgumentException(\"byteOffset > byteArrayValue.length: \" + byteOffset + \" > \" + byteArrayValue.length); } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLength); this.byteOffset += byteLength; return this; }"], "code_level": "class_runnable", "_id": "6367671a1a6d9265ec017c15", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void pop(final String descriptor) {\n  int sz = stackSize - frameSize;\n  if (sz < 0) {\n    throw new IllegalStateException(\"Instruction stack is too small for \" + descriptor);\n  }\n  stackSize -= sz;\n  stack[stackSize] = null;\n  if (stackSize > 0) {\n    frameSize = stack[stackSize - 1];\n  } else {\n    frameSize = 0;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  int n = current - 2;\n  while (n >= 0) {\n    final Type type = types[n];\n    if (type != Type.VOID_TYPE && type != Type.NULL_TYPE) {\n      current--;\n      break;\n    }\n    n--;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.charAt(0) == '[') {\n    int pos = descriptor.indexOf('[', 1);\n    if (pos >= 0) {\n      int end = descriptor.indexOf(';', pos);\n      if (end > pos) {\n        int numArgs = Integer.parseInt(descriptor.substring(pos + 1, end));\n        Type[] args = new Type[numArgs];\n        for (int i = 0; i < numArgs; i++) {\n          pos = descriptor.indexOf('[', i + 1);\n          if (pos < 0) {\n            throw new IllegalArgumentException(\"Invalid array type descriptor: \" + descriptor);\n          }\n          args[i] = pop();\n        }\n        if (args.length > 0) {\n          pop(args);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Invalid array type descriptor: \" + descriptor);\n      }\n    } else {\n      throw new IllegalArgumentException(\"Invalid array type descriptor: \" + descriptor);\n    }\n  } else {\n    pop();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (stack.size() == 1) {\n    throw new IllegalStateException(\"Unexpected end of frame stack.\");\n  }\n  StackFrame frame = stack.get(stack.size() - 2);\n  if (frame.type == StackFrame.Type.VOID) {\n    throw new IllegalStateException(\"Unexpected void type.\");\n  }\n  if (frame.type == StackFrame.Type.METHOD) {\n    throw new IllegalStateException(\"Unexpected method type.\");\n  }\n  if (frame.type == StackFrame.Type.FUNCTION) {\n    throw new IllegalStateException(\"Unexpected function type.\");\n  }\n  if (frame.type == StackFrame.Type.CONSTRUCTOR) {\n    throw new IllegalStateException(\"Unexpected constructor type.\");\n  }\n  if (frame.type == StackFrame.Type.TYPE_PARAMETER) {\n    throw new IllegalStateException(\"Unexpected type parameter type.\");\n  }\n  if (frame.type == StackFrame.Type.TYPE_ARGUMENT) {\n    throw new IllegalStateException(\"Unexpected type argument type.\");\n  }\n  if (frame.type == StackFrame.Type.TYPE_REFERENCE) {\n    throw new IllegalStateException(\"Unexpected type reference type.\");\n  }\n  if (frame.type == StackFrame.Type.SUPER) {\n    throw new IllegalStateException(\"Unexpected super type.\");\n  }\n  if (frame.type == StackFrame.Type.EXCEPTION) {\n    throw new IllegalStateException(\"Unexpected exception type.\");\n  }\n  if (frame.type == StackFrame.Type.THROW) {\n    throw new IllegalStateException(\"Unexpected throw type.\");\n  }\n  if (frame.type == StackFrame.Type.VARIABLE) {\n    throw new IllegalStateException(\"Unexpected variable type.\");\n  }\n  if (frame.type == StackFrame.Type.CONSTANT) {\n    throw new IllegalStateException(\"Unexpected constant type.\");\n  }\n  if (frame.type == StackFrame.Type.PARAMETER) {\n    throw new IllegalStateException(\"Unexpected parameter type.\");\n  }\n  if (frame.type == StackFrame.Type.RETURN) {\n    throw new IllegalStateException(\"Unexpected return type.\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  int size = mv.visitTypeInsn(CHECKCAST, descriptor);\n  switch (size) {\n    case 0:\n      break;\n    case 1:\n      mv.visitInsn(ACONST_NULL);\n      break;\n    default:\n      mv.visitIntInsn(BIPUSH, size);\n      break;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  int p = peek();\n  if (p >= descriptor.length()) {\n    throw new IllegalStateException(\"Invalid pop() call: \" + descriptor);\n  }\n  Type t = descriptorToType(descriptor.substring(p));\n  if (t.getSort() != Type.OBJECT) {\n    throw new IllegalStateException(\"Invalid pop() call: \" + descriptor);\n  }\n  pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  int p = mv.visitTypeInsn(CHECKCAST, descriptor);\n  mv.visitInsn(POP);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){ int opcode = -1; int stack = 0; int index = 0; while (index < descriptor.length()) { char c = descriptor.charAt(index++); switch(c) { case ')': case ']': case '}': if (opcode == -1) { opcode = c - ')'; stack = 0; } else { opcode = -1; } break; default: if (opcode == -1 && c == 'L') { if (index - 1 >= 0 && descriptor.charAt(index - 1) == ';') { index--; } else { opcode = c - 'L'; stack = 0; } } else if (opcode != -1 && c == '[') { if (index - 1 >= 0 && descriptor.charAt(index - 1) == ';') { index--; } else { opcode = c - '['; stack = 0; } } else if (c == 'J') { opcode = -1; } else if (c == 'D') { opcode = -1; } else if (c == 'F') { opcode = -1; } else if (c == 'I') { opcode = -1; } else if (c == 'S') { opcode = -1; } else { opcode = -1; } break; } }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  int p = this.p;\n  if (p + 3 > this.maxStack) {\n    throw new IllegalStateException(\"Cannot pop type/method pair at the end of a stack frame\");\n  }\n  this.p = p + 3;\n  if (this.stack[p] != Opcodes.T_VOID) {\n    throw new IllegalStateException(\n        \"Cannot pop void type/method pair at the end of a stack frame\");\n  }\n  this.stack[p] = Opcodes.T_CLASS;\n  this.stack[p + 1] = this.stack[p + 2] = Opcodes.T_METHOD;\n  this.stack[p + 2] = descriptor;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  int s = stack;\n  if (s > 0) {\n    s--;\n  }\n  stack = s;\n  final int n = stack + 1;\n  if (n > maxStack) {\n    maxStack = n;\n  }\n  final int d = stack - n;\n  if (d > 0) {\n    stack = d;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n", "method_name": "pop", "codes": ["private void pop(final String descriptor){ int sz = stackSize - frameSize; if (sz < 0) { throw new IllegalStateException(\"Instruction stack is too small for \" + descriptor); } stackSize -= sz; stack[stackSize] = null; if (stackSize > 0) { frameSize = stack[stackSize - 1]; } else { frameSize = 0; } }", "private void pop(final String descriptor){ int n = current - 2; while (n >= 0) { final Type type = types[n]; if (type != Type.VOID_TYPE && type != Type.NULL_TYPE) { current--; break; } n--; } }", "private void pop(final String descriptor){ if (descriptor.charAt(0) == '[') { int pos = descriptor.indexOf('[', 1); if (pos >= 0) { int end = descriptor.indexOf(';', pos); if (end > pos) { int numArgs = Integer.parseInt(descriptor.substring(pos + 1, end)); Type[] args = new Type[numArgs]; for (int i = 0; i < numArgs; i++) { pos = descriptor.indexOf('[', i + 1); if (pos < 0) { throw new IllegalArgumentException(\"Invalid array type descriptor: \" + descriptor); } args[i] = pop(); } if (args.length > 0) { pop(args); } } else { throw new IllegalArgumentException(\"Invalid array type descriptor: \" + descriptor); } } else { throw new IllegalArgumentException(\"Invalid array type descriptor: \" + descriptor); } } else { pop(); } }", "private void pop(final String descriptor){ if (stack.size() == 1) { throw new IllegalStateException(\"Unexpected end of frame stack.\"); } StackFrame frame = stack.get(stack.size() - 2); if (frame.type == StackFrame.Type.VOID) { throw new IllegalStateException(\"Unexpected void type.\"); } if (frame.type == StackFrame.Type.METHOD) { throw new IllegalStateException(\"Unexpected method type.\"); } if (frame.type == StackFrame.Type.FUNCTION) { throw new IllegalStateException(\"Unexpected function type.\"); } if (frame.type == StackFrame.Type.CONSTRUCTOR) { throw new IllegalStateException(\"Unexpected constructor type.\"); } if (frame.type == StackFrame.Type.TYPE_PARAMETER) { throw new IllegalStateException(\"Unexpected type parameter type.\"); } if (frame.type == StackFrame.Type.TYPE_ARGUMENT) { throw new IllegalStateException(\"Unexpected type argument type.\"); } if (frame.type == StackFrame.Type.TYPE_REFERENCE) { throw new IllegalStateException(\"Unexpected type reference type.\"); } if (frame.type == StackFrame.Type.SUPER) { throw new IllegalStateException(\"Unexpected super type.\"); } if (frame.type == StackFrame.Type.EXCEPTION) { throw new IllegalStateException(\"Unexpected exception type.\"); } if (frame.type == StackFrame.Type.THROW) { throw new IllegalStateException(\"Unexpected throw type.\"); } if (frame.type == StackFrame.Type.VARIABLE) { throw new IllegalStateException(\"Unexpected variable type.\"); } if (frame.type == StackFrame.Type.CONSTANT) { throw new IllegalStateException(\"Unexpected constant type.\"); } if (frame.type == StackFrame.Type.PARAMETER) { throw new IllegalStateException(\"Unexpected parameter type.\"); } if (frame.type == StackFrame.Type.RETURN) { throw new IllegalStateException(\"Unexpected return type.\"); } }", "private void pop(final String descriptor){ int size = mv.visitTypeInsn(CHECKCAST, descriptor); switch(size) { case 0: break; case 1: mv.visitInsn(ACONST_NULL); break; default: mv.visitIntInsn(BIPUSH, size); break; } }", "private void pop(final String descriptor){ int p = peek(); if (p >= descriptor.length()) { throw new IllegalStateException(\"Invalid pop() call: \" + descriptor); } Type t = descriptorToType(descriptor.substring(p)); if (t.getSort() != Type.OBJECT) { throw new IllegalStateException(\"Invalid pop() call: \" + descriptor); } pop(); }", "private void pop(final String descriptor){ int p = mv.visitTypeInsn(CHECKCAST, descriptor); mv.visitInsn(POP); }", "private void pop(final String descriptor){ int opcode = -1; int stack = 0; int index = 0; while (index < descriptor.length()) { char c = descriptor.charAt(index++); switch(c) { case ')': case ']': case '}': if (opcode == -1) { opcode = c - ')'; stack = 0; } else { opcode = -1; } break; default: if (opcode == -1 && c == 'L') { if (index - 1 >= 0 && descriptor.charAt(index - 1) == ';') { index--; } else { opcode = c - 'L'; stack = 0; } } else if (opcode != -1 && c == '[') { if (index - 1 >= 0 && descriptor.charAt(index - 1) == ';') { index--; } else { opcode = c - '['; stack = 0; } } else if (c == 'J') { opcode = -1; } else if (c == 'D') { opcode = -1; } else if (c == 'F') { opcode = -1; } else if (c == 'I') { opcode = -1; } else if (c == 'S') { opcode = -1; } else { opcode = -1; } break; } }", "private void pop(final String descriptor){ int p = this.p; if (p + 3 > this.maxStack) { throw new IllegalStateException(\"Cannot pop type/method pair at the end of a stack frame\"); } this.p = p + 3; if (this.stack[p] != Opcodes.T_VOID) { throw new IllegalStateException(\"Cannot pop void type/method pair at the end of a stack frame\"); } this.stack[p] = Opcodes.T_CLASS; this.stack[p + 1] = this.stack[p + 2] = Opcodes.T_METHOD; this.stack[p + 2] = descriptor; }", "private void pop(final String descriptor){ int s = stack; if (s > 0) { s--; } stack = s; final int n = stack + 1; if (n > maxStack) { maxStack = n; } final int d = stack - n; if (d > 0) { stack = d; } }"], "code_level": "class_runnable", "_id": "636767021a6d9265ec0178b2", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void addInitializedType(final int abstractType) {\n  if (initializedTypes == null) {\n    initializedTypes = new ArrayList<>();\n  }\n  initializedTypes.add(abstractType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  if (initializedTypes == null) initializedTypes = new ArrayList<Integer>();\n  initializedTypes.add(abstractType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  final int typeId = abstractType & 0xFFFF;\n  final int argTypeId = abstractType >> 16;\n  if (typeId >= 0) {\n    if (typeId >= initializedTypes.length) {\n      final int[] newTypes = new int[initializedTypes.length + INITIALIZED_TYPE_SIZE];\n      System.arraycopy(initializedTypes, 0, newTypes, 0, initializedTypes.length);\n      initializedTypes = newTypes;\n    }\n    initializedTypes[typeId] = argTypeId;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  if (initializedTypes == null) {\n    initializedTypes = new LinkedList<Integer>();\n  }\n  initializedTypes.add(abstractType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  if (initializedTypes == null) {\n    initializedTypes = new ArrayList<>();\n  }\n  initializedTypes.add(abstractType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  final AbstractTypeDeclaration type = new AbstractTypeDeclaration();\n  type.setId(\n      ((AbstractTypeDeclaration) getTypeDeclaration()).getId() + \"_initialized_\" + abstractType);\n  type.setType(((AbstractTypeDeclaration) getTypeDeclaration()).getType());\n  type.setParent((AbstractTypeDeclaration) getTypeDeclaration());\n  getTypeDeclaration().addType(type);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  if (initializedTypes.contains(abstractType)) {\n    return;\n  }\n  initializedTypes.add(abstractType);\n  if (abstractType != VOID) {\n    addType(abstractType, abstractType);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  final TypeInfo typeInfo = new TypeInfo(abstractType);\n  this.initializedTypes.add(typeInfo);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  final int abstractTypeParamIndex = abstractType;\n  if (this.initializedTypes.containsKey(abstractTypeParamIndex)) {\n    return;\n  }\n  this.initializedTypes.put(abstractTypeParamIndex, abstractType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  final int[] type = new int[initializedTypes.length + 1];\n  System.arraycopy(initializedTypes, 0, type, 0, initializedTypes.length);\n  type[initializedTypes.length] = abstractType;\n  initializedTypes = type;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n", "method_name": "addInitializedType", "codes": ["private void addInitializedType(final int abstractType){ if (initializedTypes == null) { initializedTypes = new ArrayList<>(); } initializedTypes.add(abstractType); }", "private void addInitializedType(final int abstractType){ if (initializedTypes == null) initializedTypes = new ArrayList<Integer>(); initializedTypes.add(abstractType); }", "private void addInitializedType(final int abstractType){ final int typeId = abstractType & 0xFFFF; final int argTypeId = abstractType >> 16; if (typeId >= 0) { if (typeId >= initializedTypes.length) { final int[] newTypes = new int[initializedTypes.length + INITIALIZED_TYPE_SIZE]; System.arraycopy(initializedTypes, 0, newTypes, 0, initializedTypes.length); initializedTypes = newTypes; } initializedTypes[typeId] = argTypeId; } }", "private void addInitializedType(final int abstractType){ if (initializedTypes == null) { initializedTypes = new LinkedList<Integer>(); } initializedTypes.add(abstractType); }", "private void addInitializedType(final int abstractType){ if (initializedTypes == null) { initializedTypes = new ArrayList<>(); } initializedTypes.add(abstractType); }", "private void addInitializedType(final int abstractType){ final AbstractTypeDeclaration type = new AbstractTypeDeclaration(); type.setId(((AbstractTypeDeclaration) getTypeDeclaration()).getId() + \"_initialized_\" + abstractType); type.setType(((AbstractTypeDeclaration) getTypeDeclaration()).getType()); type.setParent((AbstractTypeDeclaration) getTypeDeclaration()); getTypeDeclaration().addType(type); }", "private void addInitializedType(final int abstractType){ if (initializedTypes.contains(abstractType)) { return; } initializedTypes.add(abstractType); if (abstractType != VOID) { addType(abstractType, abstractType); } }", "private void addInitializedType(final int abstractType){ final TypeInfo typeInfo = new TypeInfo(abstractType); this.initializedTypes.add(typeInfo); }", "private void addInitializedType(final int abstractType){ final int abstractTypeParamIndex = abstractType; if (this.initializedTypes.containsKey(abstractTypeParamIndex)) { return; } this.initializedTypes.put(abstractTypeParamIndex, abstractType); }", "private void addInitializedType(final int abstractType){ final int[] type = new int[initializedTypes.length + 1]; System.arraycopy(initializedTypes, 0, type, 0, initializedTypes.length); type[initializedTypes.length] = abstractType; initializedTypes = type; }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec0177a9", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  final boolean isStatic =\n      currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_STATIC) != null;\n  final boolean isFinal =\n      currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_FINAL) != null;\n  final boolean isAbstract =\n      currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_ABSTRACT) != null;\n  final boolean isSynthetic =\n      currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_SYNTHETIC) != null;\n  final boolean isStrictfp =\n      currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_STRICTFP) != null;\n  final boolean isTransient =\n      currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_TRANSIENT) != null;\n  final boolean isVolatile =\n      currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_VOLATILE) != null;\n  if (isAbstract) {\n    putAbstractTypes(\n        start, end, isStatic, isFinal, isSynthetic, isStrictfp, isTransient, isVolatile);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  int n = start;\n  for (int i = start; i < end; i++) {\n    if (currentFrame[i].getType().getSort() == Type.OBJECT) {\n      putType(n++, currentFrame[i].getType());\n    } else {\n      putType(n++, Type.getObjectType(currentFrame[i].getType().getInternalName()));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){ final int numAbstractTypes = end - start; final int numAbstractTypesSize = numAbstractTypes * StackMapTable.ITEM_SIZE; final int numAbstractTypesOffset = start + StackMapTable.ITEM_SIZE; for (int i = start; i < end; ++i) { final AbstractInsnNode ain = currentFrame.get(i); if (ain instanceof TypeInsnNode) { final TypeInsnNode tin = (TypeInsnNode) ain; final Type type = tin.desc.charAt(0) == '[' ? Type.getType(tin.desc) : Type.getObjectType(tin.desc); if (type.getSize() == 2) { stackMapTableEntries.putShort(numAbstractTypesOffset, type.getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 2, type.getOpcode(Opcodes.ICONST_0)); stackMapTableEntries.putShort(numAbstractTypesOffset + 4, type.getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 6, type.getSize()); } else { stackMapTableEntries.putShort(numAbstractTypesOffset, type.getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 2, type.getOpcode(Opcodes.ICONST_1)); stackMapTableEntries.putShort(numAbstractTypesOffset + 4, type.getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 6, type.getSize()); } } else if (ain instanceof FieldInsnNode) { final FieldInsnNode fin = (FieldInsnNode) ain; final Field field = fin.owner.getField(fin.name, fin.desc); if (field == null) { stackMapTableEntries.putShort(numAbstractTypesOffset, Type.getType(\"Ljava/lang/Object;\").getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 2, Type.getObjectType(\"Ljava/lang/Object;\").getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 4, Type.getObjectType(\"Ljava/lang/Object;\").getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 6, Type.getObjectType(\"Ljava/lang/Object;\").getSize()); } else { stackMapTableEntries.putShort(numAbstractTypesOffset, field.getType().getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 2, field.getType().getOpcode(Opcodes.ICONST_0)); stackMapTableEntries.putShort(numAbstractTypesOffset + 4, field.getType().getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 6, field.getType().getSize()); } } else if (ain instanceof MethodInsnNode) { final MethodInsnNode min = (Method", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){ if (currentFrame == null) { return; } final int typeTableOffset = currentFrame.getTypeTableOffset(); final int typeTableSize = currentFrame.getTypeTableSize(); final int typeTableEntrySize = currentFrame.getTypeTableEntrySize(); final int typeTableEntryOffset = currentFrame.getTypeTableEntryOffset(); final int typeTableEntryCount = currentFrame.getTypeTableEntryCount(); final int typeTableEntryCount2 = currentFrame.getTypeTableEntryCount2(); final int[] typeTableEntries = currentFrame.getTypeTableEntries(); final int[] typeTableEntryOffsets = currentFrame.getTypeTableEntryOffsets(); final int[] typeTableEntryCounts = currentFrame.getTypeTableEntryCounts(); final int[] typeTableEntryCount2s = currentFrame.getTypeTableEntryCount2s(); final int[] typeTableEntryCount3s = currentFrame.getTypeTableEntryCount3s(); final int[] typeTableEntryCount4s = currentFrame.getTypeTableEntryCount4s(); final int[] typeTableEntryCount5s = currentFrame.getTypeTableEntryCount5s(); final int[] typeTableEntryCount6s = currentFrame.getTypeTableEntryCount6s(); final int[] typeTableEntryCount7s = currentFrame.getTypeTableEntryCount7s(); final int[] typeTableEntryCount8s = currentFrame.getTypeTableEntryCount8s(); final int[] typeTableEntryCount9s = currentFrame.getTypeTableEntryCount9s(); final int[] typeTableEntryCount10s = currentFrame.getTypeTableEntryCount10s(); final int[] typeTableEntryCount11s = currentFrame.getTypeTableEntryCount11s(); final int[] typeTableEntryCount12s = currentFrame.getTypeTableEntryCount12s(); final int[] typeTableEntryCount13s = currentFrame.getTypeTableEntryCount13s(); final int[] typeTableEntryCount14s = currentFrame.getTypeTableEntryCount14s(); final int[] typeTableEntryCount15s = currentFrame.getTypeTableEntryCount15s(); final int[] typeTableEntryCount16s = currentFrame.getTypeTableEntryCount16s(); final int[] typeTableEntryCount17s = currentFrame.getTypeTableEntryCount17s(); final int[] typeTableEntryCount18s = currentFrame.getTypeTableEntryCount18s(); final int[] typeTableEntryCount19s = currentFrame.getTypeTableEntryCount19s(); final int[] typeTableEntryCount20s = currentFrame.getTypeTableEntryCount20s(); final int[] typeTableEntryCount21s = currentFrame.getTypeTableEntryCount21s(); final int[] typeTableEntryCount22s = currentFrame.getTypeTableEntryCount22s(); final int[] typeTableEntryCount23s = currentFrame.getTypeTableEntryCount23s(); final int[] typeTableEntryCount24s = currentFrame.getTypeTableEntryCount24s(); final int[] typeTableEntryCount25s = currentFrame.getTypeTableEntry", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  int type = currentFrame.getType(start);\n  int offset = start + 1;\n  while (type != Opcodes.TOP) {\n    final int typeCode = getTypeCode(type);\n    if (typeCode != Opcodes.UNINITIALIZED_THIS) {\n      putUninitializedThis(offset);\n    }\n    putType(offset++, type);\n    type = currentFrame.getType(type + 1);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){ if (currentFrame.typeTable == null) { return; } int i = start; while (i < end) { final int typeId = currentFrame.typeTable[i++]; if (typeId == TypeIds.CONSTANT_Utf8) { putConstantUtf8(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Integer) { putConstantInteger(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Float) { putConstantFloat(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Long) { putConstantLong(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Double) { putConstantDouble(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_NameAndType) { putConstantNameAndType(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Methodref) { putConstantMethodref(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_InterfaceMethodref) { putConstantInterfaceMethodref(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_String) { putConstantString(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Fieldref) { putConstantFieldref(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodHandle) { putConstantMethodHandle(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodType) { putConstantMethodType(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_InvokeDynamic) { putConstantInvokeDynamic(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodHandle_Dynamic) { putConstantMethodHandle_Dynamic(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodType_Dynamic) { putConstantMethodType_Dynamic(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodHandle_InvokeDynamic) { putConstantMethodHandle_InvokeDynamic(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_InvokeDynamic_Dynamic) { putConstantInvokeDynamic_Dynamic(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodType_InvokeDynamic) { putCon", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  if (start == end) {\n    return;\n  }\n  final int numTypes = end - start + 1;\n  final int numStackMapEntries = currentFrame.getLocals() - currentFrame.getStackMapEntries();\n  final int numLocals = currentFrame.getLocals();\n  final int numStackMap = numLocals + numStackMapEntries;\n  final int numBytes = numLocals * numStackMap;\n  final int numBytesToCopy = numBytes + numStackMap * 2;\n  final int numCopies = numBytesToCopy / 4;\n  final int numCopiesToCopy = numBytesToCopy % 4;\n  final int numBytesToCopyToCopy = numBytesToCopyToCopy / 4;\n  final int numCopiesToCopyToCopy = numBytesToCopyToCopy % 4;\n  if (numCopies > 0) {\n    if (numCopiesToCopy > 0) {\n      code.putByte(currentFrame.opcode << 2 | Opcodes.NOP);\n    }\n    code.putByte(Opcodes.TABLESWITCH);\n    code.putByte(numCopies);\n    for (int i = 0; i < numCopies; i++) {\n      code.putByte(Opcodes.LOOKUPSWITCH);\n      code.putByte(Opcodes.LOOKUPSWITCH_BASE);\n    }\n    if (numCopiesToCopy > 0) {\n      code.putByte(Opcodes.IRETURN);\n    }\n    code.putByte(Opcodes.ATHROW);\n  }\n  if (numCopiesToCopy > 0) {\n    if (numCopiesToCopyToCopy > 0) {\n      code.putByte(currentFrame.opcode << 2 | Opcodes.NOP);\n    }\n    code.putByte(Opcodes.ATHROW);\n  }\n  if (numBytesToCopy > 0) {\n    if (numBytesToCopyToCopy > 0) {\n      code.putByte(currentFrame.opcode << 2 | Opcodes.NOP);\n    }\n    code.putByte(Opcodes.ATHROW);\n  }\n  if (numBytesToCopyToCopy > 0) {\n    if (numBytesToCopyToCopy > 0) {\n      code.putByte(currentFrame.opcode << 2 | Opcodes.NOP);\n    }\n    code.putByte(Opcodes.ATHROW);\n  }\n  if (numBytesToCopyToCopyToCopy > 0) {\n    if (numBytesToCopyToCopyToCopy > 0) {\n      code.putByte(currentFrame.opcode << 2 | Opcodes.NOP);\n    }\n    code.putByte(Opcodes.ATHROW);\n  }\n  if (numCopiesToCopy > 0) {\n    if (numCopiesToCopyToCopy > 0) {\n      code.putByte(currentFrame.opcode << 2 | Opcodes.NOP);\n    }\n    code.putByte(Opcodes.RETURN);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){ if (this.currentFrame.getLocalVariableSize() > 0) { final int size = this.currentFrame.getLocalVariableSize(); final int startOffset = this.currentFrame.getStackMapTableOffset(start); final int endOffset = this.currentFrame.getStackMapTableOffset(end); final byte[][] bytecode = this.currentFrame.getBytecode(); final int bytecodeSize = bytecode.length; final int bytecodeOffset = bytecodeSize * bytecodeSize; final int bytecodeOffset2 = bytecodeOffset + 1; final int bytecodeOffset3 = bytecodeOffset2 + 1; final int bytecodeOffset4 = bytecodeOffset3 + 1; final int bytecodeOffset5 = bytecodeOffset4 + 1; final int bytecodeOffset6 = bytecodeOffset5 + 1; final int bytecodeOffset7 = bytecodeOffset6 + 1; final int bytecodeOffset8 = bytecodeOffset7 + 1; final int bytecodeOffset9 = bytecodeOffset8 + 1; final int bytecodeOffset10 = bytecodeOffset9 + 1; final int bytecodeOffset11 = bytecodeOffset10 + 1; final int bytecodeOffset12 = bytecodeOffset11 + 1; final int bytecodeOffset13 = bytecodeOffset12 + 1; final int bytecodeOffset14 = bytecodeOffset13 + 1; final int bytecodeOffset15 = bytecodeOffset14 + 1; final int bytecodeOffset16 = bytecodeOffset15 + 1; final int bytecodeOffset17 = bytecodeOffset16 + 1; final int bytecodeOffset18 = bytecodeOffset17 + 1; final int bytecodeOffset19 = bytecodeOffset18 + 1; final int bytecodeOffset20 = bytecodeOffset19 + 1; final int bytecodeOffset21 = bytecodeOffset20 + 1; final int bytecodeOffset22 = bytecodeOffset21 + 1; final int bytecodeOffset23 = bytecodeOffset22 + 1; final int bytecodeOffset24 = bytecodeOffset23 + 1; final int bytecodeOffset25 = bytecodeOffset24 + 1; final int bytecodeOffset26 = bytecodeOffset25 + 1; final int bytecodeOffset27 = bytecodeOffset26 + 1; final int bytecodeOffset28 = bytecodeOffset27 + 1; final int bytecodeOffset29 = bytecodeOffset28 + 1; final int bytecodeOffset30 = bytecodeOffset29 + 1; final int bytecodeOffset31 = bytecodeOffset30 + 1; final int bytecodeOffset32 = bytecodeOffset31 + 1; final int bytecodeOffset33 = bytecodeOffset32 + 1; final int bytecodeOffset34 = bytecodeOffset33 + 1; final int bytecodeOffset35 = bytecodeOffset34 + 1; final int bytecodeOffset36 = bytecodeOffset35 + 1; final int bytecodeOffset37 = bytecodeOffset36 + 1; final int bytecodeOffset38 = bytecodeOffset37 + 1; final int bytecodeOffset39 = bytecodeOffset38 + 1; final int bytecodeOffset40 = bytecodeOffset39 + 1", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  final int newLength = end - start;\n  if (newLength > stackMapTableEntries.length) {\n    final Object[] newStackMapTableEntries = new Object[newLength];\n    System.arraycopy(\n        stackMapTableEntries,\n        start,\n        newStackMapTableEntries,\n        0,\n        stackMapTableEntries.length - start);\n    System.arraycopy(\n        stackMapTableEntries,\n        0,\n        newStackMapTableEntries,\n        stackMapTableEntries.length - start,\n        newLength);\n    stackMapTableEntries = newStackMapTableEntries;\n  }\n  for (int i = start; i < end; i++) {\n    final Type type = currentFrame.getType(i);\n    if (type.isPrimitive()) {\n      final int index = type.getSort() == Type.OBJECT ? i + 1 : i;\n      stackMapTableEntries[index] = type.getDescriptor();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  if (currentFrame == null) {\n    return;\n  }\n  for (int i = start; i < end; ++i) {\n    if (currentFrame[i] == Opcodes.TOP) {\n      stackMapTableEntries[stackMapTableOffset++] = Opcodes.TOP;\n    } else if (currentFrame[i] == Opcodes.INTEGER) {\n      stackMapTableEntries[stackMapTableOffset++] = Opcodes.INTEGER;\n      stackMapTableEntries[stackMapTableOffset++] = Opcodes.TOP;\n    } else if (currentFrame[i] == Opcodes.FLOAT) {\n      stackMapTableEntries[stackMapTableOffset++] = Opcodes.FLOAT;\n      stackMapTableEntries[stackMapTableOffset++] = Opcodes.TOP;\n    } else if (currentFrame[i] == Opcodes.LONG) {\n      stackMapTableEntries[stackMapTableOffset++] = Opcodes.LONG;\n      stackMapTableEntries[stackMapTableOffset++] = Opcodes.TOP;\n    } else if (currentFrame[i] == Opcodes.DOUBLE) {\n      stackMapTableEntries[stackMapTableOffset++] = Opcodes.DOUBLE;\n      stackMapTableEntries[stackMapTableOffset++] = Opcodes.TOP;\n    } else if (currentFrame[i] == Opcodes.NULL) {\n      stackMapTableEntries[stackMapTableOffset++] = Opcodes.NULL;\n    } else {\n      throw new IllegalStateException();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.\n * @param start index of the first type in {@link #currentFrame} to write.\n * @param end index of last type in {@link #currentFrame} to write (exclusive).\n */\n", "method_name": "putAbstractTypes", "codes": ["private void putAbstractTypes(final int start,final int end){ final boolean isStatic = currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_STATIC) != null; final boolean isFinal = currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_FINAL) != null; final boolean isAbstract = currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_ABSTRACT) != null; final boolean isSynthetic = currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_SYNTHETIC) != null; final boolean isStrictfp = currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_STRICTFP) != null; final boolean isTransient = currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_TRANSIENT) != null; final boolean isVolatile = currentFrame.getStackMapTableEntry(start, StackMapTableEntry.TYPE_INFO_VOLATILE) != null; if (isAbstract) { putAbstractTypes(start, end, isStatic, isFinal, isSynthetic, isStrictfp, isTransient, isVolatile); } }", "private void putAbstractTypes(final int start,final int end){ int n = start; for (int i = start; i < end; i++) { if (currentFrame[i].getType().getSort() == Type.OBJECT) { putType(n++, currentFrame[i].getType()); } else { putType(n++, Type.getObjectType(currentFrame[i].getType().getInternalName())); } } }", "private void putAbstractTypes(final int start,final int end){ final int numAbstractTypes = end - start; final int numAbstractTypesSize = numAbstractTypes * StackMapTable.ITEM_SIZE; final int numAbstractTypesOffset = start + StackMapTable.ITEM_SIZE; for (int i = start; i < end; ++i) { final AbstractInsnNode ain = currentFrame.get(i); if (ain instanceof TypeInsnNode) { final TypeInsnNode tin = (TypeInsnNode) ain; final Type type = tin.desc.charAt(0) == '[' ? Type.getType(tin.desc) : Type.getObjectType(tin.desc); if (type.getSize() == 2) { stackMapTableEntries.putShort(numAbstractTypesOffset, type.getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 2, type.getOpcode(Opcodes.ICONST_0)); stackMapTableEntries.putShort(numAbstractTypesOffset + 4, type.getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 6, type.getSize()); } else { stackMapTableEntries.putShort(numAbstractTypesOffset, type.getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 2, type.getOpcode(Opcodes.ICONST_1)); stackMapTableEntries.putShort(numAbstractTypesOffset + 4, type.getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 6, type.getSize()); } } else if (ain instanceof FieldInsnNode) { final FieldInsnNode fin = (FieldInsnNode) ain; final Field field = fin.owner.getField(fin.name, fin.desc); if (field == null) { stackMapTableEntries.putShort(numAbstractTypesOffset, Type.getType(\"Ljava/lang/Object;\").getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 2, Type.getObjectType(\"Ljava/lang/Object;\").getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 4, Type.getObjectType(\"Ljava/lang/Object;\").getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 6, Type.getObjectType(\"Ljava/lang/Object;\").getSize()); } else { stackMapTableEntries.putShort(numAbstractTypesOffset, field.getType().getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 2, field.getType().getOpcode(Opcodes.ICONST_0)); stackMapTableEntries.putShort(numAbstractTypesOffset + 4, field.getType().getSize()); stackMapTableEntries.putShort(numAbstractTypesOffset + 6, field.getType().getSize()); } } else if (ain instanceof MethodInsnNode) { final MethodInsnNode min = (Method", "private void putAbstractTypes(final int start,final int end){ if (currentFrame == null) { return; } final int typeTableOffset = currentFrame.getTypeTableOffset(); final int typeTableSize = currentFrame.getTypeTableSize(); final int typeTableEntrySize = currentFrame.getTypeTableEntrySize(); final int typeTableEntryOffset = currentFrame.getTypeTableEntryOffset(); final int typeTableEntryCount = currentFrame.getTypeTableEntryCount(); final int typeTableEntryCount2 = currentFrame.getTypeTableEntryCount2(); final int[] typeTableEntries = currentFrame.getTypeTableEntries(); final int[] typeTableEntryOffsets = currentFrame.getTypeTableEntryOffsets(); final int[] typeTableEntryCounts = currentFrame.getTypeTableEntryCounts(); final int[] typeTableEntryCount2s = currentFrame.getTypeTableEntryCount2s(); final int[] typeTableEntryCount3s = currentFrame.getTypeTableEntryCount3s(); final int[] typeTableEntryCount4s = currentFrame.getTypeTableEntryCount4s(); final int[] typeTableEntryCount5s = currentFrame.getTypeTableEntryCount5s(); final int[] typeTableEntryCount6s = currentFrame.getTypeTableEntryCount6s(); final int[] typeTableEntryCount7s = currentFrame.getTypeTableEntryCount7s(); final int[] typeTableEntryCount8s = currentFrame.getTypeTableEntryCount8s(); final int[] typeTableEntryCount9s = currentFrame.getTypeTableEntryCount9s(); final int[] typeTableEntryCount10s = currentFrame.getTypeTableEntryCount10s(); final int[] typeTableEntryCount11s = currentFrame.getTypeTableEntryCount11s(); final int[] typeTableEntryCount12s = currentFrame.getTypeTableEntryCount12s(); final int[] typeTableEntryCount13s = currentFrame.getTypeTableEntryCount13s(); final int[] typeTableEntryCount14s = currentFrame.getTypeTableEntryCount14s(); final int[] typeTableEntryCount15s = currentFrame.getTypeTableEntryCount15s(); final int[] typeTableEntryCount16s = currentFrame.getTypeTableEntryCount16s(); final int[] typeTableEntryCount17s = currentFrame.getTypeTableEntryCount17s(); final int[] typeTableEntryCount18s = currentFrame.getTypeTableEntryCount18s(); final int[] typeTableEntryCount19s = currentFrame.getTypeTableEntryCount19s(); final int[] typeTableEntryCount20s = currentFrame.getTypeTableEntryCount20s(); final int[] typeTableEntryCount21s = currentFrame.getTypeTableEntryCount21s(); final int[] typeTableEntryCount22s = currentFrame.getTypeTableEntryCount22s(); final int[] typeTableEntryCount23s = currentFrame.getTypeTableEntryCount23s(); final int[] typeTableEntryCount24s = currentFrame.getTypeTableEntryCount24s(); final int[] typeTableEntryCount25s = currentFrame.getTypeTableEntry", "private void putAbstractTypes(final int start,final int end){ int type = currentFrame.getType(start); int offset = start + 1; while (type != Opcodes.TOP) { final int typeCode = getTypeCode(type); if (typeCode != Opcodes.UNINITIALIZED_THIS) { putUninitializedThis(offset); } putType(offset++, type); type = currentFrame.getType(type + 1); } }", "private void putAbstractTypes(final int start,final int end){ if (currentFrame.typeTable == null) { return; } int i = start; while (i < end) { final int typeId = currentFrame.typeTable[i++]; if (typeId == TypeIds.CONSTANT_Utf8) { putConstantUtf8(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Integer) { putConstantInteger(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Float) { putConstantFloat(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Long) { putConstantLong(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Double) { putConstantDouble(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_NameAndType) { putConstantNameAndType(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Methodref) { putConstantMethodref(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_InterfaceMethodref) { putConstantInterfaceMethodref(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_String) { putConstantString(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_Fieldref) { putConstantFieldref(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodHandle) { putConstantMethodHandle(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodType) { putConstantMethodType(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_InvokeDynamic) { putConstantInvokeDynamic(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodHandle_Dynamic) { putConstantMethodHandle_Dynamic(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodType_Dynamic) { putConstantMethodType_Dynamic(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodHandle_InvokeDynamic) { putConstantMethodHandle_InvokeDynamic(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_InvokeDynamic_Dynamic) { putConstantInvokeDynamic_Dynamic(i, currentFrame); } else if (typeId == TypeIds.CONSTANT_MethodType_InvokeDynamic) { putCon", "private void putAbstractTypes(final int start,final int end){ if (start == end) { return; } final int numTypes = end - start + 1; final int numStackMapEntries = currentFrame.getLocals() - currentFrame.getStackMapEntries(); final int numLocals = currentFrame.getLocals(); final int numStackMap = numLocals + numStackMapEntries; final int numBytes = numLocals * numStackMap; final int numBytesToCopy = numBytes + numStackMap * 2; final int numCopies = numBytesToCopy / 4; final int numCopiesToCopy = numBytesToCopy % 4; final int numBytesToCopyToCopy = numBytesToCopyToCopy / 4; final int numCopiesToCopyToCopy = numBytesToCopyToCopy % 4; if (numCopies > 0) { if (numCopiesToCopy > 0) { code.putByte(currentFrame.opcode << 2 | Opcodes.NOP); } code.putByte(Opcodes.TABLESWITCH); code.putByte(numCopies); for (int i = 0; i < numCopies; i++) { code.putByte(Opcodes.LOOKUPSWITCH); code.putByte(Opcodes.LOOKUPSWITCH_BASE); } if (numCopiesToCopy > 0) { code.putByte(Opcodes.IRETURN); } code.putByte(Opcodes.ATHROW); } if (numCopiesToCopy > 0) { if (numCopiesToCopyToCopy > 0) { code.putByte(currentFrame.opcode << 2 | Opcodes.NOP); } code.putByte(Opcodes.ATHROW); } if (numBytesToCopy > 0) { if (numBytesToCopyToCopy > 0) { code.putByte(currentFrame.opcode << 2 | Opcodes.NOP); } code.putByte(Opcodes.ATHROW); } if (numBytesToCopyToCopy > 0) { if (numBytesToCopyToCopy > 0) { code.putByte(currentFrame.opcode << 2 | Opcodes.NOP); } code.putByte(Opcodes.ATHROW); } if (numBytesToCopyToCopyToCopy > 0) { if (numBytesToCopyToCopyToCopy > 0) { code.putByte(currentFrame.opcode << 2 | Opcodes.NOP); } code.putByte(Opcodes.ATHROW); } if (numCopiesToCopy > 0) { if (numCopiesToCopyToCopy > 0) { code.putByte(currentFrame.opcode << 2 | Opcodes.NOP); } code.putByte(Opcodes.RETURN); } }", "private void putAbstractTypes(final int start,final int end){ if (this.currentFrame.getLocalVariableSize() > 0) { final int size = this.currentFrame.getLocalVariableSize(); final int startOffset = this.currentFrame.getStackMapTableOffset(start); final int endOffset = this.currentFrame.getStackMapTableOffset(end); final byte[][] bytecode = this.currentFrame.getBytecode(); final int bytecodeSize = bytecode.length; final int bytecodeOffset = bytecodeSize * bytecodeSize; final int bytecodeOffset2 = bytecodeOffset + 1; final int bytecodeOffset3 = bytecodeOffset2 + 1; final int bytecodeOffset4 = bytecodeOffset3 + 1; final int bytecodeOffset5 = bytecodeOffset4 + 1; final int bytecodeOffset6 = bytecodeOffset5 + 1; final int bytecodeOffset7 = bytecodeOffset6 + 1; final int bytecodeOffset8 = bytecodeOffset7 + 1; final int bytecodeOffset9 = bytecodeOffset8 + 1; final int bytecodeOffset10 = bytecodeOffset9 + 1; final int bytecodeOffset11 = bytecodeOffset10 + 1; final int bytecodeOffset12 = bytecodeOffset11 + 1; final int bytecodeOffset13 = bytecodeOffset12 + 1; final int bytecodeOffset14 = bytecodeOffset13 + 1; final int bytecodeOffset15 = bytecodeOffset14 + 1; final int bytecodeOffset16 = bytecodeOffset15 + 1; final int bytecodeOffset17 = bytecodeOffset16 + 1; final int bytecodeOffset18 = bytecodeOffset17 + 1; final int bytecodeOffset19 = bytecodeOffset18 + 1; final int bytecodeOffset20 = bytecodeOffset19 + 1; final int bytecodeOffset21 = bytecodeOffset20 + 1; final int bytecodeOffset22 = bytecodeOffset21 + 1; final int bytecodeOffset23 = bytecodeOffset22 + 1; final int bytecodeOffset24 = bytecodeOffset23 + 1; final int bytecodeOffset25 = bytecodeOffset24 + 1; final int bytecodeOffset26 = bytecodeOffset25 + 1; final int bytecodeOffset27 = bytecodeOffset26 + 1; final int bytecodeOffset28 = bytecodeOffset27 + 1; final int bytecodeOffset29 = bytecodeOffset28 + 1; final int bytecodeOffset30 = bytecodeOffset29 + 1; final int bytecodeOffset31 = bytecodeOffset30 + 1; final int bytecodeOffset32 = bytecodeOffset31 + 1; final int bytecodeOffset33 = bytecodeOffset32 + 1; final int bytecodeOffset34 = bytecodeOffset33 + 1; final int bytecodeOffset35 = bytecodeOffset34 + 1; final int bytecodeOffset36 = bytecodeOffset35 + 1; final int bytecodeOffset37 = bytecodeOffset36 + 1; final int bytecodeOffset38 = bytecodeOffset37 + 1; final int bytecodeOffset39 = bytecodeOffset38 + 1; final int bytecodeOffset40 = bytecodeOffset39 + 1", "private void putAbstractTypes(final int start,final int end){ final int newLength = end - start; if (newLength > stackMapTableEntries.length) { final Object[] newStackMapTableEntries = new Object[newLength]; System.arraycopy(stackMapTableEntries, start, newStackMapTableEntries, 0, stackMapTableEntries.length - start); System.arraycopy(stackMapTableEntries, 0, newStackMapTableEntries, stackMapTableEntries.length - start, newLength); stackMapTableEntries = newStackMapTableEntries; } for (int i = start; i < end; i++) { final Type type = currentFrame.getType(i); if (type.isPrimitive()) { final int index = type.getSort() == Type.OBJECT ? i + 1 : i; stackMapTableEntries[index] = type.getDescriptor(); } } }", "private void putAbstractTypes(final int start,final int end){ if (currentFrame == null) { return; } for (int i = start; i < end; ++i) { if (currentFrame[i] == Opcodes.TOP) { stackMapTableEntries[stackMapTableOffset++] = Opcodes.TOP; } else if (currentFrame[i] == Opcodes.INTEGER) { stackMapTableEntries[stackMapTableOffset++] = Opcodes.INTEGER; stackMapTableEntries[stackMapTableOffset++] = Opcodes.TOP; } else if (currentFrame[i] == Opcodes.FLOAT) { stackMapTableEntries[stackMapTableOffset++] = Opcodes.FLOAT; stackMapTableEntries[stackMapTableOffset++] = Opcodes.TOP; } else if (currentFrame[i] == Opcodes.LONG) { stackMapTableEntries[stackMapTableOffset++] = Opcodes.LONG; stackMapTableEntries[stackMapTableOffset++] = Opcodes.TOP; } else if (currentFrame[i] == Opcodes.DOUBLE) { stackMapTableEntries[stackMapTableOffset++] = Opcodes.DOUBLE; stackMapTableEntries[stackMapTableOffset++] = Opcodes.TOP; } else if (currentFrame[i] == Opcodes.NULL) { stackMapTableEntries[stackMapTableOffset++] = Opcodes.NULL; } else { throw new IllegalStateException(); } } }"], "code_level": "project_runnable", "_id": "6367670a1a6d9265ec0179dc", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public short readShort(final int offset) {\n  return readShort(offset, new short[2]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return (short) ((buffer.getShort(offset) << 8) + (buffer.get(offset + 1) & 0xff));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return (short) (((buffer[offset] & 0xff) << 8) | (buffer[offset + 1] & 0xff));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return (short) (readByte(offset) | (readByte(offset + 1) << 8));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return readShort(offset, 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return readShort(offset, ByteOrder.BIG_ENDIAN);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return (short) ((readByte(offset) & 0xFF) << 8 | (readByte(offset + 1) & 0xFF));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public short readShort(final int offset) {\n  return UNSAFE.getShort(byteArray, address + offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return readShort(offset, 2);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return readShort(offset, 2);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a signed short value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n", "method_name": "readShort", "codes": ["public short readShort(final int offset){ return readShort(offset, new short[2]); }", "public short readShort(final int offset){ return (short) ((buffer.getShort(offset) << 8) + (buffer.get(offset + 1) & 0xff)); }", "public short readShort(final int offset){ return (short) (((buffer[offset] & 0xff) << 8) | (buffer[offset + 1] & 0xff)); }", "public short readShort(final int offset){ return (short) (readByte(offset) | (readByte(offset + 1) << 8)); }", "public short readShort(final int offset){ return readShort(offset, 1); }", "public short readShort(final int offset){ return readShort(offset, ByteOrder.BIG_ENDIAN); }", "public short readShort(final int offset){ return (short) ((readByte(offset) & 0xFF) << 8 | (readByte(offset + 1) & 0xFF)); }", "public short readShort(final int offset){ return UNSAFE.getShort(byteArray, address + offset); }", "public short readShort(final int offset){ return readShort(offset, 2); }", "public short readShort(final int offset){ return readShort(offset, 2); }"], "code_level": "class_runnable", "_id": "636766f21a6d9265ec017667", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label label = labels[bytecodeOffset];\n  if (label == null) {\n    label = new Label();\n    labels[bytecodeOffset] = label;\n  }\n  return label;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label label = labels[bytecodeOffset];\n  if (label == null) {\n    label = new Label();\n    labels[bytecodeOffset] = label;\n  }\n  return label;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label ret = labels[bytecodeOffset];\n  if (ret == null) {\n    ret = new Label();\n    labels[bytecodeOffset] = ret;\n  }\n  return ret;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label ret = labels[bytecodeOffset];\n  if (ret == null) {\n    ret = new Label();\n    labels[bytecodeOffset] = ret;\n  }\n  return ret;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label label = labels[bytecodeOffset];\n  if (label == null) {\n    label = new Label();\n    labels[bytecodeOffset] = label;\n  }\n  return label;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label label = labels[bytecodeOffset];\n  if (label == null) {\n    label = new Label();\n    labels[bytecodeOffset] = label;\n  }\n  return label;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label label = labels[bytecodeOffset];\n  if (label == null) {\n    label = new Label();\n    labels[bytecodeOffset] = label;\n  }\n  return label;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label ret = labels[bytecodeOffset];\n  if (ret == null) {\n    ret = new Label();\n    labels[bytecodeOffset] = ret;\n  }\n  return ret;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label label = labels[bytecodeOffset];\n  if (label == null) {\n    label = new Label();\n    labels[bytecodeOffset] = label;\n  }\n  return label;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label label = labels[bytecodeOffset];\n  if (label == null) {\n    label = new Label();\n    labels[bytecodeOffset] = label;\n  }\n  return label;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n", "method_name": "readLabel", "codes": ["protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label label = labels[bytecodeOffset]; if (label == null) { label = new Label(); labels[bytecodeOffset] = label; } return label; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label label = labels[bytecodeOffset]; if (label == null) { label = new Label(); labels[bytecodeOffset] = label; } return label; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label ret = labels[bytecodeOffset]; if (ret == null) { ret = new Label(); labels[bytecodeOffset] = ret; } return ret; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label ret = labels[bytecodeOffset]; if (ret == null) { ret = new Label(); labels[bytecodeOffset] = ret; } return ret; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label label = labels[bytecodeOffset]; if (label == null) { label = new Label(); labels[bytecodeOffset] = label; } return label; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label label = labels[bytecodeOffset]; if (label == null) { label = new Label(); labels[bytecodeOffset] = label; } return label; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label label = labels[bytecodeOffset]; if (label == null) { label = new Label(); labels[bytecodeOffset] = label; } return label; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label ret = labels[bytecodeOffset]; if (ret == null) { ret = new Label(); labels[bytecodeOffset] = ret; } return ret; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label label = labels[bytecodeOffset]; if (label == null) { label = new Label(); labels[bytecodeOffset] = label; } return label; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label label = labels[bytecodeOffset]; if (label == null) { label = new Label(); labels[bytecodeOffset] = label; } return label; }"], "code_level": "self_contained", "_id": "636766ff1a6d9265ec017853", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int index = constantPoolEntryIndex >>> Constants.SHIFT_CONSTANT_POOL_UTF;\n  final int length = (constantPoolEntryIndex & Constants.CONSTANT_POOL_UTF_COUNT_MASK) - index;\n  char[] chars = new char[length];\n  if (index >= 0 && index < chars.length) {\n    System.arraycopy(classFileBuffer, index, chars, 0, length);\n  } else {\n    final StringBuilder sb = new StringBuilder(length);\n    for (int i = 0; i < length; i++) {\n      sb.append(charBuffer[i]);\n    }\n    chars = sb.toString().toCharArray();\n  }\n  return new String(chars);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  int utfIndex = readUtfIndex(constantPoolEntryIndex);\n  int utfLength = readUtfLength(constantPoolEntryIndex);\n  char[] utf = new char[utfLength];\n  System.arraycopy(classFileBuffer, utfIndex, utf, 0, utfLength);\n  return new String(utf);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int tag = this.classFileBuffer[constantPoolEntryIndex] & 0xFF;\n  switch (tag) {\n    case 0:\n      {\n        return \"\";\n      }\n    case 1:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 1], charBuffer);\n      }\n    case 2:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 2], charBuffer);\n      }\n    case 3:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 3], charBuffer);\n      }\n    case 4:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 4], charBuffer);\n      }\n    case 5:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 5], charBuffer);\n      }\n    case 6:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 6], charBuffer);\n      }\n    case 7:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 7], charBuffer);\n      }\n    case 8:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 8], charBuffer);\n      }\n    case 9:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 9], charBuffer);\n      }\n    case 10:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 10], charBuffer);\n      }\n    case 11:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 11], charBuffer);\n      }\n    case 12:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 12], charBuffer);\n      }\n    case 13:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 13], charBuffer);\n      }\n    case 14:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 14], charBuffer);\n      }\n    case 15:\n      {\n        return readUtf(this.classFileBuffer[constantPoolEntryIndex + 15], charBuffer);\n      }\n    default:\n      {\n        throw new IllegalArgumentException(\"Illegal constant pool entry tag: \" + tag);\n      }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int classIndex = (constantPoolEntryIndex >>> 6) & 0x1f;\n  final int nameAndTypeIndex = (constantPoolEntryIndex & 0x3fff);\n  final int stringIndex = (nameAndTypeIndex >>> 10) & 0x1f;\n  final int stringLength = nameAndTypeIndex & 0x1f;\n  final int stringIndex2 = stringIndex + 1;\n  final int stringLength2 = stringIndex2 + 1;\n  charBuffer[0] = classTable[classIndex].strings[stringIndex];\n  charBuffer[1] = classTable[classIndex].strings[stringIndex2];\n  charBuffer[2] = classTable[classIndex].strings[stringLength];\n  charBuffer[3] = classTable[classIndex].strings[stringLength2];\n  charBuffer[4] = classTable[classIndex].strings[stringIndex];\n  charBuffer[5] = classTable[classIndex].strings[stringIndex2];\n  charBuffer[6] = classTable[classIndex].strings[stringLength];\n  charBuffer[7] = classTable[classIndex].strings[stringLength2];\n  return new String(charBuffer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int utfLength = readUnsignedShort(constantPoolEntryIndex);\n  final String utfContents = readUTF8(utfLength, charBuffer);\n  return utfContents;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  charBuffer[0] = '\\0';\n  final int nameIndex = readUnsignedShort(constantPoolEntryIndex);\n  final String name = readClass(nameIndex, charBuffer);\n  final int descriptorIndex = readUnsignedShort(constantPoolEntryIndex + 2);\n  final String descriptor = readClass(descriptorIndex, charBuffer);\n  return name + \":\" + descriptor;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int classIndex = readUnsignedShort(constantPoolEntryIndex);\n  final int nameAndTypeIndex = readUnsignedShort(constantPoolEntryIndex + 2);\n  final String nameAndType = readUtf(nameAndTypeIndex, charBuffer);\n  final int nameIndex = readUnsignedShort(constantPoolEntryIndex + 4);\n  final int descriptorIndex = readUnsignedShort(constantPoolEntryIndex + 6);\n  final String descriptor = readUtf(descriptorIndex, charBuffer);\n  return new String(\n      charBuffer,\n      nameIndex,\n      nameAndTypeIndex - nameIndex - 1,\n      descriptorIndex - descriptorIndex - 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  charBuffer[charBuffer.length - 1] = (char) (constantPoolEntryIndex & 0xffff);\n  return new String(charBuffer, 0, charBuffer.length - 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int utfLength = readUnsignedShort(constantPoolEntryIndex);\n  if (utfLength < 0) {\n    return null;\n  }\n  final String utfContent = new String(charBuffer, 0, utfLength);\n  if (utfContent.length() > 0) {\n    if (utfContent.charAt(0) == '[') {\n      utfContent = utfContent.substring(1);\n    } else if (utfContent.charAt(0) == 'L') {\n      utfContent = utfContent.substring(1);\n    }\n  }\n  return utfContent;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int index = readUnsignedShort(constantPoolEntryIndex);\n  final String value = this.classFileBuffer[index];\n  if (value != null) {\n    charBuffer[0] = value.charAt(0);\n  }\n  return value;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.\n * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.\n * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n */\n", "method_name": "readUtf", "codes": ["final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int index = constantPoolEntryIndex >>> Constants.SHIFT_CONSTANT_POOL_UTF; final int length = (constantPoolEntryIndex & Constants.CONSTANT_POOL_UTF_COUNT_MASK) - index; char[] chars = new char[length]; if (index >= 0 && index < chars.length) { System.arraycopy(classFileBuffer, index, chars, 0, length); } else { final StringBuilder sb = new StringBuilder(length); for (int i = 0; i < length; i++) { sb.append(charBuffer[i]); } chars = sb.toString().toCharArray(); } return new String(chars); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ int utfIndex = readUtfIndex(constantPoolEntryIndex); int utfLength = readUtfLength(constantPoolEntryIndex); char[] utf = new char[utfLength]; System.arraycopy(classFileBuffer, utfIndex, utf, 0, utfLength); return new String(utf); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int tag = this.classFileBuffer[constantPoolEntryIndex] & 0xFF; switch(tag) { case 0: { return \"\"; } case 1: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 1], charBuffer); } case 2: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 2], charBuffer); } case 3: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 3], charBuffer); } case 4: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 4], charBuffer); } case 5: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 5], charBuffer); } case 6: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 6], charBuffer); } case 7: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 7], charBuffer); } case 8: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 8], charBuffer); } case 9: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 9], charBuffer); } case 10: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 10], charBuffer); } case 11: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 11], charBuffer); } case 12: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 12], charBuffer); } case 13: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 13], charBuffer); } case 14: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 14], charBuffer); } case 15: { return readUtf(this.classFileBuffer[constantPoolEntryIndex + 15], charBuffer); } default: { throw new IllegalArgumentException(\"Illegal constant pool entry tag: \" + tag); } } }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int classIndex = (constantPoolEntryIndex >>> 6) & 0x1f; final int nameAndTypeIndex = (constantPoolEntryIndex & 0x3fff); final int stringIndex = (nameAndTypeIndex >>> 10) & 0x1f; final int stringLength = nameAndTypeIndex & 0x1f; final int stringIndex2 = stringIndex + 1; final int stringLength2 = stringIndex2 + 1; charBuffer[0] = classTable[classIndex].strings[stringIndex]; charBuffer[1] = classTable[classIndex].strings[stringIndex2]; charBuffer[2] = classTable[classIndex].strings[stringLength]; charBuffer[3] = classTable[classIndex].strings[stringLength2]; charBuffer[4] = classTable[classIndex].strings[stringIndex]; charBuffer[5] = classTable[classIndex].strings[stringIndex2]; charBuffer[6] = classTable[classIndex].strings[stringLength]; charBuffer[7] = classTable[classIndex].strings[stringLength2]; return new String(charBuffer); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int utfLength = readUnsignedShort(constantPoolEntryIndex); final String utfContents = readUTF8(utfLength, charBuffer); return utfContents; }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ charBuffer[0] = '\\0'; final int nameIndex = readUnsignedShort(constantPoolEntryIndex); final String name = readClass(nameIndex, charBuffer); final int descriptorIndex = readUnsignedShort(constantPoolEntryIndex + 2); final String descriptor = readClass(descriptorIndex, charBuffer); return name + \":\" + descriptor; }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int classIndex = readUnsignedShort(constantPoolEntryIndex); final int nameAndTypeIndex = readUnsignedShort(constantPoolEntryIndex + 2); final String nameAndType = readUtf(nameAndTypeIndex, charBuffer); final int nameIndex = readUnsignedShort(constantPoolEntryIndex + 4); final int descriptorIndex = readUnsignedShort(constantPoolEntryIndex + 6); final String descriptor = readUtf(descriptorIndex, charBuffer); return new String(charBuffer, nameIndex, nameAndTypeIndex - nameIndex - 1, descriptorIndex - descriptorIndex - 1); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ charBuffer[charBuffer.length - 1] = (char) (constantPoolEntryIndex & 0xffff); return new String(charBuffer, 0, charBuffer.length - 1); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int utfLength = readUnsignedShort(constantPoolEntryIndex); if (utfLength < 0) { return null; } final String utfContent = new String(charBuffer, 0, utfLength); if (utfContent.length() > 0) { if (utfContent.charAt(0) == '[') { utfContent = utfContent.substring(1); } else if (utfContent.charAt(0) == 'L') { utfContent = utfContent.substring(1); } } return utfContent; }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int index = readUnsignedShort(constantPoolEntryIndex); final String value = this.classFileBuffer[index]; if (value != null) { charBuffer[0] = value.charAt(0); } return value; }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec01782a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic int hashCode() {\n  int result = getType().hashCode();\n  result = 31 * result + getName().hashCode();\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  return Objects.hash(\n      this.getType(),\n      this.getName(),\n      this.getDescription(),\n      this.getOwner(),\n      this.getOwnerType(),\n      this.getOwnerDisplayName(),\n      this.getCreatedBy(),\n      this.getCreatedDate(),\n      this.getLastModifiedBy(),\n      this.getLastModifiedDate(),\n      this.getAttributes());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  int result = type.hashCode();\n  result = 31 * result + name.hashCode();\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  return Objects.hash(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  return Objects.hash(getClass());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  return type.hashCode();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  return this.getClass().getName().hashCode();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  int hash = 0;\n  hash += (getId() != null ? getId().hashCode() : 0);\n  return hash;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  return _name.hashCode();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  return name.hashCode();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a hash code value for this type.\n * @return a hash code value for this type.\n */\n", "method_name": "hashCode", "codes": ["@Override public int hashCode(){ int result = getType().hashCode(); result = 31 * result + getName().hashCode(); return result; }", "@Override public int hashCode(){ return Objects.hash(this.getType(), this.getName(), this.getDescription(), this.getOwner(), this.getOwnerType(), this.getOwnerDisplayName(), this.getCreatedBy(), this.getCreatedDate(), this.getLastModifiedBy(), this.getLastModifiedDate(), this.getAttributes()); }", "@Override public int hashCode(){ int result = type.hashCode(); result = 31 * result + name.hashCode(); return result; }", "@Override public int hashCode(){ return Objects.hash(name); }", "@Override public int hashCode(){ return Objects.hash(getClass()); }", "@Override public int hashCode(){ return type.hashCode(); }", "@Override public int hashCode(){ return this.getClass().getName().hashCode(); }", "@Override public int hashCode(){ int hash = 0; hash += (getId() != null ? getId().hashCode() : 0); return hash; }", "@Override public int hashCode(){ return _name.hashCode(); }", "@Override public int hashCode(){ return name.hashCode(); }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec017758", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int pos = cp.addUtf8(name);\n  if (cp.addUtf8(descriptor)) {\n    cp.addUtf8(descriptor);\n  }\n  int index = constantPool.addConstant(pos, cp);\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  if (constantPool == null) {\n    return 0;\n  }\n  int cIndex = constantPool.addUtf8Info(name);\n  int dIndex = constantPool.addUtf8Info(descriptor);\n  if (cIndex < 0) {\n    cIndex = constantPool.addClassInfo(name);\n    dIndex = constantPool.addClassInfo(descriptor);\n  }\n  if (dIndex < 0) {\n    dIndex = constantPool.addMethodrefInfo(name, descriptor);\n  }\n  if (cIndex < 0 || dIndex < 0) {\n    return -1;\n  }\n  Symbol sym = new Symbol(name, cIndex, dIndex);\n  constantPool.addSymbol(sym);\n  return cIndex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int index = constantPool.addUtf8Info(name);\n  if (index < 0) {\n    return index;\n  }\n  index += Constants.CONSTANT_Utf8_info_name_and_type_index;\n  int type = constantPool.addUtf8Info(descriptor);\n  if (type < 0) {\n    return index;\n  }\n  return index + Constants.CONSTANT_Utf8_info_name_and_type_index + type;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  if (isConstant(name)) {\n    return -1;\n  }\n  if (!isConstant(descriptor)) {\n    return -2;\n  }\n  int c = getConstantPool().addConstantNameAndType(name, descriptor);\n  if (c == -1) {\n    return -3;\n  }\n  if (c == CONSTANT_NameAndType_info.CONSTANT_Utf8) {\n    return -4;\n  }\n  if (c == CONSTANT_NameAndType_info.CONSTANT_Integer) {\n    return -5;\n  }\n  if (c == CONSTANT_NameAndType_info.CONSTANT_Float) {\n    return -6;\n  }\n  if (c == CONSTANT_NameAndType_info.CONSTANT_Long) {\n    return -7;\n  }\n  if (c == CONSTANT_NameAndType_info.CONSTANT_Double) {\n    return -8;\n  }\n  if (c == CONSTANT_NameAndType_info.CONSTANT_NameAndType) {\n    return -9;\n  }\n  return c;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  return addConstantNameAndType(name, descriptor, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int index = constantPool.addUtf8Info(name, descriptor);\n  if (index < 0) {\n    index = constantPool.addConstantInfo(name, descriptor);\n  }\n  if (index < 0) {\n    throw new IllegalArgumentException(\"Unknown constant pool name: \" + name);\n  }\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  if (constantNameAndTypePool.containsKey(name)) {\n    return constantNameAndTypePool.get(name);\n  }\n  int cst = addConstantUtf8(name);\n  if (descriptor != null) {\n    cst += addConstantUtf8(descriptor);\n  }\n  int index = constantPool.addUtf8(name);\n  constantNameAndTypePool.put(name, index);\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int index = -1;\n  if (constantPool == null) {\n    constantPool = new ConstantPool(this);\n  }\n  if (!constantPool.contains(name)) {\n    index = constantPool.add(name, descriptor);\n  } else {\n    index = constantPool.get(name);\n  }\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  if (descriptor == null) {\n    return -1;\n  }\n  Symbol sym = getSymbol(name, descriptor);\n  if (sym != null) {\n    return sym.getIndex();\n  }\n  int index = cpool.addConstantNameAndType(name, descriptor);\n  sym = new Symbol(index, name, descriptor);\n  sym.setIndex(index);\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int index = findConstantIndex(name);\n  if (index == -1) {\n    index = constantPool.addConstant(CONSTANT_NameAndType);\n    constantPool.setConstant(index, name, descriptor);\n  }\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n", "method_name": "addConstantNameAndType", "codes": ["int addConstantNameAndType(final String name,final String descriptor){ int pos = cp.addUtf8(name); if (cp.addUtf8(descriptor)) { cp.addUtf8(descriptor); } int index = constantPool.addConstant(pos, cp); return index; }", "int addConstantNameAndType(final String name,final String descriptor){ if (constantPool == null) { return 0; } int cIndex = constantPool.addUtf8Info(name); int dIndex = constantPool.addUtf8Info(descriptor); if (cIndex < 0) { cIndex = constantPool.addClassInfo(name); dIndex = constantPool.addClassInfo(descriptor); } if (dIndex < 0) { dIndex = constantPool.addMethodrefInfo(name, descriptor); } if (cIndex < 0 || dIndex < 0) { return -1; } Symbol sym = new Symbol(name, cIndex, dIndex); constantPool.addSymbol(sym); return cIndex; }", "int addConstantNameAndType(final String name,final String descriptor){ int index = constantPool.addUtf8Info(name); if (index < 0) { return index; } index += Constants.CONSTANT_Utf8_info_name_and_type_index; int type = constantPool.addUtf8Info(descriptor); if (type < 0) { return index; } return index + Constants.CONSTANT_Utf8_info_name_and_type_index + type; }", "int addConstantNameAndType(final String name,final String descriptor){ if (isConstant(name)) { return -1; } if (!isConstant(descriptor)) { return -2; } int c = getConstantPool().addConstantNameAndType(name, descriptor); if (c == -1) { return -3; } if (c == CONSTANT_NameAndType_info.CONSTANT_Utf8) { return -4; } if (c == CONSTANT_NameAndType_info.CONSTANT_Integer) { return -5; } if (c == CONSTANT_NameAndType_info.CONSTANT_Float) { return -6; } if (c == CONSTANT_NameAndType_info.CONSTANT_Long) { return -7; } if (c == CONSTANT_NameAndType_info.CONSTANT_Double) { return -8; } if (c == CONSTANT_NameAndType_info.CONSTANT_NameAndType) { return -9; } return c; }", "int addConstantNameAndType(final String name,final String descriptor){ return addConstantNameAndType(name, descriptor, null); }", "int addConstantNameAndType(final String name,final String descriptor){ int index = constantPool.addUtf8Info(name, descriptor); if (index < 0) { index = constantPool.addConstantInfo(name, descriptor); } if (index < 0) { throw new IllegalArgumentException(\"Unknown constant pool name: \" + name); } return index; }", "int addConstantNameAndType(final String name,final String descriptor){ if (constantNameAndTypePool.containsKey(name)) { return constantNameAndTypePool.get(name); } int cst = addConstantUtf8(name); if (descriptor != null) { cst += addConstantUtf8(descriptor); } int index = constantPool.addUtf8(name); constantNameAndTypePool.put(name, index); return index; }", "int addConstantNameAndType(final String name,final String descriptor){ int index = -1; if (constantPool == null) { constantPool = new ConstantPool(this); } if (!constantPool.contains(name)) { index = constantPool.add(name, descriptor); } else { index = constantPool.get(name); } return index; }", "int addConstantNameAndType(final String name,final String descriptor){ if (descriptor == null) { return -1; } Symbol sym = getSymbol(name, descriptor); if (sym != null) { return sym.getIndex(); } int index = cpool.addConstantNameAndType(name, descriptor); sym = new Symbol(index, name, descriptor); sym.setIndex(index); return index; }", "int addConstantNameAndType(final String name,final String descriptor){ int index = findConstantIndex(name); if (index == -1) { index = constantPool.addConstant(CONSTANT_NameAndType); constantPool.setConstant(index, name, descriptor); } return index; }"], "code_level": "project_runnable", "_id": "636766fe1a6d9265ec017823", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "final void addLineNumber(final int lineNumber) {\n  this.lineNumber.add(lineNumber);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  if (lineNumber >= 0) {\n    if (this.lineNumber == null) {\n      this.lineNumber = new LinkedList<Integer>();\n    }\n    this.lineNumber.add(lineNumber);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  lineNumbers.add(lineNumber);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  if (lineNumber < 0) {\n    throw new IllegalArgumentException(\"Line number cannot be negative: \" + lineNumber);\n  }\n  if (lineNumber == 0) {\n    throw new IllegalArgumentException(\"Line number cannot be zero: \" + lineNumber);\n  }\n  if (lineNumber >= mLineNumbers.length) {\n    final int newLength = ArrayUtils.idealIntArraySize(lineNumbers.length + 1);\n    lineNumbers = Arrays.copyOf(lineNumbers, newLength);\n  }\n  lineNumbers[lineNumber] = lineNumber;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  if (lineNumber < 0) {\n    throw new IllegalArgumentException(\"lineNumber cannot be negative\");\n  }\n  if (this.lineNumber != 0) {\n    throw new IllegalStateException(\"lineNumber already set\");\n  }\n  this.lineNumber = lineNumber;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  if (lineNumber < 0) {\n    throw new IllegalArgumentException(\"Line number must be positive.\");\n  }\n  lineNumbers.add(lineNumber);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  if (lineNumber < 0) {\n    throw new IllegalArgumentException(\"Line number can not be negative: \" + lineNumber);\n  }\n  if (lineNumber >= lineNumbers.size()) {\n    lineNumbers.add(lineNumber);\n  } else {\n    lineNumbers.set(lineNumbers.size() - 1, lineNumber);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  if (lineNumber >= 0) {\n    mLineNumber = lineNumber;\n  } else {\n    mLineNumber = Integer.MAX_VALUE;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  if (lineNumber < 0) {\n    throw new IllegalArgumentException(\"Line number must be positive: \" + lineNumber);\n  }\n  if (lineNumber >= this.lineNumber) {\n    this.lineNumber = lineNumber;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  if (lineNumber < 0) {\n    throw new IllegalArgumentException(\"Line number cannot be negative: \" + lineNumber);\n  }\n  this.lineNumber = lineNumber;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n", "method_name": "addLineNumber", "codes": ["final void addLineNumber(final int lineNumber){ this.lineNumber.add(lineNumber); }", "final void addLineNumber(final int lineNumber){ if (lineNumber >= 0) { if (this.lineNumber == null) { this.lineNumber = new LinkedList<Integer>(); } this.lineNumber.add(lineNumber); } }", "final void addLineNumber(final int lineNumber){ lineNumbers.add(lineNumber); }", "final void addLineNumber(final int lineNumber){ if (lineNumber < 0) { throw new IllegalArgumentException(\"Line number cannot be negative: \" + lineNumber); } if (lineNumber == 0) { throw new IllegalArgumentException(\"Line number cannot be zero: \" + lineNumber); } if (lineNumber >= mLineNumbers.length) { final int newLength = ArrayUtils.idealIntArraySize(lineNumbers.length + 1); lineNumbers = Arrays.copyOf(lineNumbers, newLength); } lineNumbers[lineNumber] = lineNumber; }", "final void addLineNumber(final int lineNumber){ if (lineNumber < 0) { throw new IllegalArgumentException(\"lineNumber cannot be negative\"); } if (this.lineNumber != 0) { throw new IllegalStateException(\"lineNumber already set\"); } this.lineNumber = lineNumber; }", "final void addLineNumber(final int lineNumber){ if (lineNumber < 0) { throw new IllegalArgumentException(\"Line number must be positive.\"); } lineNumbers.add(lineNumber); }", "final void addLineNumber(final int lineNumber){ if (lineNumber < 0) { throw new IllegalArgumentException(\"Line number can not be negative: \" + lineNumber); } if (lineNumber >= lineNumbers.size()) { lineNumbers.add(lineNumber); } else { lineNumbers.set(lineNumbers.size() - 1, lineNumber); } }", "final void addLineNumber(final int lineNumber){ if (lineNumber >= 0) { mLineNumber = lineNumber; } else { mLineNumber = Integer.MAX_VALUE; } }", "final void addLineNumber(final int lineNumber){ if (lineNumber < 0) { throw new IllegalArgumentException(\"Line number must be positive: \" + lineNumber); } if (lineNumber >= this.lineNumber) { this.lineNumber = lineNumber; } }", "final void addLineNumber(final int lineNumber){ if (lineNumber < 0) { throw new IllegalArgumentException(\"Line number cannot be negative: \" + lineNumber); } this.lineNumber = lineNumber; }"], "code_level": "class_runnable", "_id": "636767131a6d9265ec017b23", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  return indexOfLastSeparator(filename, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  int lastSeparator = -1;\n  if (lastUnixPos >= 0) {\n    lastSeparator = lastUnixPos;\n    if (lastWindowsPos >= 0 && lastWindowsPos == lastUnixPos) {\n      lastSeparator++;\n    }\n  }\n  return lastSeparator;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  return indexOfLastSeparator(getFilename(filename));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  return indexOfLastSeparator(getFilename(filename));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n", "method_name": "indexOfLastSeparator", "codes": ["public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ return indexOfLastSeparator(filename, false); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); int lastSeparator = -1; if (lastUnixPos >= 0) { lastSeparator = lastUnixPos; if (lastWindowsPos >= 0 && lastWindowsPos == lastUnixPos) { lastSeparator++; } } return lastSeparator; }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ return indexOfLastSeparator(getFilename(filename)); }", "public static int indexOfLastSeparator(String filename){ return indexOfLastSeparator(getFilename(filename)); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec017658", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.exists()) {\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      if (files != null) {\n        for (File child : files) {\n          forceDeleteOnExit(child);\n        }\n      }\n    }\n    if (!file.delete()) {\n      throw new IOException(\"Could not delete file \" + file);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.exists()) {\n    if (file.isDirectory()) {\n      deleteDirectoryOnExit(file);\n    } else {\n      file.deleteOnExit();\n    }\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteContents(file);\n  } else {\n    if (!file.delete()) {\n      String message = String.format(\"Unable to force deleteOnExit file %s\", file);\n      throw new IOException(message);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    boolean filePresent = file.exists();\n    if (!file.deleteOnExit()) {\n      if (!filePresent) {\n        throw new IllegalArgumentException(\"File does not exist: \" + file);\n      } else if (file.isFile()) {\n        throw new IOException(\"Cannot delete file: \" + file);\n      } else {\n        throw new IOException(\"Cannot delete directory: \" + file);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    boolean filePresent = file.exists();\n    if (!file.deleteOnExit()) {\n      if (!filePresent) {\n        throw new FileNotFoundException(\"File does not exist: \" + file);\n      }\n      String message = String.format(\"Cannot delete on exit file: %s\", file);\n      throw new IOException(message);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Schedules a file to be deleted when JVM exits. If file is directory delete it and all sub-directories.\n * @param file  file or directory to delete, must not be {@code null}\n * @throws NullPointerException if the file is {@code null}\n * @throws IOException in case deletion is unsuccessful\n */\n", "method_name": "forceDeleteOnExit", "codes": ["public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.exists()) { if (file.isDirectory()) { File[] files = file.listFiles(); if (files != null) { for (File child : files) { forceDeleteOnExit(child); } } } if (!file.delete()) { throw new IOException(\"Could not delete file \" + file); } } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.exists()) { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteContents(file); } else { if (!file.delete()) { String message = String.format(\"Unable to force deleteOnExit file %s\", file); throw new IOException(message); } } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { boolean filePresent = file.exists(); if (!file.deleteOnExit()) { if (!filePresent) { throw new IllegalArgumentException(\"File does not exist: \" + file); } else if (file.isFile()) { throw new IOException(\"Cannot delete file: \" + file); } else { throw new IOException(\"Cannot delete directory: \" + file); } } } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { boolean filePresent = file.exists(); if (!file.deleteOnExit()) { if (!filePresent) { throw new FileNotFoundException(\"File does not exist: \" + file); } String message = String.format(\"Cannot delete on exit file: %s\", file); throw new IOException(message); } } }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec017833", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n", "method_name": "indexOfExtension", "codes": ["public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }"], "code_level": "class_runnable", "_id": "636767061a6d9265ec01794a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  if (b == null) {\n    return;\n  }\n  int len = b.length;\n  if (len == 0) {\n    return;\n  }\n  if (len > mBuffer.length) {\n    mBuffer = new byte[len];\n  }\n  System.arraycopy(b, 0, mBuffer, 0, len);\n  mBufferLength += len;\n  mByteCount += len;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  if (b.length == 0) return;\n  if (b.length <= limit - count) {\n    System.arraycopy(b, 0, buffer, count, b.length);\n    count += b.length;\n  } else {\n    byte[] newbuffer = new byte[limit - count];\n    System.arraycopy(buffer, 0, newbuffer, 0, count);\n    System.arraycopy(b, 0, newbuffer, count, b.length);\n    buffer = newbuffer;\n    count = b.length;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  if (b == null) {\n    write((byte[]) null);\n  } else {\n    write(b, 0, b.length);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  if (_outputTail >= _outputEnd) {\n    _flushBuffer();\n  }\n  System.arraycopy(b, 0, _outputBuffer, _outputTail, b.length);\n  _outputTail += b.length;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  if (b.length == 0) {\n    return;\n  }\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  if (b == null) {\n    writeInt(-1);\n  } else {\n    writeInt(b.length);\n    write(b);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  if (b.length > 0) {\n    out.write(b);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  if (b == null) {\n    return;\n  }\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Writes <code>b.length</code> bytes from the specified byte array to this output stream.\n * @param b The array of bytes to be written.\n * @exception IOException if an error occurs.\n */\n", "method_name": "write", "codes": ["@Override public void write(byte b[]) throws IOException { if (b == null) { return; } int len = b.length; if (len == 0) { return; } if (len > mBuffer.length) { mBuffer = new byte[len]; } System.arraycopy(b, 0, mBuffer, 0, len); mBufferLength += len; mByteCount += len; }", "@Override public void write(byte b[]) throws IOException { if (b.length == 0) return; if (b.length <= limit - count) { System.arraycopy(b, 0, buffer, count, b.length); count += b.length; } else { byte[] newbuffer = new byte[limit - count]; System.arraycopy(buffer, 0, newbuffer, 0, count); System.arraycopy(b, 0, newbuffer, count, b.length); buffer = newbuffer; count = b.length; } }", "@Override public void write(byte b[]) throws IOException { if (b == null) { write((byte[]) null); } else { write(b, 0, b.length); } }", "@Override public void write(byte b[]) throws IOException { if (_outputTail >= _outputEnd) { _flushBuffer(); } System.arraycopy(b, 0, _outputBuffer, _outputTail, b.length); _outputTail += b.length; }", "@Override public void write(byte b[]) throws IOException { out.write(b); }", "@Override public void write(byte b[]) throws IOException { if (b.length == 0) { return; } write(b, 0, b.length); }", "@Override public void write(byte b[]) throws IOException { if (b == null) { writeInt(-1); } else { writeInt(b.length); write(b); } }", "@Override public void write(byte b[]) throws IOException { if (b.length > 0) { out.write(b); } }", "@Override public void write(byte b[]) throws IOException { if (b == null) { return; } write(b, 0, b.length); }", "@Override public void write(byte b[]) throws IOException { write(b, 0, b.length); }"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec0179fe", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (len == 0) {\n    return;\n  }\n  if (buffer.length - currentPosition < len) {\n    flushBuffer();\n  }\n  System.arraycopy(b, off, buffer, currentPosition, len);\n  currentPosition += len;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  this.out.write(b, off, len);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len > 0) {\n    if (len >= 4) {\n      if (len == 4) {\n        writeInt(b[off] & 0xff);\n        writeInt(b[off + 1] & 0xff);\n        writeInt(b[off + 2] & 0xff);\n        writeInt(b[off + 3] & 0xff);\n      } else {\n        writeInt(\n            b[off] & 0xff\n                | (b[off + 1] & 0xff) << 8\n                | (b[off + 2] & 0xff) << 16\n                | (b[off + 3] & 0xff) << 24);\n      }\n    } else {\n      writeInt(\n          b[off] & 0xff\n              | (b[off + 1] & 0xff) << 8\n              | (b[off + 2] & 0xff) << 16\n              | (b[off + 3] & 0xff) << 24);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len == 0) {\n    return;\n  }\n  if (len >= 4) {\n    int i = off;\n    while (len > 4) {\n      int b1 = b[i++] & 0xff;\n      int b2 = b[i++] & 0xff;\n      int b3 = b[i++] & 0xff;\n      int b4 = b[i++] & 0xff;\n      out.write((byte) ((b1 << 2) | (b2 >> 4)));\n      out.write((byte) ((b2 << 4) | (b3 >> 2)));\n      out.write((byte) ((b3 << 6) | b4));\n      i += 3;\n      len -= 3;\n    }\n    int b1 = b[i++] & 0xff;\n    int b2 = b[i++] & 0xff;\n    int b3 = b[i++] & 0xff;\n    int b4 = b[i++] & 0xff;\n    out.write((byte) ((b1 << 2) | (b2 >> 4)));\n    out.write((byte) ((b2 << 4) | (b3 >> 2)));\n    out.write((byte) ((b3 << 6) | b4));\n  } else {\n    for (int i = off; i < off + len; i++) {\n      out.write(b[i]);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len < 0) {\n    throw new IndexOutOfBoundsException(\"len < 0: \" + len);\n  }\n  if (len == 0) {\n    return;\n  }\n  if (len >= buffer.length) {\n    flush();\n  }\n  System.arraycopy(b, off, buffer, bufferPosition, len);\n  bufferPosition += len;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (b == null) {\n    throw new NullPointerException();\n  }\n  if ((off < 0)\n      || (off > b.length)\n      || (len < 0)\n      || ((off + len) > b.length)\n      || ((off + len) < 0)) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (len == 0) {\n    return;\n  }\n  if (this.closed) {\n    throw new IOException(\"Stream is closed\");\n  }\n  if (this.position >= this.count) {\n    flushBuffer();\n  }\n  System.arraycopy(b, off, this.buffer, this.position, len);\n  this.position += len;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len == 0) {\n    return;\n  }\n  if (off < 0 || len < 0 || off > b.length - len) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (len == 0) {\n    return;\n  }\n  if (len == 1) {\n    write(b[off]);\n    return;\n  }\n  if (out == null) {\n    throw new IOException(\"Stream closed\");\n  }\n  out.write(b, off, len);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if ((off < 0)\n      || (off > b.length)\n      || (len < 0)\n      || ((off + len) > b.length)\n      || ((off + len) < 0)) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (len == 0) {\n    return;\n  }\n  if (_buffer.length < len) {\n    _buffer = new byte[len];\n  }\n  System.arraycopy(b, off, _buffer, 0, len);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len == 0) {\n    return;\n  }\n  int remaining = len;\n  while (remaining > 0) {\n    final int writeLen = Math.min(remaining, buffer.length - position);\n    System.arraycopy(b, off, buffer, position, writeLen);\n    position += writeLen;\n    remaining -= writeLen;\n    off += writeLen;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  write(new byte[] {b}, off, len);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.\n * @param b   the data.\n * @param off the start offset in the data.\n * @param len the number of bytes to write.\n */\n", "method_name": "write", "codes": ["@Override public void write(final byte b[],final int off,final int len) throws IOException { if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) { throw new IndexOutOfBoundsException(); } if (len == 0) { return; } if (buffer.length - currentPosition < len) { flushBuffer(); } System.arraycopy(b, off, buffer, currentPosition, len); currentPosition += len; }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { this.out.write(b, off, len); }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len > 0) { if (len >= 4) { if (len == 4) { writeInt(b[off] & 0xff); writeInt(b[off + 1] & 0xff); writeInt(b[off + 2] & 0xff); writeInt(b[off + 3] & 0xff); } else { writeInt(b[off] & 0xff | (b[off + 1] & 0xff) << 8 | (b[off + 2] & 0xff) << 16 | (b[off + 3] & 0xff) << 24); } } else { writeInt(b[off] & 0xff | (b[off + 1] & 0xff) << 8 | (b[off + 2] & 0xff) << 16 | (b[off + 3] & 0xff) << 24); } } }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len == 0) { return; } if (len >= 4) { int i = off; while (len > 4) { int b1 = b[i++] & 0xff; int b2 = b[i++] & 0xff; int b3 = b[i++] & 0xff; int b4 = b[i++] & 0xff; out.write((byte) ((b1 << 2) | (b2 >> 4))); out.write((byte) ((b2 << 4) | (b3 >> 2))); out.write((byte) ((b3 << 6) | b4)); i += 3; len -= 3; } int b1 = b[i++] & 0xff; int b2 = b[i++] & 0xff; int b3 = b[i++] & 0xff; int b4 = b[i++] & 0xff; out.write((byte) ((b1 << 2) | (b2 >> 4))); out.write((byte) ((b2 << 4) | (b3 >> 2))); out.write((byte) ((b3 << 6) | b4)); } else { for (int i = off; i < off + len; i++) { out.write(b[i]); } } }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len < 0) { throw new IndexOutOfBoundsException(\"len < 0: \" + len); } if (len == 0) { return; } if (len >= buffer.length) { flush(); } System.arraycopy(b, off, buffer, bufferPosition, len); bufferPosition += len; }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (b == null) { throw new NullPointerException(); } if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)) { throw new IndexOutOfBoundsException(); } if (len == 0) { return; } if (this.closed) { throw new IOException(\"Stream is closed\"); } if (this.position >= this.count) { flushBuffer(); } System.arraycopy(b, off, this.buffer, this.position, len); this.position += len; }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len == 0) { return; } if (off < 0 || len < 0 || off > b.length - len) { throw new IndexOutOfBoundsException(); } if (len == 0) { return; } if (len == 1) { write(b[off]); return; } if (out == null) { throw new IOException(\"Stream closed\"); } out.write(b, off, len); }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)) { throw new IndexOutOfBoundsException(); } if (len == 0) { return; } if (_buffer.length < len) { _buffer = new byte[len]; } System.arraycopy(b, off, _buffer, 0, len); }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len == 0) { return; } int remaining = len; while (remaining > 0) { final int writeLen = Math.min(remaining, buffer.length - position); System.arraycopy(b, off, buffer, position, writeLen); position += writeLen; remaining -= writeLen; off += writeLen; } }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { write(new byte[] { b }, off, len); }"], "code_level": "class_runnable", "_id": "636766f91a6d9265ec01776e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  this.write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  this.dos.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  this.out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  if (b == null) {\n    throw new NullPointerException();\n  }\n  if (b.length == 0) {\n    return;\n  }\n  if (this.closed) {\n    throw new IOException(\"Stream closed\");\n  }\n  if (this.buffer == null) {\n    this.buffer = ByteBuffer.wrap(b);\n  } else {\n    this.buffer.put(b);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  this.outputStream.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  if (b == null) {\n    write((byte) -1);\n  } else {\n    write(b, 0, b.length);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  if (b == null) {\n    return;\n  }\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @see OutputStream#write(byte[]) \n */\n", "method_name": "write", "codes": ["@Override public void write(final byte[] b) throws IOException { this.write(b, 0, b.length); }", "@Override public void write(final byte[] b) throws IOException { this.dos.write(b); }", "@Override public void write(final byte[] b) throws IOException { this.out.write(b); }", "@Override public void write(final byte[] b) throws IOException { write(b, 0, b.length); }", "@Override public void write(final byte[] b) throws IOException { if (b == null) { throw new NullPointerException(); } if (b.length == 0) { return; } if (this.closed) { throw new IOException(\"Stream closed\"); } if (this.buffer == null) { this.buffer = ByteBuffer.wrap(b); } else { this.buffer.put(b); } }", "@Override public void write(final byte[] b) throws IOException { out.write(b); }", "@Override public void write(final byte[] b) throws IOException { this.outputStream.write(b); }", "@Override public void write(final byte[] b) throws IOException { if (b == null) { write((byte) -1); } else { write(b, 0, b.length); } }", "@Override public void write(final byte[] b) throws IOException { if (b == null) { return; } write(b, 0, b.length); }", "@Override public void write(final byte[] b) throws IOException { out.write(b); }"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179d8", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public String toString() {\n  return this.toString(\"\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String toString() {\n  return this.toString(new StringBuffer(), 0).toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuffer buf = new StringBuffer();\n  buf.append(\"[\");\n  buf.append(\"name=\" + name);\n  buf.append(\",value=\" + value);\n  buf.append(\",type=\" + type);\n  buf.append(\"]\");\n  return buf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return builder.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return String.format(\"%s %s\", getLanguage(), getValue());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuffer sb = new StringBuffer();\n  sb.append(\"[\");\n  sb.append(id);\n  sb.append(\",\");\n  sb.append(name);\n  sb.append(\",\");\n  sb.append(url);\n  sb.append(\",\");\n  sb.append(description);\n  sb.append(\",\");\n  sb.append(status);\n  sb.append(\",\");\n  sb.append(created);\n  sb.append(\",\");\n  sb.append(updated);\n  sb.append(\",\");\n  sb.append(version);\n  sb.append(\"]\");\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){ StringBuilder sb = new StringBuilder(); sb.append(\"{\"); if (getName() != null) { sb.append(\"Name: \" + getName() + \", \"); } if (getSecurityGroups() != null) { sb.append(\"SecurityGroups: \" + getSecurityGroups() + \", \"); } if (getVpcId() != null) { sb.append(\"VpcId: \" + getVpcId() + \", \"); } if (getGroups() != null) { sb.append(\"Groups: \" + getGroups() + \", \"); } if (getIops() != null) { sb.append(\"Iops: \" + getIops() + \", \"); } if (getIpProtocol() != null) { sb.append(\"IpProtocol: \" + getIpProtocol() + \", \"); } if (getIpAddress() != null) { sb.append(\"IpAddress: \" + getIpAddress() + \", \"); } if (getIpv6Address() != null) { sb.append(\"Ipv6Address: \" + getIpv6Address() + \", \"); } if (getPorts() != null) { sb.append(\"Ports: \" + getPorts() + \", \"); } if (getUserData() != null) { sb.append(\"UserData: \" + getUserData() + \", \"); } if (getKeyPairName() != null) { sb.append(\"KeyPairName: \" + getKeyPairName() + \", \"); } if (getKeyName() != null) { sb.append(\"KeyName: \" + getKeyName() + \", \"); } if (getSubnetId() != null) { sb.append(\"SubnetId: \" + getSubnetId() + \", \"); } if (getAvailabilityZone() != null) { sb.append(\"AvailabilityZone: \" + getAvailabilityZone() + \", \"); } if (getIamInstanceProfile() != null) { sb.append(\"IamInstanceProfile: \" + getIamInstanceProfile() + \", \"); } if (getPrivateDnsName() != null) { sb.append(\"PrivateDnsName: \" + getPrivateDnsName() + \", \"); } if (getPrivateIpAddress() != null) { sb.append(\"PrivateIpAddress: \" + getPrivateIpAddress() + \", \"); } if (getPublicDnsName() != null) { sb.append(\"PublicDnsName: \" + getPublicDnsName() + \", \"); } if (getPublicIpAddress() != null) { sb.append(\"PublicIpAddress: \" + getPublicIpAddress() + \", \"); } if (getPublicIpv6Address() != null) { sb.append(\"PublicIpv6Address: \" + getPublicIpv6Address() + \", \"); } if (getSecurityGroups() != null) { sb.append(\"SecurityGroups: \" + getSecurityGroups() + \", \"); } sb.append(\"", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuilder sb = new StringBuilder(\"[\");\n  sb.append(\"type:\" + type + \",\");\n  sb.append(\"number:\" + number + \",\");\n  sb.append(\"value:\" + value + \",\");\n  sb.append(\"relative:\" + relative + \",\");\n  sb.append(\"additionalProperties:\" + additionalProperties + \",\");\n  sb.append(\"]\");\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return \"StatementBlock(\" + this.getStatements() + \")\";\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return this.toString(\"\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p> Gets the String built by this builder. </p>\n * @return the built string\n */\n", "method_name": "toString", "codes": ["public String toString(){ return this.toString(\"\"); }", "public String toString(){ return this.toString(new StringBuffer(), 0).toString(); }", "public String toString(){ StringBuffer buf = new StringBuffer(); buf.append(\"[\"); buf.append(\"name=\" + name); buf.append(\",value=\" + value); buf.append(\",type=\" + type); buf.append(\"]\"); return buf.toString(); }", "public String toString(){ return builder.toString(); }", "public String toString(){ return String.format(\"%s %s\", getLanguage(), getValue()); }", "public String toString(){ StringBuffer sb = new StringBuffer(); sb.append(\"[\"); sb.append(id); sb.append(\",\"); sb.append(name); sb.append(\",\"); sb.append(url); sb.append(\",\"); sb.append(description); sb.append(\",\"); sb.append(status); sb.append(\",\"); sb.append(created); sb.append(\",\"); sb.append(updated); sb.append(\",\"); sb.append(version); sb.append(\"]\"); return sb.toString(); }", "public String toString(){ StringBuilder sb = new StringBuilder(); sb.append(\"{\"); if (getName() != null) { sb.append(\"Name: \" + getName() + \", \"); } if (getSecurityGroups() != null) { sb.append(\"SecurityGroups: \" + getSecurityGroups() + \", \"); } if (getVpcId() != null) { sb.append(\"VpcId: \" + getVpcId() + \", \"); } if (getGroups() != null) { sb.append(\"Groups: \" + getGroups() + \", \"); } if (getIops() != null) { sb.append(\"Iops: \" + getIops() + \", \"); } if (getIpProtocol() != null) { sb.append(\"IpProtocol: \" + getIpProtocol() + \", \"); } if (getIpAddress() != null) { sb.append(\"IpAddress: \" + getIpAddress() + \", \"); } if (getIpv6Address() != null) { sb.append(\"Ipv6Address: \" + getIpv6Address() + \", \"); } if (getPorts() != null) { sb.append(\"Ports: \" + getPorts() + \", \"); } if (getUserData() != null) { sb.append(\"UserData: \" + getUserData() + \", \"); } if (getKeyPairName() != null) { sb.append(\"KeyPairName: \" + getKeyPairName() + \", \"); } if (getKeyName() != null) { sb.append(\"KeyName: \" + getKeyName() + \", \"); } if (getSubnetId() != null) { sb.append(\"SubnetId: \" + getSubnetId() + \", \"); } if (getAvailabilityZone() != null) { sb.append(\"AvailabilityZone: \" + getAvailabilityZone() + \", \"); } if (getIamInstanceProfile() != null) { sb.append(\"IamInstanceProfile: \" + getIamInstanceProfile() + \", \"); } if (getPrivateDnsName() != null) { sb.append(\"PrivateDnsName: \" + getPrivateDnsName() + \", \"); } if (getPrivateIpAddress() != null) { sb.append(\"PrivateIpAddress: \" + getPrivateIpAddress() + \", \"); } if (getPublicDnsName() != null) { sb.append(\"PublicDnsName: \" + getPublicDnsName() + \", \"); } if (getPublicIpAddress() != null) { sb.append(\"PublicIpAddress: \" + getPublicIpAddress() + \", \"); } if (getPublicIpv6Address() != null) { sb.append(\"PublicIpv6Address: \" + getPublicIpv6Address() + \", \"); } if (getSecurityGroups() != null) { sb.append(\"SecurityGroups: \" + getSecurityGroups() + \", \"); } sb.append(\"", "public String toString(){ StringBuilder sb = new StringBuilder(\"[\"); sb.append(\"type:\" + type + \",\"); sb.append(\"number:\" + number + \",\"); sb.append(\"value:\" + value + \",\"); sb.append(\"relative:\" + relative + \",\"); sb.append(\"additionalProperties:\" + additionalProperties + \",\"); sb.append(\"]\"); return sb.toString(); }", "public String toString(){ return \"StatementBlock(\" + this.getStatements() + \")\"; }", "public String toString(){ return this.toString(\"\"); }"], "code_level": "project_runnable", "_id": "636767001a6d9265ec01787e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) buffer.append(arraySeparator);\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    buffer.append(fieldName).append(\"[\").append(i).append(\"]=\").append(array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    buffer.append(fieldName).append(\"[\").append(i).append(\"]=\").append(array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    buffer.append(fieldName).append(\"[\").append(i).append(\"]=\").append(array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    buffer.append(fieldName).append(\"[\").append(i).append(\"]=\").append(array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n", "method_name": "appendDetail", "codes": ["protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) buffer.append(arraySeparator); appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } buffer.append(fieldName).append(\"[\").append(i).append(\"]=\").append(array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } buffer.append(fieldName).append(\"[\").append(i).append(\"]=\").append(array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } buffer.append(fieldName).append(\"[\").append(i).append(\"]=\").append(array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } buffer.append(fieldName).append(\"[\").append(i).append(\"]=\").append(array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }"], "code_level": "class_runnable", "_id": "636767001a6d9265ec01787f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (isEmpty(collection)) {\n    return EMPTY_STRING_ARRAY;\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (isEmpty(collection)) {\n    return EMPTY_STRING_ARRAY;\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return null;\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return null;\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return null;\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (isEmpty(collection)) {\n    return new String[0];\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (isEmpty(collection)) {\n    return ArrayUtils.EMPTY_STRING_ARRAY;\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return null;\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return null;\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return null;\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.\n * @param collection The collection to convert\n * @return A new array of Strings.\n */\n", "method_name": "toNoNullStringArray", "codes": ["static String[] toNoNullStringArray(Collection<?> collection){ if (isEmpty(collection)) { return EMPTY_STRING_ARRAY; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (isEmpty(collection)) { return EMPTY_STRING_ARRAY; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return null; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return null; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return null; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (isEmpty(collection)) { return new String[0]; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (isEmpty(collection)) { return ArrayUtils.EMPTY_STRING_ARRAY; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return null; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return null; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return null; } return collection.toArray(new String[collection.size()]); }"], "code_level": "project_runnable", "_id": "636766f71a6d9265ec017730", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "static void register(Object value) {\n  if (value == null) {\n    return;\n  }\n  try {\n    if (value.getClass().isArray()) {\n      Class<?> componentType = value.getClass().getComponentType();\n      Object[] newArray = (Object[]) Array.newInstance(componentType, Array.getLength(value));\n      System.arraycopy(Array.getLength(value), 0, newArray, 0, Array.getLength(value));\n      value = newArray;\n    }\n  } catch (ClassCastException e) {\n  }\n  if (value instanceof Class) {\n    register((Class<?>) value);\n  } else if (value instanceof Enum) {\n    register(((Enum<?>) value).name());\n  } else if (value instanceof Iterable) {\n    Iterable<?> iterable = (Iterable<?>) value;\n    for (Object item : iterable) {\n      register(item);\n    }\n  } else if (value instanceof Map) {\n    Map<?, ?> map = (Map<?, ?>) value;\n    for (Map.Entry<?, ?> entry : map.entrySet()) {\n      register(entry.getKey());\n      register(entry.getValue());\n    }\n  } else if (value instanceof Enumeration) {\n    Enumeration<?> enumeration = (Enumeration<?>) value;\n    while (enumeration.hasMoreElements()) {\n      register(enumeration.nextElement());\n    }\n  } else {\n    throw new IllegalArgumentException(\"Cannot register \" + value.getClass().getName());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value == null) {\n    return;\n  }\n  if (value instanceof Class) {\n    Class clazz = (Class) value;\n    if (clazz.isInterface()\n        || Modifier.isAbstract(clazz.getModifiers())\n        || Modifier.isFinal(clazz.getModifiers())) {\n      return;\n    }\n  }\n  for (Class clazz = value.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) {\n    try {\n      if (value instanceof DynamicType) {\n        DynamicType dynamicType = (DynamicType) value;\n        if (dynamicType.getBaseType() != null) {\n          register(dynamicType.getBaseType());\n        }\n      }\n      register(clazz.getDeclaredFields());\n    } catch (NoSuchFieldException e) {\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value){ if (value == null) return; if (value instanceof Class) return; if (value instanceof String) return; if (value instanceof Enum) return; if (value instanceof List) return; if (value instanceof Map) return; if (value instanceof Object[]) return; if (value instanceof boolean[]) return; if (value instanceof byte[]) return; if (value instanceof char[]) return; if (value instanceof short[]) return; if (value instanceof int[]) return; if (value instanceof long[]) return; if (value instanceof float[]) return; if (value instanceof double[]) return; if (value instanceof Object) return; if (value instanceof Class) return; if (value instanceof byte[]) return; if (value instanceof short[]) return; if (value instanceof int[]) return; if (value instanceof long[]) return; if (value instanceof float[]) return; if (value instanceof double[]) return; if (value instanceof boolean) return; if (value instanceof String) return; if (value instanceof Enum) return; if (value instanceof List) return; if (value instanceof Map) return; if (value instanceof Object[]) return; if (value instanceof byte[]) return; if (value instanceof short[]) return; if (value instanceof int[]) return; if (value instanceof long[]) return; if (value instanceof float[]) return; if (value instanceof double[]) return; if (value instanceof boolean[]) return; if (value instanceof String[]) return; if (value instanceof boolean[]) return; if (value instanceof byte[][]) return; if (value instanceof short[][]) return; if (value instanceof int[][]) return; if (value instanceof long[][]) return; if (value instanceof float[][]) return; if (value instanceof double[][]) return; if (value instanceof boolean[][]) return; if (value instanceof String[][]) return; if (value instanceof boolean[][]) return; if (value instanceof byte[][][]) return; if (value instanceof short[][][]) return; if (value instanceof int[][][]) return; if (value instanceof long[][][]) return; if (value instanceof float[][][]) return; if (value instanceof double[][][]) return; if (value instanceof boolean[][][]) return; if (value instanceof String[][][]) return; if (value instanceof boolean[][][]) return; if (value instanceof byte[][][][]) return; if (value instanceof short[][][][]) return; if (value instanceof int[][][][]) return; if (value instanceof long[][][][]) return; if (value instanceof float[][][][]) return; if (value instanceof double[][][][]) return; if (value instanceof boolean[][][][]) return; if (value instanceof String[][][][]) return; if (value instanceof boolean[][][][]) return; if (value instanceof byte[][][][]) return; if (value instanceof short[][][][]) return; if (value instanceof int[][][][])", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value == null) {\n    throw new NullPointerException(\"Cannot register null object.\");\n  }\n  Class<?> c = value.getClass();\n  if (c.isArray()) {\n    registerArray(value);\n  } else if (c.isPrimitive()) {\n    registerPrimitive(value);\n  } else if (c.isInterface()) {\n    registerInterface(value);\n  } else if (c.isAnnotation()) {\n    registerAnnotation(value);\n  } else if (c.isEnum()) {\n    registerEnum(value);\n  } else if (c.isAnnotationPresent(AutoValue.class)) {\n    AutoValue<?> autoValue = c.getAnnotation(AutoValue.class);\n    register(autoValue.value(), value);\n  } else if (c.isAnnotationPresent(BinaryAnnotation.class)) {\n    BinaryAnnotation binaryAnnotation = c.getAnnotation(BinaryAnnotation.class);\n    register(binaryAnnotation.value(), value);\n  } else if (c.isAnnotationPresent(EnumAnnotation.class)) {\n    EnumAnnotation enumAnnotation = c.getAnnotation(EnumAnnotation.class);\n    register(enumAnnotation.value(), value);\n  } else {\n    register(\"\", value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  try {\n    if (value == null) {\n      return;\n    }\n    registerMethod.invoke(null, value);\n  } catch (IllegalAccessException | InvocationTargetException e) {\n    throw new IllegalStateException(\"Unable to register object\", e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (!REGISTERED.contains(value)) REGISTERED.add(value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value != null) {\n    if (value instanceof Boolean) {\n      boolean b = ((Boolean) value).booleanValue();\n      if (b) {\n        register(Boolean.TRUE);\n      } else {\n        register(Boolean.FALSE);\n      }\n    } else if (value instanceof Byte) {\n      byte b = ((Byte) value).byteValue();\n      if (b == 0) {\n        register(Byte.valueOf((byte) 0));\n      } else {\n        register(Byte.valueOf((byte) 1));\n      }\n    } else if (value instanceof Character) {\n      char c = ((Character) value).charValue();\n      if (c == 0) {\n        register(Character.valueOf((char) 0));\n      } else {\n        register(Character.valueOf((char) 1));\n      }\n    } else if (value instanceof Short) {\n      short s = ((Short) value).shortValue();\n      if (s == 0) {\n        register(Short.valueOf((short) 0));\n      } else {\n        register(Short.valueOf((short) 1));\n      }\n    } else if (value instanceof Integer) {\n      int i = ((Integer) value).intValue();\n      if (i == 0) {\n        register(Integer.valueOf((int) 0));\n      } else {\n        register(Integer.valueOf((int) 1));\n      }\n    } else if (value instanceof Long) {\n      long l = ((Long) value).longValue();\n      if (l == 0) {\n        register(Long.valueOf((long) 0));\n      } else {\n        register(Long.valueOf((long) 1));\n      }\n    } else if (value instanceof Float) {\n      float f = ((Float) value).floatValue();\n      if (f == 0) {\n        register(Float.valueOf((float) 0));\n      } else {\n        register(Float.valueOf((float) 1));\n      }\n    } else if (value instanceof Double) {\n      double d = ((Double) value).doubleValue();\n      if (d == 0) {\n        register(Double.valueOf((double) 0));\n      } else {\n        register(Double.valueOf((double) 1));\n      }\n    } else if (value instanceof String) {\n      register((String) value);\n    } else {\n      register(value.getClass().getName());\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  register(value, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value == null) {\n    throw new NullPointerException(\"Cannot register null object.\");\n  }\n  synchronized (lock) {\n    if (registered) {\n      return;\n    }\n    registered = true;\n  }\n  try {\n    Objects.requireNonNull(value, \"Cannot register null object.\");\n    Class<?> clazz = value.getClass();\n    while (clazz != null) {\n      for (Method method : clazz.getMethods()) {\n        if (method.isAnnotationPresent(Bean.class)) {\n          Class<?>[] params = method.getParameterTypes();\n          if (params.length == 1 && params[0].isAssignableFrom(value.getClass())) {\n            method.invoke(bean, value);\n          }\n        }\n      }\n      clazz = clazz.getSuperclass();\n    }\n  } catch (InvocationTargetException | IllegalAccessException e) {\n    throw new RuntimeException(e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value != null) {\n    if (value instanceof Class) {\n      register((Class<?>) value);\n    } else if (value instanceof Constructor) {\n      register((Constructor<?>) value);\n    } else if (value instanceof Field) {\n      register((Field) value);\n    } else if (value instanceof Method) {\n      register((Method) value);\n    } else if (value instanceof Enum) {\n      register((Enum<?>) value);\n    } else if (value instanceof Context) {\n      register((Context) value);\n    } else if (value instanceof Iterable) {\n      register((Iterable<?>) value);\n    } else if (value instanceof Iterator) {\n      register((Iterator<?>) value);\n    } else if (value instanceof Iterator) {\n      register((Iterator<?>) value);\n    } else if (value instanceof Iterable) {\n      register((Iterable<?>) value);\n    } else if (value instanceof Object[]) {\n      register((Object[]) value);\n    } else if (value instanceof Object) {\n      register((Object) value);\n    } else if (value instanceof CharSequence) {\n      register(value.toString());\n    } else if (value instanceof CharSequence[]) {\n      register((CharSequence[]) value);\n    } else if (value instanceof byte[]) {\n      register((byte[]) value);\n    } else if (value instanceof byte[][]) {\n      register((byte[][]) value);\n    } else if (value instanceof short[]) {\n      register((short[]) value);\n    } else if (value instanceof short[][]) {\n      register((short[][]) value);\n    } else if (value instanceof int[]) {\n      register((int[]) value);\n    } else if (value instanceof int[][]) {\n      register((int[][]) value);\n    } else if (value instanceof long[]) {\n      register((long[]) value);\n    } else if (value instanceof long[][]) {\n      register((long[][]) value);\n    } else if (value instanceof float[]) {\n      register((float[]) value);\n    } else if (value instanceof float[][]) {\n      register((float[][]) value);\n    } else if (value instanceof double[]) {\n      register((double[]) value);\n    } else if (value instanceof double[][]) {\n      register((double[][]) value);\n    } else if (value instanceof boolean[]) {\n      register((boolean[]) value);\n    } else if (value instanceof boolean[][]) {\n      register((boolean[][]) value);\n    } else if (value instanceof char[]) {\n      register((char[]) value);\n    } else if (value instanceof char[][]) {\n      register((char[][]) value);\n    } else if (value instanceof Object[][]) {\n      register((Object[][]) value);\n    } else if (value instanceof Object[]) {\n      register((Object[]) value);\n    } else if (value instanceof byte[][][]) {\n      register((byte[][][]) value);\n    } else {\n      register(value.toString());\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n", "method_name": "register", "codes": ["static void register(Object value){ if (value == null) { return; } try { if (value.getClass().isArray()) { Class<?> componentType = value.getClass().getComponentType(); Object[] newArray = (Object[]) Array.newInstance(componentType, Array.getLength(value)); System.arraycopy(Array.getLength(value), 0, newArray, 0, Array.getLength(value)); value = newArray; } } catch (ClassCastException e) { } if (value instanceof Class) { register((Class<?>) value); } else if (value instanceof Enum) { register(((Enum<?>) value).name()); } else if (value instanceof Iterable) { Iterable<?> iterable = (Iterable<?>) value; for (Object item : iterable) { register(item); } } else if (value instanceof Map) { Map<?, ?> map = (Map<?, ?>) value; for (Map.Entry<?, ?> entry : map.entrySet()) { register(entry.getKey()); register(entry.getValue()); } } else if (value instanceof Enumeration) { Enumeration<?> enumeration = (Enumeration<?>) value; while (enumeration.hasMoreElements()) { register(enumeration.nextElement()); } } else { throw new IllegalArgumentException(\"Cannot register \" + value.getClass().getName()); } }", "static void register(Object value){ if (value == null) { return; } if (value instanceof Class) { Class clazz = (Class) value; if (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers()) || Modifier.isFinal(clazz.getModifiers())) { return; } } for (Class clazz = value.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) { try { if (value instanceof DynamicType) { DynamicType dynamicType = (DynamicType) value; if (dynamicType.getBaseType() != null) { register(dynamicType.getBaseType()); } } register(clazz.getDeclaredFields()); } catch (NoSuchFieldException e) { } } }", "static void register(Object value){ if (value == null) return; if (value instanceof Class) return; if (value instanceof String) return; if (value instanceof Enum) return; if (value instanceof List) return; if (value instanceof Map) return; if (value instanceof Object[]) return; if (value instanceof boolean[]) return; if (value instanceof byte[]) return; if (value instanceof char[]) return; if (value instanceof short[]) return; if (value instanceof int[]) return; if (value instanceof long[]) return; if (value instanceof float[]) return; if (value instanceof double[]) return; if (value instanceof Object) return; if (value instanceof Class) return; if (value instanceof byte[]) return; if (value instanceof short[]) return; if (value instanceof int[]) return; if (value instanceof long[]) return; if (value instanceof float[]) return; if (value instanceof double[]) return; if (value instanceof boolean) return; if (value instanceof String) return; if (value instanceof Enum) return; if (value instanceof List) return; if (value instanceof Map) return; if (value instanceof Object[]) return; if (value instanceof byte[]) return; if (value instanceof short[]) return; if (value instanceof int[]) return; if (value instanceof long[]) return; if (value instanceof float[]) return; if (value instanceof double[]) return; if (value instanceof boolean[]) return; if (value instanceof String[]) return; if (value instanceof boolean[]) return; if (value instanceof byte[][]) return; if (value instanceof short[][]) return; if (value instanceof int[][]) return; if (value instanceof long[][]) return; if (value instanceof float[][]) return; if (value instanceof double[][]) return; if (value instanceof boolean[][]) return; if (value instanceof String[][]) return; if (value instanceof boolean[][]) return; if (value instanceof byte[][][]) return; if (value instanceof short[][][]) return; if (value instanceof int[][][]) return; if (value instanceof long[][][]) return; if (value instanceof float[][][]) return; if (value instanceof double[][][]) return; if (value instanceof boolean[][][]) return; if (value instanceof String[][][]) return; if (value instanceof boolean[][][]) return; if (value instanceof byte[][][][]) return; if (value instanceof short[][][][]) return; if (value instanceof int[][][][]) return; if (value instanceof long[][][][]) return; if (value instanceof float[][][][]) return; if (value instanceof double[][][][]) return; if (value instanceof boolean[][][][]) return; if (value instanceof String[][][][]) return; if (value instanceof boolean[][][][]) return; if (value instanceof byte[][][][]) return; if (value instanceof short[][][][]) return; if (value instanceof int[][][][])", "static void register(Object value){ if (value == null) { throw new NullPointerException(\"Cannot register null object.\"); } Class<?> c = value.getClass(); if (c.isArray()) { registerArray(value); } else if (c.isPrimitive()) { registerPrimitive(value); } else if (c.isInterface()) { registerInterface(value); } else if (c.isAnnotation()) { registerAnnotation(value); } else if (c.isEnum()) { registerEnum(value); } else if (c.isAnnotationPresent(AutoValue.class)) { AutoValue<?> autoValue = c.getAnnotation(AutoValue.class); register(autoValue.value(), value); } else if (c.isAnnotationPresent(BinaryAnnotation.class)) { BinaryAnnotation binaryAnnotation = c.getAnnotation(BinaryAnnotation.class); register(binaryAnnotation.value(), value); } else if (c.isAnnotationPresent(EnumAnnotation.class)) { EnumAnnotation enumAnnotation = c.getAnnotation(EnumAnnotation.class); register(enumAnnotation.value(), value); } else { register(\"\", value); } }", "static void register(Object value){ try { if (value == null) { return; } registerMethod.invoke(null, value); } catch (IllegalAccessException | InvocationTargetException e) { throw new IllegalStateException(\"Unable to register object\", e); } }", "static void register(Object value){ if (!REGISTERED.contains(value)) REGISTERED.add(value); }", "static void register(Object value){ if (value != null) { if (value instanceof Boolean) { boolean b = ((Boolean) value).booleanValue(); if (b) { register(Boolean.TRUE); } else { register(Boolean.FALSE); } } else if (value instanceof Byte) { byte b = ((Byte) value).byteValue(); if (b == 0) { register(Byte.valueOf((byte) 0)); } else { register(Byte.valueOf((byte) 1)); } } else if (value instanceof Character) { char c = ((Character) value).charValue(); if (c == 0) { register(Character.valueOf((char) 0)); } else { register(Character.valueOf((char) 1)); } } else if (value instanceof Short) { short s = ((Short) value).shortValue(); if (s == 0) { register(Short.valueOf((short) 0)); } else { register(Short.valueOf((short) 1)); } } else if (value instanceof Integer) { int i = ((Integer) value).intValue(); if (i == 0) { register(Integer.valueOf((int) 0)); } else { register(Integer.valueOf((int) 1)); } } else if (value instanceof Long) { long l = ((Long) value).longValue(); if (l == 0) { register(Long.valueOf((long) 0)); } else { register(Long.valueOf((long) 1)); } } else if (value instanceof Float) { float f = ((Float) value).floatValue(); if (f == 0) { register(Float.valueOf((float) 0)); } else { register(Float.valueOf((float) 1)); } } else if (value instanceof Double) { double d = ((Double) value).doubleValue(); if (d == 0) { register(Double.valueOf((double) 0)); } else { register(Double.valueOf((double) 1)); } } else if (value instanceof String) { register((String) value); } else { register(value.getClass().getName()); } } }", "static void register(Object value){ register(value, null); }", "static void register(Object value){ if (value == null) { throw new NullPointerException(\"Cannot register null object.\"); } synchronized (lock) { if (registered) { return; } registered = true; } try { Objects.requireNonNull(value, \"Cannot register null object.\"); Class<?> clazz = value.getClass(); while (clazz != null) { for (Method method : clazz.getMethods()) { if (method.isAnnotationPresent(Bean.class)) { Class<?>[] params = method.getParameterTypes(); if (params.length == 1 && params[0].isAssignableFrom(value.getClass())) { method.invoke(bean, value); } } } clazz = clazz.getSuperclass(); } } catch (InvocationTargetException | IllegalAccessException e) { throw new RuntimeException(e); } }", "static void register(Object value){ if (value != null) { if (value instanceof Class) { register((Class<?>) value); } else if (value instanceof Constructor) { register((Constructor<?>) value); } else if (value instanceof Field) { register((Field) value); } else if (value instanceof Method) { register((Method) value); } else if (value instanceof Enum) { register((Enum<?>) value); } else if (value instanceof Context) { register((Context) value); } else if (value instanceof Iterable) { register((Iterable<?>) value); } else if (value instanceof Iterator) { register((Iterator<?>) value); } else if (value instanceof Iterator) { register((Iterator<?>) value); } else if (value instanceof Iterable) { register((Iterable<?>) value); } else if (value instanceof Object[]) { register((Object[]) value); } else if (value instanceof Object) { register((Object) value); } else if (value instanceof CharSequence) { register(value.toString()); } else if (value instanceof CharSequence[]) { register((CharSequence[]) value); } else if (value instanceof byte[]) { register((byte[]) value); } else if (value instanceof byte[][]) { register((byte[][]) value); } else if (value instanceof short[]) { register((short[]) value); } else if (value instanceof short[][]) { register((short[][]) value); } else if (value instanceof int[]) { register((int[]) value); } else if (value instanceof int[][]) { register((int[][]) value); } else if (value instanceof long[]) { register((long[]) value); } else if (value instanceof long[][]) { register((long[][]) value); } else if (value instanceof float[]) { register((float[]) value); } else if (value instanceof float[][]) { register((float[][]) value); } else if (value instanceof double[]) { register((double[]) value); } else if (value instanceof double[][]) { register((double[][]) value); } else if (value instanceof boolean[]) { register((boolean[]) value); } else if (value instanceof boolean[][]) { register((boolean[][]) value); } else if (value instanceof char[]) { register((char[]) value); } else if (value instanceof char[][]) { register((char[][]) value); } else if (value instanceof Object[][]) { register((Object[][]) value); } else if (value instanceof Object[]) { register((Object[]) value); } else if (value instanceof byte[][][]) { register((byte[][][]) value); } else { register(value.toString()); } } }"], "code_level": "class_runnable", "_id": "636767041a6d9265ec017911", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    buffer.append(arrayElementValueSeparator);\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  appendSummarySize(buffer, fieldName, array.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n", "method_name": "appendDetail", "codes": ["protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { buffer.append(arrayElementValueSeparator); appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ appendSummarySize(buffer, fieldName, array.length); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec017821", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  }\n  int length = array.length;\n  if (length == 0) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] result = new String[length];\n  for (int i = 0; i < length; i++) {\n    Object element = array[i];\n    if (element != null) {\n      result[i] = element.toString();\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) return null;\n  else return Arrays.copyOf(array, array.length, String[].class);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  return (String[]) toNoNull(array);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  return array == null ? EMPTY_STRING_ARRAY : array;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  }\n  return Arrays.copyOf(array, array.length, String[].class);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return new String[0];\n  }\n  return Arrays.copyOf(array, array.length, String[].class);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) return null;\n  return Arrays.copyOf(array, array.length, String[].class);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return new String[0];\n  } else {\n    return array;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    if (array[i] == null) {\n      result[i] = null;\n    } else {\n      result[i] = array[i].toString();\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return EMPTY_STRING_ARRAY;\n  }\n  return array;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.\n * @param array The array to check\n * @return The given array or a new array without null.\n */\n", "method_name": "toNoNullStringArray", "codes": ["static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } int length = array.length; if (length == 0) { return EMPTY_STRING_ARRAY; } String[] result = new String[length]; for (int i = 0; i < length; i++) { Object element = array[i]; if (element != null) { result[i] = element.toString(); } } return result; }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) return null; else return Arrays.copyOf(array, array.length, String[].class); }", "static String[] toNoNullStringArray(Object[] array){ return (String[]) toNoNull(array); }", "static String[] toNoNullStringArray(Object[] array){ return array == null ? EMPTY_STRING_ARRAY : array; }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } return Arrays.copyOf(array, array.length, String[].class); }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return new String[0]; } return Arrays.copyOf(array, array.length, String[].class); }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) return null; return Arrays.copyOf(array, array.length, String[].class); }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } else if (array.length == 0) { return new String[0]; } else { return array; } }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_STRING_ARRAY; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { if (array[i] == null) { result[i] = null; } else { result[i] = array[i].toString(); } } return result; }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return EMPTY_STRING_ARRAY; } return array; }"], "code_level": "project_runnable", "_id": "636766fc1a6d9265ec0177ef", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic int available() throws IOException {\n  if (!hasNext()) {\n    return 0;\n  }\n  int available = this.byteBuffer.remaining();\n  if (available > this.bufferSize) {\n    available = this.bufferSize;\n  }\n  return available;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return inputStream.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return in.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return is.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return is.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return in.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return this.in.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return in.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return this.in.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return mInputStream.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @see InputStream#available() \n */\n", "method_name": "available", "codes": ["@Override public int available() throws IOException { if (!hasNext()) { return 0; } int available = this.byteBuffer.remaining(); if (available > this.bufferSize) { available = this.bufferSize; } return available; }", "@Override public int available() throws IOException { return inputStream.available(); }", "@Override public int available() throws IOException { return in.available(); }", "@Override public int available() throws IOException { return is.available(); }", "@Override public int available() throws IOException { return is.available(); }", "@Override public int available() throws IOException { return in.available(); }", "@Override public int available() throws IOException { return this.in.available(); }", "@Override public int available() throws IOException { return in.available(); }", "@Override public int available() throws IOException { return this.in.available(); }", "@Override public int available() throws IOException { return mInputStream.available(); }"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec017641", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static <T> List<T> asList(T[] a) {\n  return Arrays.asList(a);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  return Arrays.asList(a);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) {\n    return null;\n  } else {\n    return Arrays.asList(a);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) {\n    return null;\n  }\n  return Arrays.asList(a);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) {\n    return null;\n  } else {\n    return new ArrayList<T>(Arrays.asList(a));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) {\n    return null;\n  }\n  return Arrays.asList(a);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  return Arrays.asList(a);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  return Arrays.asList(a);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  return Arrays.asList(a);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  return new ArrayList<T>(Arrays.asList(a));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.\n * @return a list backed by the array.\n */\n", "method_name": "asList", "codes": ["public static <T>List<T> asList(T[] a){ return Arrays.asList(a); }", "public static <T>List<T> asList(T[] a){ return Arrays.asList(a); }", "public static <T>List<T> asList(T[] a){ if (a == null) { return null; } else { return Arrays.asList(a); } }", "public static <T>List<T> asList(T[] a){ if (a == null) { return null; } return Arrays.asList(a); }", "public static <T>List<T> asList(T[] a){ if (a == null) { return null; } else { return new ArrayList<T>(Arrays.asList(a)); } }", "public static <T>List<T> asList(T[] a){ if (a == null) { return null; } return Arrays.asList(a); }", "public static <T>List<T> asList(T[] a){ return Arrays.asList(a); }", "public static <T>List<T> asList(T[] a){ return Arrays.asList(a); }", "public static <T>List<T> asList(T[] a){ return Arrays.asList(a); }", "public static <T>List<T> asList(T[] a){ return new ArrayList<T>(Arrays.asList(a)); }"], "code_level": "slib_runnable", "_id": "636766f01a6d9265ec017639", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static byte convertHexDigit(byte b) {\n  if ((b >= '0') && (b <= '9')) {\n    return (byte) (b - '0');\n  }\n  if ((b >= 'a') && (b <= 'f')) {\n    return (byte) (b - 'a' + 10);\n  }\n  if ((b >= 'A') && (b <= 'F')) {\n    return (byte) (b - 'A' + 10);\n  }\n  throw new IllegalArgumentException(\"Invalid hex digit \" + b);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if (b >= '0' && b <= '9') {\n    return (byte) (b - '0');\n  } else if (b >= 'A' && b <= 'F') {\n    return (byte) (b - 'A' + 10);\n  } else {\n    return (byte) (b - 'a' + 10);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  byte r = (byte) ((b >> 4) & 0x0f);\n  byte g = (byte) ((b >> 8) & 0x0f);\n  byte bf = (byte) (b & 0x0f);\n  return (byte) ((r << 4) | (g << 2) | bf);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if ((b >= '0') && (b <= '9')) {\n    return (byte) (b - '0');\n  } else if ((b >= 'a') && (b <= 'f')) {\n    return (byte) (b - 'a' + 10);\n  } else if ((b >= 'A') && (b <= 'F')) {\n    return (byte) (b - 'A' + 10);\n  } else {\n    return (byte) ((b - '0') + 10);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  return (byte)\n      ((b >= '0') && (b <= '9')\n          ? b\n          : (byte)\n              ((b >= 'a') && (b <= 'f')\n                  ? b - 'a' + 10\n                  : (b >= 'A') && (b <= 'F') ? b - 'A' + 10 : 0));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  return (byte) (((b & 0xF0) >> 4) | ((b & 0x0F) << 4));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if (b >= '0' && b <= '9') {\n    return (byte) (b - '0');\n  } else if (b >= 'a' && b <= 'f') {\n    return (byte) (b - 'a' + 10);\n  } else if (b >= 'A' && b <= 'F') {\n    return (byte) (b - 'A' + 10);\n  } else {\n    throw new IllegalArgumentException(\"Invalid hex digit \" + b);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if ((b >= '0') && (b <= '9')) {\n    return (byte) ((b - '0') + 'a');\n  }\n  if ((b >= 'a') && (b <= 'f')) {\n    return (byte) ((b - 'a') + 'A');\n  }\n  return (byte) ((b - 'A') + 'F');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  return (byte) ((b << 4) | (b & 0xF));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if (b >= '0' && b <= '9') {\n    return (byte) (b - '0');\n  } else if (b >= 'a' && b <= 'f') {\n    return (byte) (b - 'a' + 10);\n  } else {\n    throw new IllegalArgumentException(\"Invalid hex digit: \" + b);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * @param b An ASCII encoded character 0-9 a-f A-F\n * @return The byte value of the character 0-16.\n */\n", "method_name": "convertHexDigit", "codes": ["public static byte convertHexDigit(byte b){ if ((b >= '0') && (b <= '9')) { return (byte) (b - '0'); } if ((b >= 'a') && (b <= 'f')) { return (byte) (b - 'a' + 10); } if ((b >= 'A') && (b <= 'F')) { return (byte) (b - 'A' + 10); } throw new IllegalArgumentException(\"Invalid hex digit \" + b); }", "public static byte convertHexDigit(byte b){ if (b >= '0' && b <= '9') { return (byte) (b - '0'); } else if (b >= 'A' && b <= 'F') { return (byte) (b - 'A' + 10); } else { return (byte) (b - 'a' + 10); } }", "public static byte convertHexDigit(byte b){ byte r = (byte) ((b >> 4) & 0x0f); byte g = (byte) ((b >> 8) & 0x0f); byte bf = (byte) (b & 0x0f); return (byte) ((r << 4) | (g << 2) | bf); }", "public static byte convertHexDigit(byte b){ if ((b >= '0') && (b <= '9')) { return (byte) (b - '0'); } else if ((b >= 'a') && (b <= 'f')) { return (byte) (b - 'a' + 10); } else if ((b >= 'A') && (b <= 'F')) { return (byte) (b - 'A' + 10); } else { return (byte) ((b - '0') + 10); } }", "public static byte convertHexDigit(byte b){ return (byte) ((b >= '0') && (b <= '9') ? b : (byte) ((b >= 'a') && (b <= 'f') ? b - 'a' + 10 : (b >= 'A') && (b <= 'F') ? b - 'A' + 10 : 0)); }", "public static byte convertHexDigit(byte b){ return (byte) (((b & 0xF0) >> 4) | ((b & 0x0F) << 4)); }", "public static byte convertHexDigit(byte b){ if (b >= '0' && b <= '9') { return (byte) (b - '0'); } else if (b >= 'a' && b <= 'f') { return (byte) (b - 'a' + 10); } else if (b >= 'A' && b <= 'F') { return (byte) (b - 'A' + 10); } else { throw new IllegalArgumentException(\"Invalid hex digit \" + b); } }", "public static byte convertHexDigit(byte b){ if ((b >= '0') && (b <= '9')) { return (byte) ((b - '0') + 'a'); } if ((b >= 'a') && (b <= 'f')) { return (byte) ((b - 'a') + 'A'); } return (byte) ((b - 'A') + 'F'); }", "public static byte convertHexDigit(byte b){ return (byte) ((b << 4) | (b & 0xF)); }", "public static byte convertHexDigit(byte b){ if (b >= '0' && b <= '9') { return (byte) (b - '0'); } else if (b >= 'a' && b <= 'f') { return (byte) (b - 'a' + 10); } else { throw new IllegalArgumentException(\"Invalid hex digit: \" + b); } }"], "code_level": "slib_runnable", "_id": "636766f91a6d9265ec01777d", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public Converter lookup(final Class<?> clazz) {\n  if (clazz == null) {\n    return null;\n  }\n  final Converter converter = converters.get(clazz);\n  if (converter != null) {\n    return converter;\n  }\n  final Converter[] converters =\n      this.converters.values().toArray(new Converter[this.converters.size()]);\n  for (int i = 0; i < converters.length; i++) {\n    if (converters[i].supports(clazz)) {\n      return converters[i];\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  Converter converter = null;\n  for (Converter converter2 : this.converters) {\n    if (clazz.isAssignableFrom(converter2.getClass())) {\n      converter = converter2;\n      break;\n    }\n  }\n  return converter;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  if (clazz == null) {\n    return null;\n  }\n  final Converter converter = converters.get(clazz);\n  if (converter != null) {\n    return converter;\n  }\n  for (final Converter c : converters.values()) {\n    if (c.isSupported(clazz)) {\n      return c;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return (Converter) converters.get(clazz);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return lookup(clazz.getName());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return lookup(clazz, null);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.\n * @param clazz Class for which to return a registered Converter\n * @return The registered {@link Converter} or <code>null</code> if not found\n */\n", "method_name": "lookup", "codes": ["public Converter lookup(final Class<?> clazz){ if (clazz == null) { return null; } final Converter converter = converters.get(clazz); if (converter != null) { return converter; } final Converter[] converters = this.converters.values().toArray(new Converter[this.converters.size()]); for (int i = 0; i < converters.length; i++) { if (converters[i].supports(clazz)) { return converters[i]; } } return null; }", "public Converter lookup(final Class<?> clazz){ return converters.get(clazz); }", "public Converter lookup(final Class<?> clazz){ Converter converter = null; for (Converter converter2 : this.converters) { if (clazz.isAssignableFrom(converter2.getClass())) { converter = converter2; break; } } return converter; }", "public Converter lookup(final Class<?> clazz){ if (clazz == null) { return null; } final Converter converter = converters.get(clazz); if (converter != null) { return converter; } for (final Converter c : converters.values()) { if (c.isSupported(clazz)) { return c; } } return null; }", "public Converter lookup(final Class<?> clazz){ return (Converter) converters.get(clazz); }", "public Converter lookup(final Class<?> clazz){ return converters.get(clazz); }", "public Converter lookup(final Class<?> clazz){ return lookup(clazz.getName()); }", "public Converter lookup(final Class<?> clazz){ return lookup(clazz, null); }", "public Converter lookup(final Class<?> clazz){ return converters.get(clazz); }", "public Converter lookup(final Class<?> clazz){ return converters.get(clazz); }"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179e7", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return map.containsKey(key);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return this.map.containsKey(key);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return data[hash(key)] != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return map.containsKey(key);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return get(key) != null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  if (key == null) {\n    for (int i = 0; i < this.keys.length; i++) {\n      if (this.keys[i] == null) {\n        return true;\n      }\n    }\n  } else {\n    for (int i = 0; i < this.keys.length; i++) {\n      if (key.equals(this.keys[i])) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return containsKey(key.toString());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return map.containsKey(key);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return (get(key) != null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return get(key) != null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Return <code>true</code> if this map contains a mapping for the specified key.\n * @param key  the key to be searched for\n * @return true if the map contains the key\n */\n", "method_name": "containsKey", "codes": ["@Override public boolean containsKey(final Object key){ return map.containsKey(key); }", "@Override public boolean containsKey(final Object key){ return this.map.containsKey(key); }", "@Override public boolean containsKey(final Object key){ return data[hash(key)] != null; }", "@Override public boolean containsKey(final Object key){ return map.containsKey(key); }", "@Override public boolean containsKey(final Object key){ return get(key) != null; }", "@Override public boolean containsKey(final Object key){ if (key == null) { for (int i = 0; i < this.keys.length; i++) { if (this.keys[i] == null) { return true; } } } else { for (int i = 0; i < this.keys.length; i++) { if (key.equals(this.keys[i])) { return true; } } } return false; }", "@Override public boolean containsKey(final Object key){ return containsKey(key.toString()); }", "@Override public boolean containsKey(final Object key){ return map.containsKey(key); }", "@Override public boolean containsKey(final Object key){ return (get(key) != null); }", "@Override public boolean containsKey(final Object key){ return get(key) != null; }"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec0179f2", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] dst = new String[src.length];\n  System.arraycopy(src, 0, dst, 0, src.length);\n  return dst;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n", "method_name": "copyStrings", "codes": ["private static String[] copyStrings(final String[] src){ final String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ final String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ final String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ final String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ final String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ final String[] dst = new String[src.length]; System.arraycopy(src, 0, dst, 0, src.length); return dst; }"], "code_level": "self_contained", "_id": "636767041a6d9265ec0178f8", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (value instanceof Character) {\n    return value;\n  } else if (value instanceof Number) {\n    return ((Number) value).charValue();\n  } else {\n    throw new Exception(\"Unsupported data type: \" + value.getClass().getName());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (type.equals(char.class)) {\n    return value;\n  }\n  if (type.equals(Character.class)) {\n    return ((Character) value).charValue();\n  }\n  throw new Exception(\"Unsupported data type \" + type.getName());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (type.isAssignableFrom(String.class)) {\n    return value.toString();\n  } else if (type.isAssignableFrom(Character.class)) {\n    return value.toString().charAt(0);\n  } else if (type.isAssignableFrom(Character.TYPE)) {\n    return value.toString().charAt(0);\n  } else if (type.isAssignableFrom(Boolean.class)) {\n    return Boolean.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Boolean.TYPE)) {\n    return Boolean.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Byte.class)) {\n    return Byte.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Byte.TYPE)) {\n    return Byte.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Short.class)) {\n    return Short.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Short.TYPE)) {\n    return Short.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Integer.class)) {\n    return Integer.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Integer.TYPE)) {\n    return Integer.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Long.class)) {\n    return Long.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Long.TYPE)) {\n    return Long.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Float.class)) {\n    return Float.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Float.TYPE)) {\n    return Float.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Double.class)) {\n    return Double.valueOf(value.toString());\n  } else if (type.isAssignableFrom(Double.TYPE)) {\n    return Double.valueOf(value.toString());\n  } else if (type.isAssignableFrom(BigInteger.class)) {\n    return new BigInteger(value.toString());\n  } else if (type.isAssignableFrom(BigDecimal.class)) {\n    return new BigDecimal(value.toString());\n  } else {\n    throw new Exception(\"Unsupported type: \" + type);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (type == Character.TYPE) {\n    return (char) value;\n  }\n  if (Character.class.isAssignableFrom(type)) {\n    return (char) value;\n  }\n  if (Byte.TYPE == type) {\n    return (byte) value;\n  }\n  if (Byte.class.isAssignableFrom(type)) {\n    return (byte) value;\n  }\n  if (Short.TYPE == type) {\n    return (short) value;\n  }\n  if (Short.class.isAssignableFrom(type)) {\n    return (short) value;\n  }\n  if (Integer.TYPE == type) {\n    return (int) value;\n  }\n  if (Integer.class.isAssignableFrom(type)) {\n    return (int) value;\n  }\n  if (Long.TYPE == type) {\n    return (long) value;\n  }\n  if (Long.class.isAssignableFrom(type)) {\n    return (long) value;\n  }\n  if (Float.TYPE == type) {\n    return (float) value;\n  }\n  if (Float.class.isAssignableFrom(type)) {\n    return (float) value;\n  }\n  if (Double.TYPE == type) {\n    return (double) value;\n  }\n  if (Double.class.isAssignableFrom(type)) {\n    return (double) value;\n  }\n  if (BigInteger.class.isAssignableFrom(type)) {\n    return ((BigInteger) value).toString();\n  }\n  if (BigDecimal.class.isAssignableFrom(type)) {\n    return ((BigDecimal) value).toString();\n  }\n  if (BigDecimal.class.isAssignableFrom(type)) {\n    return (BigDecimal) value;\n  }\n  if (Boolean.TYPE == type) {\n    return ((Boolean) value).booleanValue();\n  }\n  if (Boolean.class.isAssignableFrom(type)) {\n    return ((Boolean) value).booleanValue();\n  }\n  throw new IllegalArgumentException(\"Unsupported type \" + type);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (type == Character.class) {\n    return (Character) value;\n  } else if (type == Character.TYPE) {\n    return value.toString().charAt(0);\n  } else {\n    return null;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (Boolean.class.equals(type)) {\n    return (Boolean) value;\n  } else if (Byte.class.equals(type)) {\n    return (Byte) value;\n  } else if (Short.class.equals(type)) {\n    return (Short) value;\n  } else if (Integer.class.equals(type)) {\n    return (Integer) value;\n  } else if (Long.class.equals(type)) {\n    return (Long) value;\n  } else if (Float.class.equals(type)) {\n    return (Float) value;\n  } else if (Double.class.equals(type)) {\n    return (Double) value;\n  } else if (Character.class.equals(type)) {\n    return (Character) value;\n  } else if (String.class.equals(type)) {\n    return (String) value;\n  } else if (BigDecimal.class.equals(type)) {\n    return (BigDecimal) value;\n  } else if (BigInteger.class.equals(type)) {\n    return (BigInteger) value;\n  } else if (Date.class.equals(type)) {\n    return (Date) value;\n  } else if (Calendar.class.equals(type)) {\n    return (Calendar) value;\n  } else if (Timestamp.class.equals(type)) {\n    return (Timestamp) value;\n  } else {\n    throw new IllegalArgumentException(\"Unsupported data type '\" + type + \"' for conversion.\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (type.equals(String.class)) {\n    return value;\n  }\n  if (type.equals(Character.class)) {\n    return ((Character) value).charValue();\n  }\n  return super.convertToType(type, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (type.equals(String.class)) {\n    return StringUtils.trimToEmpty((String) value);\n  }\n  if (type.equals(Integer.class)) {\n    return Integer.valueOf((String) value);\n  }\n  if (type.equals(Long.class)) {\n    return Long.valueOf((String) value);\n  }\n  if (type.equals(Double.class)) {\n    return Double.valueOf((String) value);\n  }\n  if (type.equals(Float.class)) {\n    return Float.valueOf((String) value);\n  }\n  if (type.equals(Short.class)) {\n    return Short.valueOf((String) value);\n  }\n  if (type.equals(Byte.class)) {\n    return Byte.valueOf((String) value);\n  }\n  if (type.equals(Date.class)) {\n    return DateUtils.parseDate((String) value, DateUtils.DATE_FORMAT);\n  }\n  if (type.equals(Timestamp.class)) {\n    return TimestampUtils.parseDate((String) value, DateUtils.DATE_TIME_FORMAT);\n  }\n  throw new Exception(\"Unsupported type \" + type.getName() + \" for conversion\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (type == Character.class) {\n    return ((Character) value).charValue();\n  }\n  if (type == Character.TYPE) {\n    return ((Character) value).charValue();\n  }\n  if (Character.class.isAssignableFrom(type)) {\n    return value;\n  }\n  if (type == Character.TYPE) {\n    return value;\n  }\n  if (type == Integer.class || type == int.class) {\n    return Integer.valueOf(((Character) value).charValue());\n  }\n  if (type == Integer.TYPE) {\n    return Integer.valueOf(((Character) value).charValue());\n  }\n  if (type == Long.class || type == long.class) {\n    return Long.valueOf(((Character) value).charValue());\n  }\n  if (type == Long.TYPE) {\n    return Long.valueOf(((Character) value).charValue());\n  }\n  if (type == Short.class || type == short.class) {\n    return Short.valueOf(((Character) value).charValue());\n  }\n  if (type == Short.TYPE) {\n    return Short.valueOf(((Character) value).charValue());\n  }\n  if (type == Byte.class || type == byte.class) {\n    return Byte.valueOf(((Character) value).charValue());\n  }\n  if (type == Byte.TYPE) {\n    return Byte.valueOf(((Character) value).charValue());\n  }\n  if (type == Boolean.class || type == boolean.class) {\n    return Boolean.valueOf(((Character) value).charValue());\n  }\n  if (type == Boolean.TYPE) {\n    return Boolean.valueOf(((Character) value).charValue());\n  }\n  if (type == String.class) {\n    return value.toString();\n  }\n  if (type == String.class) {\n    return value;\n  }\n  return super.convertToType(type, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (Boolean.class.isAssignableFrom(type)) { return Boolean.valueOf(value.toString()); } if (Byte.class.isAssignableFrom(type)) { return Byte.valueOf(value.toString()); } if (Character.class.isAssignableFrom(type)) { return value; } if (Short.class.isAssignableFrom(type)) { return Short.valueOf(value.toString()); } if (Integer.class.isAssignableFrom(type)) { return Integer.valueOf(value.toString()); } if (Long.class.isAssignableFrom(type)) { return Long.valueOf(value.toString()); } if (Float.class.isAssignableFrom(type)) { return Float.valueOf(value.toString()); } if (Double.class.isAssignableFrom(type)) { return Double.valueOf(value.toString()); } if (String.class.isAssignableFrom(type)) { return value.toString(); } if (BigDecimal.class.isAssignableFrom(type)) { return new BigDecimal(value.toString()); } if (Date.class.isAssignableFrom(type)) { return DateUtil.parseDate(value.toString(), DateUtil.DATE_FORMAT_SHORT); } if (java.sql.Date.class.isAssignableFrom(type)) { return new java.sql.Date(((java.util.Date) value).getTime()); } if (java.sql.Time.class.isAssignableFrom(type)) { return new java.sql.Time(((java.util.Date) value).getTime()); } if (java.sql.Timestamp.class.isAssignableFrom(type)) { return new java.sql.Timestamp(((java.util.Date) value).getTime()); } if (java.sql.Time.class.isAssignableFrom(type)) { return new java.sql.Time(((java.util.Date) value).getTime()); } if (Calendar.class.isAssignableFrom(type)) { return CalendarUtil.parseCalendar(value.toString()); } if (Blob.class.isAssignableFrom(type)) { return BlobUtil.getBlob(value.toString()); } if (Clob.class.isAssignableFrom(type)) { return ClobUtil.getClob(value.toString()); } if (Enum.class.isAssignableFrom(type)) { return EnumUtil.getEnum(type, value.toString()); } if (java.sql.Date.class.isAssignableFrom(type)) { return new java.sql.Date(((java.util.Date) value).getTime()); } if (java.sql.Time.class.isAssignableFrom(type)) { return new java.sql.Time(((java.util.Date) value).getTime()); ", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n", "method_name": "convertToType", "codes": ["@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (value instanceof Character) { return value; } else if (value instanceof Number) { return ((Number) value).charValue(); } else { throw new Exception(\"Unsupported data type: \" + value.getClass().getName()); } }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (type.equals(char.class)) { return value; } if (type.equals(Character.class)) { return ((Character) value).charValue(); } throw new Exception(\"Unsupported data type \" + type.getName()); }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (type.isAssignableFrom(String.class)) { return value.toString(); } else if (type.isAssignableFrom(Character.class)) { return value.toString().charAt(0); } else if (type.isAssignableFrom(Character.TYPE)) { return value.toString().charAt(0); } else if (type.isAssignableFrom(Boolean.class)) { return Boolean.valueOf(value.toString()); } else if (type.isAssignableFrom(Boolean.TYPE)) { return Boolean.valueOf(value.toString()); } else if (type.isAssignableFrom(Byte.class)) { return Byte.valueOf(value.toString()); } else if (type.isAssignableFrom(Byte.TYPE)) { return Byte.valueOf(value.toString()); } else if (type.isAssignableFrom(Short.class)) { return Short.valueOf(value.toString()); } else if (type.isAssignableFrom(Short.TYPE)) { return Short.valueOf(value.toString()); } else if (type.isAssignableFrom(Integer.class)) { return Integer.valueOf(value.toString()); } else if (type.isAssignableFrom(Integer.TYPE)) { return Integer.valueOf(value.toString()); } else if (type.isAssignableFrom(Long.class)) { return Long.valueOf(value.toString()); } else if (type.isAssignableFrom(Long.TYPE)) { return Long.valueOf(value.toString()); } else if (type.isAssignableFrom(Float.class)) { return Float.valueOf(value.toString()); } else if (type.isAssignableFrom(Float.TYPE)) { return Float.valueOf(value.toString()); } else if (type.isAssignableFrom(Double.class)) { return Double.valueOf(value.toString()); } else if (type.isAssignableFrom(Double.TYPE)) { return Double.valueOf(value.toString()); } else if (type.isAssignableFrom(BigInteger.class)) { return new BigInteger(value.toString()); } else if (type.isAssignableFrom(BigDecimal.class)) { return new BigDecimal(value.toString()); } else { throw new Exception(\"Unsupported type: \" + type); } }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (type == Character.TYPE) { return (char) value; } if (Character.class.isAssignableFrom(type)) { return (char) value; } if (Byte.TYPE == type) { return (byte) value; } if (Byte.class.isAssignableFrom(type)) { return (byte) value; } if (Short.TYPE == type) { return (short) value; } if (Short.class.isAssignableFrom(type)) { return (short) value; } if (Integer.TYPE == type) { return (int) value; } if (Integer.class.isAssignableFrom(type)) { return (int) value; } if (Long.TYPE == type) { return (long) value; } if (Long.class.isAssignableFrom(type)) { return (long) value; } if (Float.TYPE == type) { return (float) value; } if (Float.class.isAssignableFrom(type)) { return (float) value; } if (Double.TYPE == type) { return (double) value; } if (Double.class.isAssignableFrom(type)) { return (double) value; } if (BigInteger.class.isAssignableFrom(type)) { return ((BigInteger) value).toString(); } if (BigDecimal.class.isAssignableFrom(type)) { return ((BigDecimal) value).toString(); } if (BigDecimal.class.isAssignableFrom(type)) { return (BigDecimal) value; } if (Boolean.TYPE == type) { return ((Boolean) value).booleanValue(); } if (Boolean.class.isAssignableFrom(type)) { return ((Boolean) value).booleanValue(); } throw new IllegalArgumentException(\"Unsupported type \" + type); }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (type == Character.class) { return (Character) value; } else if (type == Character.TYPE) { return value.toString().charAt(0); } else { return null; } }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (Boolean.class.equals(type)) { return (Boolean) value; } else if (Byte.class.equals(type)) { return (Byte) value; } else if (Short.class.equals(type)) { return (Short) value; } else if (Integer.class.equals(type)) { return (Integer) value; } else if (Long.class.equals(type)) { return (Long) value; } else if (Float.class.equals(type)) { return (Float) value; } else if (Double.class.equals(type)) { return (Double) value; } else if (Character.class.equals(type)) { return (Character) value; } else if (String.class.equals(type)) { return (String) value; } else if (BigDecimal.class.equals(type)) { return (BigDecimal) value; } else if (BigInteger.class.equals(type)) { return (BigInteger) value; } else if (Date.class.equals(type)) { return (Date) value; } else if (Calendar.class.equals(type)) { return (Calendar) value; } else if (Timestamp.class.equals(type)) { return (Timestamp) value; } else { throw new IllegalArgumentException(\"Unsupported data type '\" + type + \"' for conversion.\"); } }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (type.equals(String.class)) { return value; } if (type.equals(Character.class)) { return ((Character) value).charValue(); } return super.convertToType(type, value); }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (type.equals(String.class)) { return StringUtils.trimToEmpty((String) value); } if (type.equals(Integer.class)) { return Integer.valueOf((String) value); } if (type.equals(Long.class)) { return Long.valueOf((String) value); } if (type.equals(Double.class)) { return Double.valueOf((String) value); } if (type.equals(Float.class)) { return Float.valueOf((String) value); } if (type.equals(Short.class)) { return Short.valueOf((String) value); } if (type.equals(Byte.class)) { return Byte.valueOf((String) value); } if (type.equals(Date.class)) { return DateUtils.parseDate((String) value, DateUtils.DATE_FORMAT); } if (type.equals(Timestamp.class)) { return TimestampUtils.parseDate((String) value, DateUtils.DATE_TIME_FORMAT); } throw new Exception(\"Unsupported type \" + type.getName() + \" for conversion\"); }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (type == Character.class) { return ((Character) value).charValue(); } if (type == Character.TYPE) { return ((Character) value).charValue(); } if (Character.class.isAssignableFrom(type)) { return value; } if (type == Character.TYPE) { return value; } if (type == Integer.class || type == int.class) { return Integer.valueOf(((Character) value).charValue()); } if (type == Integer.TYPE) { return Integer.valueOf(((Character) value).charValue()); } if (type == Long.class || type == long.class) { return Long.valueOf(((Character) value).charValue()); } if (type == Long.TYPE) { return Long.valueOf(((Character) value).charValue()); } if (type == Short.class || type == short.class) { return Short.valueOf(((Character) value).charValue()); } if (type == Short.TYPE) { return Short.valueOf(((Character) value).charValue()); } if (type == Byte.class || type == byte.class) { return Byte.valueOf(((Character) value).charValue()); } if (type == Byte.TYPE) { return Byte.valueOf(((Character) value).charValue()); } if (type == Boolean.class || type == boolean.class) { return Boolean.valueOf(((Character) value).charValue()); } if (type == Boolean.TYPE) { return Boolean.valueOf(((Character) value).charValue()); } if (type == String.class) { return value.toString(); } if (type == String.class) { return value; } return super.convertToType(type, value); }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (Boolean.class.isAssignableFrom(type)) { return Boolean.valueOf(value.toString()); } if (Byte.class.isAssignableFrom(type)) { return Byte.valueOf(value.toString()); } if (Character.class.isAssignableFrom(type)) { return value; } if (Short.class.isAssignableFrom(type)) { return Short.valueOf(value.toString()); } if (Integer.class.isAssignableFrom(type)) { return Integer.valueOf(value.toString()); } if (Long.class.isAssignableFrom(type)) { return Long.valueOf(value.toString()); } if (Float.class.isAssignableFrom(type)) { return Float.valueOf(value.toString()); } if (Double.class.isAssignableFrom(type)) { return Double.valueOf(value.toString()); } if (String.class.isAssignableFrom(type)) { return value.toString(); } if (BigDecimal.class.isAssignableFrom(type)) { return new BigDecimal(value.toString()); } if (Date.class.isAssignableFrom(type)) { return DateUtil.parseDate(value.toString(), DateUtil.DATE_FORMAT_SHORT); } if (java.sql.Date.class.isAssignableFrom(type)) { return new java.sql.Date(((java.util.Date) value).getTime()); } if (java.sql.Time.class.isAssignableFrom(type)) { return new java.sql.Time(((java.util.Date) value).getTime()); } if (java.sql.Timestamp.class.isAssignableFrom(type)) { return new java.sql.Timestamp(((java.util.Date) value).getTime()); } if (java.sql.Time.class.isAssignableFrom(type)) { return new java.sql.Time(((java.util.Date) value).getTime()); } if (Calendar.class.isAssignableFrom(type)) { return CalendarUtil.parseCalendar(value.toString()); } if (Blob.class.isAssignableFrom(type)) { return BlobUtil.getBlob(value.toString()); } if (Clob.class.isAssignableFrom(type)) { return ClobUtil.getClob(value.toString()); } if (Enum.class.isAssignableFrom(type)) { return EnumUtil.getEnum(type, value.toString()); } if (java.sql.Date.class.isAssignableFrom(type)) { return new java.sql.Date(((java.util.Date) value).getTime()); } if (java.sql.Time.class.isAssignableFrom(type)) { return new java.sql.Time(((java.util.Date) value).getTime()); "], "code_level": "project_runnable", "_id": "636767021a6d9265ec0178bf", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public Collection<Object> values() {\n  if (this.values == null) {\n    this.values = Collections.unmodifiableCollection(new HashSet<Object>(this.data.values()));\n  }\n  return this.values;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return map.values();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return this.values;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return map.values();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return values;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return beanMap.values();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return values;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return values;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return values;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return Collections.unmodifiableCollection(_beanMap.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the values for the BeanMap.\n * @return values for the BeanMap. The returned collection is not modifiable.\n */\n", "method_name": "values", "codes": ["public Collection<Object> values(){ if (this.values == null) { this.values = Collections.unmodifiableCollection(new HashSet<Object>(this.data.values())); } return this.values; }", "public Collection<Object> values(){ return map.values(); }", "public Collection<Object> values(){ return this.values; }", "public Collection<Object> values(){ return map.values(); }", "public Collection<Object> values(){ return values; }", "public Collection<Object> values(){ return beanMap.values(); }", "public Collection<Object> values(){ return values; }", "public Collection<Object> values(){ return values; }", "public Collection<Object> values(){ return values; }", "public Collection<Object> values(){ return Collections.unmodifiableCollection(_beanMap.values()); }"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec01764f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n    Map.Entry entry = (Map.Entry) it.next();\n    putWriteable(entry.getKey(), entry.getValue());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  if (map == null) {\n    throw new IllegalArgumentException(\"map is null\");\n  }\n  map.forEach(\n      (k, v) -> {\n        if (v instanceof ReadWriteBean) {\n          putReadWrite((ReadWriteBean) v);\n        } else if (v instanceof ReadWriteBeanMap) {\n          putReadWriteMap((ReadWriteBeanMap) v);\n        } else {\n          throw new IllegalArgumentException(\n              \"Cannot put property '\" + k + \"' of type \" + v.getClass().getName());\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Iterator<String> i = map.getPropertyNames(); i.hasNext(); ) {\n    String name = i.next();\n    if (map.getWriteableProperty(name) != null) {\n      this.putWriteable(name, map.getWriteableProperty(name));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n    Map.Entry entry = (Map.Entry) it.next();\n    put(entry.getKey(), entry.getValue());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  if (map == null) {\n    return;\n  }\n  for (String key : map.keySet()) {\n    if (key.startsWith(\"java.beans.\")) {\n      continue;\n    }\n    putWriteable(key, map.get(key));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  map.putAll(this);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  if (map == null) {\n    throw new NullPointerException(\"Map cannot be null\");\n  }\n  for (PropertyDescriptor pd : map.getPropertyDescriptors()) {\n    if (pd.getWriteMethod() == null) {\n      continue;\n    }\n    String propertyName = pd.getName();\n    Object value = map.get(propertyName);\n    if (value == null) {\n      continue;\n    }\n    if (value instanceof BeanMap) {\n      putAllWriteable((BeanMap) value);\n    } else if (value instanceof Map) {\n      putAllWriteable((Map) value);\n    } else {\n      putProperty(propertyName, value);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Iterator iter = map.keySet().iterator(); iter.hasNext(); ) {\n    Object key = iter.next();\n    Object value = map.get(key);\n    put(key, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n    Entry entry = (Entry) it.next();\n    putWriteable(entry.getKey(), entry.getValue());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Iterator<Map.Entry<String, PropertyDescriptor>> iter = map.entrySet().iterator();\n      iter.hasNext(); ) {\n    Map.Entry<String, PropertyDescriptor> entry = iter.next();\n    String key = entry.getKey();\n    PropertyDescriptor property = entry.getValue();\n    if (property.getWriteMethod() == null) {\n      iter.remove();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts all of the writable properties from the given BeanMap into this BeanMap. Read-only and Write-only properties will be ignored.\n * @param map  the BeanMap whose properties to put\n */\n", "method_name": "putAllWriteable", "codes": ["public void putAllWriteable(BeanMap map){ for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) { Map.Entry entry = (Map.Entry) it.next(); putWriteable(entry.getKey(), entry.getValue()); } }", "public void putAllWriteable(BeanMap map){ if (map == null) { throw new IllegalArgumentException(\"map is null\"); } map.forEach((k, v) -> { if (v instanceof ReadWriteBean) { putReadWrite((ReadWriteBean) v); } else if (v instanceof ReadWriteBeanMap) { putReadWriteMap((ReadWriteBeanMap) v); } else { throw new IllegalArgumentException(\"Cannot put property '\" + k + \"' of type \" + v.getClass().getName()); } }); }", "public void putAllWriteable(BeanMap map){ for (Iterator<String> i = map.getPropertyNames(); i.hasNext(); ) { String name = i.next(); if (map.getWriteableProperty(name) != null) { this.putWriteable(name, map.getWriteableProperty(name)); } } }", "public void putAllWriteable(BeanMap map){ for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) { Map.Entry entry = (Map.Entry) it.next(); put(entry.getKey(), entry.getValue()); } }", "public void putAllWriteable(BeanMap map){ if (map == null) { return; } for (String key : map.keySet()) { if (key.startsWith(\"java.beans.\")) { continue; } putWriteable(key, map.get(key)); } }", "public void putAllWriteable(BeanMap map){ map.putAll(this); }", "public void putAllWriteable(BeanMap map){ if (map == null) { throw new NullPointerException(\"Map cannot be null\"); } for (PropertyDescriptor pd : map.getPropertyDescriptors()) { if (pd.getWriteMethod() == null) { continue; } String propertyName = pd.getName(); Object value = map.get(propertyName); if (value == null) { continue; } if (value instanceof BeanMap) { putAllWriteable((BeanMap) value); } else if (value instanceof Map) { putAllWriteable((Map) value); } else { putProperty(propertyName, value); } } }", "public void putAllWriteable(BeanMap map){ for (Iterator iter = map.keySet().iterator(); iter.hasNext(); ) { Object key = iter.next(); Object value = map.get(key); put(key, value); } }", "public void putAllWriteable(BeanMap map){ for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) { Entry entry = (Entry) it.next(); putWriteable(entry.getKey(), entry.getValue()); } }", "public void putAllWriteable(BeanMap map){ for (Iterator<Map.Entry<String, PropertyDescriptor>> iter = map.entrySet().iterator(); iter.hasNext(); ) { Map.Entry<String, PropertyDescriptor> entry = iter.next(); String key = entry.getKey(); PropertyDescriptor property = entry.getValue(); if (property.getWriteMethod() == null) { iter.remove(); } } }"], "code_level": "class_runnable", "_id": "636767071a6d9265ec017962", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public long contentLength() {\n  return this.contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return this.contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return m_request.getContentLength();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return m_request.getContentLengthLong();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return (long) (response.getContentLength());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Retrieve the content length of the request.\n * @return The content length of the request.\n * @since 1.3\n */\n", "method_name": "contentLength", "codes": ["public long contentLength(){ return this.contentLength; }", "public long contentLength(){ return this.contentLength; }", "public long contentLength(){ return contentLength; }", "public long contentLength(){ return contentLength; }", "public long contentLength(){ return m_request.getContentLength(); }", "public long contentLength(){ return contentLength; }", "public long contentLength(){ return contentLength; }", "public long contentLength(){ return m_request.getContentLengthLong(); }", "public long contentLength(){ return (long) (response.getContentLength()); }", "public long contentLength(){ return contentLength; }"], "code_level": "project_runnable", "_id": "636767031a6d9265ec0178dd", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int i = 0;\n  int n = 0;\n  while (i < end) {\n    if (headerPart.charAt(i) == '\\r') {\n      n++;\n    } else if (headerPart.charAt(i) == '\\n') {\n      n = 0;\n    } else {\n      break;\n    }\n    i++;\n  }\n  return n;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  while (headerPart.charAt(end) != '\\r') {\n    end++;\n  }\n  return end;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int lineNumber = 0;\n  StringBuffer line = new StringBuffer();\n  boolean inQuotes = false;\n  while (end < headerPart.length()) {\n    char c = headerPart.charAt(end);\n    if (c == '\\r' || c == '\\n') {\n      lineNumber++;\n      if (inQuotes) {\n        line.append(c);\n      }\n    } else if (c == '\"') {\n      inQuotes = !inQuotes;\n    } else {\n      line.append(c);\n    }\n    end++;\n  }\n  return lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  while (headerPart.charAt(end) == '\\r') end++;\n  return end;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int pos = end - 1;\n  int c = pos;\n  while ((c >= 0) && (headerPart.charAt(c) != '\\n')) {\n    c--;\n  }\n  if (c < 0) {\n    return pos;\n  }\n  return pos - 1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int line = 0;\n  while (end < headerPart.length() && headerPart.charAt(end) == '\\r') {\n    end++;\n    line++;\n  }\n  return line;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int i = end - 1;\n  while (i >= 0 && headerPart.charAt(i) == '\\r') {\n    i--;\n  }\n  return i + 1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int index = end;\n  while (index > 0 && headerPart.charAt(index - 1) == '\\r') {\n    index--;\n  }\n  return index;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int index = end - 1;\n  while (index >= 0 && !headerPart.startsWith(\"\\r\\n\")) {\n    index--;\n  }\n  return index + 1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int pos = 0;\n  int l = headerPart.length();\n  while (pos < l && headerPart.charAt(pos) != '\\r') {\n    pos++;\n  }\n  if (pos == l) {\n    return pos;\n  } else {\n    return pos + 1;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n", "method_name": "parseEndOfLine", "codes": ["private int parseEndOfLine(String headerPart,int end){ int i = 0; int n = 0; while (i < end) { if (headerPart.charAt(i) == '\\r') { n++; } else if (headerPart.charAt(i) == '\\n') { n = 0; } else { break; } i++; } return n; }", "private int parseEndOfLine(String headerPart,int end){ while (headerPart.charAt(end) != '\\r') { end++; } return end; }", "private int parseEndOfLine(String headerPart,int end){ int lineNumber = 0; StringBuffer line = new StringBuffer(); boolean inQuotes = false; while (end < headerPart.length()) { char c = headerPart.charAt(end); if (c == '\\r' || c == '\\n') { lineNumber++; if (inQuotes) { line.append(c); } } else if (c == '\"') { inQuotes = !inQuotes; } else { line.append(c); } end++; } return lineNumber; }", "private int parseEndOfLine(String headerPart,int end){ while (headerPart.charAt(end) == '\\r') end++; return end; }", "private int parseEndOfLine(String headerPart,int end){ int pos = end - 1; int c = pos; while ((c >= 0) && (headerPart.charAt(c) != '\\n')) { c--; } if (c < 0) { return pos; } return pos - 1; }", "private int parseEndOfLine(String headerPart,int end){ int line = 0; while (end < headerPart.length() && headerPart.charAt(end) == '\\r') { end++; line++; } return line; }", "private int parseEndOfLine(String headerPart,int end){ int i = end - 1; while (i >= 0 && headerPart.charAt(i) == '\\r') { i--; } return i + 1; }", "private int parseEndOfLine(String headerPart,int end){ int index = end; while (index > 0 && headerPart.charAt(index - 1) == '\\r') { index--; } return index; }", "private int parseEndOfLine(String headerPart,int end){ int index = end - 1; while (index >= 0 && !headerPart.startsWith(\"\\r\\n\")) { index--; } return index + 1; }", "private int parseEndOfLine(String headerPart,int end){ int pos = 0; int l = headerPart.length(); while (pos < l && headerPart.charAt(pos) != '\\r') { pos++; } if (pos == l) { return pos; } else { return pos + 1; } }"], "code_level": "self_contained", "_id": "636767121a6d9265ec017b0a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected int findByte(byte value, int pos) {\n  int i;\n  for (i = pos; i < buffer.length; i++) {\n    if (buffer[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected int findByte(byte value, int pos) {\n  int bytePos = pos;\n  while (bytePos < buffer.length) {\n    if (buffer[bytePos] == value) {\n      return bytePos;\n    }\n    bytePos++;\n  }\n  return -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected int findByte(byte value, int pos) {\n  for (int i = pos; i < buffer.length; i++) {\n    if (buffer[i] == value) return i;\n  }\n  return -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected int findByte(byte value, int pos) {\n  for (int i = pos; i < this.buffer.length; i++) {\n    if (this.buffer[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected int findByte(byte value, int pos) {\n  int ret = 0;\n  if (pos >= buffer.length) {\n    return -1;\n  }\n  if (buffer[pos] == value) {\n    ret = pos;\n  } else {\n    while (pos < buffer.length && buffer[pos] != value) {\n      pos++;\n    }\n    if (pos < buffer.length) {\n      ret = pos;\n    }\n  }\n  return ret;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected int findByte(byte value, int pos) {\n  int res = 0;\n  while (pos < buffer.length) {\n    res = buffer[pos];\n    if (res == value) {\n      return pos;\n    }\n    pos++;\n  }\n  return -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected int findByte(byte value, int pos) {\n  for (int i = pos; i < buffer.length; i++) {\n    if (buffer[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected int findByte(byte value, int pos) {\n  for (int i = pos; i < buffer.length; i++) {\n    if (buffer[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected int findByte(byte value, int pos) {\n  for (int i = pos; i < buffer.length; i++) {\n    if (buffer[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected int findByte(byte value, int pos) {\n  int i = 0;\n  while (i < pos) {\n    if (buffer[i] == value) {\n      return i;\n    }\n    i++;\n  }\n  return -1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n", "method_name": "findByte", "codes": ["protected int findByte(byte value,int pos){ int i; for (i = pos; i < buffer.length; i++) { if (buffer[i] == value) { return i; } } return -1; }", "protected int findByte(byte value,int pos){ int bytePos = pos; while (bytePos < buffer.length) { if (buffer[bytePos] == value) { return bytePos; } bytePos++; } return -1; }", "protected int findByte(byte value,int pos){ for (int i = pos; i < buffer.length; i++) { if (buffer[i] == value) return i; } return -1; }", "protected int findByte(byte value,int pos){ for (int i = pos; i < this.buffer.length; i++) { if (this.buffer[i] == value) { return i; } } return -1; }", "protected int findByte(byte value,int pos){ int ret = 0; if (pos >= buffer.length) { return -1; } if (buffer[pos] == value) { ret = pos; } else { while (pos < buffer.length && buffer[pos] != value) { pos++; } if (pos < buffer.length) { ret = pos; } } return ret; }", "protected int findByte(byte value,int pos){ int res = 0; while (pos < buffer.length) { res = buffer[pos]; if (res == value) { return pos; } pos++; } return -1; }", "protected int findByte(byte value,int pos){ for (int i = pos; i < buffer.length; i++) { if (buffer[i] == value) { return i; } } return -1; }", "protected int findByte(byte value,int pos){ for (int i = pos; i < buffer.length; i++) { if (buffer[i] == value) { return i; } } return -1; }", "protected int findByte(byte value,int pos){ for (int i = pos; i < buffer.length; i++) { if (buffer[i] == value) { return i; } } return -1; }", "protected int findByte(byte value,int pos){ int i = 0; while (i < pos) { if (buffer[i] == value) { return i; } i++; } return -1; }"], "code_level": "class_runnable", "_id": "636766ff1a6d9265ec017851", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public byte readByte() throws IOException {\n  if (!this.hasNextByte()) throw new EOFException();\n  return this.buffer[this.position++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  if (buffer.hasRemaining()) {\n    return buffer.get();\n  } else {\n    byte[] bufferArray = new byte[1];\n    read(bufferArray);\n    return bufferArray[0];\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  int result = 0;\n  byte b = 0;\n  if (buffer.remaining() > 0) {\n    if (buffer.hasRemaining()) {\n      result = buffer.get();\n    } else {\n      buffer.clear();\n      result = inputStream.read();\n    }\n  } else {\n    result = inputStream.read();\n  }\n  return (byte) result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  int b = read();\n  if (b == -1) {\n    throw new EOFException();\n  }\n  return (byte) b;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  if (buffer.length == 0) {\n    fillBuffer();\n  }\n  return buffer[pos++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  byte b = buffer[position++];\n  if (position == buffer.length) {\n    position = 0;\n  }\n  return b;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  if (!buffer.hasRemaining()) {\n    buffer.clear();\n    fillBuffer();\n  }\n  return buffer.get();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  if (!buffer.hasRemaining()) {\n    fillBuffer();\n  }\n  return buffer.get();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  byte b = buffer.get();\n  if (b == '\\r') {\n    throw new IOException(\"End of stream reached\");\n  }\n  if (b == '\\n') {\n    return b;\n  }\n  if (b == '\\t') {\n    int n = buffer.get() & 0x0f;\n    if (n > 9) {\n      n = 10;\n    } else {\n      n = 0;\n    }\n    buffer.position(buffer.position() - 1);\n    buffer.put((byte) n);\n    return b;\n  }\n  if (b == '\\b') {\n    char c = (char) buffer.get();\n    if (c == '\\n') {\n      return b;\n    }\n  }\n  buffer.position(buffer.position() - 1);\n  return b;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  if (position == capacity) {\n    fillBuffer();\n  }\n  return buffer[position++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a byte from the <code>buffer</code>, and refills it as necessary.\n * @return The next byte from the input stream.\n * @throws IOException if there is no more data available.\n */\n", "method_name": "readByte", "codes": ["public byte readByte() throws IOException { if (!this.hasNextByte()) throw new EOFException(); return this.buffer[this.position++]; }", "public byte readByte() throws IOException { if (buffer.hasRemaining()) { return buffer.get(); } else { byte[] bufferArray = new byte[1]; read(bufferArray); return bufferArray[0]; } }", "public byte readByte() throws IOException { int result = 0; byte b = 0; if (buffer.remaining() > 0) { if (buffer.hasRemaining()) { result = buffer.get(); } else { buffer.clear(); result = inputStream.read(); } } else { result = inputStream.read(); } return (byte) result; }", "public byte readByte() throws IOException { int b = read(); if (b == -1) { throw new EOFException(); } return (byte) b; }", "public byte readByte() throws IOException { if (buffer.length == 0) { fillBuffer(); } return buffer[pos++]; }", "public byte readByte() throws IOException { byte b = buffer[position++]; if (position == buffer.length) { position = 0; } return b; }", "public byte readByte() throws IOException { if (!buffer.hasRemaining()) { buffer.clear(); fillBuffer(); } return buffer.get(); }", "public byte readByte() throws IOException { if (!buffer.hasRemaining()) { fillBuffer(); } return buffer.get(); }", "public byte readByte() throws IOException { byte b = buffer.get(); if (b == '\\r') { throw new IOException(\"End of stream reached\"); } if (b == '\\n') { return b; } if (b == '\\t') { int n = buffer.get() & 0x0f; if (n > 9) { n = 10; } else { n = 0; } buffer.position(buffer.position() - 1); buffer.put((byte) n); return b; } if (b == '\\b') { char c = (char) buffer.get(); if (c == '\\n') { return b; } } buffer.position(buffer.position() - 1); return b; }", "public byte readByte() throws IOException { if (position == capacity) { fillBuffer(); } return buffer[position++]; }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec01774b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private String parseToken(final char[] terminators) {\n  final StringBuilder token = new StringBuilder();\n  while (true) {\n    if (index >= length) {\n      break;\n    }\n    final char c = text.charAt(index);\n    if (terminators != null && c == terminators[index]) {\n      index++;\n      continue;\n    }\n    token.append(c);\n    index++;\n    if (index >= length) {\n      break;\n    }\n    if (text.charAt(index) == '\\\\') {\n      index++;\n    }\n  }\n  return token.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  StringBuilder sb = new StringBuilder();\n  boolean eof = false;\n  while (!eof) {\n    char c = input.charAt(index);\n    if (terminators != null && terminators.length > 0) {\n      if (c == terminators[0]) {\n        if (++index >= input.length()) {\n          eof = true;\n          break;\n        }\n      } else {\n        sb.append(c);\n      }\n    } else {\n      sb.append(c);\n    }\n  }\n  index++;\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  final StringBuilder token = new StringBuilder();\n  int i = 0;\n  while (i < terminators.length) {\n    if (terminators[i] == ' ') {\n      i++;\n      continue;\n    }\n    if (terminators[i] == ',') {\n      i++;\n      continue;\n    }\n    if (terminators[i] == ')') {\n      i++;\n      if (terminators[i] != '(') {\n        throw new IllegalArgumentException(\"Unexpected character after )\");\n      }\n      i++;\n      continue;\n    }\n    if (terminators[i] == '(') {\n      i++;\n      if (terminators[i] != ')') {\n        throw new IllegalArgumentException(\"Unexpected character after )\");\n      }\n      i++;\n      continue;\n    }\n    if (terminators[i] == '.') {\n      i++;\n      if (terminators[i] != '.') {\n        throw new IllegalArgumentException(\"Unexpected character after .\");\n      }\n      i++;\n      continue;\n    }\n    if (terminators[i] == '\\'') {\n      i++;\n      if (terminators[i] != '\\'') {\n        throw new IllegalArgumentException(\"Unexpected character after \\'\");\n      }\n      i++;\n      continue;\n    }\n    if (terminators[i] == '\"') {\n      i++;\n      if (terminators[i] != '\"') {\n        throw new IllegalArgumentException(\"Unexpected character after \\\"\");\n      }\n      i++;\n      continue;\n    }\n    if (terminators[i] == '\\n') {\n      break;\n    }\n    i++;\n  }\n  return token.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  StringBuilder buffer = new StringBuilder();\n  while (true) {\n    if (hasNext()) {\n      char c = next();\n      if (c == '\\\\') {\n        c = next();\n        if (c == 'u') {\n          c = next();\n          if (c >= '0' && c <= '7') {\n            buffer.append((char) Integer.parseInt(String.valueOf(c), 16));\n          } else {\n            buffer.append(c);\n          }\n        } else {\n          buffer.append(c);\n        }\n      } else {\n        buffer.append(c);\n      }\n    } else {\n      return buffer.toString();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  final StringBuilder token = new StringBuilder();\n  while (true) {\n    if (index >= src.length()) {\n      return token.toString();\n    }\n    char c = src.charAt(index++);\n    if (terminators != null) {\n      if (c == '\\\\') {\n        if (index >= src.length()) {\n          return token.toString();\n        }\n        c = src.charAt(index++);\n      } else if (c == terminators[0]) {\n        if (index >= src.length()) {\n          return token.toString();\n        }\n        c = src.charAt(index++);\n      }\n    }\n    token.append(c);\n    if (c == '\\n') {\n      line++;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  if (token == null) {\n    return null;\n  }\n  char c = token.charAt(0);\n  if (c == '\\\\') {\n    token = token.substring(1);\n    return parseToken(terminators);\n  } else if (terminators.length > 0) {\n    for (int i = 0; i < terminators.length; i++) {\n      if (terminators[i] == c) {\n        token = token.substring(0, i);\n        return parseToken(terminators);\n      }\n    }\n  }\n  return token;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  int index = this.pos;\n  StringBuilder sb = new StringBuilder();\n  while (index < this.text.length()) {\n    char c = this.text.charAt(index++);\n    if (c == '\\\\') {\n      c = this.text.charAt(index++);\n      if (c == 'n') {\n        sb.append('\\n');\n      } else if (c == 'r') {\n        sb.append('\\r');\n      } else if (c == 't') {\n        sb.append('\\t');\n      } else if (c == 'b') {\n        sb.append('\\b');\n      } else if (c == 'f') {\n        sb.append('\\f');\n      } else if (c == 'u') {\n        c = this.text.charAt(index++);\n        if (c < '0' || c > '9') {\n          throw new IllegalArgumentException(\"Invalid escape character: \" + c);\n        }\n        sb.append(c);\n      }\n    } else if (terminators.length > 0 && terminators[terminators.length - 1] == c) {\n      sb.append(c);\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  int i = 0;\n  while (true) {\n    if (terminators[i] == ' ') {\n      i++;\n      continue;\n    }\n    if (terminators[i] == '\\t') {\n      i++;\n      continue;\n    }\n    if (terminators[i] == '\\n') {\n      i++;\n      continue;\n    }\n    if (terminators[i] == '\\r') {\n      i++;\n      continue;\n    }\n    if (terminators[i] == '\\\"') {\n      i++;\n      if (i >= terminators.length) {\n        throw new IllegalArgumentException(\"Could not parse a string value\");\n      }\n      String s = new String(terminators, i, terminators.length - i);\n      i = s.length();\n      if (s.startsWith(\"\\\"\")) {\n        i++;\n      }\n      if (s.startsWith(\"\\'\")) {\n        i++;\n      }\n      if (s.startsWith(\"\\\\\\\"\")) {\n        i++;\n      }\n      if (s.startsWith(\"\\\\\\\\\")) {\n        i++;\n      }\n      if (s.startsWith(\"\\\\\\b\")) {\n        i++;\n      }\n      if (s.startsWith(\"\\\\\\f\")) {\n        i++;\n      }\n      if (s.startsWith(\"\\\\\\n\")) {\n        i++;\n      }\n      if (s.startsWith(\"\\\\\\r\")) {\n        i++;\n      }\n      if (s.startsWith(\"\\\\\\t\")) {\n        i++;\n      }\n      if (s.startsWith(\"\\\\\\\\\")) {\n        i++;\n      }\n      return s.substring(1, s.length() - 1);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  StringBuilder token = new StringBuilder();\n  while (true) {\n    char c = next();\n    if (c == '\\\\') {\n      c = next();\n      if (c == '\\\\') {\n        c = next();\n        if (c == 'u') {\n          int value = 0;\n          int i = 0;\n          while (i < 4 && c >= '0' && c <= '9') {\n            value = value * 10 + (c - '0');\n            i++;\n          }\n          token.append((char) value);\n        } else if (c == 'n') {\n          token.append('\\n');\n        } else {\n          token.append(c);\n        }\n      } else {\n        token.append(c);\n      }\n    } else {\n      token.append(c);\n    }\n    if (c == ' ' || c == '\\t') {\n    } else if (terminators.length == 0) {\n      break;\n    } else if (terminators[terminators.length - 1] != c) {\n      break;\n    }\n  }\n  return token.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  StringBuilder token = new StringBuilder();\n  boolean foundTerminator = false;\n  while (!foundTerminator && this.tokenIndex < this.tokens.length) {\n    char c = this.tokens[this.tokenIndex];\n    if (c == terminators[0]) {\n      foundTerminator = true;\n    } else if (c == '(') {\n      foundTerminator = true;\n    } else if (c == ')') {\n      foundTerminator = true;\n    } else if (foundTerminator) {\n      foundTerminator = false;\n    } else {\n      token.append(c);\n    }\n    this.tokenIndex++;\n  }\n  return token.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n", "method_name": "parseToken", "codes": ["private String parseToken(final char[] terminators){ final StringBuilder token = new StringBuilder(); while (true) { if (index >= length) { break; } final char c = text.charAt(index); if (terminators != null && c == terminators[index]) { index++; continue; } token.append(c); index++; if (index >= length) { break; } if (text.charAt(index) == '\\\\') { index++; } } return token.toString(); }", "private String parseToken(final char[] terminators){ StringBuilder sb = new StringBuilder(); boolean eof = false; while (!eof) { char c = input.charAt(index); if (terminators != null && terminators.length > 0) { if (c == terminators[0]) { if (++index >= input.length()) { eof = true; break; } } else { sb.append(c); } } else { sb.append(c); } } index++; return sb.toString(); }", "private String parseToken(final char[] terminators){ final StringBuilder token = new StringBuilder(); int i = 0; while (i < terminators.length) { if (terminators[i] == ' ') { i++; continue; } if (terminators[i] == ',') { i++; continue; } if (terminators[i] == ')') { i++; if (terminators[i] != '(') { throw new IllegalArgumentException(\"Unexpected character after )\"); } i++; continue; } if (terminators[i] == '(') { i++; if (terminators[i] != ')') { throw new IllegalArgumentException(\"Unexpected character after )\"); } i++; continue; } if (terminators[i] == '.') { i++; if (terminators[i] != '.') { throw new IllegalArgumentException(\"Unexpected character after .\"); } i++; continue; } if (terminators[i] == '\\'') { i++; if (terminators[i] != '\\'') { throw new IllegalArgumentException(\"Unexpected character after \\'\"); } i++; continue; } if (terminators[i] == '\"') { i++; if (terminators[i] != '\"') { throw new IllegalArgumentException(\"Unexpected character after \\\"\"); } i++; continue; } if (terminators[i] == '\\n') { break; } i++; } return token.toString(); }", "private String parseToken(final char[] terminators){ StringBuilder buffer = new StringBuilder(); while (true) { if (hasNext()) { char c = next(); if (c == '\\\\') { c = next(); if (c == 'u') { c = next(); if (c >= '0' && c <= '7') { buffer.append((char) Integer.parseInt(String.valueOf(c), 16)); } else { buffer.append(c); } } else { buffer.append(c); } } else { buffer.append(c); } } else { return buffer.toString(); } } }", "private String parseToken(final char[] terminators){ final StringBuilder token = new StringBuilder(); while (true) { if (index >= src.length()) { return token.toString(); } char c = src.charAt(index++); if (terminators != null) { if (c == '\\\\') { if (index >= src.length()) { return token.toString(); } c = src.charAt(index++); } else if (c == terminators[0]) { if (index >= src.length()) { return token.toString(); } c = src.charAt(index++); } } token.append(c); if (c == '\\n') { line++; } } }", "private String parseToken(final char[] terminators){ if (token == null) { return null; } char c = token.charAt(0); if (c == '\\\\') { token = token.substring(1); return parseToken(terminators); } else if (terminators.length > 0) { for (int i = 0; i < terminators.length; i++) { if (terminators[i] == c) { token = token.substring(0, i); return parseToken(terminators); } } } return token; }", "private String parseToken(final char[] terminators){ int index = this.pos; StringBuilder sb = new StringBuilder(); while (index < this.text.length()) { char c = this.text.charAt(index++); if (c == '\\\\') { c = this.text.charAt(index++); if (c == 'n') { sb.append('\\n'); } else if (c == 'r') { sb.append('\\r'); } else if (c == 't') { sb.append('\\t'); } else if (c == 'b') { sb.append('\\b'); } else if (c == 'f') { sb.append('\\f'); } else if (c == 'u') { c = this.text.charAt(index++); if (c < '0' || c > '9') { throw new IllegalArgumentException(\"Invalid escape character: \" + c); } sb.append(c); } } else if (terminators.length > 0 && terminators[terminators.length - 1] == c) { sb.append(c); } else { sb.append(c); } } return sb.toString(); }", "private String parseToken(final char[] terminators){ int i = 0; while (true) { if (terminators[i] == ' ') { i++; continue; } if (terminators[i] == '\\t') { i++; continue; } if (terminators[i] == '\\n') { i++; continue; } if (terminators[i] == '\\r') { i++; continue; } if (terminators[i] == '\\\"') { i++; if (i >= terminators.length) { throw new IllegalArgumentException(\"Could not parse a string value\"); } String s = new String(terminators, i, terminators.length - i); i = s.length(); if (s.startsWith(\"\\\"\")) { i++; } if (s.startsWith(\"\\'\")) { i++; } if (s.startsWith(\"\\\\\\\"\")) { i++; } if (s.startsWith(\"\\\\\\\\\")) { i++; } if (s.startsWith(\"\\\\\\b\")) { i++; } if (s.startsWith(\"\\\\\\f\")) { i++; } if (s.startsWith(\"\\\\\\n\")) { i++; } if (s.startsWith(\"\\\\\\r\")) { i++; } if (s.startsWith(\"\\\\\\t\")) { i++; } if (s.startsWith(\"\\\\\\\\\")) { i++; } return s.substring(1, s.length() - 1); } } }", "private String parseToken(final char[] terminators){ StringBuilder token = new StringBuilder(); while (true) { char c = next(); if (c == '\\\\') { c = next(); if (c == '\\\\') { c = next(); if (c == 'u') { int value = 0; int i = 0; while (i < 4 && c >= '0' && c <= '9') { value = value * 10 + (c - '0'); i++; } token.append((char) value); } else if (c == 'n') { token.append('\\n'); } else { token.append(c); } } else { token.append(c); } } else { token.append(c); } if (c == ' ' || c == '\\t') { } else if (terminators.length == 0) { break; } else if (terminators[terminators.length - 1] != c) { break; } } return token.toString(); }", "private String parseToken(final char[] terminators){ StringBuilder token = new StringBuilder(); boolean foundTerminator = false; while (!foundTerminator && this.tokenIndex < this.tokens.length) { char c = this.tokens[this.tokenIndex]; if (c == terminators[0]) { foundTerminator = true; } else if (c == '(') { foundTerminator = true; } else if (c == ')') { foundTerminator = true; } else if (foundTerminator) { foundTerminator = false; } else { token.append(c); } this.tokenIndex++; } return token.toString(); }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec01779c", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a == b) {\n    return true;\n  } else if (a == null || b == null || count < 0 || count > a.length || count > b.length) {\n    return false;\n  }\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (count < 0) return false;\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  int i = 0;\n  while (i < count) {\n    if (a[i] != b[i]) return false;\n    i++;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (count < 1) return a == b;\n  if (count > a.length && count < b.length) return false;\n  if (count >= a.length && count < b.length) return true;\n  if (count >= a.length && count < b.length) {\n    for (int i = 0; i < count; i++) {\n      if (a[i] != b[i]) return false;\n    }\n    return true;\n  }\n  if (count >= a.length && count < b.length) {\n    for (int i = 0; i < count; i++) {\n      if (a[i] != b[count - i - 1]) return false;\n    }\n    return true;\n  }\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (count != a.length) {\n    return false;\n  }\n  if (count != b.length) {\n    return false;\n  }\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (count < 0) {\n    return false;\n  }\n  if (a.length != b.length) {\n    return false;\n  }\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a.length != b.length) return false;\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (count < 0 || count > a.length) {\n    throw new IllegalArgumentException(\"count out of range\");\n  }\n  if (count < 0) {\n    count = a.length + count;\n  }\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a == b) {\n    return true;\n  }\n  if (a == null || b == null) {\n    return false;\n  }\n  if (a.length != b.length) {\n    return false;\n  }\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (count != a.length && count != b.length) return false;\n  for (int i = 0; i < count; i++) if (a[i] != b[i]) return false;\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.\n * @param a     The first array to compare.\n * @param b     The second array to compare.\n * @param count How many bytes should be compared.\n * @return <code>true</code> if <code>count</code> first bytes in arrays<code>a</code> and <code>b</code> are equal.\n */\n", "method_name": "arrayequals", "codes": ["public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a == b) { return true; } else if (a == null || b == null || count < 0 || count > a.length || count > b.length) { return false; } for (int i = 0; i < count; i++) { if (a[i] != b[i]) { return false; } } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (count < 0) return false; for (int i = 0; i < count; i++) { if (a[i] != b[i]) return false; } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ int i = 0; while (i < count) { if (a[i] != b[i]) return false; i++; } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (count < 1) return a == b; if (count > a.length && count < b.length) return false; if (count >= a.length && count < b.length) return true; if (count >= a.length && count < b.length) { for (int i = 0; i < count; i++) { if (a[i] != b[i]) return false; } return true; } if (count >= a.length && count < b.length) { for (int i = 0; i < count; i++) { if (a[i] != b[count - i - 1]) return false; } return true; } for (int i = 0; i < count; i++) { if (a[i] != b[i]) return false; } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (count != a.length) { return false; } if (count != b.length) { return false; } for (int i = 0; i < count; i++) { if (a[i] != b[i]) { return false; } } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (count < 0) { return false; } if (a.length != b.length) { return false; } for (int i = 0; i < count; i++) { if (a[i] != b[i]) { return false; } } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a.length != b.length) return false; for (int i = 0; i < count; i++) { if (a[i] != b[i]) return false; } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (count < 0 || count > a.length) { throw new IllegalArgumentException(\"count out of range\"); } if (count < 0) { count = a.length + count; } for (int i = 0; i < count; i++) { if (a[i] != b[i]) { return false; } } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a == b) { return true; } if (a == null || b == null) { return false; } if (a.length != b.length) { return false; } for (int i = 0; i < count; i++) { if (a[i] != b[i]) { return false; } } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (count != a.length && count != b.length) return false; for (int i = 0; i < count; i++) if (a[i] != b[i]) return false; return true; }"], "code_level": "self_contained", "_id": "636766fd1a6d9265ec017814", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  return lastIndexOf(str, searchStr, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  return lastIndexOf(str, searchStr, str.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  return lastIndexOf(str, searchStr, str.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if ((str == null) || (searchStr == null)) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if ((str == null) || (searchStr == null)) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if (isEmpty(str) || isEmpty(searchStr)) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. \n */\n", "method_name": "lastIndexOf", "codes": ["public static int lastIndexOf(String str,String searchStr){ return lastIndexOf(str, searchStr, 0); }", "public static int lastIndexOf(String str,String searchStr){ return lastIndexOf(str, searchStr, str.length()); }", "public static int lastIndexOf(String str,String searchStr){ return lastIndexOf(str, searchStr, str.length()); }", "public static int lastIndexOf(String str,String searchStr){ if ((str == null) || (searchStr == null)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ if ((str == null) || (searchStr == null)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ if (isEmpty(str) || isEmpty(searchStr)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); }"], "code_level": "project_runnable", "_id": "636766f61a6d9265ec017701", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  return sub(str, start, end, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  return sub(str, start, end, \"\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (start < 0) {\n    start += str.length();\n  }\n  if (end < 0) {\n    end += str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Gets a substring from the specified String avoiding exceptions. \n */\n", "method_name": "sub", "codes": ["public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ return sub(str, start, end, null); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ return sub(str, start, end, \"\"); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (start < 0) { start += str.length(); } if (end < 0) { end += str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }"], "code_level": "project_runnable", "_id": "636766ff1a6d9265ec01783b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (containsIgnoreCase(str, searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null || searchStrArray.size() == 0) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (containsIgnoreCase(str, searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (isEmpty(str) || isEmpty(searchStrArray)) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (str.indexOf(searchStr) >= 0) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null || searchStrArray.isEmpty()) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (containsIgnoreCase(str, searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null || searchStrArray.isEmpty()) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (str.indexOf(searchStr) == 0) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (isEmpty(str) || isEmpty(searchStrArray)) {\n    return false;\n  }\n  int strLen = str.length();\n  for (String searchStr : searchStrArray) {\n    if (containsIgnoreCase(str, searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (isEmpty(str) || searchStrArray == null) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (str.contains(searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (containsIgnoreCase(str, searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null || searchStrArray.isEmpty()) {\n    return false;\n  }\n  String strToUse = str.toLowerCase();\n  for (String searchStr : searchStrArray) {\n    if (strToUse.contains(searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  for (String searchStr : searchStrArray) {\n    if (containsIgnoreCase(str, searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Case in-sensitive Checks if the String contains any character in the given set of string. \n */\n", "method_name": "containsAnyIgnoreCase", "codes": ["public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null) { return false; } for (String searchStr : searchStrArray) { if (containsIgnoreCase(str, searchStr)) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null || searchStrArray.size() == 0) { return false; } for (String searchStr : searchStrArray) { if (containsIgnoreCase(str, searchStr)) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (isEmpty(str) || isEmpty(searchStrArray)) { return false; } for (String searchStr : searchStrArray) { if (str.indexOf(searchStr) >= 0) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null || searchStrArray.isEmpty()) { return false; } for (String searchStr : searchStrArray) { if (containsIgnoreCase(str, searchStr)) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null || searchStrArray.isEmpty()) { return false; } for (String searchStr : searchStrArray) { if (str.indexOf(searchStr) == 0) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (isEmpty(str) || isEmpty(searchStrArray)) { return false; } int strLen = str.length(); for (String searchStr : searchStrArray) { if (containsIgnoreCase(str, searchStr)) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (isEmpty(str) || searchStrArray == null) { return false; } for (String searchStr : searchStrArray) { if (str.contains(searchStr)) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null) { return false; } for (String searchStr : searchStrArray) { if (containsIgnoreCase(str, searchStr)) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null || searchStrArray.isEmpty()) { return false; } String strToUse = str.toLowerCase(); for (String searchStr : searchStrArray) { if (strToUse.contains(searchStr)) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ for (String searchStr : searchStrArray) { if (containsIgnoreCase(str, searchStr)) { return true; } } return false; }"], "code_level": "project_runnable", "_id": "6367670b1a6d9265ec017a0f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int indexOf(String str, String searchStr) {\n  if ((str == null) || (searchStr == null) || (searchStr.length() == 0)) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (isEmpty(str) || isEmpty(searchStr)) {\n    return -1;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  return indexOf(str, searchStr, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  return indexOf(str, searchStr, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds the first index within a String, handling <code>null</code>. This method uses  {@link String#indexOf(String)}. \n */\n", "method_name": "indexOf", "codes": ["public static int indexOf(String str,String searchStr){ if ((str == null) || (searchStr == null) || (searchStr.length() == 0)) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ if (isEmpty(str) || isEmpty(searchStr)) { return -1; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ return indexOf(str, searchStr, 0); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ return indexOf(str, searchStr, 0); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); }"], "code_level": "project_runnable", "_id": "636767021a6d9265ec0178bc", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == '.' || c == '[' || c == ']';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == ',' || c == ';' || c == ':' || c == '=' || c == '?';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == '.' || c == ':';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == ':' || c == '-';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == '_' || c == '-' || c == '.' || c == ':' || c == '/' || c == '#';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == ':' || c == '-';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == '.' || c == ',' || c == ';' || c == '(' || c == ')';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == '(' || c == ')' || c == '=' || c == ';' || c == ':' || c == ',' || c == '\\\\';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == ':' || c == ';';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == ':' || c == ',' || c == ';';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n", "method_name": "isParameterSeparator", "codes": ["private static boolean isParameterSeparator(final char c){ return c == '.' || c == '[' || c == ']'; }", "private static boolean isParameterSeparator(final char c){ return c == ',' || c == ';' || c == ':' || c == '=' || c == '?'; }", "private static boolean isParameterSeparator(final char c){ return c == '.' || c == ':'; }", "private static boolean isParameterSeparator(final char c){ return c == ':' || c == '-'; }", "private static boolean isParameterSeparator(final char c){ return c == '_' || c == '-' || c == '.' || c == ':' || c == '/' || c == '#'; }", "private static boolean isParameterSeparator(final char c){ return c == ':' || c == '-'; }", "private static boolean isParameterSeparator(final char c){ return c == '.' || c == ',' || c == ';' || c == '(' || c == ')'; }", "private static boolean isParameterSeparator(final char c){ return c == '(' || c == ')' || c == '=' || c == ';' || c == ':' || c == ',' || c == '\\\\'; }", "private static boolean isParameterSeparator(final char c){ return c == ':' || c == ';'; }", "private static boolean isParameterSeparator(final char c){ return c == ':' || c == ',' || c == ';'; }"], "code_level": "class_runnable", "_id": "636766fc1a6d9265ec0177da", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  int arrayLength = Array.getLength(array);\n  Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n  System.arraycopy(array, 0, newArray, 0, arrayLength);\n  if (newArrayComponentType != null) {\n    newArray[arrayLength] = Array.newInstance(newArrayComponentType, 1);\n  }\n  return newArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  final int arrayLength = Array.getLength(array);\n  final Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n  System.arraycopy(array, 0, newArray, 0, arrayLength);\n  return newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return Array.newInstance(newArrayComponentType, 1);\n  }\n  if (newArrayComponentType == byte.class) {\n    final byte[] array2 = (byte[]) array;\n    return copyArrayGrow1(array2);\n  }\n  if (newArrayComponentType == short.class) {\n    final short[] array2 = (short[]) array;\n    return copyArrayGrow1(array2);\n  }\n  if (newArrayComponentType == int.class) {\n    final int[] array2 = (int[]) array;\n    return copyArrayGrow1(array2);\n  }\n  if (newArrayComponentType == long.class) {\n    final long[] array2 = (long[]) array;\n    return copyArrayGrow1(array2);\n  }\n  if (newArrayComponentType == float.class) {\n    final float[] array2 = (float[]) array;\n    return copyArrayGrow1(array2);\n  }\n  if (newArrayComponentType == double.class) {\n    final double[] array2 = (double[]) array;\n    return copyArrayGrow1(array2);\n  }\n  if (newArrayComponentType == boolean.class) {\n    final boolean[] array2 = (boolean[]) array;\n    return copyArrayGrow1(array2);\n  }\n  if (newArrayComponentType == char.class) {\n    final char[] array2 = (char[]) array;\n    return copyArrayGrow1(array2);\n  }\n  if (newArrayComponentType == Object.class) {\n    final Object[] array2 = (Object[]) array;\n    return copyArrayGrow1(array2);\n  }\n  throw new UnsupportedOperationException(\"Unsupported array type: \" + newArrayComponentType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  int arrayLength = Array.getLength(array);\n  Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n  System.arraycopy(array, 0, newArray, 0, arrayLength);\n  if (newArrayComponentType != null) {\n    newArray[arrayLength] = Array.newInstance(newArrayComponentType, 1);\n  }\n  return newArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  if (newArrayComponentType == byte.class) {\n    final byte[] array2 = (byte[]) array;\n    final byte[] newArray = new byte[array2.length + 1];\n    System.arraycopy(array2, 0, newArray, 1, array2.length);\n    return newArray;\n  } else if (newArrayComponentType == short.class) {\n    final short[] array2 = (short[]) array;\n    final short[] newArray = new short[array2.length + 1];\n    System.arraycopy(array2, 0, newArray, 1, array2.length);\n    return newArray;\n  } else if (newArrayComponentType == int.class) {\n    final int[] array2 = (int[]) array;\n    final int[] newArray = new int[array2.length + 1];\n    System.arraycopy(array2, 0, newArray, 1, array2.length);\n    return newArray;\n  } else if (newArrayComponentType == long.class) {\n    final long[] array2 = (long[]) array;\n    final long[] newArray = new long[array2.length + 1];\n    System.arraycopy(array2, 0, newArray, 1, array2.length);\n    return newArray;\n  } else if (newArrayComponentType == float.class) {\n    final float[] array2 = (float[]) array;\n    final float[] newArray = new float[array2.length + 1];\n    System.arraycopy(array2, 0, newArray, 1, array2.length);\n    return newArray;\n  } else if (newArrayComponentType == double.class) {\n    final double[] array2 = (double[]) array;\n    final double[] newArray = new double[array2.length + 1];\n    System.arraycopy(array2, 0, newArray, 1, array2.length);\n    return newArray;\n  } else {\n    final Object[] newArray =\n        (Object[]) Array.newInstance(array.getClass().getComponentType(), 1);\n    System.arraycopy(\n        array, 0, newArray, 0, array.getClass().getComponentType().isPrimitive() ? 1 : 0);\n    newArray[newArray.length - 1] = array;\n    return newArray;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  int newLength = java.lang.reflect.Array.getLength(array);\n  if (newLength == 0) {\n    return array;\n  }\n  Object result =\n      java.lang.reflect.Array.newInstance(array.getClass().getComponentType(), newLength + 1);\n  System.arraycopy(array, 0, result, 0, newLength);\n  if (newArrayComponentType != null) {\n    result[newLength] = newArrayComponentType.getName();\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  final int length = Array.getLength(array);\n  if (newArrayComponentType == Object.class) {\n    return Array.newInstance(array.getClass().getComponentType(), length + 1);\n  }\n  if (newArrayComponentType == Integer.TYPE) {\n    final int[] newArray = new int[length + 1];\n    System.arraycopy((int[]) array, 0, newArray, 0, length);\n    return newArray;\n  }\n  if (newArrayComponentType == Long.TYPE) {\n    final long[] newArray = new long[length + 1];\n    System.arraycopy((long[]) array, 0, newArray, 0, length);\n    return newArray;\n  }\n  if (newArrayComponentType == Float.TYPE) {\n    final float[] newArray = new float[length + 1];\n    System.arraycopy((float[]) array, 0, newArray, 0, length);\n    return newArray;\n  }\n  if (newArrayComponentType == Double.TYPE) {\n    final double[] newArray = new double[length + 1];\n    System.arraycopy((double[]) array, 0, newArray, 0, length);\n    return newArray;\n  }\n  throw new IllegalArgumentException(\n      \"Unsupported array component type: \" + newArrayComponentType);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return EMPTY_OBJECT_ARRAY;\n  }\n  final int arrayLength = Array.getLength(array);\n  final Class<?> componentType = array.getClass().getComponentType();\n  if (newArrayComponentType == boolean.class) {\n    return copyArray(array, arrayLength, (boolean[]) array);\n  } else if (newArrayComponentType == byte.class) {\n    return copyArray(array, arrayLength, (byte[]) array);\n  } else if (newArrayComponentType == char.class) {\n    return copyArray(array, arrayLength, (char[]) array);\n  } else if (newArrayComponentType == short.class) {\n    return copyArray(array, arrayLength, (short[]) array);\n  } else if (newArrayComponentType == int.class) {\n    return copyArray(array, arrayLength, (int[]) array);\n  } else if (newArrayComponentType == long.class) {\n    return copyArray(array, arrayLength, (long[]) array);\n  } else if (newArrayComponentType == float.class) {\n    return copyArray(array, arrayLength, (float[]) array);\n  } else if (newArrayComponentType == double.class) {\n    return copyArray(array, arrayLength, (double[]) array);\n  } else {\n    return copyArray(\n        array,\n        arrayLength,\n        newArrayComponentType.isArray()\n            ? Array.newInstance(newArrayComponentType.getComponentType(), arrayLength)\n            : Array.newInstance(newArrayComponentType, arrayLength));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  if (newArrayComponentType == Object[].class) {\n    return Arrays.copyOf((Object[]) array, ((Object[]) array).length + 1);\n  } else {\n    return Array.newInstance(newArrayComponentType, 1);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  final int length = Array.getLength(array);\n  if (newArrayComponentType == null) {\n    return Array.newInstance(array.getClass().getComponentType(), length + 1);\n  }\n  return Array.newInstance(newArrayComponentType, length + 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n", "method_name": "copyArrayGrow1", "codes": ["private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } int arrayLength = Array.getLength(array); Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1); System.arraycopy(array, 0, newArray, 0, arrayLength); if (newArrayComponentType != null) { newArray[arrayLength] = Array.newInstance(newArrayComponentType, 1); } return newArray; }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } final int arrayLength = Array.getLength(array); final Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1); System.arraycopy(array, 0, newArray, 0, arrayLength); return newArray; }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return Array.newInstance(newArrayComponentType, 1); } if (newArrayComponentType == byte.class) { final byte[] array2 = (byte[]) array; return copyArrayGrow1(array2); } if (newArrayComponentType == short.class) { final short[] array2 = (short[]) array; return copyArrayGrow1(array2); } if (newArrayComponentType == int.class) { final int[] array2 = (int[]) array; return copyArrayGrow1(array2); } if (newArrayComponentType == long.class) { final long[] array2 = (long[]) array; return copyArrayGrow1(array2); } if (newArrayComponentType == float.class) { final float[] array2 = (float[]) array; return copyArrayGrow1(array2); } if (newArrayComponentType == double.class) { final double[] array2 = (double[]) array; return copyArrayGrow1(array2); } if (newArrayComponentType == boolean.class) { final boolean[] array2 = (boolean[]) array; return copyArrayGrow1(array2); } if (newArrayComponentType == char.class) { final char[] array2 = (char[]) array; return copyArrayGrow1(array2); } if (newArrayComponentType == Object.class) { final Object[] array2 = (Object[]) array; return copyArrayGrow1(array2); } throw new UnsupportedOperationException(\"Unsupported array type: \" + newArrayComponentType); }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } int arrayLength = Array.getLength(array); Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1); System.arraycopy(array, 0, newArray, 0, arrayLength); if (newArrayComponentType != null) { newArray[arrayLength] = Array.newInstance(newArrayComponentType, 1); } return newArray; }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } if (newArrayComponentType == byte.class) { final byte[] array2 = (byte[]) array; final byte[] newArray = new byte[array2.length + 1]; System.arraycopy(array2, 0, newArray, 1, array2.length); return newArray; } else if (newArrayComponentType == short.class) { final short[] array2 = (short[]) array; final short[] newArray = new short[array2.length + 1]; System.arraycopy(array2, 0, newArray, 1, array2.length); return newArray; } else if (newArrayComponentType == int.class) { final int[] array2 = (int[]) array; final int[] newArray = new int[array2.length + 1]; System.arraycopy(array2, 0, newArray, 1, array2.length); return newArray; } else if (newArrayComponentType == long.class) { final long[] array2 = (long[]) array; final long[] newArray = new long[array2.length + 1]; System.arraycopy(array2, 0, newArray, 1, array2.length); return newArray; } else if (newArrayComponentType == float.class) { final float[] array2 = (float[]) array; final float[] newArray = new float[array2.length + 1]; System.arraycopy(array2, 0, newArray, 1, array2.length); return newArray; } else if (newArrayComponentType == double.class) { final double[] array2 = (double[]) array; final double[] newArray = new double[array2.length + 1]; System.arraycopy(array2, 0, newArray, 1, array2.length); return newArray; } else { final Object[] newArray = (Object[]) Array.newInstance(array.getClass().getComponentType(), 1); System.arraycopy(array, 0, newArray, 0, array.getClass().getComponentType().isPrimitive() ? 1 : 0); newArray[newArray.length - 1] = array; return newArray; } }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ int newLength = java.lang.reflect.Array.getLength(array); if (newLength == 0) { return array; } Object result = java.lang.reflect.Array.newInstance(array.getClass().getComponentType(), newLength + 1); System.arraycopy(array, 0, result, 0, newLength); if (newArrayComponentType != null) { result[newLength] = newArrayComponentType.getName(); } return result; }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ final int length = Array.getLength(array); if (newArrayComponentType == Object.class) { return Array.newInstance(array.getClass().getComponentType(), length + 1); } if (newArrayComponentType == Integer.TYPE) { final int[] newArray = new int[length + 1]; System.arraycopy((int[]) array, 0, newArray, 0, length); return newArray; } if (newArrayComponentType == Long.TYPE) { final long[] newArray = new long[length + 1]; System.arraycopy((long[]) array, 0, newArray, 0, length); return newArray; } if (newArrayComponentType == Float.TYPE) { final float[] newArray = new float[length + 1]; System.arraycopy((float[]) array, 0, newArray, 0, length); return newArray; } if (newArrayComponentType == Double.TYPE) { final double[] newArray = new double[length + 1]; System.arraycopy((double[]) array, 0, newArray, 0, length); return newArray; } throw new IllegalArgumentException(\"Unsupported array component type: \" + newArrayComponentType); }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return EMPTY_OBJECT_ARRAY; } final int arrayLength = Array.getLength(array); final Class<?> componentType = array.getClass().getComponentType(); if (newArrayComponentType == boolean.class) { return copyArray(array, arrayLength, (boolean[]) array); } else if (newArrayComponentType == byte.class) { return copyArray(array, arrayLength, (byte[]) array); } else if (newArrayComponentType == char.class) { return copyArray(array, arrayLength, (char[]) array); } else if (newArrayComponentType == short.class) { return copyArray(array, arrayLength, (short[]) array); } else if (newArrayComponentType == int.class) { return copyArray(array, arrayLength, (int[]) array); } else if (newArrayComponentType == long.class) { return copyArray(array, arrayLength, (long[]) array); } else if (newArrayComponentType == float.class) { return copyArray(array, arrayLength, (float[]) array); } else if (newArrayComponentType == double.class) { return copyArray(array, arrayLength, (double[]) array); } else { return copyArray(array, arrayLength, newArrayComponentType.isArray() ? Array.newInstance(newArrayComponentType.getComponentType(), arrayLength) : Array.newInstance(newArrayComponentType, arrayLength)); } }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } if (newArrayComponentType == Object[].class) { return Arrays.copyOf((Object[]) array, ((Object[]) array).length + 1); } else { return Array.newInstance(newArrayComponentType, 1); } }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ final int length = Array.getLength(array); if (newArrayComponentType == null) { return Array.newInstance(array.getClass().getComponentType(), length + 1); } return Array.newInstance(newArrayComponentType, length + 1); }"], "code_level": "slib_runnable", "_id": "636767031a6d9265ec0178ef", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String sessionId() {\n  return sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return SESSION_ID;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return \"__\" + sdk.getSessionId();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return \"___SESSION_ID___\";\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return sContext.sessionId();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return UUID.randomUUID().toString().replace(\"-\", \"\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Session ID. \n */\n", "method_name": "sessionId", "codes": ["public static String sessionId(){ return sessionId; }", "public static String sessionId(){ return SESSION_ID; }", "public static String sessionId(){ return sessionId; }", "public static String sessionId(){ return sessionId; }", "public static String sessionId(){ return \"__\" + sdk.getSessionId(); }", "public static String sessionId(){ return sessionId; }", "public static String sessionId(){ return \"___SESSION_ID___\"; }", "public static String sessionId(){ return sessionId; }", "public static String sessionId(){ return sContext.sessionId(); }", "public static String sessionId(){ return UUID.randomUUID().toString().replace(\"-\", \"\"); }"], "code_level": "plib_runnable", "_id": "636766fe1a6d9265ec017834", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public Boolean isPartialContentResponse() {\n  return mResponse.getStatusLine().getStatusCode() >= 206;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return isPartialContentResponse(response.getStatusCode());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return HttpResponseCode.isPartialContent(this.statusCode);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  if (response.getStatusCode() != HttpStatus.PARTIAL_CONTENT.value()) {\n    return false;\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return response.getStatusCode().equals(HttpStatus.PARTIAL_CONTENT);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return ((response != null) && (response.getStatusCode() == HttpResponseStatus.PARTIAL_CONTENT));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return getResponse().getStatusCode().is2xxSuccessful();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return (getStatusCode() == HttpStatus.PARTIAL_CONTENT.value());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return this.responseStatusCode == HttpStatus.PARTIAL_CONTENT.value();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return response.isPartialContent();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if the actual response is a Partial Content (HTTP 206 code)\n * @return is partial content or not\n */\n", "method_name": "isPartialContentResponse", "codes": ["public Boolean isPartialContentResponse(){ return mResponse.getStatusLine().getStatusCode() >= 206; }", "public Boolean isPartialContentResponse(){ return isPartialContentResponse(response.getStatusCode()); }", "public Boolean isPartialContentResponse(){ return HttpResponseCode.isPartialContent(this.statusCode); }", "public Boolean isPartialContentResponse(){ if (response.getStatusCode() != HttpStatus.PARTIAL_CONTENT.value()) { return false; } return true; }", "public Boolean isPartialContentResponse(){ return response.getStatusCode().equals(HttpStatus.PARTIAL_CONTENT); }", "public Boolean isPartialContentResponse(){ return ((response != null) && (response.getStatusCode() == HttpResponseStatus.PARTIAL_CONTENT)); }", "public Boolean isPartialContentResponse(){ return getResponse().getStatusCode().is2xxSuccessful(); }", "public Boolean isPartialContentResponse(){ return (getStatusCode() == HttpStatus.PARTIAL_CONTENT.value()); }", "public Boolean isPartialContentResponse(){ return this.responseStatusCode == HttpStatus.PARTIAL_CONTENT.value(); }", "public Boolean isPartialContentResponse(){ return response.isPartialContent(); }"], "code_level": "plib_runnable", "_id": "636766ae1a6d9265ec0175dc", "project_name": "framework-master"}, {"generate_results": [{"generate_code": "private String buildContentRange() {\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"bytes \")\n      .append(this.contentLength)\n      .append(\"-\")\n      .append(this.contentLength)\n      .append(\"/\")\n      .append(this.contentLength);\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  StringBuilder builder = new StringBuilder();\n  builder.append(\"bytes \");\n  builder.append(getStart());\n  builder.append(\"-\");\n  builder.append(getEnd());\n  builder.append(\"/\");\n  builder.append(getSize());\n  return builder.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  return String.format(\"bytes %d-%d/%d\", start, end, length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  if (!isMultipart) {\n    return null;\n  }\n  StringBuilder builder = new StringBuilder();\n  builder.append(\"bytes \");\n  if (start != null) {\n    builder.append(start).append(\"-\");\n  }\n  if (end != null) {\n    builder.append(end);\n  }\n  if (builder.length() > 0) {\n    builder.append(\"/\");\n  }\n  builder.append(String.valueOf(fileLength));\n  return builder.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  String range = \"bytes \" + this.contentLength + \"-\";\n  range = range + this.contentLength;\n  if (this.contentLength == this.contentLengthLong) {\n    range = range + \"/\";\n  } else if (this.contentLength == this.contentLengthShort) {\n    range = range + \"/*\";\n  } else {\n    range = range + \"/\" + this.contentLength;\n  }\n  return range;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  return \"bytes \" + this.contentLength + \"-\" + this.contentLength + \"/\" + this.contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"bytes \");\n  sb.append(this.contentLength);\n  sb.append(\"-\");\n  sb.append(this.contentLength);\n  sb.append(\"/\");\n  sb.append(this.contentLength);\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"bytes \");\n  sb.append(getByteRangeStart());\n  sb.append(\"-\");\n  sb.append(getByteRangeEnd());\n  sb.append(\"/\");\n  sb.append(getByteRangeCount());\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  StringBuilder sb = new StringBuilder();\n  if (isLast) {\n    sb.append(\"bytes \");\n  } else {\n    sb.append(\"bytes \");\n  }\n  if (start != -1) {\n    sb.append(start).append(\"-\").append(end);\n  } else {\n    sb.append(\"0-\").append(end);\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  StringBuilder builder = new StringBuilder();\n  builder.append(\"bytes \");\n  builder.append(this.contentLength);\n  builder.append(\"-\");\n  builder.append(this.contentLength);\n  builder.append(\"/\");\n  builder.append(this.contentLength);\n  return builder.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n", "method_name": "buildContentRange", "codes": ["private String buildContentRange(){ StringBuilder sb = new StringBuilder(); sb.append(\"bytes \").append(this.contentLength).append(\"-\").append(this.contentLength).append(\"/\").append(this.contentLength); return sb.toString(); }", "private String buildContentRange(){ StringBuilder builder = new StringBuilder(); builder.append(\"bytes \"); builder.append(getStart()); builder.append(\"-\"); builder.append(getEnd()); builder.append(\"/\"); builder.append(getSize()); return builder.toString(); }", "private String buildContentRange(){ return String.format(\"bytes %d-%d/%d\", start, end, length); }", "private String buildContentRange(){ if (!isMultipart) { return null; } StringBuilder builder = new StringBuilder(); builder.append(\"bytes \"); if (start != null) { builder.append(start).append(\"-\"); } if (end != null) { builder.append(end); } if (builder.length() > 0) { builder.append(\"/\"); } builder.append(String.valueOf(fileLength)); return builder.toString(); }", "private String buildContentRange(){ String range = \"bytes \" + this.contentLength + \"-\"; range = range + this.contentLength; if (this.contentLength == this.contentLengthLong) { range = range + \"/\"; } else if (this.contentLength == this.contentLengthShort) { range = range + \"/*\"; } else { range = range + \"/\" + this.contentLength; } return range; }", "private String buildContentRange(){ return \"bytes \" + this.contentLength + \"-\" + this.contentLength + \"/\" + this.contentLength; }", "private String buildContentRange(){ StringBuilder sb = new StringBuilder(); sb.append(\"bytes \"); sb.append(this.contentLength); sb.append(\"-\"); sb.append(this.contentLength); sb.append(\"/\"); sb.append(this.contentLength); return sb.toString(); }", "private String buildContentRange(){ StringBuilder sb = new StringBuilder(); sb.append(\"bytes \"); sb.append(getByteRangeStart()); sb.append(\"-\"); sb.append(getByteRangeEnd()); sb.append(\"/\"); sb.append(getByteRangeCount()); return sb.toString(); }", "private String buildContentRange(){ StringBuilder sb = new StringBuilder(); if (isLast) { sb.append(\"bytes \"); } else { sb.append(\"bytes \"); } if (start != -1) { sb.append(start).append(\"-\").append(end); } else { sb.append(\"0-\").append(end); } return sb.toString(); }", "private String buildContentRange(){ StringBuilder builder = new StringBuilder(); builder.append(\"bytes \"); builder.append(this.contentLength); builder.append(\"-\"); builder.append(this.contentLength); builder.append(\"/\"); builder.append(this.contentLength); return builder.toString(); }"], "code_level": "class_runnable", "_id": "636766ae1a6d9265ec0175d8", "project_name": "framework-master"}, {"generate_results": [{"generate_code": "private static String javaCharset(String charset) {\n  String ret = null;\n  if (charset != null) {\n    ret = charset.replace(\" \", \"_\");\n    ret = ret.replace(\"-\", \"_\");\n    ret = ret.replace(\"=\", \"_\");\n    ret = ret.replace(\"+\", \"_\");\n    ret = ret.replace(\"/\", \"_\");\n    ret = ret.replace(\"$\", \"_\");\n    ret = ret.replace(\"%\", \"_\");\n    ret = ret.replace(\"~\", \"_\");\n    ret = ret.replace(\"!\", \"_\");\n    ret = ret.replace(\"@\", \"_\");\n    ret = ret.replace(\"#\", \"_\");\n    ret = ret.replace(\"$\", \"_\");\n    ret = ret.replace(\"%\", \"_\");\n    ret = ret.replace(\"^\", \"_\");\n    ret = ret.replace(\"&\", \"_\");\n    ret = ret.replace(\"*\", \"_\");\n    ret = ret.replace(\"(\", \"_\");\n    ret = ret.replace(\")\", \"_\");\n    ret = ret.replace(\"_\", \"_\");\n    ret = ret.replace(\"{\", \"_\");\n    ret = ret.replace(\"}\", \"_\");\n    ret = ret.replace(\"[\", \"_\");\n    ret = ret.replace(\"]\", \"_\");\n    ret = ret.replace(\"+\", \"_\");\n    ret = ret.replace(\"=\", \"_\");\n    ret = ret.replace(\"_\", \"_\");\n    ret = ret.replace(\";\", \"_\");\n    ret = ret.replace(\"<\", \"_\");\n    ret = ret.replace(\">\", \"_\");\n    ret = ret.replace(\"'\", \"_\");\n    ret = ret.replace(\"\\\"\", \"_\");\n  }\n  return ret;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  if (charset.startsWith(\"UTF-16\")) return \"UTF-16\";\n  if (charset.startsWith(\"UTF-32\")) return \"UTF-32\";\n  if (charset.startsWith(\"UTF-16BE\")) return \"UTF-16BE\";\n  if (charset.startsWith(\"UTF-32BE\")) return \"UTF-32BE\";\n  if (charset.startsWith(\"UTF-16LE\")) return \"UTF-16LE\";\n  if (charset.startsWith(\"UTF-32LE\")) return \"UTF-32LE\";\n  if (charset.startsWith(\"UTF-16\")) return \"UTF-16\";\n  if (charset.startsWith(\"UTF-32\")) return \"UTF-32\";\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){ if (charset.equalsIgnoreCase(\"UTF-8\")) return \"UTF-8\"; else if (charset.equalsIgnoreCase(\"ISO-8859-1\")) return \"ISO-8859-1\"; else if (charset.equalsIgnoreCase(\"ISO-8859-2\")) return \"ISO-8859-2\"; else if (charset.equalsIgnoreCase(\"ISO-8859-3\")) return \"ISO-8859-3\"; else if (charset.equalsIgnoreCase(\"ISO-8859-4\")) return \"ISO-8859-4\"; else if (charset.equalsIgnoreCase(\"ISO-8859-5\")) return \"ISO-8859-5\"; else if (charset.equalsIgnoreCase(\"ISO-8859-6\")) return \"ISO-8859-6\"; else if (charset.equalsIgnoreCase(\"ISO-8859-7\")) return \"ISO-8859-7\"; else if (charset.equalsIgnoreCase(\"ISO-8859-8\")) return \"ISO-8859-8\"; else if (charset.equalsIgnoreCase(\"ISO-8859-9\")) return \"ISO-8859-9\"; else if (charset.equalsIgnoreCase(\"ISO-8859-10\")) return \"ISO-8859-10\"; else if (charset.equalsIgnoreCase(\"ISO-8859-11\")) return \"ISO-8859-11\"; else if (charset.equalsIgnoreCase(\"ISO-8859-12\")) return \"ISO-8859-12\"; else if (charset.equalsIgnoreCase(\"ISO-8859-13\")) return \"ISO-8859-13\"; else if (charset.equalsIgnoreCase(\"ISO-8859-14\")) return \"ISO-8859-14\"; else if (charset.equalsIgnoreCase(\"ISO-8859-15\")) return \"ISO-8859-15\"; else if (charset.equalsIgnoreCase(\"ISO-8859-16\")) return \"ISO-8859-16\"; else if (charset.equalsIgnoreCase(\"ISO-8859-17\")) return \"ISO-8859-17\"; else if (charset.equalsIgnoreCase(\"ISO-8859-18\")) return \"ISO-8859-18\"; else if (charset.equalsIgnoreCase(\"ISO-8859-19\")) return \"ISO-8859-19\"; else if (charset.equalsIgnoreCase(\"ISO-8859-20\")) return \"ISO-8859-20\"; else if (charset.equalsIgnoreCase(\"ISO-8859-21\")) return \"ISO-8859-21\"; else if (charset.equalsIgnoreCase(\"ISO-8859-22\")) return \"ISO-8859-22\"; else if (charset.equalsIgnoreCase(\"ISO-8859-23\")) return \"ISO-8859-23\"; else if (charset.equalsIgnoreCase(\"ISO-8859-24\")) return \"ISO-8859-24\"; else if (charset.equalsIgnoreCase(\"ISO-8859-25\")) return \"ISO-8859-25\"; else if (charset", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  if (charset.equals(\"ISO-8859-1\")) return \"ISO-8859-1\";\n  if (charset.equals(\"UTF-8\")) return \"UTF-8\";\n  if (charset.equals(\"GB2312\")) return \"GB2312\";\n  if (charset.equals(\"GBK\")) return \"GBK\";\n  if (charset.equals(\"UTF-16BE\")) return \"UTF-16BE\";\n  if (charset.equals(\"UTF-16LE\")) return \"UTF-16LE\";\n  if (charset.equals(\"UTF-16\")) return \"UTF-16\";\n  if (charset.equals(\"UTF-16BE\")) return \"UTF-16BE\";\n  if (charset.equals(\"UTF-16LE\")) return \"UTF-16LE\";\n  if (charset.equals(\"UTF-16\")) return \"UTF-16\";\n  if (charset.equals(\"UTF-16BE\")) return \"UTF-16BE\";\n  if (charset.equals(\"UTF-16LE\")) return \"UTF-16LE\";\n  if (charset.equals(\"UTF-16\")) return \"UTF-16\";\n  return charset;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  String enc = charsetToJavaEncoding(charset);\n  if (enc == null) {\n    enc = \"ISO-8859-1\";\n  }\n  return enc;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  StringBuilder result = new StringBuilder(\"\");\n  if (charset != null) {\n    int i = 0;\n    while (i < charset.length()) {\n      char ch = charset.charAt(i);\n      if (ch >= 0x20 && ch <= 0x7E) {\n        if (ch == '\"') {\n          result.append(\"\\\\\\\"\");\n        } else if (ch == '\\'') {\n          result.append(\"\\\\\\'\");\n        } else if (ch == '/') {\n          result.append(\"\\\\/\");\n        } else if (ch == '\\\\') {\n          result.append(\"\\\\\\\\\");\n        } else if (ch == '\\n') {\n          result.append(\"\\\\n\");\n        } else if (ch == '\\r') {\n          result.append(\"\\\\r\");\n        } else if (ch == '\\t') {\n          result.append(\"\\\\t\");\n        } else {\n          result.append(ch);\n        }\n      } else {\n        result.append(ch);\n      }\n      i++;\n    }\n  }\n  return result.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){ if (charset.equals(\"ISO-8859-1\")) { return \"iso-8859-1\"; } else if (charset.equals(\"ISO-8859-2\")) { return \"iso-8859-2\"; } else if (charset.equals(\"ISO-8859-3\")) { return \"iso-8859-3\"; } else if (charset.equals(\"ISO-8859-4\")) { return \"iso-8859-4\"; } else if (charset.equals(\"ISO-8859-5\")) { return \"iso-8859-5\"; } else if (charset.equals(\"ISO-8859-6\")) { return \"iso-8859-6\"; } else if (charset.equals(\"ISO-8859-7\")) { return \"iso-8859-7\"; } else if (charset.equals(\"ISO-8859-8\")) { return \"iso-8859-8\"; } else if (charset.equals(\"ISO-8859-9\")) { return \"iso-8859-9\"; } else if (charset.equals(\"ISO-8859-10\")) { return \"iso-8859-10\"; } else if (charset.equals(\"ISO-8859-11\")) { return \"iso-8859-11\"; } else if (charset.equals(\"ISO-8859-12\")) { return \"iso-8859-12\"; } else if (charset.equals(\"ISO-8859-13\")) { return \"iso-8859-13\"; } else if (charset.equals(\"ISO-8859-14\")) { return \"iso-8859-14\"; } else if (charset.equals(\"ISO-8859-15\")) { return \"iso-8859-15\"; } else if (charset.equals(\"ISO-8859-16\")) { return \"iso-8859-16\"; } else if (charset.equals(\"ISO-8859-17\")) { return \"iso-8859-17\"; } else if (charset.equals(\"ISO-8859-18\")) { return \"iso-8859-18\"; } else if (charset.equals(\"ISO-8859-19\")) { return \"iso-8859-19\"; } else if (charset.equals(\"ISO-8859-20\")) { return \"iso-8859-20\"; } else if (charset.equals(\"ISO-8859-21\")) { return \"iso-8859-21\"; } else if (charset.equals(\"ISO-8859-22\")) { return \"iso-8859-22\"; } else if (charset.equals(\"ISO-8859-23\")) { return \"iso-8859-23\"; } else if (charset.equals(\"ISO-8859-24\")) { return \"iso-8859-24\"; } else if (charset.equals(\"ISO-8859-25\")) { return \"iso-8859-25\"; } else if (charset.equals(\"ISO-8859-26\")) { return \"iso-8859-26\"; } else if (charset.equals(\"ISO-8859-27\")) { return \"iso-8859-27\"; } else if (charset.equals(\"ISO-8859-28\")) { return \"iso-8859-28\"; } else ", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){ if (charset == null) return null; if (charset.equals(\"UTF-8\")) return \"UTF-8\"; if (charset.equals(\"US-ASCII\")) return \"US-ASCII\"; if (charset.equals(\"ISO-8859-1\")) return \"ISO-8859-1\"; if (charset.equals(\"ISO-8859-2\")) return \"ISO-8859-2\"; if (charset.equals(\"ISO-8859-3\")) return \"ISO-8859-3\"; if (charset.equals(\"ISO-8859-4\")) return \"ISO-8859-4\"; if (charset.equals(\"ISO-8859-5\")) return \"ISO-8859-5\"; if (charset.equals(\"ISO-8859-6\")) return \"ISO-8859-6\"; if (charset.equals(\"ISO-8859-7\")) return \"ISO-8859-7\"; if (charset.equals(\"ISO-8859-8\")) return \"ISO-8859-8\"; if (charset.equals(\"ISO-8859-9\")) return \"ISO-8859-9\"; if (charset.equals(\"ISO-8859-10\")) return \"ISO-8859-10\"; if (charset.equals(\"ISO-8859-11\")) return \"ISO-8859-11\"; if (charset.equals(\"ISO-8859-12\")) return \"ISO-8859-12\"; if (charset.equals(\"ISO-8859-13\")) return \"ISO-8859-13\"; if (charset.equals(\"ISO-8859-14\")) return \"ISO-8859-14\"; if (charset.equals(\"ISO-8859-15\")) return \"ISO-8859-15\"; if (charset.equals(\"ISO-8859-16\")) return \"ISO-8859-16\"; if (charset.equals(\"ISO-8859-17\")) return \"ISO-8859-17\"; if (charset.equals(\"ISO-8859-18\")) return \"ISO-8859-18\"; if (charset.equals(\"ISO-8859-19\")) return \"ISO-8859-19\"; if (charset.equals(\"ISO-8859-20\")) return \"ISO-8859-20\"; if (charset.equals(\"ISO-8859-21\")) return \"ISO-8859-21\"; if (charset.equals(\"ISO-8859-22\")) return \"ISO-8859-22\"; if (charset.equals(\"ISO-8859-23\")) return \"ISO-8859-23\"; if (charset.equals(\"ISO-8859-24\")) return \"ISO-8859-24\"; if (charset.equals(\"ISO-8859-25\")) return \"ISO-8859-25\"; if (charset.equals(\"ISO-8859-26\")) return \"ISO-8859-26\"; if (charset.equals(\"ISO-8859-27\")) return \"ISO-8859-27\"; if (charset.equals(\"ISO-8859-28\")) return \"ISO-8859-28\"; if (charset.equals(\"ISO-8859-29\")) return \"ISO-8859-29\"; if (charset.equals(\"ISO-8859-30\")) return \"ISO-8859-30\"; if (charset.equals(\"ISO-8859-31\")", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  if (charset == null) {\n    return \"ISO-8859-1\";\n  }\n  String charsetJava = charset.toUpperCase(Locale.ENGLISH);\n  if (charsetJava.startsWith(\"ISO-8859-1\")) {\n    return \"ISO-8859-1\";\n  }\n  if (charsetJava.startsWith(\"US-ASCII\")) {\n    return \"US-ASCII\";\n  }\n  return charset;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){ if (charset.equals(\"ASCII\")) { return \"ISO-8859-1\"; } else if (charset.equals(\"UTF-8\")) { return \"UTF-8\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"ISO-8859-1\")) { return \"ISO-8859-1\"; } else if (charset.equals(\"ISO-8859-2\")) { return \"ISO-8859-2\"; } else if (charset.equals(\"ISO-8859-3\")) { return \"ISO-8859-3\"; } else if (charset.equals(\"ISO-8859-4\")) { return \"ISO-8859-4\"; } else if (charset.equals(\"ISO-8859-5\")) { return \"ISO-8859-5\"; } else if (charset.equals(\"ISO-8859-6\")) { return \"ISO-8859-6\"; } else if (charset.equals(\"ISO-8859-7\")) { return \"ISO-8859-7\"; } else if (charset.equals(\"ISO-8859-8\")) { return \"ISO-8859-8\"; } else if (charset.equals(\"ISO-8859-9\")) { return \"ISO-8859-9\"; } else if (charset.equals(\"ISO-8859-10\")) { return \"ISO-8859-10\"; } else if (charset.equals(\"ISO-8859-11\")) { return \"ISO-8859-11\"; } else if (charset.equals(\"ISO-8859-12\")) { return \"ISO-8859-12\"; } else if (charset.equals(\"ISO-8859-13\")) { return \"ISO-8859-13\"; } else if (charset.equals(\"ISO-8859-14\")) { return \"ISO-8859-14\"; } else if (charset.equals(\"ISO-8859-15\")) { return \"ISO-8859-15\"; } else if (charset.equals(\"ISO-8859-16\")) { return \"ISO-8859-16\"; } else if (charset.equals(\"ISO-8859-17\")) { return \"ISO-8859-17\"; } else if (charset.equals(\"ISO-8859-18\")) { return \"ISO-8859-18\"; } else if (charset.equals(\"ISO-8859-19\")) { return \"ISO-8859-19\"; } else if (charset.equals(\"ISO-8859-20\")) { return \"ISO-8859-20\"; } else if (charset.equals(\"ISO-8859-21\")) { return \"ISO-8859-21\"; } else if (charset.equals(\"ISO-8859-22\")) { return \"ISO-8859-22\"; } else if (charset.equals(\"ISO-8859-23\")) { return \"ISO-8859-23\"; } else if (charset.equals(\"ISO-8859-24\")) { return \"ISO-8859-24\"; ", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n", "method_name": "javaCharset", "codes": ["private static String javaCharset(String charset){ String ret = null; if (charset != null) { ret = charset.replace(\" \", \"_\"); ret = ret.replace(\"-\", \"_\"); ret = ret.replace(\"=\", \"_\"); ret = ret.replace(\"+\", \"_\"); ret = ret.replace(\"/\", \"_\"); ret = ret.replace(\"$\", \"_\"); ret = ret.replace(\"%\", \"_\"); ret = ret.replace(\"~\", \"_\"); ret = ret.replace(\"!\", \"_\"); ret = ret.replace(\"@\", \"_\"); ret = ret.replace(\"#\", \"_\"); ret = ret.replace(\"$\", \"_\"); ret = ret.replace(\"%\", \"_\"); ret = ret.replace(\"^\", \"_\"); ret = ret.replace(\"&\", \"_\"); ret = ret.replace(\"*\", \"_\"); ret = ret.replace(\"(\", \"_\"); ret = ret.replace(\")\", \"_\"); ret = ret.replace(\"_\", \"_\"); ret = ret.replace(\"{\", \"_\"); ret = ret.replace(\"}\", \"_\"); ret = ret.replace(\"[\", \"_\"); ret = ret.replace(\"]\", \"_\"); ret = ret.replace(\"+\", \"_\"); ret = ret.replace(\"=\", \"_\"); ret = ret.replace(\"_\", \"_\"); ret = ret.replace(\";\", \"_\"); ret = ret.replace(\"<\", \"_\"); ret = ret.replace(\">\", \"_\"); ret = ret.replace(\"'\", \"_\"); ret = ret.replace(\"\\\"\", \"_\"); } return ret; }", "private static String javaCharset(String charset){ if (charset.startsWith(\"UTF-16\")) return \"UTF-16\"; if (charset.startsWith(\"UTF-32\")) return \"UTF-32\"; if (charset.startsWith(\"UTF-16BE\")) return \"UTF-16BE\"; if (charset.startsWith(\"UTF-32BE\")) return \"UTF-32BE\"; if (charset.startsWith(\"UTF-16LE\")) return \"UTF-16LE\"; if (charset.startsWith(\"UTF-32LE\")) return \"UTF-32LE\"; if (charset.startsWith(\"UTF-16\")) return \"UTF-16\"; if (charset.startsWith(\"UTF-32\")) return \"UTF-32\"; return null; }", "private static String javaCharset(String charset){ if (charset.equalsIgnoreCase(\"UTF-8\")) return \"UTF-8\"; else if (charset.equalsIgnoreCase(\"ISO-8859-1\")) return \"ISO-8859-1\"; else if (charset.equalsIgnoreCase(\"ISO-8859-2\")) return \"ISO-8859-2\"; else if (charset.equalsIgnoreCase(\"ISO-8859-3\")) return \"ISO-8859-3\"; else if (charset.equalsIgnoreCase(\"ISO-8859-4\")) return \"ISO-8859-4\"; else if (charset.equalsIgnoreCase(\"ISO-8859-5\")) return \"ISO-8859-5\"; else if (charset.equalsIgnoreCase(\"ISO-8859-6\")) return \"ISO-8859-6\"; else if (charset.equalsIgnoreCase(\"ISO-8859-7\")) return \"ISO-8859-7\"; else if (charset.equalsIgnoreCase(\"ISO-8859-8\")) return \"ISO-8859-8\"; else if (charset.equalsIgnoreCase(\"ISO-8859-9\")) return \"ISO-8859-9\"; else if (charset.equalsIgnoreCase(\"ISO-8859-10\")) return \"ISO-8859-10\"; else if (charset.equalsIgnoreCase(\"ISO-8859-11\")) return \"ISO-8859-11\"; else if (charset.equalsIgnoreCase(\"ISO-8859-12\")) return \"ISO-8859-12\"; else if (charset.equalsIgnoreCase(\"ISO-8859-13\")) return \"ISO-8859-13\"; else if (charset.equalsIgnoreCase(\"ISO-8859-14\")) return \"ISO-8859-14\"; else if (charset.equalsIgnoreCase(\"ISO-8859-15\")) return \"ISO-8859-15\"; else if (charset.equalsIgnoreCase(\"ISO-8859-16\")) return \"ISO-8859-16\"; else if (charset.equalsIgnoreCase(\"ISO-8859-17\")) return \"ISO-8859-17\"; else if (charset.equalsIgnoreCase(\"ISO-8859-18\")) return \"ISO-8859-18\"; else if (charset.equalsIgnoreCase(\"ISO-8859-19\")) return \"ISO-8859-19\"; else if (charset.equalsIgnoreCase(\"ISO-8859-20\")) return \"ISO-8859-20\"; else if (charset.equalsIgnoreCase(\"ISO-8859-21\")) return \"ISO-8859-21\"; else if (charset.equalsIgnoreCase(\"ISO-8859-22\")) return \"ISO-8859-22\"; else if (charset.equalsIgnoreCase(\"ISO-8859-23\")) return \"ISO-8859-23\"; else if (charset.equalsIgnoreCase(\"ISO-8859-24\")) return \"ISO-8859-24\"; else if (charset.equalsIgnoreCase(\"ISO-8859-25\")) return \"ISO-8859-25\"; else if (charset", "private static String javaCharset(String charset){ if (charset.equals(\"ISO-8859-1\")) return \"ISO-8859-1\"; if (charset.equals(\"UTF-8\")) return \"UTF-8\"; if (charset.equals(\"GB2312\")) return \"GB2312\"; if (charset.equals(\"GBK\")) return \"GBK\"; if (charset.equals(\"UTF-16BE\")) return \"UTF-16BE\"; if (charset.equals(\"UTF-16LE\")) return \"UTF-16LE\"; if (charset.equals(\"UTF-16\")) return \"UTF-16\"; if (charset.equals(\"UTF-16BE\")) return \"UTF-16BE\"; if (charset.equals(\"UTF-16LE\")) return \"UTF-16LE\"; if (charset.equals(\"UTF-16\")) return \"UTF-16\"; if (charset.equals(\"UTF-16BE\")) return \"UTF-16BE\"; if (charset.equals(\"UTF-16LE\")) return \"UTF-16LE\"; if (charset.equals(\"UTF-16\")) return \"UTF-16\"; return charset; }", "private static String javaCharset(String charset){ String enc = charsetToJavaEncoding(charset); if (enc == null) { enc = \"ISO-8859-1\"; } return enc; }", "private static String javaCharset(String charset){ StringBuilder result = new StringBuilder(\"\"); if (charset != null) { int i = 0; while (i < charset.length()) { char ch = charset.charAt(i); if (ch >= 0x20 && ch <= 0x7E) { if (ch == '\"') { result.append(\"\\\\\\\"\"); } else if (ch == '\\'') { result.append(\"\\\\\\'\"); } else if (ch == '/') { result.append(\"\\\\/\"); } else if (ch == '\\\\') { result.append(\"\\\\\\\\\"); } else if (ch == '\\n') { result.append(\"\\\\n\"); } else if (ch == '\\r') { result.append(\"\\\\r\"); } else if (ch == '\\t') { result.append(\"\\\\t\"); } else { result.append(ch); } } else { result.append(ch); } i++; } } return result.toString(); }", "private static String javaCharset(String charset){ if (charset.equals(\"ISO-8859-1\")) { return \"iso-8859-1\"; } else if (charset.equals(\"ISO-8859-2\")) { return \"iso-8859-2\"; } else if (charset.equals(\"ISO-8859-3\")) { return \"iso-8859-3\"; } else if (charset.equals(\"ISO-8859-4\")) { return \"iso-8859-4\"; } else if (charset.equals(\"ISO-8859-5\")) { return \"iso-8859-5\"; } else if (charset.equals(\"ISO-8859-6\")) { return \"iso-8859-6\"; } else if (charset.equals(\"ISO-8859-7\")) { return \"iso-8859-7\"; } else if (charset.equals(\"ISO-8859-8\")) { return \"iso-8859-8\"; } else if (charset.equals(\"ISO-8859-9\")) { return \"iso-8859-9\"; } else if (charset.equals(\"ISO-8859-10\")) { return \"iso-8859-10\"; } else if (charset.equals(\"ISO-8859-11\")) { return \"iso-8859-11\"; } else if (charset.equals(\"ISO-8859-12\")) { return \"iso-8859-12\"; } else if (charset.equals(\"ISO-8859-13\")) { return \"iso-8859-13\"; } else if (charset.equals(\"ISO-8859-14\")) { return \"iso-8859-14\"; } else if (charset.equals(\"ISO-8859-15\")) { return \"iso-8859-15\"; } else if (charset.equals(\"ISO-8859-16\")) { return \"iso-8859-16\"; } else if (charset.equals(\"ISO-8859-17\")) { return \"iso-8859-17\"; } else if (charset.equals(\"ISO-8859-18\")) { return \"iso-8859-18\"; } else if (charset.equals(\"ISO-8859-19\")) { return \"iso-8859-19\"; } else if (charset.equals(\"ISO-8859-20\")) { return \"iso-8859-20\"; } else if (charset.equals(\"ISO-8859-21\")) { return \"iso-8859-21\"; } else if (charset.equals(\"ISO-8859-22\")) { return \"iso-8859-22\"; } else if (charset.equals(\"ISO-8859-23\")) { return \"iso-8859-23\"; } else if (charset.equals(\"ISO-8859-24\")) { return \"iso-8859-24\"; } else if (charset.equals(\"ISO-8859-25\")) { return \"iso-8859-25\"; } else if (charset.equals(\"ISO-8859-26\")) { return \"iso-8859-26\"; } else if (charset.equals(\"ISO-8859-27\")) { return \"iso-8859-27\"; } else if (charset.equals(\"ISO-8859-28\")) { return \"iso-8859-28\"; } else ", "private static String javaCharset(String charset){ if (charset == null) return null; if (charset.equals(\"UTF-8\")) return \"UTF-8\"; if (charset.equals(\"US-ASCII\")) return \"US-ASCII\"; if (charset.equals(\"ISO-8859-1\")) return \"ISO-8859-1\"; if (charset.equals(\"ISO-8859-2\")) return \"ISO-8859-2\"; if (charset.equals(\"ISO-8859-3\")) return \"ISO-8859-3\"; if (charset.equals(\"ISO-8859-4\")) return \"ISO-8859-4\"; if (charset.equals(\"ISO-8859-5\")) return \"ISO-8859-5\"; if (charset.equals(\"ISO-8859-6\")) return \"ISO-8859-6\"; if (charset.equals(\"ISO-8859-7\")) return \"ISO-8859-7\"; if (charset.equals(\"ISO-8859-8\")) return \"ISO-8859-8\"; if (charset.equals(\"ISO-8859-9\")) return \"ISO-8859-9\"; if (charset.equals(\"ISO-8859-10\")) return \"ISO-8859-10\"; if (charset.equals(\"ISO-8859-11\")) return \"ISO-8859-11\"; if (charset.equals(\"ISO-8859-12\")) return \"ISO-8859-12\"; if (charset.equals(\"ISO-8859-13\")) return \"ISO-8859-13\"; if (charset.equals(\"ISO-8859-14\")) return \"ISO-8859-14\"; if (charset.equals(\"ISO-8859-15\")) return \"ISO-8859-15\"; if (charset.equals(\"ISO-8859-16\")) return \"ISO-8859-16\"; if (charset.equals(\"ISO-8859-17\")) return \"ISO-8859-17\"; if (charset.equals(\"ISO-8859-18\")) return \"ISO-8859-18\"; if (charset.equals(\"ISO-8859-19\")) return \"ISO-8859-19\"; if (charset.equals(\"ISO-8859-20\")) return \"ISO-8859-20\"; if (charset.equals(\"ISO-8859-21\")) return \"ISO-8859-21\"; if (charset.equals(\"ISO-8859-22\")) return \"ISO-8859-22\"; if (charset.equals(\"ISO-8859-23\")) return \"ISO-8859-23\"; if (charset.equals(\"ISO-8859-24\")) return \"ISO-8859-24\"; if (charset.equals(\"ISO-8859-25\")) return \"ISO-8859-25\"; if (charset.equals(\"ISO-8859-26\")) return \"ISO-8859-26\"; if (charset.equals(\"ISO-8859-27\")) return \"ISO-8859-27\"; if (charset.equals(\"ISO-8859-28\")) return \"ISO-8859-28\"; if (charset.equals(\"ISO-8859-29\")) return \"ISO-8859-29\"; if (charset.equals(\"ISO-8859-30\")) return \"ISO-8859-30\"; if (charset.equals(\"ISO-8859-31\")", "private static String javaCharset(String charset){ if (charset == null) { return \"ISO-8859-1\"; } String charsetJava = charset.toUpperCase(Locale.ENGLISH); if (charsetJava.startsWith(\"ISO-8859-1\")) { return \"ISO-8859-1\"; } if (charsetJava.startsWith(\"US-ASCII\")) { return \"US-ASCII\"; } return charset; }", "private static String javaCharset(String charset){ if (charset.equals(\"ASCII\")) { return \"ISO-8859-1\"; } else if (charset.equals(\"UTF-8\")) { return \"UTF-8\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"ISO-8859-1\")) { return \"ISO-8859-1\"; } else if (charset.equals(\"ISO-8859-2\")) { return \"ISO-8859-2\"; } else if (charset.equals(\"ISO-8859-3\")) { return \"ISO-8859-3\"; } else if (charset.equals(\"ISO-8859-4\")) { return \"ISO-8859-4\"; } else if (charset.equals(\"ISO-8859-5\")) { return \"ISO-8859-5\"; } else if (charset.equals(\"ISO-8859-6\")) { return \"ISO-8859-6\"; } else if (charset.equals(\"ISO-8859-7\")) { return \"ISO-8859-7\"; } else if (charset.equals(\"ISO-8859-8\")) { return \"ISO-8859-8\"; } else if (charset.equals(\"ISO-8859-9\")) { return \"ISO-8859-9\"; } else if (charset.equals(\"ISO-8859-10\")) { return \"ISO-8859-10\"; } else if (charset.equals(\"ISO-8859-11\")) { return \"ISO-8859-11\"; } else if (charset.equals(\"ISO-8859-12\")) { return \"ISO-8859-12\"; } else if (charset.equals(\"ISO-8859-13\")) { return \"ISO-8859-13\"; } else if (charset.equals(\"ISO-8859-14\")) { return \"ISO-8859-14\"; } else if (charset.equals(\"ISO-8859-15\")) { return \"ISO-8859-15\"; } else if (charset.equals(\"ISO-8859-16\")) { return \"ISO-8859-16\"; } else if (charset.equals(\"ISO-8859-17\")) { return \"ISO-8859-17\"; } else if (charset.equals(\"ISO-8859-18\")) { return \"ISO-8859-18\"; } else if (charset.equals(\"ISO-8859-19\")) { return \"ISO-8859-19\"; } else if (charset.equals(\"ISO-8859-20\")) { return \"ISO-8859-20\"; } else if (charset.equals(\"ISO-8859-21\")) { return \"ISO-8859-21\"; } else if (charset.equals(\"ISO-8859-22\")) { return \"ISO-8859-22\"; } else if (charset.equals(\"ISO-8859-23\")) { return \"ISO-8859-23\"; } else if (charset.equals(\"ISO-8859-24\")) { return \"ISO-8859-24\"; "], "code_level": "class_runnable", "_id": "636766f01a6d9265ec01763e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> newRight = node.getLeft();\n  node.setLeft(newRight.getRight());\n  newRight.setRight(node);\n  newRight.setHeight(Math.max(height(newRight.getLeft()), height(newRight.getRight())) + 1);\n  newRight.setBalance(balance(node));\n  return newRight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> newNode = node.left;\n  node.left = newNode.right;\n  newNode.right = node;\n  return newNode;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> newRightNode = node.getRight();\n  node.setRight(newRightNode.getLeft());\n  newRightNode.setLeft(node);\n  newRightNode.setHeight(\n      Math.max(height(newRightNode.getLeft()), height(newRightNode.getRight())) + 1);\n  newRightNode.setBalanceFactor(balanceFactor(newRightNode));\n  return newRightNode;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> parent = node.getParent();\n  node.setParent(parent.getParent());\n  if (parent.getParent() != null) {\n    if (parent.getParent().getLeft() == parent) {\n      parent.getParent().setLeft(node);\n    } else {\n      parent.getParent().setRight(node);\n    }\n  }\n  parent.setParent(node);\n  node.setRight(parent);\n  parent.setRight(node);\n  return parent;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> left = node.getLeft();\n  node.setLeft(left.getRight());\n  left.setRight(node);\n  left.setHeight(Math.max(height(left.getLeft()), height(left.getRight())) + 1);\n  node.setHeight(Math.max(height(node.getLeft()), height(node.getRight())) + 1);\n  return left;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> right = node.left;\n  node.left = right.right;\n  right.right = node;\n  node.height = Math.max(height(node.left), height(node.right)) + 1;\n  right.height = Math.max(height(right.left), right.height) + 1;\n  return right;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> parent = node.parent;\n  TreeNode<T> leftChild = node.left;\n  node.left = leftChild.right;\n  leftChild.right = node;\n  node.parent = parent;\n  if (parent != null) {\n    if (parent.left == node) {\n      parent.left = leftChild;\n    } else {\n      parent.right = leftChild;\n    }\n  } else {\n    root = leftChild;\n  }\n  leftChild.parent = parent;\n  parent.left = leftChild;\n  leftChild.color = node.color;\n  node.color = Color.BLACK;\n  leftChild.height = 1 + Math.max(height(leftChild.left), height(leftChild.right));\n  leftChild.size = 1 + size(leftChild.left) + size(leftChild.right);\n  return parent;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  node.setLeft(rotateLeft(node.getLeft()));\n  return rotateRight(node);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> newRight = node.getLeft();\n  node.setLeft(newRight.getRight());\n  newRight.setRight(node);\n  newRight.setHeight(Math.max(getHeight(newRight.getLeft()), getHeight(newRight.getRight())) + 1);\n  return newRight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> newParent = node.parent;\n  if (newParent == null) {\n    return node;\n  }\n  TreeNode<T> newRight = newParent.right;\n  newParent.right = node;\n  node.parent = newParent;\n  node.right = newRight;\n  newRight.parent = node;\n  return newRight;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}\n */\n", "method_name": "rotateRight", "codes": ["private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> newRight = node.getLeft(); node.setLeft(newRight.getRight()); newRight.setRight(node); newRight.setHeight(Math.max(height(newRight.getLeft()), height(newRight.getRight())) + 1); newRight.setBalance(balance(node)); return newRight; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> newNode = node.left; node.left = newNode.right; newNode.right = node; return newNode; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> newRightNode = node.getRight(); node.setRight(newRightNode.getLeft()); newRightNode.setLeft(node); newRightNode.setHeight(Math.max(height(newRightNode.getLeft()), height(newRightNode.getRight())) + 1); newRightNode.setBalanceFactor(balanceFactor(newRightNode)); return newRightNode; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> parent = node.getParent(); node.setParent(parent.getParent()); if (parent.getParent() != null) { if (parent.getParent().getLeft() == parent) { parent.getParent().setLeft(node); } else { parent.getParent().setRight(node); } } parent.setParent(node); node.setRight(parent); parent.setRight(node); return parent; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> left = node.getLeft(); node.setLeft(left.getRight()); left.setRight(node); left.setHeight(Math.max(height(left.getLeft()), height(left.getRight())) + 1); node.setHeight(Math.max(height(node.getLeft()), height(node.getRight())) + 1); return left; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> right = node.left; node.left = right.right; right.right = node; node.height = Math.max(height(node.left), height(node.right)) + 1; right.height = Math.max(height(right.left), right.height) + 1; return right; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> parent = node.parent; TreeNode<T> leftChild = node.left; node.left = leftChild.right; leftChild.right = node; node.parent = parent; if (parent != null) { if (parent.left == node) { parent.left = leftChild; } else { parent.right = leftChild; } } else { root = leftChild; } leftChild.parent = parent; parent.left = leftChild; leftChild.color = node.color; node.color = Color.BLACK; leftChild.height = 1 + Math.max(height(leftChild.left), height(leftChild.right)); leftChild.size = 1 + size(leftChild.left) + size(leftChild.right); return parent; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ node.setLeft(rotateLeft(node.getLeft())); return rotateRight(node); }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> newRight = node.getLeft(); node.setLeft(newRight.getRight()); newRight.setRight(node); newRight.setHeight(Math.max(getHeight(newRight.getLeft()), getHeight(newRight.getRight())) + 1); return newRight; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> newParent = node.parent; if (newParent == null) { return node; } TreeNode<T> newRight = newParent.right; newParent.right = node; node.parent = newParent; node.right = newRight; newRight.parent = node; return newRight; }"], "code_level": "file_runnable", "_id": "636767441a6d9265ec017cc1", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  if (arr == null) {\n    return;\n  }\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V t = arr[i];\n  arr[i] = arr[j];\n  arr[j] = t;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Swaps the two elements at the specified indices in the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param i the index of the first element\n * @param j the index of the second element\n */\n", "method_name": "swap", "codes": ["public static final <V>void swap(V[] arr,int i,int j){ if (arr == null) { return; } V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }", "public static final <V>void swap(V[] arr,int i,int j){ V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }", "public static final <V>void swap(V[] arr,int i,int j){ V temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }", "public static final <V>void swap(V[] arr,int i,int j){ V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }", "public static final <V>void swap(V[] arr,int i,int j){ V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }", "public static final <V>void swap(V[] arr,int i,int j){ V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }", "public static final <V>void swap(V[] arr,int i,int j){ V temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }", "public static final <V>void swap(V[] arr,int i,int j){ V temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }", "public static final <V>void swap(V[] arr,int i,int j){ V t = arr[i]; arr[i] = arr[j]; arr[j] = t; }", "public static final <V>void swap(V[] arr,int i,int j){ V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }"], "code_level": "self_contained", "_id": "636767551a6d9265ec017f3f", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () -> \"\" + start;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () -> {\n    return IntStream.range(start, start + 1)\n        .mapToObj(i -> String.valueOf(i))\n        .collect(Collectors.joining());\n  };\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () ->\n      IntStream.range(start, start + 1).mapToObj(String::valueOf).collect(Collectors.joining());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return (Supplier<String>)\n      () -> {\n        StringBuilder sb = new StringBuilder(start);\n        for (int i = start; i < start + 10; i++) {\n          sb.append(i);\n        }\n        return sb.toString();\n      };\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () -> {\n    StringBuilder sb = new StringBuilder();\n    for (int i = start; i < start + 10; i++) {\n      sb.append(i);\n      sb.append(\" \");\n    }\n    return sb.toString();\n  };\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return (Supplier<String>)\n      () -> {\n        return String.valueOf(start);\n      };\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () ->\n      IntStream.rangeClosed(start, start + 1)\n          .mapToObj(String::valueOf)\n          .collect(Collectors.joining());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return (Supplier<String>) () -> \"\" + start;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () -> {\n    StringBuilder sb = new StringBuilder();\n    for (int i = start; i < start + 20; i++) {\n      sb.append(i);\n    }\n    return sb.toString();\n  };\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () ->\n      IntStream.rangeClosed(start, start + 1)\n          .mapToObj(String::valueOf)\n          .collect(Collectors.joining(\" \"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n", "method_name": "createStringSupplier", "codes": ["@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> \"\" + start; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> { return IntStream.range(start, start + 1).mapToObj(i -> String.valueOf(i)).collect(Collectors.joining()); }; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> IntStream.range(start, start + 1).mapToObj(String::valueOf).collect(Collectors.joining()); }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return (Supplier<String>) () -> { StringBuilder sb = new StringBuilder(start); for (int i = start; i < start + 10; i++) { sb.append(i); } return sb.toString(); }; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> { StringBuilder sb = new StringBuilder(); for (int i = start; i < start + 10; i++) { sb.append(i); sb.append(\" \"); } return sb.toString(); }; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return (Supplier<String>) () -> { return String.valueOf(start); }; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> IntStream.rangeClosed(start, start + 1).mapToObj(String::valueOf).collect(Collectors.joining()); }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return (Supplier<String>) () -> \"\" + start; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> { StringBuilder sb = new StringBuilder(); for (int i = start; i < start + 20; i++) { sb.append(i); } return sb.toString(); }; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> IntStream.rangeClosed(start, start + 1).mapToObj(String::valueOf).collect(Collectors.joining(\" \")); }"], "code_level": "slib_runnable", "_id": "6367675c1a6d9265ec018058", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return this.previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return (ListNode<E>) previousNode;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  ListNode<E> p = prev;\n  if (p == null) throw new NoSuchElementException();\n  prev = p.prev;\n  if (prev == null) tail = null;\n  else prev.next = null;\n  return p;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  if (this.previousNode == null) {\n    return null;\n  }\n  ListNode<E> result = this.previousNode;\n  this.previousNode = this.previousNode.previousNode;\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previousNode;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previousNode;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previousNode;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return this.previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previousNode;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * {@inheritDoc}\n */\n", "method_name": "previousNode", "codes": ["@Override public ListNode<E> previousNode(){ return previous; }", "@Override public ListNode<E> previousNode(){ return this.previous; }", "@Override public ListNode<E> previousNode(){ return (ListNode<E>) previousNode; }", "@Override public ListNode<E> previousNode(){ ListNode<E> p = prev; if (p == null) throw new NoSuchElementException(); prev = p.prev; if (prev == null) tail = null; else prev.next = null; return p; }", "@Override public ListNode<E> previousNode(){ if (this.previousNode == null) { return null; } ListNode<E> result = this.previousNode; this.previousNode = this.previousNode.previousNode; return result; }", "@Override public ListNode<E> previousNode(){ return previousNode; }", "@Override public ListNode<E> previousNode(){ return previousNode; }", "@Override public ListNode<E> previousNode(){ return previousNode; }", "@Override public ListNode<E> previousNode(){ return this.previous; }", "@Override public ListNode<E> previousNode(){ return previousNode; }"], "code_level": "class_runnable", "_id": "636767501a6d9265ec017e86", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static long factorial(int n) {\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n == 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n < 0) {\n    throw new IllegalArgumentException(\"n must be non-negative\");\n  }\n  if (n == 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n < 0) {\n    return -1;\n  }\n  long factorial = 1;\n  for (int i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  long fact = 1;\n  for (int i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n < 0) {\n    throw new IllegalArgumentException(\"n must be >= 0\");\n  }\n  long result = 1;\n  for (int i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n <= 1) return 1;\n  else return n * factorial(n - 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Calculate the factorial of $n$.\n * @param n the input number\n * @return the factorial\n */\n", "method_name": "factorial", "codes": ["public static long factorial(int n){ if (n == 0) { return 1; } else { return n * factorial(n - 1); } }", "public static long factorial(int n){ if (n <= 1) { return 1; } else { return n * factorial(n - 1); } }", "public static long factorial(int n){ if (n == 0) { return 1; } return n * factorial(n - 1); }", "public static long factorial(int n){ if (n <= 1) { return 1; } return n * factorial(n - 1); }", "public static long factorial(int n){ if (n < 0) { throw new IllegalArgumentException(\"n must be non-negative\"); } if (n == 0) { return 1; } return n * factorial(n - 1); }", "public static long factorial(int n){ if (n < 0) { return -1; } long factorial = 1; for (int i = 1; i <= n; i++) { factorial *= i; } return factorial; }", "public static long factorial(int n){ if (n == 0) { return 1; } else { return n * factorial(n - 1); } }", "public static long factorial(int n){ long fact = 1; for (int i = 1; i <= n; i++) { fact *= i; } return fact; }", "public static long factorial(int n){ if (n < 0) { throw new IllegalArgumentException(\"n must be >= 0\"); } long result = 1; for (int i = 1; i <= n; i++) { result *= i; } return result; }", "public static long factorial(int n){ if (n <= 1) return 1; else return n * factorial(n - 1); }"], "code_level": "self_contained", "_id": "636767581a6d9265ec017fc4", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == null) {\n    return false;\n  }\n  if (node.next == null) {\n    next = null;\n    prev = null;\n  } else {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n  size--;\n  modCount++;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  final ListNodeImpl<E> next = node.next;\n  final ListNodeImpl<E> prev = node.prev;\n  if (next == null) {\n    if (prev == null) {\n      first = null;\n    } else {\n      prev.next = null;\n      last = prev;\n    }\n  } else {\n    if (prev == null) {\n      first = next;\n    } else {\n      prev.next = next;\n      next.prev = prev;\n    }\n  }\n  node.prev = null;\n  node.next = null;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == null) {\n    return false;\n  }\n  ListNodeImpl<E> next = node.next;\n  if (next == null) {\n    prev = next;\n  } else {\n    next.prev = prev;\n  }\n  if (prev == null) {\n    first = next;\n  } else {\n    prev.next = next;\n  }\n  size--;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  ListNodeImpl<E> next = node.next;\n  node.next = null;\n  node.previous = null;\n  if (next == null) {\n    head = null;\n    tail = null;\n  } else {\n    next.previous = null;\n    node.previous = null;\n  }\n  size--;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  ListNodeImpl<E> prev = node.prev;\n  ListNodeImpl<E> next = node.next;\n  if (prev == null && next == null) {\n    head = null;\n    tail = null;\n    size = 0;\n    modCount++;\n    return true;\n  }\n  if (prev != null) {\n    prev.next = next;\n  }\n  if (next != null) {\n    next.prev = prev;\n  }\n  if (node == head) {\n    head = next;\n  }\n  if (node == tail) {\n    tail = prev;\n  }\n  size--;\n  modCount++;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  ListNodeImpl<E> prev = node.prev;\n  ListNodeImpl<E> next = node.next;\n  if (prev == null && next == null) {\n    first = null;\n    last = null;\n  } else if (prev != null) {\n    prev.next = next;\n  } else {\n    next.prev = prev;\n  }\n  size--;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  ListNodeImpl<E> prev = node.prev;\n  ListNodeImpl<E> next = node.next;\n  if (prev == null) {\n    first = next;\n  } else {\n    prev.next = next;\n    node.prev = null;\n  }\n  if (next == null) {\n    last = prev;\n  } else {\n    next.prev = prev;\n    node.next = null;\n  }\n  node.node = null;\n  node.next = null;\n  size--;\n  modCount++;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  node.previous.next = node.next;\n  node.next.previous = node.previous;\n  node.next = null;\n  node.previous = null;\n  size--;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == null) {\n    throw new NullPointerException();\n  }\n  if (node.prev == null) {\n    if (node.next != null) {\n      node.next.prev = null;\n    } else {\n      head = node.next;\n    }\n  } else {\n    node.prev.next = node.next;\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    } else {\n      head = node.prev;\n    }\n  }\n  node.prev = null;\n  node.next = null;\n  size--;\n  modCount++;\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  ListNodeImpl<E> prev = node.prev;\n  ListNodeImpl<E> next = node.next;\n  prev.next = next;\n  next.prev = prev;\n  size--;\n  return node == head;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Remove the non null  {@code node} from the list. \n */\n", "method_name": "unlink", "codes": ["private boolean unlink(ListNodeImpl<E> node){ if (node == null) { return false; } if (node.next == null) { next = null; prev = null; } else { node.prev.next = node.next; node.next.prev = node.prev; } size--; modCount++; return true; }", "private boolean unlink(ListNodeImpl<E> node){ final ListNodeImpl<E> next = node.next; final ListNodeImpl<E> prev = node.prev; if (next == null) { if (prev == null) { first = null; } else { prev.next = null; last = prev; } } else { if (prev == null) { first = next; } else { prev.next = next; next.prev = prev; } } node.prev = null; node.next = null; return true; }", "private boolean unlink(ListNodeImpl<E> node){ if (node == null) { return false; } ListNodeImpl<E> next = node.next; if (next == null) { prev = next; } else { next.prev = prev; } if (prev == null) { first = next; } else { prev.next = next; } size--; return true; }", "private boolean unlink(ListNodeImpl<E> node){ ListNodeImpl<E> next = node.next; node.next = null; node.previous = null; if (next == null) { head = null; tail = null; } else { next.previous = null; node.previous = null; } size--; return true; }", "private boolean unlink(ListNodeImpl<E> node){ ListNodeImpl<E> prev = node.prev; ListNodeImpl<E> next = node.next; if (prev == null && next == null) { head = null; tail = null; size = 0; modCount++; return true; } if (prev != null) { prev.next = next; } if (next != null) { next.prev = prev; } if (node == head) { head = next; } if (node == tail) { tail = prev; } size--; modCount++; return true; }", "private boolean unlink(ListNodeImpl<E> node){ ListNodeImpl<E> prev = node.prev; ListNodeImpl<E> next = node.next; if (prev == null && next == null) { first = null; last = null; } else if (prev != null) { prev.next = next; } else { next.prev = prev; } size--; return true; }", "private boolean unlink(ListNodeImpl<E> node){ ListNodeImpl<E> prev = node.prev; ListNodeImpl<E> next = node.next; if (prev == null) { first = next; } else { prev.next = next; node.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; node.next = null; } node.node = null; node.next = null; size--; modCount++; return true; }", "private boolean unlink(ListNodeImpl<E> node){ node.previous.next = node.next; node.next.previous = node.previous; node.next = null; node.previous = null; size--; return true; }", "private boolean unlink(ListNodeImpl<E> node){ if (node == null) { throw new NullPointerException(); } if (node.prev == null) { if (node.next != null) { node.next.prev = null; } else { head = node.next; } } else { node.prev.next = node.next; if (node.next != null) { node.next.prev = node.prev; } else { head = node.prev; } } node.prev = null; node.next = null; size--; modCount++; return true; }", "private boolean unlink(ListNodeImpl<E> node){ ListNodeImpl<E> prev = node.prev; ListNodeImpl<E> next = node.next; prev.next = next; next.prev = prev; size--; return node == head; }"], "code_level": "class_runnable", "_id": "636767631a6d9265ec018171", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  for (int i = from; i < to; i++) {\n    swap(arr, i, to - i);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  for (int i = from, j = to - 1; i < j; i++, j--) {\n    swap(arr, i, j);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (arr == null) {\n    throw new IllegalArgumentException(\"Array must not be null\");\n  }\n  if (from > to) {\n    throw new IllegalArgumentException(\"from > to\");\n  }\n  for (int i = from; i < to; i++) {\n    Object tmp = arr[i];\n    arr[i] = arr[to - i];\n    arr[to - i] = tmp;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (from >= to) {\n    return;\n  }\n  int i = from;\n  int j = to;\n  while (i < j) {\n    V tmp = arr[i];\n    arr[i++] = arr[j];\n    arr[j--] = tmp;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  int n = to - from;\n  if (n <= 1) return;\n  for (int i = from; i < to - n; i++) {\n    swap(arr, i, from + n - 1 - i);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (from < 0 || to > arr.length || from > to)\n    throw new ArrayIndexOutOfBoundsException(\"from=\" + from + \", to=\" + to);\n  for (int i = from, j = to - 1; i < j; i++, j--) swap(arr, i, j);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  int len = to - from;\n  for (int i = from; i < to - len; i++) {\n    arr[i] = arr[to - len + i];\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (from >= to) return;\n  for (int i = from, j = to; i < j; i++, j--) swap(arr, i, j);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  for (int i = from; i < to; i++) {\n    V tmp = arr[i];\n    arr[i] = arr[to - i];\n    arr[to - i] = tmp;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (from >= to) {\n    return;\n  }\n  int n = to - from;\n  int m = from + n / 2;\n  for (int i = from, j = m; i < j; i++, j--) {\n    V t = arr[i];\n    arr[i] = arr[j];\n    arr[j] = t;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Reverses the order of the elements in the specified range within the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param from the index of the first element (inclusive) inside the range to reverse\n * @param to the index of the last element (inclusive) inside the range to reverse\n */\n", "method_name": "reverse", "codes": ["public static final <V>void reverse(V[] arr,int from,int to){ for (int i = from; i < to; i++) { swap(arr, i, to - i); } }", "public static final <V>void reverse(V[] arr,int from,int to){ for (int i = from, j = to - 1; i < j; i++, j--) { swap(arr, i, j); } }", "public static final <V>void reverse(V[] arr,int from,int to){ if (arr == null) { throw new IllegalArgumentException(\"Array must not be null\"); } if (from > to) { throw new IllegalArgumentException(\"from > to\"); } for (int i = from; i < to; i++) { Object tmp = arr[i]; arr[i] = arr[to - i]; arr[to - i] = tmp; } }", "public static final <V>void reverse(V[] arr,int from,int to){ if (from >= to) { return; } int i = from; int j = to; while (i < j) { V tmp = arr[i]; arr[i++] = arr[j]; arr[j--] = tmp; } }", "public static final <V>void reverse(V[] arr,int from,int to){ int n = to - from; if (n <= 1) return; for (int i = from; i < to - n; i++) { swap(arr, i, from + n - 1 - i); } }", "public static final <V>void reverse(V[] arr,int from,int to){ if (from < 0 || to > arr.length || from > to) throw new ArrayIndexOutOfBoundsException(\"from=\" + from + \", to=\" + to); for (int i = from, j = to - 1; i < j; i++, j--) swap(arr, i, j); }", "public static final <V>void reverse(V[] arr,int from,int to){ int len = to - from; for (int i = from; i < to - len; i++) { arr[i] = arr[to - len + i]; } }", "public static final <V>void reverse(V[] arr,int from,int to){ if (from >= to) return; for (int i = from, j = to; i < j; i++, j--) swap(arr, i, j); }", "public static final <V>void reverse(V[] arr,int from,int to){ for (int i = from; i < to; i++) { V tmp = arr[i]; arr[i] = arr[to - i]; arr[to - i] = tmp; } }", "public static final <V>void reverse(V[] arr,int from,int to){ if (from >= to) { return; } int n = to - from; int m = from + n / 2; for (int i = from, j = m; i < j; i++, j--) { V t = arr[i]; arr[i] = arr[j]; arr[j] = t; } }"], "code_level": "class_runnable", "_id": "636767491a6d9265ec017d90", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  for (ListNode<E> node : list.getListNodes()) {\n    if (node != null) {\n      moveListNode(node);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  int i = 0;\n  while (i < list.size()) {\n    ListNodeImpl node = list.getListNode(i);\n    if (node != null) {\n      moveListNode(node);\n      i++;\n    } else {\n      i++;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  ListNode<E> current = list.getHead();\n  while (current != null) {\n    moveListNode(current);\n    current = current.getNext();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  for (ListNode<E> node : list) {\n    moveListNode(node);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  if (list == null) return;\n  ListNode<E> listNode = list.head;\n  while (listNode != null) {\n    removeListNode(listNode);\n    listNode = listNode.next;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  for (ListNodeImpl<E> node : list.getListNodes()) {\n    if (node.getNext() == null) {\n      removeListNode(node);\n    } else if (node.getNext() != null) {\n      addListNode(node);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  ListNode<E> first = list.getFirst();\n  ListNode<E> last = list.getLast();\n  while (first != last) {\n    moveListNode(first, last);\n    first = first.getNext();\n    last = last.getPrev();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  for (ListNode<E> node : list.getNodes()) {\n    moveListNode(node);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  if (list.isEmpty()) {\n    return;\n  }\n  Iterator<E> it = list.iterator();\n  while (it.hasNext()) {\n    E e = it.next();\n    if (e != null) {\n      if (!removeListNode(e)) {\n        it.remove();\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  for (ListNode<E> listNode : list.getListNodes()) {\n    moveListNode(listNode);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.\n */\n", "method_name": "moveAllListNodes", "codes": ["private void moveAllListNodes(DoublyLinkedList<E> list){ for (ListNode<E> node : list.getListNodes()) { if (node != null) { moveListNode(node); } } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ int i = 0; while (i < list.size()) { ListNodeImpl node = list.getListNode(i); if (node != null) { moveListNode(node); i++; } else { i++; } } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ ListNode<E> current = list.getHead(); while (current != null) { moveListNode(current); current = current.getNext(); } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ for (ListNode<E> node : list) { moveListNode(node); } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ if (list == null) return; ListNode<E> listNode = list.head; while (listNode != null) { removeListNode(listNode); listNode = listNode.next; } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ for (ListNodeImpl<E> node : list.getListNodes()) { if (node.getNext() == null) { removeListNode(node); } else if (node.getNext() != null) { addListNode(node); } } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ ListNode<E> first = list.getFirst(); ListNode<E> last = list.getLast(); while (first != last) { moveListNode(first, last); first = first.getNext(); last = last.getPrev(); } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ for (ListNode<E> node : list.getNodes()) { moveListNode(node); } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ if (list.isEmpty()) { return; } Iterator<E> it = list.iterator(); while (it.hasNext()) { E e = it.next(); if (e != null) { if (!removeListNode(e)) { it.remove(); } } } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ for (ListNode<E> listNode : list.getListNodes()) { moveListNode(listNode); } }"], "code_level": "class_runnable", "_id": "6367674a1a6d9265ec017da9", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IdentityIsomorphicGraphMapping<>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IdentityIsomorphicGraphMapping<>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>() {\n    @Override\n    public <V2 extends V> void putVertex(V2 v, E e) {\n      graph.putVertex(v, e);\n    }\n\n    @Override\n    public <V2 extends V> void putEdge(V2 v, E e) {\n      graph.putEdge(v, e);\n    }\n\n    @Override\n    public <V2 extends V> boolean containsVertex(V2 v) {\n      return graph.containsVertex(v);\n    }\n\n    @Override\n    public <V2 extends V> boolean containsEdge(V2 v, E e) {\n      return graph.containsEdge(v, e);\n    }\n\n    @Override\n    public <V2 extends V> IsomorphicGraphMapping<V2, E> reverse() {\n      return this;\n    }\n\n    @Override\n    public <V2 extends V> IsomorphicGraphMapping<V2, E> reverse(\n        IsomorphicGraphMapping<V2, E> reversed) {\n      return reversed;\n    }\n\n    @Override\n    public <V2 extends V> IsomorphicGraphMapping<V2, E> reverse(\n        IsomorphicGraphMapping<V2, E> reversed, boolean reversedReverse) {\n      return reversed;\n    }\n\n    @Override\n    public <V2 extends V> IsomorphicGraphMapping<V2, E> reverse(\n        IsomorphicGraphMapping<V2, E> reversed,\n        boolean reversedReverse,\n        boolean reversedReversed) {\n      return reversed;\n    }\n\n    @Override\n    public <V2 extends V> IsomorphicGraphMapping<V2, E> reverse(\n        IsomorphicGraphMapping<V2, E> reversed,\n        boolean reversedReverse,\n        boolean reversedReversed,\n        boolean reversedReversed) {\n      return reversed;\n    }\n  };\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>() {\n    @Override\n    public void map(V from, V to) {\n      graph.addVertex(from);\n      graph.addVertex(to);\n    }\n\n    @Override\n    public void map(E from, E to) {\n      graph.addEdge(from, to);\n    }\n  };\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new Identity<>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<>(graph, new HashMap<>());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).\n * @param graph the input graph\n * @param < V > the graph vertex type\n * @param < E > the graph edge type\n * @return a mapping from graph to graph\n */\n", "method_name": "identity", "codes": ["public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IdentityIsomorphicGraphMapping<>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IdentityIsomorphicGraphMapping<>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>() { @Override public <V2 extends V> void putVertex(V2 v, E e) { graph.putVertex(v, e); } @Override public <V2 extends V> void putEdge(V2 v, E e) { graph.putEdge(v, e); } @Override public <V2 extends V> boolean containsVertex(V2 v) { return graph.containsVertex(v); } @Override public <V2 extends V> boolean containsEdge(V2 v, E e) { return graph.containsEdge(v, e); } @Override public <V2 extends V> IsomorphicGraphMapping<V2, E> reverse() { return this; } @Override public <V2 extends V> IsomorphicGraphMapping<V2, E> reverse(IsomorphicGraphMapping<V2, E> reversed) { return reversed; } @Override public <V2 extends V> IsomorphicGraphMapping<V2, E> reverse(IsomorphicGraphMapping<V2, E> reversed, boolean reversedReverse) { return reversed; } @Override public <V2 extends V> IsomorphicGraphMapping<V2, E> reverse(IsomorphicGraphMapping<V2, E> reversed, boolean reversedReverse, boolean reversedReversed) { return reversed; } @Override public <V2 extends V> IsomorphicGraphMapping<V2, E> reverse(IsomorphicGraphMapping<V2, E> reversed, boolean reversedReverse, boolean reversedReversed, boolean reversedReversed) { return reversed; } }; }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>() { @Override public void map(V from, V to) { graph.addVertex(from); graph.addVertex(to); } @Override public void map(E from, E to) { graph.addEdge(from, to); } }; }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new Identity<>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<>(graph, new HashMap<>()); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>(graph); }"], "code_level": "project_runnable", "_id": "6367675f1a6d9265ec0180d3", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (target == null) {\n    throw new NullPointerException(\"target\");\n  }\n  if (resultMap == null) {\n    throw new NullPointerException(\"resultMap\");\n  }\n  if (this.graph == null) {\n    this.graph = new Graph<>(target);\n  }\n  for (String vertexId : resultMap.keySet()) {\n    Vertex<V, E> vertex = target.getVertex(vertexId);\n    if (vertex == null) {\n      throw new IllegalArgumentException(\"target vertex \" + vertexId + \" not found in graph\");\n    }\n    if (!vertex.isVertex()) {\n      throw new IllegalArgumentException(\"target vertex \" + vertexId + \" is not a vertex\");\n    }\n    if (!resultMap.get(vertexId).equals(vertex.getValue())) {\n      throw new IllegalArgumentException(\n          \"target vertex \"\n              + vertexId\n              + \" has different value for vertex \"\n              + vertex.getValue()\n              + \" and \"\n              + resultMap.get(vertexId));\n    }\n  }\n  for (V vertex : resultMap.values()) {\n    this.graph.addVertex(vertex);\n  }\n  for (E edge : resultMap.values()) {\n    this.graph.addEdge(edge);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  Graph<V, E> graph = new Graph<V, E>(target);\n  V source;\n  V target;\n  for (String key : resultMap.keySet()) {\n    source = resultMap.get(key);\n    target = resultMap.get(key);\n    graph.addVertex(source);\n    graph.addVertex(target);\n    graph.addEdge(source, target);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (!target.getVertices().isEmpty()) {\n    target\n        .getVertices()\n        .forEach(\n            v -> {\n              v.setColor(Color.WHITE);\n              v.setParent(null);\n            });\n  }\n  if (!target.getEdges().isEmpty()) {\n    target\n        .getEdges()\n        .forEach(\n            e -> {\n              e.setColor(Color.WHITE);\n              e.setParent(null);\n            });\n  }\n  if (!target.getAdjacencyList().isEmpty()) {\n    target\n        .getAdjacencyList()\n        .forEach(\n            a -> {\n              a.setColor(Color.WHITE);\n              a.setParent(null);\n            });\n  }\n  if (!target.getEdges().isEmpty()) {\n    target\n        .getEdges()\n        .forEach(\n            e -> {\n              e.setColor(Color.WHITE);\n              e.setParent(null);\n            });\n  }\n  if (!target.getAdjacencyList().isEmpty()) {\n    target\n        .getAdjacencyList()\n        .forEach(\n            a -> {\n              a.setColor(Color.WHITE);\n              a.setParent(null);\n            });\n  }\n  for (V v : target.getVertices()) {\n    v.setColor(Color.BLACK);\n  }\n  for (E e : target.getEdges()) {\n    e.setColor(Color.BLACK);\n  }\n  for (E e : target.getAdjacencyList()) {\n    e.setColor(Color.BLACK);\n  }\n  for (V v : target.getVertices()) {\n    v.setColor(Color.WHITE);\n  }\n  for (E e : target.getEdges()) {\n    e.setColor(Color.WHITE);\n  }\n  for (E e : target.getAdjacencyList()) {\n    e.setColor(Color.WHITE);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (target == null) return;\n  this.graph = new Graph<V, E>(target, resultMap);\n  this.generateGraph(this.graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (resultMap == null) {\n    throw new IllegalArgumentException(\"resultMap cannot be null\");\n  }\n  if (target == null) {\n    throw new IllegalArgumentException(\"target cannot be null\");\n  }\n  if (!target.isDirected()) {\n    throw new IllegalArgumentException(\"target is not directed\");\n  }\n  if (resultMap.size() <= 0) {\n    return;\n  }\n  Map<String, V> map = new HashMap<>(resultMap);\n  for (V v : map.values()) {\n    if (v == null) {\n      throw new IllegalArgumentException(\"v cannot be null\");\n    }\n  }\n  for (V v : map.values()) {\n    if (v == null) {\n      throw new IllegalArgumentException(\"v cannot be null\");\n    }\n  }\n  if (target.vertexSet().containsAll(resultMap.values())) {\n    throw new IllegalArgumentException(\"target cannot contain all vertex\");\n  }\n  if (target.edgeSet().containsAll(resultMap.values())) {\n    throw new IllegalArgumentException(\"target cannot contain all edge\");\n  }\n  if (target.vertexSet().size() != resultMap.size()) {\n    throw new IllegalArgumentException(\"target and result map have different number of vertices\");\n  }\n  if (target.edgeSet().size() != resultMap.size()) {\n    throw new IllegalArgumentException(\"target and result map have different number of edges\");\n  }\n  Set<V> vertices = new HashSet<>(resultMap.values());\n  Set<E> edges = new HashSet<>(resultMap.values());\n  vertices.removeAll(map.values());\n  edges.removeAll(map.values());\n  vertices.removeAll(target.vertexSet());\n  edges.removeAll(target.edgeSet());\n  if (vertices.size() > 0) {\n    throw new IllegalArgumentException(\"target and result map have different number of vertices\");\n  }\n  if (edges.size() > 0) {\n    throw new IllegalArgumentException(\"target and result map have different number of edges\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  Map<V, Set<V>> vertices = new HashMap<>();\n  Map<V, Set<V>> edges = new HashMap<>();\n  Graph<V, E> graph = new DirectedSparseMultigraph<>(Edge.class);\n  for (V v : resultMap.keySet()) {\n    V targetVertex = vertices.get(v);\n    if (targetVertex == null) {\n      targetVertex = v;\n      vertices.put(v, new HashSet<>());\n    }\n    vertices.get(v).add(targetVertex);\n  }\n  for (V v : resultMap.keySet()) {\n    V targetVertex = vertices.get(v);\n    for (V u : resultMap.get(v).keySet()) {\n      V sourceVertex = vertices.get(u);\n      if (sourceVertex.equals(targetVertex)) {\n        continue;\n      }\n      edges.put(sourceVertex, new HashSet<>());\n      edges.get(sourceVertex).add(targetVertex);\n      edges.put(targetVertex, new HashSet<>());\n      edges.get(targetVertex).add(sourceVertex);\n    }\n  }\n  graph.addVertices(vertices.keySet());\n  graph.addEdges(edges.keySet());\n  target.addGraph(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  for (String nodeName : resultMap.keySet()) {\n    V node = resultMap.get(nodeName);\n    target.addVertex(node);\n  }\n  for (V v : target.vertexSet()) {\n    for (E edge : target.outgoingEdgesOf(v)) {\n      V targetVertex = target.getEdgeTarget(edge);\n      if (!resultMap.containsKey(targetVertex.getName())) {\n        generateGraph(target, resultMap);\n      }\n      target.addEdge(v, targetVertex);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (!(target instanceof UndirectedGraph)) {\n    throw new IllegalArgumentException(\"Graph must be a undirected graph\");\n  }\n  UndirectedGraph<V, E> graph = (UndirectedGraph<V, E>) target;\n  if (!graph.isDirected()) {\n    throw new IllegalArgumentException(\"Graph must be directed\");\n  }\n  String source = null;\n  String dest = null;\n  V sourceV = null;\n  V destV = null;\n  for (Map.Entry<String, V> entry : resultMap.entrySet()) {\n    source = entry.getKey();\n    sourceV = entry.getValue();\n    if (source.equals(dest)) {\n      throw new IllegalArgumentException(\"Source and destination must be different\");\n    }\n    dest = source;\n    destV = resultMap.get(dest);\n    if (destV == null) {\n      throw new IllegalArgumentException(\"Destination vertex '\" + dest + \"' does not exist\");\n    }\n    if (!(graph.getEdge(sourceV, destV) instanceof DirectedEdge)) {\n      throw new IllegalArgumentException(\n          \"Source and destination vertex '\" + source + \"' does not have a directed edge\");\n    }\n    DirectedEdge<V, E> directedEdge = (DirectedEdge<V, E>) graph.getEdge(sourceV, destV);\n    if (directedEdge == null) {\n      throw new IllegalArgumentException(\n          \"Source and destination vertex '\" + source + \"' does not have a directed edge\");\n    }\n    graph.addEdge(sourceV, destV, directedEdge);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (!isInitialized()) {\n    return;\n  }\n  this.target = target;\n  this.resultMap = resultMap;\n  this.graph = new SimpleDirectedWeightedGraph<>(new DefaultWeightedEdgeFactory());\n  this.vertices = new HashSet<>();\n  this.edges = new HashSet<>();\n  this.vertices.addAll(resultMap.keySet());\n  this.edges.addAll(resultMap.values());\n  for (String key : this.vertices) {\n    graph.addVertex(resultMap.get(key));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (graph == null) {\n    throw new IllegalArgumentException(\"The graph must be set before calling generateGraph.\");\n  }\n  if (target == null) {\n    throw new IllegalArgumentException(\n        \"The target graph must be set before calling generateGraph.\");\n  }\n  if (resultMap == null) {\n    throw new IllegalArgumentException(\n        \"The result map must be set before calling generateGraph.\");\n  }\n  if (!graph.getVertices().containsAll(target.getVertices())) {\n    throw new IllegalArgumentException(\n        \"The target graph does not contain all the source graphs.\");\n  }\n  if (!graph.getEdges().containsAll(target.getEdges())) {\n    throw new IllegalArgumentException(\"The target graph does not contain all the source edges.\");\n  }\n  if (!graph.getVertices().containsAll(resultMap.keySet())) {\n    throw new IllegalArgumentException(\n        \"The source graph does not contain all the result map keys.\");\n  }\n  if (!graph.getEdges().containsAll(resultMap.values())) {\n    throw new IllegalArgumentException(\n        \"The source graph does not contain all the result map values.\");\n  }\n  if (!graph.getVertices().containsAll(resultMap.keySet())) {\n    throw new IllegalArgumentException(\n        \"The target graph does not contain all the result map keys.\");\n  }\n  if (!graph.getEdges().containsAll(resultMap.values())) {\n    throw new IllegalArgumentException(\n        \"The target graph does not contain all the result map values.\");\n  }\n  if (!graph.getVertices().containsAll(resultMap.keySet())) {\n    throw new IllegalArgumentException(\n        \"The source graph does not contain all the result map keys.\");\n  }\n  if (!graph.getEdges().containsAll(resultMap.values())) {\n    throw new IllegalArgumentException(\n        \"The source graph does not contain all the result map values.\");\n  }\n  if (!graph.getVertices().containsAll(resultMap.keySet())) {\n    throw new IllegalArgumentException(\n        \"The target graph does not contain all the result map keys.\");\n  }\n  if (!graph.getEdges().containsAll(resultMap.values())) {\n    throw new IllegalArgumentException(\n        \"The target graph does not contain all the result map values.\");\n  }\n  if (!graph.getVertices().containsAll(resultMap.keySet())) {\n    throw new IllegalArgumentException(\n        \"The source graph does not contain all the result map keys.\");\n  }\n  if (!graph.getEdges().containsAll(resultMap.values())) {\n    throw new IllegalArgumentException(\n        \"The source graph does not contain all the result map values.\");\n  }\n  if (!graph.getVertices().containsAll(resultMap.keySet())) {\n    throw new IllegalArgumentException(\n        \"The target graph does not contain all the result map keys.\");\n  }\n  if (!graph.getEdges().containsAll(resultMap.values())) {\n    throw new IllegalArgumentException(\n        \"The target graph does not contain all the result map values.\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Construct a complete bipartite graph\n */\n", "method_name": "generateGraph", "codes": ["@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (target == null) { throw new NullPointerException(\"target\"); } if (resultMap == null) { throw new NullPointerException(\"resultMap\"); } if (this.graph == null) { this.graph = new Graph<>(target); } for (String vertexId : resultMap.keySet()) { Vertex<V, E> vertex = target.getVertex(vertexId); if (vertex == null) { throw new IllegalArgumentException(\"target vertex \" + vertexId + \" not found in graph\"); } if (!vertex.isVertex()) { throw new IllegalArgumentException(\"target vertex \" + vertexId + \" is not a vertex\"); } if (!resultMap.get(vertexId).equals(vertex.getValue())) { throw new IllegalArgumentException(\"target vertex \" + vertexId + \" has different value for vertex \" + vertex.getValue() + \" and \" + resultMap.get(vertexId)); } } for (V vertex : resultMap.values()) { this.graph.addVertex(vertex); } for (E edge : resultMap.values()) { this.graph.addEdge(edge); } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ Graph<V,E> graph = new Graph<V, E>(target); V source; V target; for (String key : resultMap.keySet()) { source = resultMap.get(key); target = resultMap.get(key); graph.addVertex(source); graph.addVertex(target); graph.addEdge(source, target); } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (!target.getVertices().isEmpty()) { target.getVertices().forEach(v -> { v.setColor(Color.WHITE); v.setParent(null); }); } if (!target.getEdges().isEmpty()) { target.getEdges().forEach(e -> { e.setColor(Color.WHITE); e.setParent(null); }); } if (!target.getAdjacencyList().isEmpty()) { target.getAdjacencyList().forEach(a -> { a.setColor(Color.WHITE); a.setParent(null); }); } if (!target.getEdges().isEmpty()) { target.getEdges().forEach(e -> { e.setColor(Color.WHITE); e.setParent(null); }); } if (!target.getAdjacencyList().isEmpty()) { target.getAdjacencyList().forEach(a -> { a.setColor(Color.WHITE); a.setParent(null); }); } for (V v : target.getVertices()) { v.setColor(Color.BLACK); } for (E e : target.getEdges()) { e.setColor(Color.BLACK); } for (E e : target.getAdjacencyList()) { e.setColor(Color.BLACK); } for (V v : target.getVertices()) { v.setColor(Color.WHITE); } for (E e : target.getEdges()) { e.setColor(Color.WHITE); } for (E e : target.getAdjacencyList()) { e.setColor(Color.WHITE); } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (target == null) return; this.graph = new Graph<V,E>(target, resultMap); this.generateGraph(this.graph); }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (resultMap == null) { throw new IllegalArgumentException(\"resultMap cannot be null\"); } if (target == null) { throw new IllegalArgumentException(\"target cannot be null\"); } if (!target.isDirected()) { throw new IllegalArgumentException(\"target is not directed\"); } if (resultMap.size() <= 0) { return; } Map<String, V> map = new HashMap<>(resultMap); for (V v : map.values()) { if (v == null) { throw new IllegalArgumentException(\"v cannot be null\"); } } for (V v : map.values()) { if (v == null) { throw new IllegalArgumentException(\"v cannot be null\"); } } if (target.vertexSet().containsAll(resultMap.values())) { throw new IllegalArgumentException(\"target cannot contain all vertex\"); } if (target.edgeSet().containsAll(resultMap.values())) { throw new IllegalArgumentException(\"target cannot contain all edge\"); } if (target.vertexSet().size() != resultMap.size()) { throw new IllegalArgumentException(\"target and result map have different number of vertices\"); } if (target.edgeSet().size() != resultMap.size()) { throw new IllegalArgumentException(\"target and result map have different number of edges\"); } Set<V> vertices = new HashSet<>(resultMap.values()); Set<E> edges = new HashSet<>(resultMap.values()); vertices.removeAll(map.values()); edges.removeAll(map.values()); vertices.removeAll(target.vertexSet()); edges.removeAll(target.edgeSet()); if (vertices.size() > 0) { throw new IllegalArgumentException(\"target and result map have different number of vertices\"); } if (edges.size() > 0) { throw new IllegalArgumentException(\"target and result map have different number of edges\"); } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ Map<V, Set<V>> vertices = new HashMap<>(); Map<V, Set<V>> edges = new HashMap<>(); Graph<V, E> graph = new DirectedSparseMultigraph<>(Edge.class); for (V v : resultMap.keySet()) { V targetVertex = vertices.get(v); if (targetVertex == null) { targetVertex = v; vertices.put(v, new HashSet<>()); } vertices.get(v).add(targetVertex); } for (V v : resultMap.keySet()) { V targetVertex = vertices.get(v); for (V u : resultMap.get(v).keySet()) { V sourceVertex = vertices.get(u); if (sourceVertex.equals(targetVertex)) { continue; } edges.put(sourceVertex, new HashSet<>()); edges.get(sourceVertex).add(targetVertex); edges.put(targetVertex, new HashSet<>()); edges.get(targetVertex).add(sourceVertex); } } graph.addVertices(vertices.keySet()); graph.addEdges(edges.keySet()); target.addGraph(graph); }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ for (String nodeName : resultMap.keySet()) { V node = resultMap.get(nodeName); target.addVertex(node); } for (V v : target.vertexSet()) { for (E edge : target.outgoingEdgesOf(v)) { V targetVertex = target.getEdgeTarget(edge); if (!resultMap.containsKey(targetVertex.getName())) { generateGraph(target, resultMap); } target.addEdge(v, targetVertex); } } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (!(target instanceof UndirectedGraph)) { throw new IllegalArgumentException(\"Graph must be a undirected graph\"); } UndirectedGraph<V,E> graph = (UndirectedGraph<V,E>) target; if (!graph.isDirected()) { throw new IllegalArgumentException(\"Graph must be directed\"); } String source = null; String dest = null; V sourceV = null; V destV = null; for (Map.Entry<String, V> entry : resultMap.entrySet()) { source = entry.getKey(); sourceV = entry.getValue(); if (source.equals(dest)) { throw new IllegalArgumentException(\"Source and destination must be different\"); } dest = source; destV = resultMap.get(dest); if (destV == null) { throw new IllegalArgumentException(\"Destination vertex '\" + dest + \"' does not exist\"); } if (!(graph.getEdge(sourceV, destV) instanceof DirectedEdge)) { throw new IllegalArgumentException(\"Source and destination vertex '\" + source + \"' does not have a directed edge\"); } DirectedEdge<V, E> directedEdge = (DirectedEdge<V, E>) graph.getEdge(sourceV, destV); if (directedEdge == null) { throw new IllegalArgumentException(\"Source and destination vertex '\" + source + \"' does not have a directed edge\"); } graph.addEdge(sourceV, destV, directedEdge); } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (!isInitialized()) { return; } this.target = target; this.resultMap = resultMap; this.graph = new SimpleDirectedWeightedGraph<>(new DefaultWeightedEdgeFactory()); this.vertices = new HashSet<>(); this.edges = new HashSet<>(); this.vertices.addAll(resultMap.keySet()); this.edges.addAll(resultMap.values()); for (String key : this.vertices) { graph.addVertex(resultMap.get(key)); } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (graph == null) { throw new IllegalArgumentException(\"The graph must be set before calling generateGraph.\"); } if (target == null) { throw new IllegalArgumentException(\"The target graph must be set before calling generateGraph.\"); } if (resultMap == null) { throw new IllegalArgumentException(\"The result map must be set before calling generateGraph.\"); } if (!graph.getVertices().containsAll(target.getVertices())) { throw new IllegalArgumentException(\"The target graph does not contain all the source graphs.\"); } if (!graph.getEdges().containsAll(target.getEdges())) { throw new IllegalArgumentException(\"The target graph does not contain all the source edges.\"); } if (!graph.getVertices().containsAll(resultMap.keySet())) { throw new IllegalArgumentException(\"The source graph does not contain all the result map keys.\"); } if (!graph.getEdges().containsAll(resultMap.values())) { throw new IllegalArgumentException(\"The source graph does not contain all the result map values.\"); } if (!graph.getVertices().containsAll(resultMap.keySet())) { throw new IllegalArgumentException(\"The target graph does not contain all the result map keys.\"); } if (!graph.getEdges().containsAll(resultMap.values())) { throw new IllegalArgumentException(\"The target graph does not contain all the result map values.\"); } if (!graph.getVertices().containsAll(resultMap.keySet())) { throw new IllegalArgumentException(\"The source graph does not contain all the result map keys.\"); } if (!graph.getEdges().containsAll(resultMap.values())) { throw new IllegalArgumentException(\"The source graph does not contain all the result map values.\"); } if (!graph.getVertices().containsAll(resultMap.keySet())) { throw new IllegalArgumentException(\"The target graph does not contain all the result map keys.\"); } if (!graph.getEdges().containsAll(resultMap.values())) { throw new IllegalArgumentException(\"The target graph does not contain all the result map values.\"); } if (!graph.getVertices().containsAll(resultMap.keySet())) { throw new IllegalArgumentException(\"The source graph does not contain all the result map keys.\"); } if (!graph.getEdges().containsAll(resultMap.values())) { throw new IllegalArgumentException(\"The source graph does not contain all the result map values.\"); } if (!graph.getVertices().containsAll(resultMap.keySet())) { throw new IllegalArgumentException(\"The target graph does not contain all the result map keys.\"); } if (!graph.getEdges().containsAll(resultMap.values())) { throw new IllegalArgumentException(\"The target graph does not contain all the result map values.\"); } }"], "code_level": "class_runnable", "_id": "636767641a6d9265ec01817d", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket == null) {\n    return;\n  }\n  if (this.isEmpty()) {\n    this.head = bucket.head;\n    this.tail = bucket.tail;\n  } else {\n    this.tail.insertBefore(bucket);\n  }\n  this.size++;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket == null) {\n    return;\n  }\n  if (bucket.getNext() != null) {\n    throw new RuntimeException(\"Bucket already has a next bucket.\");\n  }\n  Node<T> node = bucket.getNext();\n  bucket.setNext(node);\n  node.setPrev(bucket);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (this.bucket == null) {\n    this.bucket = bucket;\n    return;\n  }\n  Bucket tmp = this.bucket;\n  while (tmp != null) {\n    if (tmp.next == null) {\n      break;\n    }\n    tmp = tmp.next;\n  }\n  tmp.next = bucket;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  int index = bucket.index;\n  int newIndex = index + 1;\n  while (newIndex < buckets.length && buckets[newIndex] == null) {\n    newIndex++;\n  }\n  if (newIndex == buckets.length) {\n    resize(newIndex + 1);\n  } else {\n    if (newIndex >= index) {\n      return;\n    }\n  }\n  Object[] newBuckets = Arrays.copyOf(buckets, buckets.length);\n  newBuckets[index] = bucket;\n  buckets = newBuckets;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  Bucket next = bucket.next;\n  if (next != null) {\n    bucket.next = next.prev;\n    next.prev = bucket;\n  } else {\n    bucket.next = this;\n    this.prev = bucket;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket == null) {\n    throw new NullPointerException();\n  }\n  if (head.next == tail) {\n    return;\n  }\n  bucket.next = head.next;\n  head.next.prev = bucket;\n  head.next = bucket;\n  bucket.prev = head;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  assert this.bucket == null;\n  this.bucket = bucket;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket == null) {\n    throw new NullPointerException(\"bucket\");\n  }\n  if (bucket.previous != this) {\n    throw new IllegalArgumentException(\"bucket\");\n  }\n  if (previous == bucket) {\n    throw new IllegalArgumentException(\"bucket\");\n  }\n  if (previous.next == bucket) {\n    previous = bucket;\n  } else {\n    bucket.next.previous = previous;\n  }\n  bucket.previous = this;\n  previous = bucket;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket.next == null) {\n    bucket.next = this;\n  } else {\n    insertBefore(bucket.next);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void insertBefore(Bucket bucket) {\n  assert bucket != null;\n  assert this.equals(bucket);\n  this.buckets.add(bucket);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Inserts this bucket in the data structure before the  {@code bucket}.\n * @param bucket the bucket, that will be the next to this bucket.\n */\n", "method_name": "insertBefore", "codes": ["void insertBefore(Bucket bucket){ if (bucket == null) { return; } if (this.isEmpty()) { this.head = bucket.head; this.tail = bucket.tail; } else { this.tail.insertBefore(bucket); } this.size++; }", "void insertBefore(Bucket bucket){ if (bucket == null) { return; } if (bucket.getNext() != null) { throw new RuntimeException(\"Bucket already has a next bucket.\"); } Node<T> node = bucket.getNext(); bucket.setNext(node); node.setPrev(bucket); }", "void insertBefore(Bucket bucket){ if (this.bucket == null) { this.bucket = bucket; return; } Bucket tmp = this.bucket; while (tmp != null) { if (tmp.next == null) { break; } tmp = tmp.next; } tmp.next = bucket; }", "void insertBefore(Bucket bucket){ int index = bucket.index; int newIndex = index + 1; while (newIndex < buckets.length && buckets[newIndex] == null) { newIndex++; } if (newIndex == buckets.length) { resize(newIndex + 1); } else { if (newIndex >= index) { return; } } Object[] newBuckets = Arrays.copyOf(buckets, buckets.length); newBuckets[index] = bucket; buckets = newBuckets; }", "void insertBefore(Bucket bucket){ Bucket next = bucket.next; if (next != null) { bucket.next = next.prev; next.prev = bucket; } else { bucket.next = this; this.prev = bucket; } }", "void insertBefore(Bucket bucket){ if (bucket == null) { throw new NullPointerException(); } if (head.next == tail) { return; } bucket.next = head.next; head.next.prev = bucket; head.next = bucket; bucket.prev = head; }", "void insertBefore(Bucket bucket){ assert this.bucket == null; this.bucket = bucket; }", "void insertBefore(Bucket bucket){ if (bucket == null) { throw new NullPointerException(\"bucket\"); } if (bucket.previous != this) { throw new IllegalArgumentException(\"bucket\"); } if (previous == bucket) { throw new IllegalArgumentException(\"bucket\"); } if (previous.next == bucket) { previous = bucket; } else { bucket.next.previous = previous; } bucket.previous = this; previous = bucket; }", "void insertBefore(Bucket bucket){ if (bucket.next == null) { bucket.next = this; } else { insertBefore(bucket.next); } }", "void insertBefore(Bucket bucket){ assert bucket != null; assert this.equals(bucket); this.buckets.add(bucket); }"], "code_level": "class_runnable", "_id": "636767531a6d9265ec017efb", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic boolean hasNext() {\n  return !this.unVisitedVertices.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return (!vertices.isEmpty());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !vertices.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  if (!hasNext) {\n    if (!vertices.isEmpty()) {\n      hasNext = true;\n    } else {\n      hasNext = false;\n    }\n  }\n  return hasNext;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !visited.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !this.visited.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return unvisitedVertices.size() > 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !visited.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !this.unVisited.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !this.unvisited.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Checks whether there exist unvisited vertices.\n * @return true if there exist unvisited vertices.\n */\n", "method_name": "hasNext", "codes": ["@Override public boolean hasNext(){ return !this.unVisitedVertices.isEmpty(); }", "@Override public boolean hasNext(){ return (!vertices.isEmpty()); }", "@Override public boolean hasNext(){ return !vertices.isEmpty(); }", "@Override public boolean hasNext(){ if (!hasNext) { if (!vertices.isEmpty()) { hasNext = true; } else { hasNext = false; } } return hasNext; }", "@Override public boolean hasNext(){ return !visited.isEmpty(); }", "@Override public boolean hasNext(){ return !this.visited.isEmpty(); }", "@Override public boolean hasNext(){ return unvisitedVertices.size() > 0; }", "@Override public boolean hasNext(){ return !visited.isEmpty(); }", "@Override public boolean hasNext(){ return !this.unVisited.isEmpty(); }", "@Override public boolean hasNext(){ return !this.unvisited.isEmpty(); }"], "code_level": "class_runnable", "_id": "636767561a6d9265ec017f63", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "void removeSelf() {\n  m_buckets.remove(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  if (!this.isFull()) {\n    this.buckets[this.currentBucket] = null;\n    this.currentBucket = (this.currentBucket + 1) % this.buckets.length;\n  } else {\n    System.out.println(\"The data structure is full, cannot remove!\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  buckets.remove(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  this.bucket = null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  if (parent != null) parent.children.remove(this);\n  if (children != null) children.remove(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  buckets.remove(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  buckets.remove(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  this.bucket = null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  buckets.remove(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  if (this.bucketId != null) {\n    this.bucketId.removeSelf();\n  }\n  this.bucketId = null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes this bucket from the data structure.\n */\n", "method_name": "removeSelf", "codes": ["void removeSelf(){ m_buckets.remove(this); }", "void removeSelf(){ if (!this.isFull()) { this.buckets[this.currentBucket] = null; this.currentBucket = (this.currentBucket + 1) % this.buckets.length; } else { System.out.println(\"The data structure is full, cannot remove!\"); } }", "void removeSelf(){ buckets.remove(this); }", "void removeSelf(){ this.bucket = null; }", "void removeSelf(){ if (parent != null) parent.children.remove(this); if (children != null) children.remove(this); }", "void removeSelf(){ buckets.remove(this); }", "void removeSelf(){ buckets.remove(this); }", "void removeSelf(){ this.bucket = null; }", "void removeSelf(){ buckets.remove(this); }", "void removeSelf(){ if (this.bucketId != null) { this.bucketId.removeSelf(); } this.bucketId = null; }"], "code_level": "class_runnable", "_id": "6367675a1a6d9265ec018010", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (Edge<V> e : edges) {\n    if (e.isVisible()) {\n      vertices.add(e.getOtherVertex(e.getSource()));\n    }\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (Edge<V> edge : edges()) {\n    if (edge.isVisible()) {\n      vertices.add(edge.to());\n    }\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> visibleVertices = new HashSet<>();\n  for (int i = 0; i < vertices.length; i++) {\n    if (vertices[i].getDegree() > 0) {\n      visibleVertices.add(vertices[i]);\n    }\n  }\n  return visibleVertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (int i = 0; i < graph.getNumVertices(); i++) {\n    if (graph.getDegree(i) > 0) {\n      vertices.add(graph.getVertex(i));\n    }\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (V v : graph.getVertices()) {\n    if (graph.getEdges(v).size() <= 0) {\n      vertices.add(v);\n    }\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<V>();\n  for (Edge edge : edges) {\n    vertices.add(edge.getVertex1());\n    vertices.add(edge.getVertex2());\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> visibleVertices = new HashSet<>();\n  for (Edge<V> e : edges) {\n    if (e.getWeight() > 0) {\n      visibleVertices.add(e.getVertexA());\n      visibleVertices.add(e.getVertexB());\n    }\n  }\n  return visibleVertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (Edge<V> edge : edges) {\n    V u = edge.getFrom();\n    vertices.add(u);\n    if (u.equals(edge.getTo())) {\n      vertices.add(edge.getTo());\n    }\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> visibleVertices = new HashSet<>();\n  for (V v : graph.vertexSet()) {\n    if (graph.getEdgeWeight(v, null) > 0) {\n      visibleVertices.add(v);\n    }\n  }\n  return visibleVertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (Edge<V, E> edge : edges) {\n    if (edge.getDegree() > 0) {\n      vertices.add(edge.getVertex1());\n      vertices.add(edge.getVertex2());\n    }\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n", "method_name": "initVisibleVertices", "codes": ["private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (Edge<V> e : edges) { if (e.isVisible()) { vertices.add(e.getOtherVertex(e.getSource())); } } return vertices; }", "private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (Edge<V> edge : edges()) { if (edge.isVisible()) { vertices.add(edge.to()); } } return vertices; }", "private Set<V> initVisibleVertices(){ Set<V> visibleVertices = new HashSet<>(); for (int i = 0; i < vertices.length; i++) { if (vertices[i].getDegree() > 0) { visibleVertices.add(vertices[i]); } } return visibleVertices; }", "private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (int i = 0; i < graph.getNumVertices(); i++) { if (graph.getDegree(i) > 0) { vertices.add(graph.getVertex(i)); } } return vertices; }", "private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (V v : graph.getVertices()) { if (graph.getEdges(v).size() <= 0) { vertices.add(v); } } return vertices; }", "private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<V>(); for (Edge edge : edges) { vertices.add(edge.getVertex1()); vertices.add(edge.getVertex2()); } return vertices; }", "private Set<V> initVisibleVertices(){ Set<V> visibleVertices = new HashSet<>(); for (Edge<V> e : edges) { if (e.getWeight() > 0) { visibleVertices.add(e.getVertexA()); visibleVertices.add(e.getVertexB()); } } return visibleVertices; }", "private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (Edge<V> edge : edges) { V u = edge.getFrom(); vertices.add(u); if (u.equals(edge.getTo())) { vertices.add(edge.getTo()); } } return vertices; }", "private Set<V> initVisibleVertices(){ Set<V> visibleVertices = new HashSet<>(); for (V v : graph.vertexSet()) { if (graph.getEdgeWeight(v, null) > 0) { visibleVertices.add(v); } } return visibleVertices; }", "private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (Edge<V, E> edge : edges) { if (edge.getDegree() > 0) { vertices.add(edge.getVertex1()); vertices.add(edge.getVertex2()); } } return vertices; }"], "code_level": "class_runnable", "_id": "6367674b1a6d9265ec017dc0", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.treeEdgeList == null) {\n    return;\n  }\n  this.treeEdgeList.remove(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.treeEdgeList != null) {\n    this.treeEdgeList.remove(this);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.treeEdges != null) {\n    if (this.treeEdges.get(this) != null) {\n      this.treeEdges.remove(this);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  treeEdgeList.remove(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.headEdge != null) {\n    this.headEdge.removeFromTreeEdgeList();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (firstEdge == null) {\n    return;\n  } else if (firstEdge == lastEdge) {\n    firstEdge = null;\n    lastEdge = null;\n    return;\n  } else {\n    Node<E> previous = firstEdge.previous;\n    Node<E> next = firstEdge.next;\n    previous.next = next;\n    next.previous = previous;\n    return;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.treeEdgeList != null) {\n    this.treeEdgeList.remove(this);\n    this.treeEdgeList = null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.getEdgeList() != null) {\n    this.getEdgeList().remove(this);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  treeEdgeList.remove(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.treeEdges.size() > 0) {\n    this.treeEdges.remove(this.treeEdges.size() - 1);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes this edge from both doubly linked lists of tree edges.\n */\n", "method_name": "removeFromTreeEdgeList", "codes": ["public void removeFromTreeEdgeList(){ if (this.treeEdgeList == null) { return; } this.treeEdgeList.remove(this); }", "public void removeFromTreeEdgeList(){ if (this.treeEdgeList != null) { this.treeEdgeList.remove(this); } }", "public void removeFromTreeEdgeList(){ if (this.treeEdges != null) { if (this.treeEdges.get(this) != null) { this.treeEdges.remove(this); } } }", "public void removeFromTreeEdgeList(){ treeEdgeList.remove(this); }", "public void removeFromTreeEdgeList(){ if (this.headEdge != null) { this.headEdge.removeFromTreeEdgeList(); } }", "public void removeFromTreeEdgeList(){ if (firstEdge == null) { return; } else if (firstEdge == lastEdge) { firstEdge = null; lastEdge = null; return; } else { Node<E> previous = firstEdge.previous; Node<E> next = firstEdge.next; previous.next = next; next.previous = previous; return; } }", "public void removeFromTreeEdgeList(){ if (this.treeEdgeList != null) { this.treeEdgeList.remove(this); this.treeEdgeList = null; } }", "public void removeFromTreeEdgeList(){ if (this.getEdgeList() != null) { this.getEdgeList().remove(this); } }", "public void removeFromTreeEdgeList(){ treeEdgeList.remove(this); }", "public void removeFromTreeEdgeList(){ if (this.treeEdges.size() > 0) { this.treeEdges.remove(this.treeEdges.size() - 1); } }"], "code_level": "class_runnable", "_id": "6367675c1a6d9265ec01805b", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  Vertex<V, E> v = getVertex(sourceVertex);\n  Vertex<V, E> w = getVertex(targetVertex);\n  if (v == null) {\n    v = new Vertex<>(sourceVertex);\n    vertexSet.add(v);\n  }\n  if (w == null) {\n    w = new Vertex<>(targetVertex);\n    vertexSet.add(w);\n  }\n  v.addEdge(w, e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (!vertexIndex.containsKey(sourceVertex)) {\n    vertexIndex.put(sourceVertex, new HashSet<V>());\n  }\n  vertexIndex.get(sourceVertex).add(targetVertex);\n  if (!vertexIndex.containsKey(targetVertex)) {\n    vertexIndex.put(targetVertex, new HashSet<V>());\n  }\n  vertexIndex.get(targetVertex).add(sourceVertex);\n  edgeIndex.put(e, sourceVertex, targetVertex);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (!index.containsKey(sourceVertex)) index.put(sourceVertex, new HashSet<>());\n  index.get(sourceVertex).add(targetVertex);\n  if (!index.containsKey(targetVertex)) index.put(targetVertex, new HashSet<>());\n  index.get(targetVertex).add(sourceVertex);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (e.getSource().equals(sourceVertex) && e.getTarget().equals(targetVertex)) {\n    return;\n  }\n  Vertex<V, E> v = vertexMap.get(sourceVertex);\n  if (v == null) {\n    v = new Vertex<V, E>(sourceVertex);\n    vertexMap.put(sourceVertex, v);\n  }\n  v.addEdge(targetVertex, e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  index.addEdge(sourceVertex, targetVertex, e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (!vertices.containsKey(sourceVertex)) {\n    throw new IllegalArgumentException(\"Vertex \" + sourceVertex + \" does not exist\");\n  }\n  if (!vertices.containsKey(targetVertex)) {\n    throw new IllegalArgumentException(\"Vertex \" + targetVertex + \" does not exist\");\n  }\n  vertices.get(sourceVertex).addEdge(targetVertex, e);\n  vertices.get(targetVertex).addEdge(sourceVertex, e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  addToIndex(sourceVertex, targetVertex, e, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  int index = vertexIndex(sourceVertex);\n  indexes.get(index).add(targetVertex);\n  indexes.get(index).add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (!index.containsKey(sourceVertex)) index.put(sourceVertex, new ArrayList<E>());\n  index.get(sourceVertex).add(e);\n  if (!index.containsKey(targetVertex)) index.put(targetVertex, new ArrayList<E>());\n  index.get(targetVertex).add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (sourceVertex.equals(targetVertex)) {\n    throw new IllegalArgumentException(\"Target vertex must be different than source vertex\");\n  }\n  if (!index.containsKey(sourceVertex)) {\n    index.put(sourceVertex, new HashSet<V>());\n  }\n  index.get(sourceVertex).add(targetVertex);\n  if (!index.containsKey(targetVertex)) {\n    index.put(targetVertex, new HashSet<V>());\n  }\n  index.get(targetVertex).add(sourceVertex);\n  if (!edges.containsKey(sourceVertex)) {\n    edges.put(sourceVertex, new LinkedList<E>());\n  }\n  edges.get(sourceVertex).add(e);\n  if (!edges.containsKey(targetVertex)) {\n    edges.put(targetVertex, new LinkedList<E>());\n  }\n  edges.get(targetVertex).add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n", "method_name": "addToIndex", "codes": ["protected void addToIndex(V sourceVertex,V targetVertex,E e){ Vertex<V, E> v = getVertex(sourceVertex); Vertex<V, E> w = getVertex(targetVertex); if (v == null) { v = new Vertex<>(sourceVertex); vertexSet.add(v); } if (w == null) { w = new Vertex<>(targetVertex); vertexSet.add(w); } v.addEdge(w, e); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (!vertexIndex.containsKey(sourceVertex)) { vertexIndex.put(sourceVertex, new HashSet<V>()); } vertexIndex.get(sourceVertex).add(targetVertex); if (!vertexIndex.containsKey(targetVertex)) { vertexIndex.put(targetVertex, new HashSet<V>()); } vertexIndex.get(targetVertex).add(sourceVertex); edgeIndex.put(e, sourceVertex, targetVertex); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (!index.containsKey(sourceVertex)) index.put(sourceVertex, new HashSet<>()); index.get(sourceVertex).add(targetVertex); if (!index.containsKey(targetVertex)) index.put(targetVertex, new HashSet<>()); index.get(targetVertex).add(sourceVertex); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (e.getSource().equals(sourceVertex) && e.getTarget().equals(targetVertex)) { return; } Vertex<V, E> v = vertexMap.get(sourceVertex); if (v == null) { v = new Vertex<V, E>(sourceVertex); vertexMap.put(sourceVertex, v); } v.addEdge(targetVertex, e); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ index.addEdge(sourceVertex, targetVertex, e); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (!vertices.containsKey(sourceVertex)) { throw new IllegalArgumentException(\"Vertex \" + sourceVertex + \" does not exist\"); } if (!vertices.containsKey(targetVertex)) { throw new IllegalArgumentException(\"Vertex \" + targetVertex + \" does not exist\"); } vertices.get(sourceVertex).addEdge(targetVertex, e); vertices.get(targetVertex).addEdge(sourceVertex, e); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ addToIndex(sourceVertex, targetVertex, e, true); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ int index = vertexIndex(sourceVertex); indexes.get(index).add(targetVertex); indexes.get(index).add(e); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (!index.containsKey(sourceVertex)) index.put(sourceVertex, new ArrayList<E>()); index.get(sourceVertex).add(e); if (!index.containsKey(targetVertex)) index.put(targetVertex, new ArrayList<E>()); index.get(targetVertex).add(e); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (sourceVertex.equals(targetVertex)) { throw new IllegalArgumentException(\"Target vertex must be different than source vertex\"); } if (!index.containsKey(sourceVertex)) { index.put(sourceVertex, new HashSet<V>()); } index.get(sourceVertex).add(targetVertex); if (!index.containsKey(targetVertex)) { index.put(targetVertex, new HashSet<V>()); } index.get(targetVertex).add(sourceVertex); if (!edges.containsKey(sourceVertex)) { edges.put(sourceVertex, new LinkedList<E>()); } edges.get(sourceVertex).add(e); if (!edges.containsKey(targetVertex)) { edges.put(targetVertex, new LinkedList<E>()); } edges.get(targetVertex).add(e); }"], "code_level": "class_runnable", "_id": "636767601a6d9265ec0180fd", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left = box.getLeft();\n  Box2D right = box.getRight();\n  if (left.getX() == right.getX()) {\n    if (left.getY() == right.getY()) {\n      return new Pair<Box2D, Box2D>(left, right);\n    } else {\n      return new Pair<Box2D, Box2D>(right, left);\n    }\n  } else if (left.getX() > right.getX()) {\n    if (left.getY() > right.getY()) {\n      return new Pair<Box2D, Box2D>(left, right);\n    } else {\n      return new Pair<Box2D, Box2D>(right, left);\n    }\n  } else {\n    if (left.getY() > right.getY()) {\n      return new Pair<Box2D, Box2D>(right, left);\n    } else {\n      return new Pair<Box2D, Box2D>(left, right);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  if (box.getWidth() > box.getHeight()) {\n    return new Pair<>(\n        new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight()),\n        new Box2D(box.getX() + box.getWidth(), box.getY(), box.getWidth(), box.getHeight()));\n  } else {\n    return new Pair<>(\n        new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight()),\n        new Box2D(box.getX(), box.getY() + box.getHeight(), box.getWidth(), box.getHeight()));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  return splitAlongXAxis(box, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  if (box == null) {\n    throw new IllegalArgumentException(\"box cannot be null.\");\n  }\n  double x = box.getX();\n  double y = box.getY();\n  double width = box.getWidth();\n  double height = box.getHeight();\n  double a = Math.sqrt((x * x) + (y * y));\n  double b = Math.sqrt((x * x) + (height * height));\n  double c = Math.sqrt((height * height) + (y * y));\n  if (a < b + c) {\n    return new Pair<Box2D, Box2D>(\n        new Box2D(x, y, width, height), new Box2D(x + width, y, width, height));\n  } else {\n    return new Pair<Box2D, Box2D>(\n        new Box2D(x, y, width, height), new Box2D(x, y + height, width, height));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left = new Box2D(box.getMinX(), box.getMinY(), box.getMaxX(), box.getMaxY());\n  Box2D right = new Box2D(box.getMinX(), box.getMinY(), box.getMaxX(), box.getMinY());\n  return new Pair<>(left, right);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  return new Pair<Box2D, Box2D>(\n      splitAlongXAxis(box, box.getX()), splitAlongXAxis(box, box.getY()));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  if (box.getX() < 0) {\n    Box2D leftBox = new Box2D(-box.getX(), box.getY(), box.getZ(), box.getW());\n    return new Pair<Box2D, Box2D>(leftBox, box);\n  } else {\n    Box2D rightBox = new Box2D(box.getX(), box.getY(), box.getZ(), box.getW());\n    return new Pair<Box2D, Box2D>(box, rightBox);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left = new Box2D(box.x1 - box.x2, box.y1 - box.y2, box.x2 - box.x1, box.y2 - box.y1);\n  Box2D right = new Box2D(box.x1 - box.x2, box.y1 - box.y2, box.x2 - box.x1, box.y2 - box.y1);\n  return new Pair<Box2D, Box2D>(left, right);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left =\n      new Box2D(box.getX() - box.getWidth() / 2, box.getY(), box.getWidth(), box.getHeight());\n  Box2D right =\n      new Box2D(box.getX() + box.getWidth() / 2, box.getY(), box.getWidth(), box.getHeight());\n  return new Pair<>(left, right);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  return new Pair<Box2D, Box2D>(\n      box, new Box2D(box.getX() / 2, box.getY() / 2, box.getWidth() / 2, box.getHeight() / 2));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split a box along the x axis into two equal boxes.\n * @param box the box to split\n * @return a pair with the two resulting boxes\n */\n", "method_name": "splitAlongXAxis", "codes": ["public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = box.getLeft(); Box2D right = box.getRight(); if (left.getX() == right.getX()) { if (left.getY() == right.getY()) { return new Pair<Box2D, Box2D>(left, right); } else { return new Pair<Box2D, Box2D>(right, left); } } else if (left.getX() > right.getX()) { if (left.getY() > right.getY()) { return new Pair<Box2D, Box2D>(left, right); } else { return new Pair<Box2D, Box2D>(right, left); } } else { if (left.getY() > right.getY()) { return new Pair<Box2D, Box2D>(right, left); } else { return new Pair<Box2D, Box2D>(left, right); } } }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ if (box.getWidth() > box.getHeight()) { return new Pair<>(new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight()), new Box2D(box.getX() + box.getWidth(), box.getY(), box.getWidth(), box.getHeight())); } else { return new Pair<>(new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight()), new Box2D(box.getX(), box.getY() + box.getHeight(), box.getWidth(), box.getHeight())); } }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ return splitAlongXAxis(box, true); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ if (box == null) { throw new IllegalArgumentException(\"box cannot be null.\"); } double x = box.getX(); double y = box.getY(); double width = box.getWidth(); double height = box.getHeight(); double a = Math.sqrt((x * x) + (y * y)); double b = Math.sqrt((x * x) + (height * height)); double c = Math.sqrt((height * height) + (y * y)); if (a < b + c) { return new Pair<Box2D, Box2D>(new Box2D(x, y, width, height), new Box2D(x + width, y, width, height)); } else { return new Pair<Box2D, Box2D>(new Box2D(x, y, width, height), new Box2D(x, y + height, width, height)); } }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.getMinX(), box.getMinY(), box.getMaxX(), box.getMaxY()); Box2D right = new Box2D(box.getMinX(), box.getMinY(), box.getMaxX(), box.getMinY()); return new Pair<>(left, right); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ return new Pair<Box2D, Box2D>(splitAlongXAxis(box, box.getX()), splitAlongXAxis(box, box.getY())); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ if (box.getX() < 0) { Box2D leftBox = new Box2D(-box.getX(), box.getY(), box.getZ(), box.getW()); return new Pair<Box2D, Box2D>(leftBox, box); } else { Box2D rightBox = new Box2D(box.getX(), box.getY(), box.getZ(), box.getW()); return new Pair<Box2D, Box2D>(box, rightBox); } }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.x1 - box.x2, box.y1 - box.y2, box.x2 - box.x1, box.y2 - box.y1); Box2D right = new Box2D(box.x1 - box.x2, box.y1 - box.y2, box.x2 - box.x1, box.y2 - box.y1); return new Pair<Box2D, Box2D>(left, right); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.getX() - box.getWidth() / 2, box.getY(), box.getWidth(), box.getHeight()); Box2D right = new Box2D(box.getX() + box.getWidth() / 2, box.getY(), box.getWidth(), box.getHeight()); return new Pair<>(left, right); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ return new Pair<Box2D, Box2D>(box, new Box2D(box.getX() / 2, box.getY() / 2, box.getWidth() / 2, box.getHeight() / 2)); }"], "code_level": "project_runnable", "_id": "636767521a6d9265ec017ecc", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return Math.abs(p1.x - p2.x) <= 1e-9 && Math.abs(p1.y - p2.y) <= 1e-9;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return p1.getX() == p2.getX() && p1.getY() == p2.getY();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  if (p1 == null || p2 == null) return false;\n  return Math.abs(p1.x - p2.x) < 1e-9 && Math.abs(p1.y - p2.y) < 1e-9;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return equals(p1.getX(), p1.getY(), p2.getX(), p2.getY());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return equals(p1.getX(), p1.getY(), p2.getX(), p2.getY());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return (p1.x == p2.x && p1.y == p2.y);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return equals(p1.getX(), p1.getY(), p2.getX(), p2.getY());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return equals(p1.x, p1.y, p2.x, p2.y);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return Math.abs(p1.x - p2.x) < tolerance && Math.abs(p1.y - p2.y) < tolerance;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return equals(p1.x, p1.y, p2.x, p2.y);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compare two points for equality using tolerance 1e-9.\n * @param p1 the first point\n * @param p2 the second point\n * @return whether the two points are equal or not\n */\n", "method_name": "equals", "codes": ["public static boolean equals(Point2D p1,Point2D p2){ return Math.abs(p1.x - p2.x) <= 1e-9 && Math.abs(p1.y - p2.y) <= 1e-9; }", "public static boolean equals(Point2D p1,Point2D p2){ return p1.getX() == p2.getX() && p1.getY() == p2.getY(); }", "public static boolean equals(Point2D p1,Point2D p2){ if (p1 == null || p2 == null) return false; return Math.abs(p1.x - p2.x) < 1e-9 && Math.abs(p1.y - p2.y) < 1e-9; }", "public static boolean equals(Point2D p1,Point2D p2){ return equals(p1.getX(), p1.getY(), p2.getX(), p2.getY()); }", "public static boolean equals(Point2D p1,Point2D p2){ return equals(p1.getX(), p1.getY(), p2.getX(), p2.getY()); }", "public static boolean equals(Point2D p1,Point2D p2){ return (p1.x == p2.x && p1.y == p2.y); }", "public static boolean equals(Point2D p1,Point2D p2){ return equals(p1.getX(), p1.getY(), p2.getX(), p2.getY()); }", "public static boolean equals(Point2D p1,Point2D p2){ return equals(p1.x, p1.y, p2.x, p2.y); }", "public static boolean equals(Point2D p1,Point2D p2){ return Math.abs(p1.x - p2.x) < tolerance && Math.abs(p1.y - p2.y) < tolerance; }", "public static boolean equals(Point2D p1,Point2D p2){ return equals(p1.x, p1.y, p2.x, p2.y); }"], "code_level": "project_runnable", "_id": "636767531a6d9265ec017ef1", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  if (o1 == null && o2 == null) {\n    return 0;\n  } else if (o1 == null) {\n    return -1;\n  } else if (o2 == null) {\n    return 1;\n  } else {\n    return o1.compareTo(o2);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return o1.compareTo(o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return Double.compare(o1, o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return o1.compareTo(o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return Double.compare(o1, o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  if (o1 < o2) {\n    return -1;\n  } else if (o1 == o2) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  if (o1 == o2) {\n    return 0;\n  }\n  if (o1 == null) {\n    return -1;\n  }\n  if (o2 == null) {\n    return 1;\n  }\n  return Double.compare(o1, o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return Double.compare(o1, o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return o1.compareTo(o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  if (o1 < o2) {\n    return -1;\n  } else if (o1 > o2) {\n    return 1;\n  } else {\n    return 0;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares two floating point values. Returns 0 if they are equal, -1 if  {@literal o1 < o2}, 1 otherwise\n * @param o1 the first value\n * @param o2 the second value\n * @return 0 if they are equal, -1 if {@literal o1 < o2}, 1 otherwise\n */\n", "method_name": "compare", "codes": ["@Override public int compare(Double o1,Double o2){ if (o1 == null && o2 == null) { return 0; } else if (o1 == null) { return -1; } else if (o2 == null) { return 1; } else { return o1.compareTo(o2); } }", "@Override public int compare(Double o1,Double o2){ return o1.compareTo(o2); }", "@Override public int compare(Double o1,Double o2){ return Double.compare(o1, o2); }", "@Override public int compare(Double o1,Double o2){ return o1.compareTo(o2); }", "@Override public int compare(Double o1,Double o2){ return Double.compare(o1, o2); }", "@Override public int compare(Double o1,Double o2){ if (o1 < o2) { return -1; } else if (o1 == o2) { return 0; } else { return 1; } }", "@Override public int compare(Double o1,Double o2){ if (o1 == o2) { return 0; } if (o1 == null) { return -1; } if (o2 == null) { return 1; } return Double.compare(o1, o2); }", "@Override public int compare(Double o1,Double o2){ return Double.compare(o1, o2); }", "@Override public int compare(Double o1,Double o2){ return o1.compareTo(o2); }", "@Override public int compare(Double o1,Double o2){ if (o1 < o2) { return -1; } else if (o1 > o2) { return 1; } else { return 0; } }"], "code_level": "slib_runnable", "_id": "6367674a1a6d9265ec017dab", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public String toString() {\n  String queue = \"\";\n  for (int i = 0; i < capacity; i++) {\n    if (i == 0) {\n      queue += \"[\" + data[i] + \"]\";\n    } else {\n      queue += \", \" + data[i];\n    }\n  }\n  return queue;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < size; i++) {\n    sb.append(i).append(\" \").append(get(i)).append(\"\\n\");\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuilder sb = new StringBuilder(\"[\");\n  if (front == null) {\n    return sb.append(\"]\").toString();\n  }\n  sb.append(front.data).append(\",\");\n  sb.append(\"]\");\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < size; i++) {\n    sb.append(queue[i] + \" \");\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuilder builder = new StringBuilder();\n  for (int i = front; i != rear; i = (i + 1) % size) {\n    builder.append(queue[i]);\n    builder.append(\" \");\n  }\n  return builder.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuilder result = new StringBuilder(\"[\");\n  if (isEmpty()) {\n    return \"[]\";\n  } else {\n    result.append(queueArray[front]);\n    result.append(\", \");\n    result.append(queueArray[front + 1]);\n    result.append(\", \");\n    result.append(queueArray[front + 2]);\n    result.append(\", \");\n    result.append(queueArray[front + 3]);\n    result.append(\"]\");\n    return result.toString();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"[\");\n  for (Node n = first; n != null; n = n.next) {\n    sb.append(n.item);\n    sb.append(\" \");\n  }\n  sb.append(\"]\");\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return queue.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  String result = \"\";\n  for (int i = 0; i < size(); i++) {\n    result += queue[i] + \" \";\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuffer buffer = new StringBuffer();\n  buffer.append(\"[\");\n  for (int i = 0; i < size(); i++) {\n    buffer.append(get(i));\n    if (i != size() - 1) buffer.append(\",\");\n  }\n  buffer.append(\"]\");\n  return buffer.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a textual representation of the queue.\n * @return a textual representation of the queue.\n */\n", "method_name": "toString", "codes": ["public String toString(){ String queue = \"\"; for (int i = 0; i < capacity; i++) { if (i == 0) { queue += \"[\" + data[i] + \"]\"; } else { queue += \", \" + data[i]; } } return queue; }", "public String toString(){ StringBuilder sb = new StringBuilder(); for (int i = 0; i < size; i++) { sb.append(i).append(\" \").append(get(i)).append(\"\\n\"); } return sb.toString(); }", "public String toString(){ StringBuilder sb = new StringBuilder(\"[\"); if (front == null) { return sb.append(\"]\").toString(); } sb.append(front.data).append(\",\"); sb.append(\"]\"); return sb.toString(); }", "public String toString(){ StringBuilder sb = new StringBuilder(); for (int i = 0; i < size; i++) { sb.append(queue[i] + \" \"); } return sb.toString(); }", "public String toString(){ StringBuilder builder = new StringBuilder(); for (int i = front; i != rear; i = (i + 1) % size) { builder.append(queue[i]); builder.append(\" \"); } return builder.toString(); }", "public String toString(){ StringBuilder result = new StringBuilder(\"[\"); if (isEmpty()) { return \"[]\"; } else { result.append(queueArray[front]); result.append(\", \"); result.append(queueArray[front + 1]); result.append(\", \"); result.append(queueArray[front + 2]); result.append(\", \"); result.append(queueArray[front + 3]); result.append(\"]\"); return result.toString(); } }", "public String toString(){ StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (Node n = first; n != null; n = n.next) { sb.append(n.item); sb.append(\" \"); } sb.append(\"]\"); return sb.toString(); }", "public String toString(){ return queue.toString(); }", "public String toString(){ String result = \"\"; for (int i = 0; i < size(); i++) { result += queue[i] + \" \"; } return result; }", "public String toString(){ StringBuffer buffer = new StringBuffer(); buffer.append(\"[\"); for (int i = 0; i < size(); i++) { buffer.append(get(i)); if (i != size() - 1) buffer.append(\",\"); } buffer.append(\"]\"); return buffer.toString(); }"], "code_level": "class_runnable", "_id": "6367674f1a6d9265ec017e74", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private int computeBinaryLog(int n) {\n  int log = 0;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      log++;\n    }\n    n /= 2;\n  }\n  return log;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n) {\n  return (int) Math.floor(Math.log(n) / Math.log(2));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n) {\n  int i = 0;\n  while (i < n && (n & 1) == 0) {\n    n >>= 1;\n    i++;\n  }\n  return i;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n) {\n  if (n < 0) {\n    throw new ArithmeticException(\"Negative logarithm: \" + n);\n  }\n  int log = n;\n  while (log > 0 && log % 2 == 1) {\n    log /= 2;\n  }\n  return log;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private int computeBinaryLog(int n) {\n  return n > 0 ? n : -n;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private int computeBinaryLog(int n) {\n  if (n == 0) return 1;\n  return (int) Math.floor(Math.log(n) / Math.log(2));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n) {\n  return (int) Math.floor(Math.log(n) / Math.log(2));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n) {\n  if (n < 0) {\n    return 1;\n  } else if (n == 0) {\n    return 0;\n  } else if (n == 1) {\n    return 1;\n  } else {\n    return computeBinaryLog(n - 1) + 1;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private int computeBinaryLog(int n) {\n  if (n < 0) {\n    throw new IllegalArgumentException(\"n must be greater than zero\");\n  }\n  if (n < 2) {\n    return n;\n  }\n  return computeBinaryLog(n / 2) + n % 2;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n) {\n  return (int) Math.floor(Math.log(n) / Math.log(2));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n", "method_name": "computeBinaryLog", "codes": ["private int computeBinaryLog(int n){ int log = 0; while (n > 0) { if (n % 2 == 1) { log++; } n /= 2; } return log; }", "private int computeBinaryLog(int n){ return (int) Math.floor(Math.log(n) / Math.log(2)); }", "private int computeBinaryLog(int n){ int i = 0; while (i < n && (n & 1) == 0) { n >>= 1; i++; } return i; }", "private int computeBinaryLog(int n){ if (n < 0) { throw new ArithmeticException(\"Negative logarithm: \" + n); } int log = n; while (log > 0 && log % 2 == 1) { log /= 2; } return log; }", "private int computeBinaryLog(int n){ return n > 0 ? n : -n; }", "private int computeBinaryLog(int n){ if (n == 0) return 1; return (int) Math.floor(Math.log(n) / Math.log(2)); }", "private int computeBinaryLog(int n){ return (int) Math.floor(Math.log(n) / Math.log(2)); }", "private int computeBinaryLog(int n){ if (n < 0) { return 1; } else if (n == 0) { return 0; } else if (n == 1) { return 1; } else { return computeBinaryLog(n - 1) + 1; } }", "private int computeBinaryLog(int n){ if (n < 0) { throw new IllegalArgumentException(\"n must be greater than zero\"); } if (n < 2) { return n; } return computeBinaryLog(n / 2) + n % 2; }", "private int computeBinaryLog(int n){ return (int) Math.floor(Math.log(n) / Math.log(2)); }"], "code_level": "self_contained", "_id": "636767431a6d9265ec017c8d", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public double vertexWeight(Set<V> v) {\n  double weight = 0;\n  for (V w : v) {\n    weight += this.getWeight(w);\n  }\n  return weight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0;\n  for (V u : v) {\n    sum += weight(u, v);\n  }\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0.0;\n  for (V u : v) {\n    sum += weight(u);\n  }\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0;\n  for (V u : v) {\n    sum += weights.get(u);\n  }\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0;\n  for (V e : v) {\n    sum += weights.get(e);\n  }\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0;\n  for (V elem : v) sum += weight(elem);\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0;\n  for (V n : v) {\n    sum += weights.get(n);\n  }\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double weight = 0;\n  for (V w : v) {\n    weight += weights.get(w);\n  }\n  return weight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0.0;\n  for (V k : v) {\n    sum += this.getWeight(k);\n  }\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0;\n  for (V vv : v) sum += weight(vv);\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compute the sum of the weights entering a vertex\n * @param v the vertex\n * @return the sum of the weights entering a vertex\n */\n", "method_name": "vertexWeight", "codes": ["public double vertexWeight(Set<V> v){ double weight = 0; for (V w : v) { weight += this.getWeight(w); } return weight; }", "public double vertexWeight(Set<V> v){ double sum = 0; for (V u : v) { sum += weight(u, v); } return sum; }", "public double vertexWeight(Set<V> v){ double sum = 0.0; for (V u : v) { sum += weight(u); } return sum; }", "public double vertexWeight(Set<V> v){ double sum = 0; for (V u : v) { sum += weights.get(u); } return sum; }", "public double vertexWeight(Set<V> v){ double sum = 0; for (V e : v) { sum += weights.get(e); } return sum; }", "public double vertexWeight(Set<V> v){ double sum = 0; for (V elem : v) sum += weight(elem); return sum; }", "public double vertexWeight(Set<V> v){ double sum = 0; for (V n : v) { sum += weights.get(n); } return sum; }", "public double vertexWeight(Set<V> v){ double weight = 0; for (V w : v) { weight += weights.get(w); } return weight; }", "public double vertexWeight(Set<V> v){ double sum = 0.0; for (V k : v) { sum += this.getWeight(k); } return sum; }", "public double vertexWeight(Set<V> v){ double sum = 0; for (V vv : v) sum += weight(vv); return sum; }"], "code_level": "class_runnable", "_id": "636767611a6d9265ec018106", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>(set1);\n  intersection.retainAll(set2);\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  if (set1.isEmpty() || set2.isEmpty()) {\n    return set1;\n  }\n  Set<V> intersection = new HashSet<V>();\n  for (V v : set1) {\n    if (set2.contains(v)) {\n      intersection.add(v);\n    }\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  if (set1.size() == 0) {\n    return set2;\n  } else if (set2.size() == 0) {\n    return set1;\n  }\n  Set<V> intersection = new HashSet<V>();\n  for (V v : set1) {\n    if (set2.contains(v)) {\n      intersection.add(v);\n    }\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>(set1);\n  intersection.retainAll(set2);\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>();\n  for (V v : set1) {\n    if (set2.contains(v)) {\n      intersection.add(v);\n    }\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>();\n  Iterator<V> it1 = set1.iterator();\n  Iterator<V> it2 = set2.iterator();\n  while (it1.hasNext() && it2.hasNext()) {\n    V v1 = it1.next();\n    V v2 = it2.next();\n    if (v1.equals(v2)) {\n      intersection.add(v1);\n    }\n  }\n  return intersection;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<>();\n  for (V v : set1) {\n    if (set2.contains(v)) intersection.add(v);\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<>();\n  for (V v : set1) {\n    if (set2.contains(v)) {\n      intersection.add(v);\n    }\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>(set1);\n  intersection.retainAll(set2);\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<>(set1);\n  intersection.retainAll(set2);\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n", "method_name": "intersection", "codes": ["private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(set1); intersection.retainAll(set2); return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ if (set1.isEmpty() || set2.isEmpty()) { return set1; } Set<V> intersection = new HashSet<V>(); for (V v : set1) { if (set2.contains(v)) { intersection.add(v); } } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ if (set1.size() == 0) { return set2; } else if (set2.size() == 0) { return set1; } Set<V> intersection = new HashSet<V>(); for (V v : set1) { if (set2.contains(v)) { intersection.add(v); } } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(set1); intersection.retainAll(set2); return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(); for (V v : set1) { if (set2.contains(v)) { intersection.add(v); } } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(); Iterator<V> it1 = set1.iterator(); Iterator<V> it2 = set2.iterator(); while (it1.hasNext() && it2.hasNext()) { V v1 = it1.next(); V v2 = it2.next(); if (v1.equals(v2)) { intersection.add(v1); } } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<>(); for (V v : set1) { if (set2.contains(v)) intersection.add(v); } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<>(); for (V v : set1) { if (set2.contains(v)) { intersection.add(v); } } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(set1); intersection.retainAll(set2); return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<>(set1); intersection.retainAll(set2); return intersection; }"], "code_level": "slib_runnable", "_id": "636767611a6d9265ec018116", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  if (start == null) {\n    return null;\n  }\n  OuterFaceCirculator outer = null;\n  int i = 0;\n  while (i < numOuterFaces) {\n    if (predicate.apply(outerFaces.get(i))) {\n      outer = outerFaces.get(i);\n      break;\n    }\n    i++;\n  }\n  if (outer != null) {\n    if (dir == 0) {\n      if (stop.isInternalNode()) {\n        return outer;\n      } else {\n        Node node = stop.getNearestNodeTo(start);\n        if (node != null && predicate.apply(node)) {\n          return outer;\n        }\n      }\n    } else {\n      if (start.isInternalNode()) {\n        return outer;\n      } else {\n        Node node = start.getNearestNodeTo(stop);\n        if (node != null && predicate.apply(node)) {\n          return outer;\n        }\n      }\n    }\n  }\n  return outer;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  if (predicate.test(start)) {\n    return outerFaceCirculatorMap.get(dir);\n  } else {\n    return innerFaceCirculatorMap.get(dir);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  if (predicate.test(start) && predicate.test(stop)) {\n    switch (dir) {\n      case 0:\n        return new OuterFaceCirculator(start, stop);\n      case 1:\n        return new OuterFaceCirculator(stop, start);\n      default:\n        return new OuterFaceCirculator(start, stop);\n    }\n  } else {\n    return new OuterFaceCirculator(start, stop);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  if (predicate.test(start)) {\n    return new OuterFaceCirculator(start, stop, dir);\n  } else if (predicate.test(stop)) {\n    return new OuterFaceCirculator(stop, start, dir);\n  } else {\n    throw new IllegalArgumentException(\n        \"Cannot find a circulator between \" + start + \" and \" + stop);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  OuterFaceCirculator ret = null;\n  if (predicate.test(start)) {\n    ret = new OuterFaceCirculator(start, dir);\n  } else if (predicate.test(stop)) {\n    ret = new OuterFaceCirculator(stop, dir);\n  } else {\n    ret = new OuterFaceCirculator(start, dir);\n  }\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  if (predicate.test(start)) {\n    return OuterFaceCirculator.create(start, dir);\n  } else {\n    return OuterFaceCirculator.create(stop, dir);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  if (predicate.test(start)) {\n    return new OuterFaceCirculator(start, stop, dir);\n  } else if (predicate.test(stop)) {\n    return new OuterFaceCirculator(stop, start, dir);\n  } else {\n    return new OuterFaceCirculator(start, stop, dir);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  OuterFaceCirculator outerFaceCirculator = null;\n  for (Node node : getNodes(start, stop)) {\n    if (predicate.test(node)) {\n      if (outerFaceCirculator == null) {\n        outerFaceCirculator = new OuterFaceCirculator(node, dir);\n      } else {\n        outerFaceCirculator.addNode(node, dir);\n      }\n    }\n  }\n  return outerFaceCirculator;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  return new OuterFaceCirculator(predicate, start, stop, dir);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  if (start == stop) {\n    return OuterFaceCirculator.singleton(start);\n  } else {\n    Node n = start;\n    while (predicate.test(n)) {\n      n = pred.apply(n, dir);\n    }\n    return OuterFaceCirculator.singleton(n);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.\n * @param predicate the condition the desired node should satisfy\n * @param start the node to start the search from\n * @param stop the node to end the search with\n * @param dir the direction to start the traversal in\n * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node\n */\n", "method_name": "selectOnOuterFace", "codes": ["private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (start == null) { return null; } OuterFaceCirculator outer = null; int i = 0; while (i < numOuterFaces) { if (predicate.apply(outerFaces.get(i))) { outer = outerFaces.get(i); break; } i++; } if (outer != null) { if (dir == 0) { if (stop.isInternalNode()) { return outer; } else { Node node = stop.getNearestNodeTo(start); if (node != null && predicate.apply(node)) { return outer; } } } else { if (start.isInternalNode()) { return outer; } else { Node node = start.getNearestNodeTo(stop); if (node != null && predicate.apply(node)) { return outer; } } } } return outer; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (predicate.test(start)) { return outerFaceCirculatorMap.get(dir); } else { return innerFaceCirculatorMap.get(dir); } }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (predicate.test(start) && predicate.test(stop)) { switch(dir) { case 0: return new OuterFaceCirculator(start, stop); case 1: return new OuterFaceCirculator(stop, start); default: return new OuterFaceCirculator(start, stop); } } else { return new OuterFaceCirculator(start, stop); } }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (predicate.test(start)) { return new OuterFaceCirculator(start, stop, dir); } else if (predicate.test(stop)) { return new OuterFaceCirculator(stop, start, dir); } else { throw new IllegalArgumentException(\"Cannot find a circulator between \" + start + \" and \" + stop); } }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ OuterFaceCirculator ret = null; if (predicate.test(start)) { ret = new OuterFaceCirculator(start, dir); } else if (predicate.test(stop)) { ret = new OuterFaceCirculator(stop, dir); } else { ret = new OuterFaceCirculator(start, dir); } return ret; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (predicate.test(start)) { return OuterFaceCirculator.create(start, dir); } else { return OuterFaceCirculator.create(stop, dir); } }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (predicate.test(start)) { return new OuterFaceCirculator(start, stop, dir); } else if (predicate.test(stop)) { return new OuterFaceCirculator(stop, start, dir); } else { return new OuterFaceCirculator(start, stop, dir); } }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ OuterFaceCirculator outerFaceCirculator = null; for (Node node : getNodes(start, stop)) { if (predicate.test(node)) { if (outerFaceCirculator == null) { outerFaceCirculator = new OuterFaceCirculator(node, dir); } else { outerFaceCirculator.addNode(node, dir); } } } return outerFaceCirculator; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ return new OuterFaceCirculator(predicate, start, stop, dir); }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (start == stop) { return OuterFaceCirculator.singleton(start); } else { Node n = start; while (predicate.test(n)) { n = pred.apply(n, dir); } return OuterFaceCirculator.singleton(n); } }"], "code_level": "class_runnable", "_id": "636767511a6d9265ec017eb6", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "Edge edgeToNext() {\n  if (virtual) {\n    return new Edge(node, node);\n  } else {\n    return new Edge(node, virtualNode);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return edgeToNext(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return edgeToNext(node);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  if (node == virtual) return null;\n  return edges[node][edgeIndex++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return edgeToNext;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  if (next == null) return null;\n  return next.edgeTo(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return edgeToNext(node);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  if (node == null) {\n    return null;\n  }\n  return node.getNext();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return this.next;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  if (virtualNode != null) {\n    return new Edge(virtualNode, nextNode);\n  } else {\n    return new Edge(nextNode, virtualNode);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n", "method_name": "edgeToNext", "codes": ["Edge edgeToNext(){ if (virtual) { return new Edge(node, node); } else { return new Edge(node, virtualNode); } }", "Edge edgeToNext(){ return edgeToNext(this); }", "Edge edgeToNext(){ return edgeToNext(node); }", "Edge edgeToNext(){ if (node == virtual) return null; return edges[node][edgeIndex++]; }", "Edge edgeToNext(){ return edgeToNext; }", "Edge edgeToNext(){ if (next == null) return null; return next.edgeTo(this); }", "Edge edgeToNext(){ return edgeToNext(node); }", "Edge edgeToNext(){ if (node == null) { return null; } return node.getNext(); }", "Edge edgeToNext(){ return this.next; }", "Edge edgeToNext(){ if (virtualNode != null) { return new Edge(virtualNode, nextNode); } else { return new Edge(nextNode, virtualNode); } }"], "code_level": "class_runnable", "_id": "6367675d1a6d9265ec018082", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  return new GraphPath<>(graph, tour);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  GraphPath<V, E> path = new GraphPath<V, E>(graph.getNodeTypes());\n  for (E edge : tour) {\n    Node<V, E> from = graph.getNode(edge.getFrom());\n    Node<V, E> to = graph.getNode(edge.getTo());\n    path.addEdge(from, to);\n  }\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  GraphPath<V, E> path = new GraphPath<>();\n  for (E edge : tour) {\n    path.addEdge(edge);\n  }\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  Set<E> edges = new HashSet<>();\n  Set<V> vertices = new HashSet<>(tour.size());\n  for (E e : tour) {\n    vertices.add(e.getOrigin());\n    edges.add(e);\n  }\n  GraphPath<V, E> path = new GraphPath<>();\n  path.setEdges(edges);\n  path.setVertices(vertices);\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  GraphPath<V, E> path = new GraphPath<>();\n  for (E edge : tour) {\n    V source = graph.getSource(edge);\n    V target = graph.getTarget(edge);\n    path.addEdge(source, target);\n  }\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  GraphPath<V, E> gp = new GraphPath<V, E>(graph);\n  for (E e : tour) {\n    gp.addEdge(e, graph.getEdgeSource(e));\n    gp.addEdge(e, graph.getEdgeTarget(e));\n  }\n  return gp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  GraphPath<V, E> path = new GraphPath<>(graph);\n  Iterator<E> it = tour.iterator();\n  while (it.hasNext()) {\n    E e = it.next();\n    if (!path.contains(e)) {\n      path.add(e);\n    }\n  }\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  GraphPath<V, E> edgeSetToTour = new GraphPath<V, E>(graph);\n  for (E edge : tour) {\n    edgeSetToTour.addVertex(edge.getSource());\n    edgeSetToTour.addVertex(edge.getTarget());\n  }\n  return edgeSetToTour;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  Set<E> tourSet = new HashSet<E>(tour);\n  return new GraphPath<V, E>(tourSet, graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  Set<E> tourTmp = new HashSet<E>(tour);\n  GraphPath<V, E> path = new GraphPath<V, E>();\n  path.add(graph.getNode(tourTmp.iterator().next()));\n  while (tourTmp.size() > 0) {\n    path.add(graph.getNode(tourTmp.iterator().next()));\n    tourTmp.remove(tourTmp.iterator().next());\n  }\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n", "method_name": "edgeSetToTour", "codes": ["protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ return new GraphPath<>(graph, tour); }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ GraphPath<V,E> path = new GraphPath<V, E>(graph.getNodeTypes()); for (E edge : tour) { Node<V, E> from = graph.getNode(edge.getFrom()); Node<V, E> to = graph.getNode(edge.getTo()); path.addEdge(from, to); } return path; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ GraphPath<V,E> path = new GraphPath<>(); for (E edge : tour) { path.addEdge(edge); } return path; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ Set<E> edges = new HashSet<>(); Set<V> vertices = new HashSet<>(tour.size()); for (E e : tour) { vertices.add(e.getOrigin()); edges.add(e); } GraphPath<V,E> path = new GraphPath<>(); path.setEdges(edges); path.setVertices(vertices); return path; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ GraphPath<V,E> path = new GraphPath<>(); for (E edge : tour) { V source = graph.getSource(edge); V target = graph.getTarget(edge); path.addEdge(source, target); } return path; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ GraphPath<V,E> gp = new GraphPath<V, E>(graph); for (E e : tour) { gp.addEdge(e, graph.getEdgeSource(e)); gp.addEdge(e, graph.getEdgeTarget(e)); } return gp; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ GraphPath<V,E> path = new GraphPath<>(graph); Iterator<E> it = tour.iterator(); while (it.hasNext()) { E e = it.next(); if (!path.contains(e)) { path.add(e); } } return path; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ GraphPath<V,E> edgeSetToTour = new GraphPath<V, E>(graph); for (E edge : tour) { edgeSetToTour.addVertex(edge.getSource()); edgeSetToTour.addVertex(edge.getTarget()); } return edgeSetToTour; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ Set<E> tourSet = new HashSet<E>(tour); return new GraphPath<V, E>(tourSet, graph); }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ Set<E> tourTmp = new HashSet<E>(tour); GraphPath<V,E> path = new GraphPath<V, E>(); path.add(graph.getNode(tourTmp.iterator().next())); while (tourTmp.size() > 0) { path.add(graph.getNode(tourTmp.iterator().next())); tourTmp.remove(tourTmp.iterator().next()); } return path; }"], "code_level": "class_runnable", "_id": "636767561a6d9265ec017f7c", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  List<Integer> verticesToRemove = new ArrayList<>();\n  for (int i = 0; i < labels.size(); i++) {\n    if (bucketsByLabel.get(labels.get(i)).size() == 0) {\n      verticesToRemove.add(labels.get(i));\n    }\n  }\n  for (int i = 0; i < verticesToRemove.size(); i++) {\n    bucketsByLabel.remove(verticesToRemove.get(i));\n  }\n  for (int label : labels) {\n    bucketsByLabel.get(label).add(minLabel);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    if (labels.get(i) < minLabel) {\n      bucketsByLabel.get(i).remove(labels.get(i));\n    }\n  }\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    bucketsByLabel.get(i).add(0, labels.get(i));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (Set<Integer> bucket : bucketsByLabel) {\n    for (int label : bucket) {\n      if (labels.contains(label)) {\n        labels.remove(label);\n      }\n    }\n  }\n  if (labels.size() > 0) {\n    if (minLabel == -1) {\n      minLabel = labels.get(0);\n    } else if (labels.get(0) < minLabel) {\n      minLabel = labels.get(0);\n    }\n  }\n  for (int label : labels) {\n    if (label < minLabel) {\n      minLabel = label;\n    }\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (Set<Integer> bucket : bucketsByLabel) {\n    for (Integer label : bucket) {\n      if (labels.contains(label)) {\n        bucketsByLabel.get(label).remove(bucket);\n        labels.remove(label);\n      }\n    }\n  }\n  if (labels.size() > 0) {\n    bucketsByLabel.get(minLabel).addAll(labels);\n  } else {\n    bucketsByLabel.remove(minLabel);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    if (bucketsByLabel.get(i).size() == 0) continue;\n    bucketsByLabel.get(i).remove(minLabel);\n    bucketsByLabel.get(i).add(minLabel);\n    labels.set(minLabel, i);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    Set<Integer> bucket = bucketsByLabel.get(i);\n    for (int label : labels) {\n      if (bucket.contains(label)) {\n        bucket.remove(label);\n        bucket.add(minLabel);\n      }\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    if (bucketsByLabel.get(i).contains(minLabel)) {\n      bucketsByLabel.get(i).remove(minLabel);\n      if (bucketsByLabel.get(i).isEmpty()) {\n        bucketsByLabel.remove(i);\n        i--;\n      }\n    }\n  }\n  if (bucketsByLabel.isEmpty()) {\n    labels.add(0, minLabel);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    Set<Integer> bucket = bucketsByLabel.get(i);\n    int bucketLabel = labels.get(i);\n    if (bucketLabel >= minLabel) {\n      reload(bucket, labels, bucketLabel);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    if (bucketsByLabel.get(i).contains(minLabel)) {\n      bucketsByLabel.get(i).remove(Integer.valueOf(minLabel));\n      bucketsByLabel.get(i).add(0, minLabel);\n    }\n  }\n  for (int i = 0; i < labels.size(); i++) {\n    int label = labels.get(i);\n    for (int j = 0; j < bucketsByLabel.size(); j++) {\n      if (bucketsByLabel.get(j).contains(label)) {\n        bucketsByLabel.get(j).remove(Integer.valueOf(label));\n        bucketsByLabel.get(j).add(label);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    Set<Integer> bucket = bucketsByLabel.get(i);\n    if (bucket.size() == 0) {\n      bucketsByLabel.remove(i);\n      labels.remove(i);\n      i--;\n    } else if (bucket.size() == 1) {\n      bucket.add(minLabel);\n    } else {\n      bucket.remove(minLabel);\n      bucket.add(minLabel);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Moves all vertices from the bucket with label  {@code minLabel} to the bucket with label 0.Clears the bucket with label  {@code minLabel}. Updates the labeling accordingly.\n * @param bucketsByLabel the buckets vertices are stored in\n * @param labels the labels of the vertices\n * @param minLabel the minimum value of the non-empty bucket\n */\n", "method_name": "reload", "codes": ["private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ List<Integer> verticesToRemove = new ArrayList<>(); for (int i = 0; i < labels.size(); i++) { if (bucketsByLabel.get(labels.get(i)).size() == 0) { verticesToRemove.add(labels.get(i)); } } for (int i = 0; i < verticesToRemove.size(); i++) { bucketsByLabel.remove(verticesToRemove.get(i)); } for (int label : labels) { bucketsByLabel.get(label).add(minLabel); } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = 0; i < bucketsByLabel.size(); i++) { if (labels.get(i) < minLabel) { bucketsByLabel.get(i).remove(labels.get(i)); } } for (int i = 0; i < bucketsByLabel.size(); i++) { bucketsByLabel.get(i).add(0, labels.get(i)); } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (Set<Integer> bucket : bucketsByLabel) { for (int label : bucket) { if (labels.contains(label)) { labels.remove(label); } } } if (labels.size() > 0) { if (minLabel == -1) { minLabel = labels.get(0); } else if (labels.get(0) < minLabel) { minLabel = labels.get(0); } } for (int label : labels) { if (label < minLabel) { minLabel = label; } } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (Set<Integer> bucket : bucketsByLabel) { for (Integer label : bucket) { if (labels.contains(label)) { bucketsByLabel.get(label).remove(bucket); labels.remove(label); } } } if (labels.size() > 0) { bucketsByLabel.get(minLabel).addAll(labels); } else { bucketsByLabel.remove(minLabel); } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = 0; i < bucketsByLabel.size(); i++) { if (bucketsByLabel.get(i).size() == 0) continue; bucketsByLabel.get(i).remove(minLabel); bucketsByLabel.get(i).add(minLabel); labels.set(minLabel, i); } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = 0; i < bucketsByLabel.size(); i++) { Set<Integer> bucket = bucketsByLabel.get(i); for (int label : labels) { if (bucket.contains(label)) { bucket.remove(label); bucket.add(minLabel); } } } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = 0; i < bucketsByLabel.size(); i++) { if (bucketsByLabel.get(i).contains(minLabel)) { bucketsByLabel.get(i).remove(minLabel); if (bucketsByLabel.get(i).isEmpty()) { bucketsByLabel.remove(i); i--; } } } if (bucketsByLabel.isEmpty()) { labels.add(0, minLabel); } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = 0; i < bucketsByLabel.size(); i++) { Set<Integer> bucket = bucketsByLabel.get(i); int bucketLabel = labels.get(i); if (bucketLabel >= minLabel) { reload(bucket, labels, bucketLabel); } } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = 0; i < bucketsByLabel.size(); i++) { if (bucketsByLabel.get(i).contains(minLabel)) { bucketsByLabel.get(i).remove(Integer.valueOf(minLabel)); bucketsByLabel.get(i).add(0, minLabel); } } for (int i = 0; i < labels.size(); i++) { int label = labels.get(i); for (int j = 0; j < bucketsByLabel.size(); j++) { if (bucketsByLabel.get(j).contains(label)) { bucketsByLabel.get(j).remove(Integer.valueOf(label)); bucketsByLabel.get(j).add(label); } } } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = 0; i < bucketsByLabel.size(); i++) { Set<Integer> bucket = bucketsByLabel.get(i); if (bucket.size() == 0) { bucketsByLabel.remove(i); labels.remove(i); i--; } else if (bucket.size() == 1) { bucket.add(minLabel); } else { bucket.remove(minLabel); bucket.add(minLabel); } } }"], "code_level": "self_contained", "_id": "636767641a6d9265ec018190", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\nprotected V provideNextVertex() {\n  return graph.next();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  return vertex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  return vertex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  V v = null;\n  while (v == null) {\n    if (!iter.hasNext()) {\n      iter = vertices.iterator();\n    }\n    v = iter.next();\n    if (!iter.hasNext()) {\n      iter = vertices.iterator();\n    }\n  }\n  return v;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  return vertices.poll();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  return getVertex();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  return (V) vertices.get(currentIndex++);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  return vertexIterator.next();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  while (true) {\n    V v = vIterator.next();\n    if (!visited.contains(v)) {\n      return v;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * {@inheritDoc}\n */\n", "method_name": "provideNextVertex", "codes": ["@Override protected V provideNextVertex(){ return graph.next(); }", "@Override protected V provideNextVertex(){ return vertex; }", "@Override protected V provideNextVertex(){ return vertex; }", "@Override protected V provideNextVertex(){ V v = null; while (v == null) { if (!iter.hasNext()) { iter = vertices.iterator(); } v = iter.next(); if (!iter.hasNext()) { iter = vertices.iterator(); } } return v; }", "@Override protected V provideNextVertex(){ return vertices.poll(); }", "@Override protected V provideNextVertex(){ return getVertex(); }", "@Override protected V provideNextVertex(){ return null; }", "@Override protected V provideNextVertex(){ return (V) vertices.get(currentIndex++); }", "@Override protected V provideNextVertex(){ return vertexIterator.next(); }", "@Override protected V provideNextVertex(){ while (true) { V v = vIterator.next(); if (!visited.contains(v)) { return v; } } }"], "code_level": "class_runnable", "_id": "636767611a6d9265ec018112", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> globalSeparatorList = new ArrayList<>();\n  for (E edge : graph.getEdges()) {\n    if (!globalSeparatorList.contains(new Pair<>(graph.getNeighborList(edge), edge))) {\n      globalSeparatorList.add(new Pair<>(graph.getNeighborList(edge), edge));\n    }\n  }\n  return globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  if (globalSeparatorList == null) {\n    List<Pair<List<Pair<Integer, Integer>>, E>> l =\n        new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n    for (E e : graph.edgeSet()) {\n      if (e.isDirected()) {\n        List<Pair<Integer, Integer>> l0 = new ArrayList<Pair<Integer, Integer>>();\n        for (int v = 0; v < graph.vertices(); v++) {\n          if (graph.getEdgeWeight(e, v) == 0) {\n            l0.add(new Pair<Integer, Integer>(v, 0));\n          }\n        }\n        l.add(new Pair<List<Pair<Integer, Integer>>, E>(l0, e));\n      }\n    }\n    globalSeparatorList = l;\n  }\n  return globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> globalSeparatorList = new ArrayList<>();\n  for (E edge : graph.getEdges()) {\n    List<Pair<Integer, Integer>> minimalSeparators = new ArrayList<>();\n    for (int v = 0; v < graph.getVerticesCount(); v++) {\n      if (graph.getEdge(edge, v) != null) {\n        if (graph.getEdge(edge, v).getDistance() == 0) {\n          continue;\n        }\n        if (graph.getEdge(edge, v).getDistance()\n            > graph.getEdge(edge, v).getDistance() + graph.getEdge(edge, v).getWeight()) {\n          minimalSeparators.add(\n              new Pair<>(\n                  v, graph.getEdge(edge, v).getDistance() + graph.getEdge(edge, v).getWeight()));\n        }\n      }\n    }\n    globalSeparatorList.add(new Pair<>(minimalSeparators, edge));\n  }\n  return globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> l = new ArrayList<>();\n  for (int v = 0; v < numVertices; v++) {\n    for (E e : vertices.get(v).edges) {\n      if (e.getWeight() < 0) {\n        continue;\n      }\n      List<Pair<Integer, Integer>> l1 = l.stream().map(Pair::new).collect(Collectors.toList());\n      l1.add(Pair.of(e.getVertex(), e.getWeight()));\n      l.add(Pair.of(l1, e));\n    }\n  }\n  return l;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> result = new ArrayList<>();\n  for (E edge : graph.getEdges()) {\n    Pair<List<Pair<Integer, Integer>>, E> pair = computeSeparatorList(edge);\n    result.add(pair);\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> globalSeparatorList = new ArrayList<>();\n  for (E edge : graph.getEdges()) {\n    for (E edge2 : graph.getEdges()) {\n      if (!edge.equals(edge2)) {\n        if (edge.getNeighbors().contains(edge2)) {\n          for (E edge3 : graph.getEdges()) {\n            if (!edge.equals(edge3) && !edge2.equals(edge3) && !edge3.equals(edge)) {\n              if (!edge.getNeighbors().contains(edge3)\n                  && !edge2.getNeighbors().contains(edge3)\n                  && !edge3.getNeighbors().contains(edge)) {\n                List<Pair<Integer, Integer>> minimalSeparatorList = new ArrayList<>();\n                minimalSeparatorList.add(\n                    new Pair<>(\n                        edge.getNeighbors().indexOf(edge2), edge2.getNeighbors().indexOf(edge3)));\n                minimalSeparatorList.add(\n                    new Pair<>(\n                        edge2.getNeighbors().indexOf(edge3), edge3.getNeighbors().indexOf(edge)));\n                minimalSeparatorList.add(\n                    new Pair<>(\n                        edge3.getNeighbors().indexOf(edge), edge.getNeighbors().indexOf(edge2)));\n                globalSeparatorList.add(new Pair<>(minimalSeparatorList, edge));\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> globalSeparatorList =\n      new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n  for (E edge : graph.edges()) {\n    int v = edge.from();\n    int e = edge.to();\n    if (!graph.isDirected() && v == e) continue;\n    List<Pair<List<Pair<Integer, Integer>>, E>> l =\n        new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n    l.add(\n        new Pair<List<Pair<Integer, Integer>>, E>(new ArrayList<Pair<Integer, Integer>>(), edge));\n    l.add(\n        new Pair<List<Pair<Integer, Integer>>, E>(new ArrayList<Pair<Integer, Integer>>(), edge));\n    l.add(\n        new Pair<List<Pair<Integer, Integer>>, E>(new ArrayList<Pair<Integer, Integer>>(), edge));\n    globalSeparatorList.add(new Pair<List<Pair<Integer, Integer>>, E>(l, edge));\n  }\n  return globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> result = new ArrayList<>();\n  for (int i = 0; i < graph.getVerticesCount(); i++) {\n    for (int j = i + 1; j < graph.getVerticesCount(); j++) {\n      for (int k = j + 1; k < graph.getVerticesCount(); k++) {\n        List<Pair<Integer, Integer>> separators = new ArrayList<>();\n        separators.add(new Pair<>(i, j));\n        separators.add(new Pair<>(j, k));\n        if (!graph.getNeighborhood(i, j).contains(k)) {\n          separators.add(new Pair<>(k, i));\n        }\n        if (!graph.getNeighborhood(j, k).contains(i)) {\n          separators.add(new Pair<>(i, k));\n        }\n        if (!graph.getNeighborhood(k, i).contains(j)) {\n          separators.add(new Pair<>(j, k));\n        }\n        if (!graph.getNeighborhood(k, j).contains(i)) {\n          separators.add(new Pair<>(i, j));\n        }\n        result.add(new Pair<>(separators, graph.getNeighborhood(i, j)));\n      }\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> result = new ArrayList<>();\n  for (Pair<List<Pair<Integer, Integer>>, E> e : getSeparators()) {\n    if (e.getFirst().size() > 1) {\n      result.add(e);\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> res = new ArrayList<>();\n  for (E e : graph) {\n    if (!res.contains(new Pair<>(new ArrayList<>(), e))) {\n      List<Pair<Integer, Integer>> lst = new ArrayList<>();\n      lst.add(new Pair<>(0, 0));\n      res.add(new Pair<>(lst, e));\n    }\n  }\n  for (int i = 0; i < res.size(); i++) {\n    for (int j = i + 1; j < res.size(); j++) {\n      if (res.get(i).getValue().getLeft() == res.get(j).getValue().getLeft()) {\n        List<Pair<Integer, Integer>> lst1 = res.get(i).getValue().getLeft();\n        List<Pair<Integer, Integer>> lst2 = res.get(j).getValue().getLeft();\n        if (lst1.size() < lst2.size()) {\n          List<Pair<Integer, Integer>> lst3 = res.get(i).getValue().getLeft();\n          res.set(i, new Pair<>(lst3, res.get(j).getValue()));\n          res.set(j, new Pair<>(lst2, res.get(i).getValue()));\n        } else if (lst2.size() < lst1.size()) {\n          List<Pair<Integer, Integer>> lst3 = res.get(j).getValue().getLeft();\n          res.set(j, new Pair<>(lst2, res.get(i).getValue()));\n          res.set(i, new Pair<>(lst1, res.get(j).getValue()));\n        } else {\n          if (lst1.size() == lst2.size()) {\n            for (int k = 0; k < lst1.size(); k++) {\n              if (lst1.get(k).getLeft() < lst2.get(k).getLeft()) {\n                res.set(i, new Pair<>(lst1, res.get(j).getValue()));\n                res.set(j, new Pair<>(lst2, res.get(i).getValue()));\n                break;\n              }\n            }\n          } else {\n            res.set(i, new Pair<>(lst2, res.get(j).getValue()));\n            res.set(j, new Pair<>(lst1, res.get(i).getValue()));\n          }\n        }\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates\n * @return the list of minimal separators of every edge $e$ in the inspected graph\n */\n", "method_name": "computeGlobalSeparatorList", "codes": ["private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<>(); for (E edge : graph.getEdges()) { if (!globalSeparatorList.contains(new Pair<>(graph.getNeighborList(edge), edge))) { globalSeparatorList.add(new Pair<>(graph.getNeighborList(edge), edge)); } } return globalSeparatorList; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ if (globalSeparatorList == null) { List<Pair<List<Pair<Integer,Integer>>,E>> l = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); for (E e : graph.edgeSet()) { if (e.isDirected()) { List<Pair<Integer,Integer>> l0 = new ArrayList<Pair<Integer,Integer>>(); for (int v = 0; v < graph.vertices(); v++) { if (graph.getEdgeWeight(e, v) == 0) { l0.add(new Pair<Integer, Integer>(v, 0)); } } l.add(new Pair<List<Pair<Integer,Integer>>,E>(l0, e)); } } globalSeparatorList = l; } return globalSeparatorList; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<>(); for (E edge : graph.getEdges()) { List<Pair<Integer, Integer>> minimalSeparators = new ArrayList<>(); for (int v = 0; v < graph.getVerticesCount(); v++) { if (graph.getEdge(edge, v) != null) { if (graph.getEdge(edge, v).getDistance() == 0) { continue; } if (graph.getEdge(edge, v).getDistance() > graph.getEdge(edge, v).getDistance() + graph.getEdge(edge, v).getWeight()) { minimalSeparators.add(new Pair<>(v, graph.getEdge(edge, v).getDistance() + graph.getEdge(edge, v).getWeight())); } } } globalSeparatorList.add(new Pair<>(minimalSeparators, edge)); } return globalSeparatorList; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> l = new ArrayList<>(); for (int v = 0; v < numVertices; v++) { for (E e : vertices.get(v).edges) { if (e.getWeight() < 0) { continue; } List<Pair<Integer,Integer>> l1 = l.stream().map(Pair::new).collect(Collectors.toList()); l1.add(Pair.of(e.getVertex(), e.getWeight())); l.add(Pair.of(l1, e)); } } return l; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> result = new ArrayList<>(); for (E edge : graph.getEdges()) { Pair<List<Pair<Integer, Integer>>,E> pair = computeSeparatorList(edge); result.add(pair); } return result; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<>(); for (E edge : graph.getEdges()) { for (E edge2 : graph.getEdges()) { if (!edge.equals(edge2)) { if (edge.getNeighbors().contains(edge2)) { for (E edge3 : graph.getEdges()) { if (!edge.equals(edge3) && !edge2.equals(edge3) && !edge3.equals(edge)) { if (!edge.getNeighbors().contains(edge3) && !edge2.getNeighbors().contains(edge3) && !edge3.getNeighbors().contains(edge)) { List<Pair<Integer, Integer>> minimalSeparatorList = new ArrayList<>(); minimalSeparatorList.add(new Pair<>(edge.getNeighbors().indexOf(edge2), edge2.getNeighbors().indexOf(edge3))); minimalSeparatorList.add(new Pair<>(edge2.getNeighbors().indexOf(edge3), edge3.getNeighbors().indexOf(edge))); minimalSeparatorList.add(new Pair<>(edge3.getNeighbors().indexOf(edge), edge.getNeighbors().indexOf(edge2))); globalSeparatorList.add(new Pair<>(minimalSeparatorList, edge)); } } } } } } } return globalSeparatorList; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer, Integer>>,E>> globalSeparatorList = new ArrayList<Pair<List<Pair<Integer, Integer>>,E>>(); for (E edge : graph.edges()) { int v = edge.from(); int e = edge.to(); if (!graph.isDirected() && v == e) continue; List<Pair<List<Pair<Integer, Integer>>,E>> l = new ArrayList<Pair<List<Pair<Integer, Integer>>,E>>(); l.add(new Pair<List<Pair<Integer, Integer>>,E>(new ArrayList<Pair<Integer, Integer>>(), edge)); l.add(new Pair<List<Pair<Integer, Integer>>,E>(new ArrayList<Pair<Integer, Integer>>(), edge)); l.add(new Pair<List<Pair<Integer, Integer>>,E>(new ArrayList<Pair<Integer, Integer>>(), edge)); globalSeparatorList.add(new Pair<List<Pair<Integer, Integer>>,E>(l, edge)); } return globalSeparatorList; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> result = new ArrayList<>(); for (int i = 0; i < graph.getVerticesCount(); i++) { for (int j = i + 1; j < graph.getVerticesCount(); j++) { for (int k = j + 1; k < graph.getVerticesCount(); k++) { List<Pair<Integer, Integer>> separators = new ArrayList<>(); separators.add(new Pair<>(i, j)); separators.add(new Pair<>(j, k)); if (!graph.getNeighborhood(i, j).contains(k)) { separators.add(new Pair<>(k, i)); } if (!graph.getNeighborhood(j, k).contains(i)) { separators.add(new Pair<>(i, k)); } if (!graph.getNeighborhood(k, i).contains(j)) { separators.add(new Pair<>(j, k)); } if (!graph.getNeighborhood(k, j).contains(i)) { separators.add(new Pair<>(i, j)); } result.add(new Pair<>(separators, graph.getNeighborhood(i, j))); } } } return result; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer, Integer>>,E>> result = new ArrayList<>(); for (Pair<List<Pair<Integer, Integer>>,E> e : getSeparators()) { if (e.getFirst().size() > 1) { result.add(e); } } return result; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> res = new ArrayList<>(); for (E e : graph) { if (!res.contains(new Pair<>(new ArrayList<>(), e))) { List<Pair<Integer,Integer>> lst = new ArrayList<>(); lst.add(new Pair<>(0, 0)); res.add(new Pair<>(lst, e)); } } for (int i = 0; i < res.size(); i++) { for (int j = i + 1; j < res.size(); j++) { if (res.get(i).getValue().getLeft() == res.get(j).getValue().getLeft()) { List<Pair<Integer,Integer>> lst1 = res.get(i).getValue().getLeft(); List<Pair<Integer,Integer>> lst2 = res.get(j).getValue().getLeft(); if (lst1.size() < lst2.size()) { List<Pair<Integer,Integer>> lst3 = res.get(i).getValue().getLeft(); res.set(i, new Pair<>(lst3, res.get(j).getValue())); res.set(j, new Pair<>(lst2, res.get(i).getValue())); } else if (lst2.size() < lst1.size()) { List<Pair<Integer,Integer>> lst3 = res.get(j).getValue().getLeft(); res.set(j, new Pair<>(lst2, res.get(i).getValue())); res.set(i, new Pair<>(lst1, res.get(j).getValue())); } else { if (lst1.size() == lst2.size()) { for (int k = 0; k < lst1.size(); k++) { if (lst1.get(k).getLeft() < lst2.get(k).getLeft()) { res.set(i, new Pair<>(lst1, res.get(j).getValue())); res.set(j, new Pair<>(lst2, res.get(i).getValue())); break; } } } else { res.set(i, new Pair<>(lst2, res.get(j).getValue())); res.set(j, new Pair<>(lst1, res.get(i).getValue())); } } } } } }"], "code_level": "class_runnable", "_id": "636767601a6d9265ec0180e2", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  long sum = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    int j = bounds.get(i);\n    sum += j;\n  }\n  List<Integer> suffixSumList = new ArrayList<>();\n  long sumOfSuffixSums = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    int j = bounds.get(i);\n    sumOfSuffixSums += j;\n    suffixSumList.add(j);\n  }\n  return Pair.of(suffixSumList, sumOfSuffixSums);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  Pair<List<Integer>, Long> result = new Pair<List<Integer>, Long>(new ArrayList<Integer>(), 0L);\n  for (int i = bounds.size() - 1; i >= 0; i--) {\n    int num = bounds.get(i);\n    List<Integer> newBounds = new ArrayList<Integer>(bounds);\n    newBounds.remove(i);\n    result.setFirst(newBounds);\n    result.setSecond(result.getSecond() + num);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  if (bounds == null) {\n    throw new IllegalArgumentException(\"Cannot compute suffix sum of null list.\");\n  }\n  if (bounds.isEmpty()) {\n    return new Pair<>(Collections.emptyList(), 0L);\n  }\n  List<Integer> suffix = computeSuffix(bounds);\n  List<Long> sum = computeSuffixSum(bounds.subList(0, bounds.size() - 1));\n  return new Pair<>(suffix, sum.stream().reduce((a, b) -> a + b).get());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  long sum = 0;\n  for (int i = bounds.size() - 1; i >= 0; i--) {\n    sum += bounds.get(i);\n  }\n  List<Integer> suffixList = new ArrayList<>(bounds.size());\n  for (int i = bounds.size() - 1; i >= 0; i--) {\n    suffixList.add(bounds.get(i));\n  }\n  return Pair.of(suffixList, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  long sum = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    int a = bounds.get(i);\n    int b = bounds.get(i + 1);\n    sum += a * b;\n  }\n  return Pair.of(bounds, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  Pair<List<Integer>, Long> result = new Pair<>();\n  long sum = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    sum += bounds.get(i);\n  }\n  result.first = new ArrayList<>(bounds.size());\n  result.second = sum;\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  int n = bounds.size();\n  int[] s = new int[n];\n  Arrays.fill(s, 0);\n  for (int i = 0; i < n; i++) {\n    int v = bounds.get(i);\n    for (int j = i + 1; j < n; j++) {\n      if (v == bounds.get(j)) {\n        s[i]++;\n        s[j]++;\n      }\n    }\n  }\n  List<Integer> res = new ArrayList<>(n);\n  Arrays.fill(s, 0);\n  long sum = 0;\n  for (int i = 0; i < n; i++) {\n    if (s[i] > 0) {\n      res.add(i);\n      sum += s[i] * s[i];\n    }\n  }\n  return new Pair<>(res, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  List<Integer> suffixSum = new ArrayList<>();\n  List<Long> sums = new ArrayList<>();\n  long sum = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    sum += bounds.get(i);\n    suffixSum.add(sum);\n    sums.add(sum);\n  }\n  Collections.sort(suffixSum);\n  Collections.sort(sums);\n  List<Integer> suffixSumList = new ArrayList<>();\n  for (int i = 0; i < suffixSum.size(); i++) {\n    suffixSumList.add(suffixSum.get(i));\n  }\n  List<Long> sumsList = new ArrayList<>();\n  for (int i = 0; i < sums.size(); i++) {\n    sumsList.add(sums.get(i));\n  }\n  return new Pair<>(suffixSumList, sumsList);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  long sum = 0;\n  for (int i = bounds.size() - 1; i >= 0; i--) {\n    sum += bounds.get(i);\n  }\n  return Pair.of(bounds, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  List<Integer> suffixSumList = new ArrayList<>();\n  Long sum = 0L;\n  for (int i = bounds.size() - 1; i >= 0; i--) {\n    Integer a = bounds.get(i);\n    Integer b = bounds.get(i - 1);\n    if (a < b) {\n      suffixSumList.add(a);\n    } else {\n      suffixSumList.add(b);\n      sum += (long) a;\n    }\n  }\n  return new Pair<>(suffixSumList, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.\n * @param bounds list of integers.\n * @return computed pair of suffix sum list and a sum of all elements.\n */\n", "method_name": "computeSuffixSum", "codes": ["private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ long sum = 0; for (int i = 0; i < bounds.size(); i++) { int j = bounds.get(i); sum += j; } List<Integer> suffixSumList = new ArrayList<>(); long sumOfSuffixSums = 0; for (int i = 0; i < bounds.size(); i++) { int j = bounds.get(i); sumOfSuffixSums += j; suffixSumList.add(j); } return Pair.of(suffixSumList, sumOfSuffixSums); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ Pair<List<Integer>,Long> result = new Pair<List<Integer>,Long>(new ArrayList<Integer>(), 0L); for (int i = bounds.size() - 1; i >= 0; i--) { int num = bounds.get(i); List<Integer> newBounds = new ArrayList<Integer>(bounds); newBounds.remove(i); result.setFirst(newBounds); result.setSecond(result.getSecond() + num); } return result; }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ if (bounds == null) { throw new IllegalArgumentException(\"Cannot compute suffix sum of null list.\"); } if (bounds.isEmpty()) { return new Pair<>(Collections.emptyList(), 0L); } List<Integer> suffix = computeSuffix(bounds); List<Long> sum = computeSuffixSum(bounds.subList(0, bounds.size() - 1)); return new Pair<>(suffix, sum.stream().reduce((a, b) -> a + b).get()); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ long sum = 0; for (int i = bounds.size() - 1; i >= 0; i--) { sum += bounds.get(i); } List<Integer> suffixList = new ArrayList<>(bounds.size()); for (int i = bounds.size() - 1; i >= 0; i--) { suffixList.add(bounds.get(i)); } return Pair.of(suffixList, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ long sum = 0; for (int i = 0; i < bounds.size(); i++) { int a = bounds.get(i); int b = bounds.get(i + 1); sum += a * b; } return Pair.of(bounds, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ Pair<List<Integer>,Long> result = new Pair<>(); long sum = 0; for (int i = 0; i < bounds.size(); i++) { sum += bounds.get(i); } result.first = new ArrayList<>(bounds.size()); result.second = sum; return result; }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ int n = bounds.size(); int[] s = new int[n]; Arrays.fill(s, 0); for (int i = 0; i < n; i++) { int v = bounds.get(i); for (int j = i + 1; j < n; j++) { if (v == bounds.get(j)) { s[i]++; s[j]++; } } } List<Integer> res = new ArrayList<>(n); Arrays.fill(s, 0); long sum = 0; for (int i = 0; i < n; i++) { if (s[i] > 0) { res.add(i); sum += s[i] * s[i]; } } return new Pair<>(res, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ List<Integer> suffixSum = new ArrayList<>(); List<Long> sums = new ArrayList<>(); long sum = 0; for (int i = 0; i < bounds.size(); i++) { sum += bounds.get(i); suffixSum.add(sum); sums.add(sum); } Collections.sort(suffixSum); Collections.sort(sums); List<Integer> suffixSumList = new ArrayList<>(); for (int i = 0; i < suffixSum.size(); i++) { suffixSumList.add(suffixSum.get(i)); } List<Long> sumsList = new ArrayList<>(); for (int i = 0; i < sums.size(); i++) { sumsList.add(sums.get(i)); } return new Pair<>(suffixSumList, sumsList); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ long sum = 0; for (int i = bounds.size() - 1; i >= 0; i--) { sum += bounds.get(i); } return Pair.of(bounds, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ List<Integer> suffixSumList = new ArrayList<>(); Long sum = 0L; for (int i = bounds.size() - 1; i >= 0; i--) { Integer a = bounds.get(i); Integer b = bounds.get(i - 1); if (a < b) { suffixSumList.add(a); } else { suffixSumList.add(b); sum += (long) a; } } return new Pair<>(suffixSumList, sum); }"], "code_level": "project_runnable", "_id": "636767461a6d9265ec017d0e", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<Integer>();\n  for (K key : keys) {\n    lowerBounds.add(this.lowerBounds.get(key));\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  for (K key : keys) {\n    Integer lowerBound = map.get(key);\n    if (lowerBound != null) {\n      lowerBounds.add(lowerBound);\n    }\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>(keys.size());\n  for (K key : keys) {\n    lowerBounds.add(getKeyLowerBound(key));\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  int size = keys.size();\n  List<Integer> lowerBounds = new ArrayList<>(size);\n  for (int i = 0; i < size; i++) {\n    int n = i;\n    for (int j = i + 1; j < size; j++) {\n      if (compare(keys.get(i), keys.get(j)) > 0) {\n        n = j;\n      }\n    }\n    int tmp = keys.get(i);\n    keys.set(i, keys.get(n));\n    keys.set(n, tmp);\n    lowerBounds.add(n);\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  for (K key : keys) {\n    int lowerBound = computeLowerBound(key);\n    lowerBounds.add(lowerBound);\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<Integer>();\n  for (K key : keys) {\n    lowerBounds.add(computeLowerBound(key));\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lb = new ArrayList<>();\n  for (int i = 0; i < keys.size(); i++) {\n    if (!lb.contains(i)) {\n      lb.add(i);\n    }\n  }\n  return lb;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>(keys.size());\n  for (K key : keys) {\n    lowerBounds.add(this.lowerBounds.get(key));\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  int n = keys.size();\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      for (int k = j + 1; k < n; k++) {\n        lowerBounds.add(keys.get(i).compareTo(keys.get(j)) > 0 ? keys.get(i) : keys.get(j));\n        lowerBounds.add(keys.get(i).compareTo(keys.get(k)) > 0 ? keys.get(j) : keys.get(k));\n      }\n    }\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  for (int i = 0; i < keys.size(); i++) {\n    lowerBounds.add(i);\n  }\n  return lowerBounds;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n", "method_name": "computeLowerBounds", "codes": ["private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<Integer>(); for (K key : keys) { lowerBounds.add(this.lowerBounds.get(key)); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); for (K key : keys) { Integer lowerBound = map.get(key); if (lowerBound != null) { lowerBounds.add(lowerBound); } } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(keys.size()); for (K key : keys) { lowerBounds.add(getKeyLowerBound(key)); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ int size = keys.size(); List<Integer> lowerBounds = new ArrayList<>(size); for (int i = 0; i < size; i++) { int n = i; for (int j = i + 1; j < size; j++) { if (compare(keys.get(i), keys.get(j)) > 0) { n = j; } } int tmp = keys.get(i); keys.set(i, keys.get(n)); keys.set(n, tmp); lowerBounds.add(n); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); for (K key : keys) { int lowerBound = computeLowerBound(key); lowerBounds.add(lowerBound); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<Integer>(); for (K key : keys) { lowerBounds.add(computeLowerBound(key)); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lb = new ArrayList<>(); for (int i = 0; i < keys.size(); i++) { if (!lb.contains(i)) { lb.add(i); } } return lb; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(keys.size()); for (K key : keys) { lowerBounds.add(this.lowerBounds.get(key)); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); int n = keys.size(); for (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { for (int k = j + 1; k < n; k++) { lowerBounds.add(keys.get(i).compareTo(keys.get(j)) > 0 ? keys.get(i) : keys.get(j)); lowerBounds.add(keys.get(i).compareTo(keys.get(k)) > 0 ? keys.get(j) : keys.get(k)); } } } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); for (int i = 0; i < keys.size(); i++) { lowerBounds.add(i); } return lowerBounds; }"], "code_level": "class_runnable", "_id": "636767431a6d9265ec017c88", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<Integer>();\n  for (int i = 0; i < keys.size(); i++) {\n    upperBounds.add(i);\n  }\n  return upperBounds;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>(keys.size());\n  for (int i = 0; i < keys.size(); i++) {\n    upperBounds.add(i);\n  }\n  for (int i = 0; i < keys.size(); i++) {\n    for (int j = i + 1; j < keys.size(); j++) {\n      if (keys.get(i).compareTo(keys.get(j)) > 0) {\n        upperBounds.set(j, i);\n      }\n    }\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>(keys.size());\n  for (K key : keys) {\n    upperBounds.add(getUpperBound(key));\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  return keys.stream().map(this::getUpperBound).sorted().collect(Collectors.toList());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>(keys.size());\n  for (int i = 0; i < keys.size(); i++) {\n    upperBounds.add(i);\n  }\n  Collections.sort(upperBounds);\n  return upperBounds;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<Integer>();\n  int n = keys.size();\n  for (int i = 0; i < n; i++) {\n    int j = i;\n    while (j >= 0 && keys.get(j).compareTo(keys.get(i)) < 0) {\n      upperBounds.add(j + 1, i);\n      j--;\n    }\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<Integer>();\n  int smallest = Integer.MAX_VALUE;\n  for (K key : keys) {\n    int upperBound = Math.min(key.getKey(), smallest);\n    upperBounds.add(upperBound);\n    smallest = Math.min(upperBound, smallest);\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>();\n  for (K key : keys) {\n    int upperBound = Math.min(getKeyLowerBound(key), key.getBound());\n    upperBounds.add(upperBound);\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>(keys.size());\n  for (K key : keys) {\n    upperBounds.add(getUpperBound(key));\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> result = new ArrayList<Integer>();\n  for (int i = 0; i < keys.size(); i++) {\n    Integer upperBound =\n        i == 0\n            ? null\n            : keys.get(i).compareTo(keys.get(i - 1)) > 0\n                ? null\n                : keys.get(i).compareTo(keys.get(i - 1)) + 1;\n    result.add(upperBound);\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n", "method_name": "computeUpperBounds", "codes": ["private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<Integer>(); for (int i = 0; i < keys.size(); i++) { upperBounds.add(i); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(keys.size()); for (int i = 0; i < keys.size(); i++) { upperBounds.add(i); } for (int i = 0; i < keys.size(); i++) { for (int j = i + 1; j < keys.size(); j++) { if (keys.get(i).compareTo(keys.get(j)) > 0) { upperBounds.set(j, i); } } } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(keys.size()); for (K key : keys) { upperBounds.add(getUpperBound(key)); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ return keys.stream().map(this::getUpperBound).sorted().collect(Collectors.toList()); }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(keys.size()); for (int i = 0; i < keys.size(); i++) { upperBounds.add(i); } Collections.sort(upperBounds); return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<Integer>(); int n = keys.size(); for (int i = 0; i < n; i++) { int j = i; while (j >= 0 && keys.get(j).compareTo(keys.get(i)) < 0) { upperBounds.add(j + 1, i); j--; } } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<Integer>(); int smallest = Integer.MAX_VALUE; for (K key : keys) { int upperBound = Math.min(key.getKey(), smallest); upperBounds.add(upperBound); smallest = Math.min(upperBound, smallest); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(); for (K key : keys) { int upperBound = Math.min(getKeyLowerBound(key), key.getBound()); upperBounds.add(upperBound); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(keys.size()); for (K key : keys) { upperBounds.add(getUpperBound(key)); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> result = new ArrayList<Integer>(); for (int i = 0; i < keys.size(); i++) { Integer upperBound = i == 0 ? null : keys.get(i).compareTo(keys.get(i - 1)) > 0 ? null : keys.get(i).compareTo(keys.get(i - 1)) + 1; result.add(upperBound); } return result; }"], "code_level": "class_runnable", "_id": "636767581a6d9265ec017fb4", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (vertices.size() == 0) return true;\n  Set<V> visited = new HashSet<>();\n  Set<V> nodes = new HashSet<>();\n  Set<V> marked = new HashSet<>();\n  for (V v : vertices) {\n    if (!visited.contains(v)) {\n      if (!nodes.contains(v)) {\n        if (!marked.contains(v)) {\n          if (isClique(graph, v, nodes, marked, visited)) return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (vertices.size() < 2) {\n    return false;\n  }\n  Set<V> visited = new HashSet<V>();\n  for (V v : vertices) {\n    if (!visited.add(v)) {\n      return false;\n    }\n  }\n  Set<V> verticesToVisit = new HashSet<V>(vertices);\n  while (verticesToVisit.size() > 1) {\n    Set<V> newVertices = new HashSet<V>();\n    for (V v : verticesToVisit) {\n      for (V u : verticesToVisit) {\n        if (!visited.contains(u) && graph.hasEdge(v, u)) {\n          newVertices.add(u);\n        }\n      }\n    }\n    verticesToVisit = newVertices;\n  }\n  return verticesToVisit.size() == 1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  boolean ret = true;\n  Set<V> verticesClique = new HashSet<V>(graph.vertexSet());\n  verticesClique.retainAll(vertices);\n  for (V v : verticesClique) {\n    if (!graph.outgoingEdgesOf(v).isEmpty()) {\n      ret = false;\n      break;\n    }\n  }\n  return ret;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  boolean[][] adjacencyMatrix = graph.getAdjacencyMatrix();\n  for (V v : vertices) {\n    if (!adjacencyMatrix[vertices.size()][v]) return false;\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (vertices.isEmpty()) return true;\n  Set<V> verticesToInduce = new HashSet<V>(vertices);\n  Set<V> verticesToInduceFrom = new HashSet<V>(graph.vertices());\n  verticesToInduceFrom.removeAll(verticesToInduce);\n  if (verticesToInduceFrom.isEmpty()) return false;\n  for (V vertex : verticesToInduceFrom) {\n    if (vertices.contains(vertex)) continue;\n    verticesToInduce.remove(vertex);\n    if (isClique(graph, verticesToInduce)) return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  Set<E> edges = new HashSet<E>();\n  for (V v : vertices) {\n    for (V u : graph.getNeighbors(v)) {\n      if (graph.isNeighbor(u, v)) {\n        edges.add(graph.getEdge(u, v));\n      }\n    }\n  }\n  return edges.size() == graph.numberOfEdges();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  boolean[] visited = new boolean[graph.size()];\n  Stack<V> stack = new Stack<V>();\n  for (V v : vertices) {\n    if (!visited[v.getIndex()]) {\n      if (graph.getEdges(v).size() > 1) {\n        stack.push(v);\n        while (!stack.isEmpty()) {\n          V u = stack.pop();\n          for (E e : graph.getEdges(u)) {\n            if (!visited[e.getVertexA().getIndex()]) {\n              visited[e.getVertexA().getIndex()] = true;\n              if (!visited[e.getVertexB().getIndex()]) {\n                stack.push(e.getVertexB());\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return stack.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (vertices.size() == 0) {\n    return true;\n  }\n  Set<V> visited = new HashSet<>(vertices);\n  Set<V> incident = new HashSet<>();\n  Set<V> out = new HashSet<>();\n  for (V vertex : vertices) {\n    if (!visited.contains(vertex)) {\n      if (incident.add(vertex)) {\n        if (!isClique(graph, incident, out)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (vertices.size() == 1) return true;\n  if (graph.isClique()) return false;\n  Set<V> visited = new HashSet<>();\n  Stack<V> stack = new Stack<>();\n  stack.push(vertices.iterator().next());\n  while (!stack.isEmpty()) {\n    V v = stack.pop();\n    if (visited.contains(v)) continue;\n    visited.add(v);\n    Set<V> adj = graph.getAdjacentVertices(v);\n    if (adj.size() == 1) {\n      stack.push(adj.iterator().next());\n      continue;\n    }\n    for (V v2 : adj) {\n      if (!visited.contains(v2)) {\n        stack.push(v2);\n      }\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (vertices.size() == 0) {\n    return false;\n  }\n  if (vertices.size() == 1) {\n    return true;\n  }\n  Set<V> connectedVertices = new HashSet<V>();\n  Set<V> unconnectedVertices = new HashSet<V>(vertices);\n  Set<V> connectedVerticesWithoutEdges = new HashSet<V>();\n  for (V v : vertices) {\n    if (!unconnectedVertices.contains(v)) {\n      connectedVertices.add(v);\n    }\n  }\n  while (!connectedVertices.isEmpty()) {\n    if (connectedVertices.size() == 1) {\n      return true;\n    }\n    Set<V> newConnectedVertices = new HashSet<V>();\n    for (V v : connectedVertices) {\n      if (unconnectedVertices.contains(v)) {\n        unconnectedVertices.remove(v);\n        continue;\n      }\n      if (connectedVerticesWithoutEdges.contains(v)) {\n        continue;\n      }\n      if (unconnectedVertices.contains(v)) {\n        newConnectedVertices.add(v);\n      }\n    }\n    connectedVertices = newConnectedVertices;\n  }\n  return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n", "method_name": "isClique", "codes": ["private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (vertices.size() == 0) return true; Set<V> visited = new HashSet<>(); Set<V> nodes = new HashSet<>(); Set<V> marked = new HashSet<>(); for (V v : vertices) { if (!visited.contains(v)) { if (!nodes.contains(v)) { if (!marked.contains(v)) { if (isClique(graph, v, nodes, marked, visited)) return true; } } } } return false; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (vertices.size() < 2) { return false; } Set<V> visited = new HashSet<V>(); for (V v : vertices) { if (!visited.add(v)) { return false; } } Set<V> verticesToVisit = new HashSet<V>(vertices); while (verticesToVisit.size() > 1) { Set<V> newVertices = new HashSet<V>(); for (V v : verticesToVisit) { for (V u : verticesToVisit) { if (!visited.contains(u) && graph.hasEdge(v, u)) { newVertices.add(u); } } } verticesToVisit = newVertices; } return verticesToVisit.size() == 1; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ boolean ret = true; Set<V> verticesClique = new HashSet<V>(graph.vertexSet()); verticesClique.retainAll(vertices); for (V v : verticesClique) { if (!graph.outgoingEdgesOf(v).isEmpty()) { ret = false; break; } } return ret; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ boolean[][] adjacencyMatrix = graph.getAdjacencyMatrix(); for (V v : vertices) { if (!adjacencyMatrix[vertices.size()][v]) return false; } return true; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (vertices.isEmpty()) return true; Set<V> verticesToInduce = new HashSet<V>(vertices); Set<V> verticesToInduceFrom = new HashSet<V>(graph.vertices()); verticesToInduceFrom.removeAll(verticesToInduce); if (verticesToInduceFrom.isEmpty()) return false; for (V vertex : verticesToInduceFrom) { if (vertices.contains(vertex)) continue; verticesToInduce.remove(vertex); if (isClique(graph, verticesToInduce)) return true; } return false; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ Set<E> edges = new HashSet<E>(); for (V v : vertices) { for (V u : graph.getNeighbors(v)) { if (graph.isNeighbor(u, v)) { edges.add(graph.getEdge(u, v)); } } } return edges.size() == graph.numberOfEdges(); }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ boolean[] visited = new boolean[graph.size()]; Stack<V> stack = new Stack<V>(); for (V v : vertices) { if (!visited[v.getIndex()]) { if (graph.getEdges(v).size() > 1) { stack.push(v); while (!stack.isEmpty()) { V u = stack.pop(); for (E e : graph.getEdges(u)) { if (!visited[e.getVertexA().getIndex()]) { visited[e.getVertexA().getIndex()] = true; if (!visited[e.getVertexB().getIndex()]) { stack.push(e.getVertexB()); } } } } } } } return stack.isEmpty(); }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (vertices.size() == 0) { return true; } Set<V> visited = new HashSet<>(vertices); Set<V> incident = new HashSet<>(); Set<V> out = new HashSet<>(); for (V vertex : vertices) { if (!visited.contains(vertex)) { if (incident.add(vertex)) { if (!isClique(graph, incident, out)) { return false; } } } } return true; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (vertices.size() == 1) return true; if (graph.isClique()) return false; Set<V> visited = new HashSet<>(); Stack<V> stack = new Stack<>(); stack.push(vertices.iterator().next()); while (!stack.isEmpty()) { V v = stack.pop(); if (visited.contains(v)) continue; visited.add(v); Set<V> adj = graph.getAdjacentVertices(v); if (adj.size() == 1) { stack.push(adj.iterator().next()); continue; } for (V v2 : adj) { if (!visited.contains(v2)) { stack.push(v2); } } } return true; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (vertices.size() == 0) { return false; } if (vertices.size() == 1) { return true; } Set<V> connectedVertices = new HashSet<V>(); Set<V> unconnectedVertices = new HashSet<V>(vertices); Set<V> connectedVerticesWithoutEdges = new HashSet<V>(); for (V v : vertices) { if (!unconnectedVertices.contains(v)) { connectedVertices.add(v); } } while (!connectedVertices.isEmpty()) { if (connectedVertices.size() == 1) { return true; } Set<V> newConnectedVertices = new HashSet<V>(); for (V v : connectedVertices) { if (unconnectedVertices.contains(v)) { unconnectedVertices.remove(v); continue; } if (connectedVerticesWithoutEdges.contains(v)) { continue; } if (unconnectedVertices.contains(v)) { newConnectedVertices.add(v); } } connectedVertices = newConnectedVertices; } return false; }"], "code_level": "class_runnable", "_id": "6367675f1a6d9265ec0180cf", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public int nonZeros(int row) {\n  return (((row << 6) | (row >> 5)) & 0x3FFFFFFF);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int nz = 0;\n  for (int i = 0; i < n; i++) {\n    if (data[row][i] != 0) nz++;\n  }\n  return nz;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int nz = 0;\n  for (int i = 0; i < m_nRows; i++) if (m_advanced[i][row] != 0) nz++;\n  return nz;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int nz = 0;\n  for (int i = 0; i < this.getColumnCount(); i++) if (this.getValue(row, i) != 0) nz++;\n  return nz;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  return nonZeros[row];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int num = 0;\n  for (int col = 0; col < n; col++) {\n    if (data[row][col] == 0) {\n      num++;\n    }\n  }\n  return num;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  return nonZeros[row];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int count = 0;\n  for (int col = 0; col < numCols; col++) {\n    if (matrix[row][col] == 0) {\n      count++;\n    }\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  return nonZeros[row];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int count = 0;\n  for (int i = 0; i < getDimension(); i++) {\n    if (get(row, i) != 0) count++;\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Get the number of non-zero entries of a row.\n * @param row the row\n * @return the number of non-zero entries of a row\n */\n", "method_name": "nonZeros", "codes": ["public int nonZeros(int row){ return (((row << 6) | (row >> 5)) & 0x3FFFFFFF); }", "public int nonZeros(int row){ int nz = 0; for (int i = 0; i < n; i++) { if (data[row][i] != 0) nz++; } return nz; }", "public int nonZeros(int row){ int nz = 0; for (int i = 0; i < m_nRows; i++) if (m_advanced[i][row] != 0) nz++; return nz; }", "public int nonZeros(int row){ int nz = 0; for (int i = 0; i < this.getColumnCount(); i++) if (this.getValue(row, i) != 0) nz++; return nz; }", "public int nonZeros(int row){ return nonZeros[row]; }", "public int nonZeros(int row){ int num = 0; for (int col = 0; col < n; col++) { if (data[row][col] == 0) { num++; } } return num; }", "public int nonZeros(int row){ return nonZeros[row]; }", "public int nonZeros(int row){ int count = 0; for (int col = 0; col < numCols; col++) { if (matrix[row][col] == 0) { count++; } } return count; }", "public int nonZeros(int row){ return nonZeros[row]; }", "public int nonZeros(int row){ int count = 0; for (int i = 0; i < getDimension(); i++) { if (get(row, i) != 0) count++; } return count; }"], "code_level": "class_runnable", "_id": "636767511a6d9265ec017eb0", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private String unescapeId(String input) {\n  StringBuffer sb = new StringBuffer(input.length());\n  for (int i = 0; i < input.length(); i++) {\n    char c = input.charAt(i);\n    if (c == '.') {\n      sb.append('.');\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  return input.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  return input.replaceAll(\"\\\\\\\\d\", \"\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < input.length(); i++) {\n    char c = input.charAt(i);\n    if (c == '.') {\n      sb.append('.');\n      continue;\n    }\n    if (c == '$') {\n      sb.append('.');\n      continue;\n    }\n    sb.append(c);\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  return input.replace(\"\\\\\", \"\").replace(\"\\\"\", \"\");\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private String unescapeId(String input) {\n  if (input.indexOf('.') > -1) {\n    input = input.replace('.', '_');\n  }\n  return input;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < input.length(); i++) {\n    char c = input.charAt(i);\n    if (c == '.') {\n      sb.append(c);\n    } else if (c == '_') {\n      sb.append(c);\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  StringBuilder out = new StringBuilder();\n  for (int i = 0; i < input.length(); i++) {\n    char c = input.charAt(i);\n    if (c == '.') {\n      out.append('.');\n    } else if (c == '_') {\n      out.append('_');\n    } else if (c == '-') {\n      out.append('-');\n    } else {\n      out.append(c);\n    }\n  }\n  return out.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  if (input == null) {\n    return null;\n  }\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < input.length(); i++) {\n    char c = input.charAt(i);\n    if (c == '.') {\n      sb.append('.');\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  return input.replaceAll(\"([^\\\\\\\\])\\\\\\\\d+\", \"$1\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n", "method_name": "unescapeId", "codes": ["private String unescapeId(String input){ StringBuffer sb = new StringBuffer(input.length()); for (int i = 0; i < input.length(); i++) { char c = input.charAt(i); if (c == '.') { sb.append('.'); } else { sb.append(c); } } return sb.toString(); }", "private String unescapeId(String input){ return input.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\"); }", "private String unescapeId(String input){ return input.replaceAll(\"\\\\\\\\d\", \"\"); }", "private String unescapeId(String input){ StringBuilder sb = new StringBuilder(); for (int i = 0; i < input.length(); i++) { char c = input.charAt(i); if (c == '.') { sb.append('.'); continue; } if (c == '$') { sb.append('.'); continue; } sb.append(c); } return sb.toString(); }", "private String unescapeId(String input){ return input.replace(\"\\\\\", \"\").replace(\"\\\"\", \"\"); }", "private String unescapeId(String input){ if (input.indexOf('.') > -1) { input = input.replace('.', '_'); } return input; }", "private String unescapeId(String input){ StringBuilder sb = new StringBuilder(); for (int i = 0; i < input.length(); i++) { char c = input.charAt(i); if (c == '.') { sb.append(c); } else if (c == '_') { sb.append(c); } else { sb.append(c); } } return sb.toString(); }", "private String unescapeId(String input){ StringBuilder out = new StringBuilder(); for (int i = 0; i < input.length(); i++) { char c = input.charAt(i); if (c == '.') { out.append('.'); } else if (c == '_') { out.append('_'); } else if (c == '-') { out.append('-'); } else { out.append(c); } } return out.toString(); }", "private String unescapeId(String input){ if (input == null) { return null; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < input.length(); i++) { char c = input.charAt(i); if (c == '.') { sb.append('.'); } else { sb.append(c); } } return sb.toString(); }", "private String unescapeId(String input){ return input.replaceAll(\"([^\\\\\\\\])\\\\\\\\d+\", \"$1\"); }"], "code_level": "class_runnable", "_id": "636767461a6d9265ec017d17", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  if (i >= 0x80) {\n    sb.append((char) i);\n    return i;\n  } else if (i < 0xC0) {\n    sb.append((char) (0xC0 + i));\n    return i + 1;\n  } else if (i < 0xE0) {\n    sb.append((char) (0xE0 + i));\n    return i + 1;\n  } else if (i < 0xF0) {\n    sb.append((char) (0xF0 + i));\n    return i + 1;\n  } else {\n    sb.append((char) (0xF0 + i));\n    return i + 1;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  int c = i;\n  if (c < 0x80) {\n    bb.put((byte) c);\n  } else if (c < 0x800) {\n    bb.put((byte) (0xc0 | (c >> 6)));\n    bb.put((byte) (0x80 | (c & 0x3f)));\n  } else if (c < 0x10000) {\n    bb.put((byte) (0xe0 | (c >> 12)));\n    bb.put((byte) (0x80 | ((c >> 6) & 0x3f)));\n    bb.put((byte) (0x80 | (c & 0x3f)));\n  } else if (c < 0x1000000) {\n    bb.put((byte) (0xf0 | (c >> 18)));\n    bb.put((byte) (0x80 | ((c >> 12) & 0x3f)));\n    bb.put((byte) (0x80 | ((c >> 6) & 0x3f)));\n    bb.put((byte) (0x80 | (c & 0x3f)));\n  } else {\n    bb.put((byte) (0xf1 | (c >> 24)));\n    bb.put((byte) (0x80 | ((c >> 20) & 0x3f)));\n    bb.put((byte) (0x80 | ((c >> 16) & 0x3f)));\n    bb.put((byte) (0x80 | ((c >> 8) & 0x3f)));\n    bb.put((byte) (0x80 | (c & 0x3f)));\n  }\n  return c + 1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  int n = bb.position();\n  int j = i;\n  int k = bb.position();\n  while (i < n) {\n    if (bb.get(i) == '\\\\') {\n      i++;\n    } else if (bb.get(i) == 'u') {\n      int h = (bb.get(i + 1) & 0xFF);\n      int l = (bb.get(i + 2) & 0xFF);\n      i += 4;\n      sb.append((char) ((h << 8) + l));\n      i += 3;\n    } else {\n      i++;\n    }\n  }\n  if (i < n) {\n    sb.append((char) bb.get(i));\n  }\n  return j;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  if (i >= bb.capacity()) {\n    if (i >= bb.limit()) {\n      sb.append(\"<EOF>\");\n      return bb.limit();\n    }\n    int s = bb.get(bb.position());\n    if (s == -1) {\n      sb.append(\"<EOF>\");\n      return bb.limit();\n    }\n    bb.position(bb.position() + 1);\n    i = s;\n  }\n  char ch = (char) (((i & 0xF0) >> 4) + '0');\n  sb.append(ch);\n  ch = (char) (i & 0x0F);\n  sb.append(ch);\n  i = i >> 4;\n  return i;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  if (bb.hasArray()) {\n    byte[] bytes = bb.array();\n    int offset = bb.arrayOffset();\n    int length = bb.limit();\n    int j = offset + i;\n    for (int k = offset; k < j; k++) {\n      sb.append((char) (bytes[k] & 0xff));\n    }\n  } else {\n    int j = i + bb.limit();\n    for (int k = i; k < j; k++) {\n      sb.append((char) ((bb.get(k) & 0xff)));\n    }\n  }\n  return i + bb.limit();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int s = i; while (i < bb.limit()) { char c = (char) (bb.get(i++) & 0xFF); if (c == '\\n') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\n\"); sb.append(c); } } else if (c == '\\r') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\r\"); sb.append(c); } } else if (c == '\\t') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\t\"); sb.append(c); } } else if (c == '\\b') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\b\"); sb.append(c); } } else if (c == '\\f') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\f\"); sb.append(c); } } else if (c == '\\\"') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\\\\"\"); sb.append(c); } } else if (c == '\\'') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\\\'\"); sb.append(c); } } else if (c == '\\\\') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\\\\\\"); sb.append(c); } } else if (c == '\\b') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\b\"); sb.append(c); } } else if (c == '\\f') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\f\"); sb.append(c); } } else if (c == '\\r') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\r\"); sb.append(c); } } else if (c == '\\t') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\t\"); sb.append(c); } } else if (c == '\\'') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\'\"); sb.append(c); } } else if (c == '\\\"') { if (s == i) { ", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  if (i >= 0 && i <= 9) {\n    sb.append((char) ('0' + i));\n    return i;\n  } else if (i >= 10 && i <= 35) {\n    sb.append((char) ('a' + (i - 10)));\n    return i - 10;\n  } else if (i >= 36 && i <= 126) {\n    sb.append((char) ('A' + (i - 36)));\n    return i - 36;\n  } else if (i == 127) {\n    return -1;\n  } else {\n    throw new IllegalArgumentException(\"Illegal octet value: \" + i);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ char[] ch = new char[8]; int ch_idx = 0; if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xD800 + ((i >> 10) & 0x3FF)); ch[ch_idx++] = (char) (0xDC00 + ((i & 0x3FF) >> 10) & 0x3FF); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xE000 + ((i >> 20) & 0x1F)); ch[ch_idx++] = (char) (0xFF00 + ((i >> 12) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xF000 + ((i >> 24) & 0x3F)); ch[ch_idx++] = (char) (0xFF00 + ((i >> 16) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xC000 + ((i >> 30) & 0x1F)); ch[ch_idx++] = (char) (0x00FF + ((i >> 24) & 0x3F)); ch[ch_idx++] = (char) (0xFF00 + ((i >> 16) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xD800 + ((i >> 18) & 0x3F)); ch[ch_idx++] = (char) (0xDC00 + ((i >> 12) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xE000 + ((i >> 20) & 0x1F)); ch[ch_idx++] = (char) (0xFF00 + ((i >> 12) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xF000 + ((i >> 24) & 0x3F)); ch[ch_idx++] = (char) (0xFF00 + ((i >> 16) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xC000 + ((i >> 30) & 0x1F)); ch[ch_idx++] = (char", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  int n = 0;\n  if ((i < 0) || (i >= bb.limit())) {\n    return n;\n  }\n  if ((i & 0x80) == 0) {\n    if (bb.get(i) == 0) {\n      sb.append('\\\\');\n    }\n    sb.append((char) ((bb.get(i) & 0x7f) + '0'));\n    n++;\n  } else {\n    int v = bb.get(i) & 0x7f;\n    if ((v >= 'a') && (v <= 'f')) {\n      sb.append((char) ((v - 'a') + '0'));\n      n++;\n    } else if ((v >= 'A') && (v <= 'F')) {\n      sb.append((char) ((v - 'A') + '0'));\n      n++;\n    } else {\n      sb.append('\\\\');\n      sb.append((char) (v + '0'));\n      n++;\n    }\n  }\n  i++;\n  while ((i < bb.limit()) && ((bb.get(i) & 0x80) == 0)) {\n    sb.append((char) ((bb.get(i) & 0x7f) + '0'));\n    i++;\n  }\n  return n;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  int len = bb.remaining();\n  int j = i;\n  char c = '\\0';\n  while (j < len) {\n    c = (char) (bb.get(j++) & 0xff);\n    if (c >= '0' && c <= '9') {\n      sb.append(c);\n    } else if (c == '\\\\') {\n      if (j == len) {\n        return i;\n      }\n      c = (char) (bb.get(j++) & 0xff);\n      if (c >= '0' && c <= '9') {\n        sb.append(c);\n      } else {\n        throw new IllegalArgumentException(\n            \"Illegal escape character '\" + c + \"' in octet at index \" + i + \" of string: \" + sb);\n      }\n    } else {\n      throw new IllegalArgumentException(\n          \"Illegal character '\" + c + \"' in octet at index \" + i + \" of string: \" + sb);\n    }\n  }\n  return i;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n", "method_name": "decodeOctets", "codes": ["private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ if (i >= 0x80) { sb.append((char) i); return i; } else if (i < 0xC0) { sb.append((char) (0xC0 + i)); return i + 1; } else if (i < 0xE0) { sb.append((char) (0xE0 + i)); return i + 1; } else if (i < 0xF0) { sb.append((char) (0xF0 + i)); return i + 1; } else { sb.append((char) (0xF0 + i)); return i + 1; } }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int c = i; if (c < 0x80) { bb.put((byte) c); } else if (c < 0x800) { bb.put((byte) (0xc0 | (c >> 6))); bb.put((byte) (0x80 | (c & 0x3f))); } else if (c < 0x10000) { bb.put((byte) (0xe0 | (c >> 12))); bb.put((byte) (0x80 | ((c >> 6) & 0x3f))); bb.put((byte) (0x80 | (c & 0x3f))); } else if (c < 0x1000000) { bb.put((byte) (0xf0 | (c >> 18))); bb.put((byte) (0x80 | ((c >> 12) & 0x3f))); bb.put((byte) (0x80 | ((c >> 6) & 0x3f))); bb.put((byte) (0x80 | (c & 0x3f))); } else { bb.put((byte) (0xf1 | (c >> 24))); bb.put((byte) (0x80 | ((c >> 20) & 0x3f))); bb.put((byte) (0x80 | ((c >> 16) & 0x3f))); bb.put((byte) (0x80 | ((c >> 8) & 0x3f))); bb.put((byte) (0x80 | (c & 0x3f))); } return c + 1; }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int n = bb.position(); int j = i; int k = bb.position(); while (i < n) { if (bb.get(i) == '\\\\') { i++; } else if (bb.get(i) == 'u') { int h = (bb.get(i + 1) & 0xFF); int l = (bb.get(i + 2) & 0xFF); i += 4; sb.append((char) ((h << 8) + l)); i += 3; } else { i++; } } if (i < n) { sb.append((char) bb.get(i)); } return j; }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ if (i >= bb.capacity()) { if (i >= bb.limit()) { sb.append(\"<EOF>\"); return bb.limit(); } int s = bb.get(bb.position()); if (s == -1) { sb.append(\"<EOF>\"); return bb.limit(); } bb.position(bb.position() + 1); i = s; } char ch = (char) (((i & 0xF0) >> 4) + '0'); sb.append(ch); ch = (char) (i & 0x0F); sb.append(ch); i = i >> 4; return i; }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ if (bb.hasArray()) { byte[] bytes = bb.array(); int offset = bb.arrayOffset(); int length = bb.limit(); int j = offset + i; for (int k = offset; k < j; k++) { sb.append((char) (bytes[k] & 0xff)); } } else { int j = i + bb.limit(); for (int k = i; k < j; k++) { sb.append((char) ((bb.get(k) & 0xff))); } } return i + bb.limit(); }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int s = i; while (i < bb.limit()) { char c = (char) (bb.get(i++) & 0xFF); if (c == '\\n') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\n\"); sb.append(c); } } else if (c == '\\r') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\r\"); sb.append(c); } } else if (c == '\\t') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\t\"); sb.append(c); } } else if (c == '\\b') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\b\"); sb.append(c); } } else if (c == '\\f') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\f\"); sb.append(c); } } else if (c == '\\\"') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\\\\"\"); sb.append(c); } } else if (c == '\\'') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\\\'\"); sb.append(c); } } else if (c == '\\\\') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\\\\\\"); sb.append(c); } } else if (c == '\\b') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\b\"); sb.append(c); } } else if (c == '\\f') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\f\"); sb.append(c); } } else if (c == '\\r') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\r\"); sb.append(c); } } else if (c == '\\t') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\t\"); sb.append(c); } } else if (c == '\\'') { if (s == i) { sb.append(c); } else { sb.append(\"\\\\'\"); sb.append(c); } } else if (c == '\\\"') { if (s == i) { ", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ if (i >= 0 && i <= 9) { sb.append((char) ('0' + i)); return i; } else if (i >= 10 && i <= 35) { sb.append((char) ('a' + (i - 10))); return i - 10; } else if (i >= 36 && i <= 126) { sb.append((char) ('A' + (i - 36))); return i - 36; } else if (i == 127) { return -1; } else { throw new IllegalArgumentException(\"Illegal octet value: \" + i); } }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ char[] ch = new char[8]; int ch_idx = 0; if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xD800 + ((i >> 10) & 0x3FF)); ch[ch_idx++] = (char) (0xDC00 + ((i & 0x3FF) >> 10) & 0x3FF); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xE000 + ((i >> 20) & 0x1F)); ch[ch_idx++] = (char) (0xFF00 + ((i >> 12) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xF000 + ((i >> 24) & 0x3F)); ch[ch_idx++] = (char) (0xFF00 + ((i >> 16) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xC000 + ((i >> 30) & 0x1F)); ch[ch_idx++] = (char) (0x00FF + ((i >> 24) & 0x3F)); ch[ch_idx++] = (char) (0xFF00 + ((i >> 16) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xD800 + ((i >> 18) & 0x3F)); ch[ch_idx++] = (char) (0xDC00 + ((i >> 12) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xE000 + ((i >> 20) & 0x1F)); ch[ch_idx++] = (char) (0xFF00 + ((i >> 12) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xF000 + ((i >> 24) & 0x3F)); ch[ch_idx++] = (char) (0xFF00 + ((i >> 16) & 0x3F)); ch[ch_idx++] = (char) (0x00FF + (i & 0x3F)); } if (i >= 0x10000) { i = i - 0x10000; ch[ch_idx++] = (char) (0xC000 + ((i >> 30) & 0x1F)); ch[ch_idx++] = (char", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int n = 0; if ((i < 0) || (i >= bb.limit())) { return n; } if ((i & 0x80) == 0) { if (bb.get(i) == 0) { sb.append('\\\\'); } sb.append((char) ((bb.get(i) & 0x7f) + '0')); n++; } else { int v = bb.get(i) & 0x7f; if ((v >= 'a') && (v <= 'f')) { sb.append((char) ((v - 'a') + '0')); n++; } else if ((v >= 'A') && (v <= 'F')) { sb.append((char) ((v - 'A') + '0')); n++; } else { sb.append('\\\\'); sb.append((char) (v + '0')); n++; } } i++; while ((i < bb.limit()) && ((bb.get(i) & 0x80) == 0)) { sb.append((char) ((bb.get(i) & 0x7f) + '0')); i++; } return n; }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int len = bb.remaining(); int j = i; char c = '\\0'; while (j < len) { c = (char) (bb.get(j++) & 0xff); if (c >= '0' && c <= '9') { sb.append(c); } else if (c == '\\\\') { if (j == len) { return i; } c = (char) (bb.get(j++) & 0xff); if (c >= '0' && c <= '9') { sb.append(c); } else { throw new IllegalArgumentException(\"Illegal escape character '\" + c + \"' in octet at index \" + i + \" of string: \" + sb); } } else { throw new IllegalArgumentException(\"Illegal character '\" + c + \"' in octet at index \" + i + \" of string: \" + sb); } } return i; }"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec017457", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  if (u == null) {\n    return null;\n  }\n  String path = u.getPath();\n  if (path == null) {\n    return null;\n  }\n  List<PathSegmentImpl> ret = new ArrayList<>();\n  int idx = path.indexOf('/');\n  if (idx == -1) {\n    ret.add(new PathSegmentImpl(path));\n    return ret;\n  }\n  String pathSegment = path.substring(0, idx);\n  String[] pathSegments = pathSegment.split(\"/\");\n  for (String segment : pathSegments) {\n    ret.add(new PathSegmentImpl(segment, decode));\n  }\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  List<PathSegmentImpl> pathSegments = new ArrayList<PathSegmentImpl>();\n  if (u.isAbsolute()) {\n    for (String s : u.getPath().split(\"/\")) {\n      if (s.isEmpty()) {\n        continue;\n      }\n      PathSegmentImpl p = new PathSegmentImpl(s, u.getQuery(), u.getFragment());\n      pathSegments.add(p);\n    }\n  } else {\n    String s = u.getPath();\n    for (String s1 : s.split(\"/\")) {\n      if (s1.isEmpty()) {\n        continue;\n      }\n      PathSegmentImpl p = new PathSegmentImpl(s1, u.getQuery(), u.getFragment());\n      pathSegments.add(p);\n    }\n  }\n  if (decode) {\n    for (PathSegmentImpl p : pathSegments) {\n      p.setDecoded(true);\n    }\n  }\n  return pathSegments;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  List<PathSegmentImpl> pathSegments = new ArrayList<>();\n  if (u.getPath() != null) {\n    String[] pathComponents = u.getPath().split(\"/\");\n    for (String pathComponent : pathComponents) {\n      if (decode) {\n        pathComponent = decode(pathComponent);\n      }\n      pathSegments.add(new PathSegmentImpl(pathComponent));\n    }\n  }\n  return pathSegments;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  String path = u.getPath();\n  if (path == null) {\n    return Collections.emptyList();\n  }\n  String[] segments = path.split(\"/\");\n  List<PathSegmentImpl> result = new ArrayList<>(segments.length);\n  for (String segment : segments) {\n    if (segment.isEmpty() || segment.startsWith(\"/\")) {\n      continue;\n    }\n    if (decode) {\n      segment = decode(segment);\n    }\n    result.add(new PathSegmentImpl(segment));\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  if (!u.isAbsolute()) {\n    throw new IllegalArgumentException(\"URI must be absolute\");\n  }\n  List<PathSegmentImpl> pathSegments = new ArrayList<PathSegmentImpl>();\n  if (decode) {\n    String path = u.getRawPath();\n    int i = path.length();\n    if (i > 0) {\n      path = path.substring(0, i - 1);\n    }\n    pathSegments.add(new PathSegmentImpl(path, false));\n  }\n  String path = u.getRawPath();\n  int i = path.length();\n  if (i > 0) {\n    path = path.substring(0, i - 1);\n  }\n  String[] pathSegmentsArray = path.split(\"/\");\n  for (int j = 0; j < pathSegmentsArray.length; j++) {\n    String segment = pathSegmentsArray[j];\n    if (segment.length() > 0) {\n      if (segment.equals(\"/\")) {\n      } else if (segment.equals(\".\")) {\n        pathSegments.add(new PathSegmentImpl(\"\", true));\n      } else if (segment.equals(\"\")) {\n      } else {\n        pathSegments.add(new PathSegmentImpl(segment, false));\n      }\n    }\n  }\n  return pathSegments;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  List<PathSegmentImpl> path = new ArrayList<PathSegmentImpl>();\n  if (u == null) {\n    return path;\n  }\n  String scheme = u.getScheme();\n  if (scheme == null) {\n    return path;\n  }\n  String host = u.getHost();\n  if (host == null) {\n    return path;\n  }\n  String path = u.getPath();\n  if (path == null) {\n    return path;\n  }\n  String query = u.getRawQuery();\n  if (query == null) {\n    return path;\n  }\n  String fragment = u.getRawFragment();\n  if (fragment == null) {\n    return path;\n  }\n  String[] components = u.getRawPath().split(\"/\");\n  if (components.length == 0) {\n    return path;\n  }\n  StringBuffer buffer = new StringBuffer();\n  boolean inSlash = false;\n  for (int i = 0; i < components.length; i++) {\n    if (inSlash) {\n      buffer.append('/');\n    }\n    if (components[i].equals(\"\")) {\n      continue;\n    } else if (components[i].equals(\"/\")) {\n      if (buffer.length() > 0) {\n        buffer.append('/');\n      }\n    } else {\n      if (!inSlash && (components[i].equals(\"/.\") || components[i].equals(\"/..\"))) {\n        if (buffer.length() > 0) {\n          buffer.append('/');\n        }\n      }\n    }\n    if (components[i].equals(\"..\")) {\n      inSlash = true;\n    } else {\n      buffer.append(components[i]);\n    }\n  }\n  if (buffer.length() > 0) {\n    buffer.setLength(buffer.length() - 1);\n  }\n  if (decode) {\n    try {\n      buffer.insert(0, '/');\n    } catch (StringIndexOutOfBoundsException e) {\n    }\n  }\n  buffer.insert(0, scheme);\n  buffer.insert(0, host);\n  if (query != null) {\n    buffer.append('?');\n    buffer.append(query);\n  }\n  if (fragment != null) {\n    buffer.append('#');\n    buffer.append(fragment);\n  }\n  path.add(new PathSegmentImpl(buffer.toString()));\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  List<PathSegmentImpl> result = new ArrayList<>();\n  int slashCount = 0;\n  int i = 0;\n  while (i < u.getPath().length()) {\n    char c = u.getPath().charAt(i);\n    if (c == '/') {\n      if (slashCount > 0) {\n        slashCount--;\n      } else {\n        result.add(new PathSegmentImpl(u.getPath().substring(0, i), decode));\n      }\n    } else {\n      if (c == '?') {\n        result.add(new PathSegmentImpl(u.getPath().substring(0, i), decode));\n      } else if (c == '#') {\n        result.add(new PathSegmentImpl(u.getPath().substring(0, i), decode));\n      } else {\n        slashCount++;\n      }\n    }\n    i++;\n  }\n  result.add(new PathSegmentImpl(u.getPath(), decode));\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  List<PathSegmentImpl> res = new ArrayList<>();\n  String path = u.getPath();\n  String[] segments = decode ? path.split(\"/\") : path.split(\"\\\\/\");\n  for (String s : segments) {\n    res.add(new PathSegmentImpl(s, decode));\n  }\n  return res;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  if (u == null) {\n    return null;\n  }\n  if (u.getPath() == null || u.getPath().length() == 0) {\n    return new ArrayList<PathSegmentImpl>();\n  }\n  List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>();\n  int pos = 0;\n  while (pos < u.getPath().length()) {\n    char c = u.getPath().charAt(pos);\n    if (c == '/') {\n      result.add(new PathSegmentImpl(u.getPath().substring(0, pos), decode));\n      pos++;\n    } else if (c == '%') {\n      pos += 2;\n      int hex = 0;\n      while (pos < u.getPath().length()) {\n        char d = u.getPath().charAt(pos);\n        if (d == '%') {\n          hex = (hex << 4) + Character.digit(u.getPath().charAt(pos + 1), 16);\n          pos += 2;\n        } else {\n          hex += Character.digit(d, 16);\n          pos++;\n        }\n      }\n      result.add(new PathSegmentImpl(u.getPath().substring(0, pos), decode));\n      pos++;\n      result.add(new PathSegmentImpl(u.getPath().substring(pos), decode));\n      pos++;\n    } else {\n      result.add(new PathSegmentImpl(u.getPath().substring(0, pos), decode));\n      pos++;\n    }\n  }\n  if (pos < u.getPath().length()) {\n    result.add(new PathSegmentImpl(u.getPath().substring(0, pos), decode));\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> path = new ArrayList<PathSegmentImpl>(); if (u == null) { return path; } String pathString = u.getPath(); if (pathString.startsWith(\"//\")) { pathString = pathString.substring(2); } if (pathString.startsWith(\"/..\")) { pathString = pathString.substring(3); } if (pathString.startsWith(\"/.\")) { pathString = pathString.substring(1); } if (pathString.startsWith(\"/../\")) { pathString = pathString.substring(3); } if (pathString.startsWith(\"/..//\")) { pathString = pathString.substring(3); } if (pathString.startsWith(\"/../\")) { pathString = pathString.substring(3); } if (pathString.startsWith(\"/..///\")) { pathString = pathString.substring(3); } if (pathString.startsWith(\"/..//////\")) { pathString = pathString.substring(3); } String[] pathSegments = pathString.split(\"/\"); if (pathSegments.length == 0) { path.add(new PathSegmentImpl(\"/\", true)); return path; } for (String pathSegment : pathSegments) { if (pathSegment.length() > 0) { if (pathSegment.startsWith(\"/.\")) { pathSegment = pathSegment.substring(1); } if (pathSegment.startsWith(\"/./\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..//\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/../\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/../////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..////////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..///////////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..////////////////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..//////////////////////////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..///////////////////////////////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decode the path component of a URI as path segments.\n * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.\n * @param decode true if the path segments of the path componentshould be in decoded form.\n * @return the list of path segments.\n */\n", "method_name": "decodePath", "codes": ["public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ if (u == null) { return null; } String path = u.getPath(); if (path == null) { return null; } List<PathSegmentImpl> ret = new ArrayList<>(); int idx = path.indexOf('/'); if (idx == -1) { ret.add(new PathSegmentImpl(path)); return ret; } String pathSegment = path.substring(0, idx); String[] pathSegments = pathSegment.split(\"/\"); for (String segment : pathSegments) { ret.add(new PathSegmentImpl(segment, decode)); } return ret; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> pathSegments = new ArrayList<PathSegmentImpl>(); if (u.isAbsolute()) { for (String s : u.getPath().split(\"/\")) { if (s.isEmpty()) { continue; } PathSegmentImpl p = new PathSegmentImpl(s, u.getQuery(), u.getFragment()); pathSegments.add(p); } } else { String s = u.getPath(); for (String s1 : s.split(\"/\")) { if (s1.isEmpty()) { continue; } PathSegmentImpl p = new PathSegmentImpl(s1, u.getQuery(), u.getFragment()); pathSegments.add(p); } } if (decode) { for (PathSegmentImpl p : pathSegments) { p.setDecoded(true); } } return pathSegments; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> pathSegments = new ArrayList<>(); if (u.getPath() != null) { String[] pathComponents = u.getPath().split(\"/\"); for (String pathComponent : pathComponents) { if (decode) { pathComponent = decode(pathComponent); } pathSegments.add(new PathSegmentImpl(pathComponent)); } } return pathSegments; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ String path = u.getPath(); if (path == null) { return Collections.emptyList(); } String[] segments = path.split(\"/\"); List<PathSegmentImpl> result = new ArrayList<>(segments.length); for (String segment : segments) { if (segment.isEmpty() || segment.startsWith(\"/\")) { continue; } if (decode) { segment = decode(segment); } result.add(new PathSegmentImpl(segment)); } return result; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ if (!u.isAbsolute()) { throw new IllegalArgumentException(\"URI must be absolute\"); } List<PathSegmentImpl> pathSegments = new ArrayList<PathSegmentImpl>(); if (decode) { String path = u.getRawPath(); int i = path.length(); if (i > 0) { path = path.substring(0, i - 1); } pathSegments.add(new PathSegmentImpl(path, false)); } String path = u.getRawPath(); int i = path.length(); if (i > 0) { path = path.substring(0, i - 1); } String[] pathSegmentsArray = path.split(\"/\"); for (int j = 0; j < pathSegmentsArray.length; j++) { String segment = pathSegmentsArray[j]; if (segment.length() > 0) { if (segment.equals(\"/\")) { } else if (segment.equals(\".\")) { pathSegments.add(new PathSegmentImpl(\"\", true)); } else if (segment.equals(\"\")) { } else { pathSegments.add(new PathSegmentImpl(segment, false)); } } } return pathSegments; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> path = new ArrayList<PathSegmentImpl>(); if (u == null) { return path; } String scheme = u.getScheme(); if (scheme == null) { return path; } String host = u.getHost(); if (host == null) { return path; } String path = u.getPath(); if (path == null) { return path; } String query = u.getRawQuery(); if (query == null) { return path; } String fragment = u.getRawFragment(); if (fragment == null) { return path; } String[] components = u.getRawPath().split(\"/\"); if (components.length == 0) { return path; } StringBuffer buffer = new StringBuffer(); boolean inSlash = false; for (int i = 0; i < components.length; i++) { if (inSlash) { buffer.append('/'); } if (components[i].equals(\"\")) { continue; } else if (components[i].equals(\"/\")) { if (buffer.length() > 0) { buffer.append('/'); } } else { if (!inSlash && (components[i].equals(\"/.\") || components[i].equals(\"/..\"))) { if (buffer.length() > 0) { buffer.append('/'); } } } if (components[i].equals(\"..\")) { inSlash = true; } else { buffer.append(components[i]); } } if (buffer.length() > 0) { buffer.setLength(buffer.length() - 1); } if (decode) { try { buffer.insert(0, '/'); } catch (StringIndexOutOfBoundsException e) { } } buffer.insert(0, scheme); buffer.insert(0, host); if (query != null) { buffer.append('?'); buffer.append(query); } if (fragment != null) { buffer.append('#'); buffer.append(fragment); } path.add(new PathSegmentImpl(buffer.toString())); return path; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> result = new ArrayList<>(); int slashCount = 0; int i = 0; while (i < u.getPath().length()) { char c = u.getPath().charAt(i); if (c == '/') { if (slashCount > 0) { slashCount--; } else { result.add(new PathSegmentImpl(u.getPath().substring(0, i), decode)); } } else { if (c == '?') { result.add(new PathSegmentImpl(u.getPath().substring(0, i), decode)); } else if (c == '#') { result.add(new PathSegmentImpl(u.getPath().substring(0, i), decode)); } else { slashCount++; } } i++; } result.add(new PathSegmentImpl(u.getPath(), decode)); return result; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> res = new ArrayList<>(); String path = u.getPath(); String[] segments = decode ? path.split(\"/\") : path.split(\"\\\\/\"); for (String s : segments) { res.add(new PathSegmentImpl(s, decode)); } return res; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ if (u == null) { return null; } if (u.getPath() == null || u.getPath().length() == 0) { return new ArrayList<PathSegmentImpl>(); } List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>(); int pos = 0; while (pos < u.getPath().length()) { char c = u.getPath().charAt(pos); if (c == '/') { result.add(new PathSegmentImpl(u.getPath().substring(0, pos), decode)); pos++; } else if (c == '%') { pos += 2; int hex = 0; while (pos < u.getPath().length()) { char d = u.getPath().charAt(pos); if (d == '%') { hex = (hex << 4) + Character.digit(u.getPath().charAt(pos + 1), 16); pos += 2; } else { hex += Character.digit(d, 16); pos++; } } result.add(new PathSegmentImpl(u.getPath().substring(0, pos), decode)); pos++; result.add(new PathSegmentImpl(u.getPath().substring(pos), decode)); pos++; } else { result.add(new PathSegmentImpl(u.getPath().substring(0, pos), decode)); pos++; } } if (pos < u.getPath().length()) { result.add(new PathSegmentImpl(u.getPath().substring(0, pos), decode)); } return result; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> path = new ArrayList<PathSegmentImpl>(); if (u == null) { return path; } String pathString = u.getPath(); if (pathString.startsWith(\"//\")) { pathString = pathString.substring(2); } if (pathString.startsWith(\"/..\")) { pathString = pathString.substring(3); } if (pathString.startsWith(\"/.\")) { pathString = pathString.substring(1); } if (pathString.startsWith(\"/../\")) { pathString = pathString.substring(3); } if (pathString.startsWith(\"/..//\")) { pathString = pathString.substring(3); } if (pathString.startsWith(\"/../\")) { pathString = pathString.substring(3); } if (pathString.startsWith(\"/..///\")) { pathString = pathString.substring(3); } if (pathString.startsWith(\"/..//////\")) { pathString = pathString.substring(3); } String[] pathSegments = pathString.split(\"/\"); if (pathSegments.length == 0) { path.add(new PathSegmentImpl(\"/\", true)); return path; } for (String pathSegment : pathSegments) { if (pathSegment.length() > 0) { if (pathSegment.startsWith(\"/.\")) { pathSegment = pathSegment.substring(1); } if (pathSegment.startsWith(\"/./\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..//\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/../\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/../////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..////////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..///////////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..////////////////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..//////////////////////////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith(\"/..///////////////////////////////\")) { pathSegment = pathSegment.substring(2); } if (pathSegment.startsWith("], "code_level": "slib_runnable", "_id": "6367667f1a6d9265ec01745d", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public final MatchResult match(CharSequence uri) {\n  return match(uri, 0, uri.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  Matcher matcher = pattern.matcher(uri);\n  if (matcher.matches()) {\n    return new MatchResult(matcher);\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  if (!uri.toString().contains(this.pattern)) {\n    return null;\n  }\n  return new MatchResult(uri, this.matches);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  return match(uri, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  if (uri == null) return null;\n  MatchResult matchResult = null;\n  for (int i = 0; i < uri.length(); i++) {\n    if (matchResult == null) {\n      matchResult = match(uri.charAt(i));\n    } else {\n      if (matchResult.isMatch()) {\n        return matchResult;\n      }\n    }\n  }\n  return matchResult;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  return match(uri, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  Matcher matcher = pattern.matcher(uri);\n  if (matcher.find()) {\n    return new MatchResult(matcher, matcher.start(), matcher.end());\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  return match(uri, 0, uri.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  return match(uri, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  return match(uri, 0, uri.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Match a URI against the pattern.\n * @param uri the uri to match against the template.\n * @return the match result, otherwise null if no match occurs.\n */\n", "method_name": "match", "codes": ["public final MatchResult match(CharSequence uri){ return match(uri, 0, uri.length()); }", "public final MatchResult match(CharSequence uri){ Matcher matcher = pattern.matcher(uri); if (matcher.matches()) { return new MatchResult(matcher); } else { return null; } }", "public final MatchResult match(CharSequence uri){ if (!uri.toString().contains(this.pattern)) { return null; } return new MatchResult(uri, this.matches); }", "public final MatchResult match(CharSequence uri){ return match(uri, false); }", "public final MatchResult match(CharSequence uri){ if (uri == null) return null; MatchResult matchResult = null; for (int i = 0; i < uri.length(); i++) { if (matchResult == null) { matchResult = match(uri.charAt(i)); } else { if (matchResult.isMatch()) { return matchResult; } } } return matchResult; }", "public final MatchResult match(CharSequence uri){ return match(uri, 0); }", "public final MatchResult match(CharSequence uri){ Matcher matcher = pattern.matcher(uri); if (matcher.find()) { return new MatchResult(matcher, matcher.start(), matcher.end()); } else { return null; } }", "public final MatchResult match(CharSequence uri){ return match(uri, 0, uri.length()); }", "public final MatchResult match(CharSequence uri){ return match(uri, 0); }", "public final MatchResult match(CharSequence uri){ return match(uri, 0, uri.length()); }"], "code_level": "project_runnable", "_id": "636766861a6d9265ec01755a", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return templateVariables.contains(name);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  if (name == null) return false;\n  if (name.equals(\"\")) return false;\n  if (name.equals(\"select\")) return true;\n  if (name.equals(\"insert\")) return true;\n  if (name.equals(\"update\")) return true;\n  if (name.equals(\"delete\")) return true;\n  if (name.equals(\"refresh\")) return true;\n  if (name.equals(\"refresh_instance\")) return true;\n  if (name.equals(\"refresh_all\")) return true;\n  if (name.equals(\"refresh_all_instances\")) return true;\n  if (name.equals(\"refresh_all_instances_as_set\")) return true;\n  if (name.equals(\"refresh_all_instances_as_set_as_set\")) return true;\n  if (name.equals(\"refresh_all_instances_as_set_as_set_as_set\")) return true;\n  if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set\")) return true;\n  if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set_as_set\")) return true;\n  if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set\")) return true;\n  if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set_as_set\"))\n    return true;\n  if (name.equals(\n      \"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set\"))\n    return true;\n  if (name.equals(\n      \"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set\"))\n    return true;\n  if (name.equals(\n      \"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set\"))\n    return true;\n  if (name.equals(\n      \"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set\"))\n    return true;\n  return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return getTemplateVariable(name) != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  if (name == null) {\n    return false;\n  }\n  return templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  if (this.templateVariables.containsKey(name)) {\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return (templateVariables != null) && (templateVariables.containsKey(name));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Ascertain if a template variable is a member of this template.\n * @param name name The template variable.\n * @return true if the template variable is a member of the template, otherwisefalse.\n */\n", "method_name": "isTemplateVariablePresent", "codes": ["public final boolean isTemplateVariablePresent(String name){ return templateVariables.contains(name); }", "public final boolean isTemplateVariablePresent(String name){ if (name == null) return false; if (name.equals(\"\")) return false; if (name.equals(\"select\")) return true; if (name.equals(\"insert\")) return true; if (name.equals(\"update\")) return true; if (name.equals(\"delete\")) return true; if (name.equals(\"refresh\")) return true; if (name.equals(\"refresh_instance\")) return true; if (name.equals(\"refresh_all\")) return true; if (name.equals(\"refresh_all_instances\")) return true; if (name.equals(\"refresh_all_instances_as_set\")) return true; if (name.equals(\"refresh_all_instances_as_set_as_set\")) return true; if (name.equals(\"refresh_all_instances_as_set_as_set_as_set\")) return true; if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set\")) return true; if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set_as_set\")) return true; if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set\")) return true; if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set_as_set\")) return true; if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set\")) return true; if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set\")) return true; if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set\")) return true; if (name.equals(\"refresh_all_instances_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set_as_set\")) return true; return false; }", "public final boolean isTemplateVariablePresent(String name){ return getTemplateVariable(name) != null; }", "public final boolean isTemplateVariablePresent(String name){ return this.templateVariables.containsKey(name); }", "public final boolean isTemplateVariablePresent(String name){ if (name == null) { return false; } return templateVariables.containsKey(name); }", "public final boolean isTemplateVariablePresent(String name){ return this.templateVariables.containsKey(name); }", "public final boolean isTemplateVariablePresent(String name){ if (this.templateVariables.containsKey(name)) { return true; } return false; }", "public final boolean isTemplateVariablePresent(String name){ return (templateVariables != null) && (templateVariables.containsKey(name)); }", "public final boolean isTemplateVariablePresent(String name){ return this.templateVariables.containsKey(name); }", "public final boolean isTemplateVariablePresent(String name){ return this.templateVariables.containsKey(name); }"], "code_level": "class_runnable", "_id": "636766861a6d9265ec017553", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String encodeTemplateNames(String s) {\n  StringBuilder sb = new StringBuilder();\n  for (char c : s.toCharArray()) {\n    if (c == '{' || c == '}') {\n      sb.append('%');\n      sb.append(Integer.toHexString(c));\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  StringBuilder sb = new StringBuilder();\n  if (s == null) return sb.toString();\n  int len = s.length();\n  for (int i = 0; i < len; i++) {\n    char c = s.charAt(i);\n    if (c == '{' || c == '}') sb.append('%');\n    else if (c == '&') sb.append('%');\n    else sb.append(c);\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  if (s == null) {\n    return null;\n  }\n  StringBuilder sb = new StringBuilder(s.length() * 2);\n  char[] chars = s.toCharArray();\n  for (char c : chars) {\n    switch (c) {\n      case '{':\n        sb.append(\"{\");\n        break;\n      case '}':\n        sb.append(\"}\");\n        break;\n      case ',':\n        sb.append(\",\");\n        break;\n      case ':':\n        sb.append(\":\");\n        break;\n      case ':':\n        sb.append(\":\");\n        break;\n      case ' ':\n        sb.append(\" \");\n        break;\n      default:\n        sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  return encodeTemplateNames(s, \"{\", \"}\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  return encodeTemplateNames(s, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  return encodeTemplateNames(s, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  if (s == null) {\n    return null;\n  }\n  char[] chars = s.toCharArray();\n  StringBuilder buf = new StringBuilder();\n  for (int i = 0; i < chars.length; i++) {\n    char c = chars[i];\n    if (c == '{' || c == '}') {\n      if (c == '}') {\n        chars[i] = '%';\n      } else {\n        chars[i] = '{';\n      }\n    }\n    buf.append(chars[i]);\n  }\n  return buf.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  return encodeTemplateNames(s, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  StringBuilder sb = new StringBuilder();\n  boolean inQuote = false;\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    if (inQuote) {\n      if (c == '{') {\n        sb.append('\\\\');\n      } else {\n        sb.append(c);\n      }\n    } else if (c == '{') {\n      inQuote = true;\n    } else if (c == '}') {\n      inQuote = false;\n    } else if (c == ' ') {\n      sb.append('%');\n      sb.append(Integer.toHexString(c));\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    if (c == '{') {\n      sb.append(\"%2f\");\n    } else if (c == '}') {\n      sb.append(\"%2e\");\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Encodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-encoded.\n * @param s the string with zero or more template parameters names\n * @return the string with encoded template parameters names.\n */\n", "method_name": "encodeTemplateNames", "codes": ["public static String encodeTemplateNames(String s){ StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (c == '{' || c == '}') { sb.append('%'); sb.append(Integer.toHexString(c)); } else { sb.append(c); } } return sb.toString(); }", "public static String encodeTemplateNames(String s){ StringBuilder sb = new StringBuilder(); if (s == null) return sb.toString(); int len = s.length(); for (int i = 0; i < len; i++) { char c = s.charAt(i); if (c == '{' || c == '}') sb.append('%'); else if (c == '&') sb.append('%'); else sb.append(c); } return sb.toString(); }", "public static String encodeTemplateNames(String s){ if (s == null) { return null; } StringBuilder sb = new StringBuilder(s.length() * 2); char[] chars = s.toCharArray(); for (char c : chars) { switch(c) { case '{': sb.append(\"{\"); break; case '}': sb.append(\"}\"); break; case ',': sb.append(\",\"); break; case ':': sb.append(\":\"); break; case ':': sb.append(\":\"); break; case ' ': sb.append(\" \"); break; default: sb.append(c); } } return sb.toString(); }", "public static String encodeTemplateNames(String s){ return encodeTemplateNames(s, \"{\", \"}\"); }", "public static String encodeTemplateNames(String s){ return encodeTemplateNames(s, null); }", "public static String encodeTemplateNames(String s){ return encodeTemplateNames(s, null); }", "public static String encodeTemplateNames(String s){ if (s == null) { return null; } char[] chars = s.toCharArray(); StringBuilder buf = new StringBuilder(); for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (c == '{' || c == '}') { if (c == '}') { chars[i] = '%'; } else { chars[i] = '{'; } } buf.append(chars[i]); } return buf.toString(); }", "public static String encodeTemplateNames(String s){ return encodeTemplateNames(s, null); }", "public static String encodeTemplateNames(String s){ StringBuilder sb = new StringBuilder(); boolean inQuote = false; for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (inQuote) { if (c == '{') { sb.append('\\\\'); } else { sb.append(c); } } else if (c == '{') { inQuote = true; } else if (c == '}') { inQuote = false; } else if (c == ' ') { sb.append('%'); sb.append(Integer.toHexString(c)); } else { sb.append(c); } } return sb.toString(); }", "public static String encodeTemplateNames(String s){ StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c == '{') { sb.append(\"%2f\"); } else if (c == '}') { sb.append(\"%2e\"); } else { sb.append(c); } } return sb.toString(); }"], "code_level": "self_contained", "_id": "636766801a6d9265ec017487", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  String[] files = dir.split(\"\\\\\\\\\");\n  for (int i = 0; i < files.length; i++) {\n    String file = files[i];\n    if (file.endsWith(\".jar\")) {\n      addToClassPath(cpV, new File(file).getAbsolutePath());\n    } else {\n      cpV.add(new File(file).getAbsoluteFile().toURI().toURL());\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  File f = new File(dir);\n  if (!f.exists()) {\n    return;\n  }\n  File[] files = f.listFiles();\n  if (files != null) {\n    for (File file : files) {\n      if (file.isDirectory()) {\n        addToClassPath(cpV, file.getAbsolutePath());\n      } else {\n        cpV.add(file.toURI().toURL());\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  try {\n    File f = new File(dir);\n    if (f.isDirectory()) {\n      for (File f2 : f.listFiles()) {\n        addToClassPath(cpV, f2.getAbsolutePath());\n      }\n    } else {\n      cpV.add(new URL(\"file:\" + dir));\n    }\n  } catch (MalformedURLException e) {\n    throw new RuntimeException(e);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  if (dir == null) return;\n  String[] dirs = dir.split(\";\");\n  for (int i = 0; i < dirs.length; i++) {\n    String d = dirs[i].trim();\n    if (d.length() == 0) continue;\n    File f = new File(d);\n    if (f.isAbsolute()) {\n      cpV.add(f.toURI().toURL());\n      continue;\n    }\n    try {\n      cpV.add(f.toURI().toURL());\n    } catch (MalformedURLException e) {\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  if (dir == null) {\n    return;\n  }\n  File f = new File(dir);\n  if (!f.exists()) {\n    return;\n  }\n  File[] jars =\n      f.listFiles(\n          new FilenameFilter() {\n            public boolean accept(File dir, String name) {\n              return name.endsWith(\".jar\");\n            }\n          });\n  if (jars == null) {\n    return;\n  }\n  for (File jar : jars) {\n    if (jar.isFile()) {\n      try {\n        cpV.add(jar.toURI().toURL());\n      } catch (MalformedURLException e) {\n      }\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  File dirF = new File(dir);\n  if (!dirF.exists() || !dirF.isDirectory()) {\n    return;\n  }\n  String[] files = dirF.list();\n  for (int i = 0; i < files.length; i++) {\n    File f = new File(dirF, files[i]);\n    if (f.isDirectory()) {\n      addToClassPath(cpV, f.getPath());\n    } else {\n      try {\n        cpV.addElement(new URL(\"file:\" + f.getPath()));\n      } catch (MalformedURLException e) {\n        throw new RuntimeException(e.getMessage());\n      }\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  File f = new File(dir);\n  if (f.isDirectory()) {\n    File[] fs = f.listFiles();\n    for (int i = 0; i < fs.length; i++) addToClassPath(cpV, fs[i].getAbsolutePath());\n  } else if (f.isFile()) {\n    try {\n      cpV.addElement(f.toURI().toURL());\n    } catch (MalformedURLException e) {\n      e.printStackTrace();\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  try {\n    File file = new File(dir);\n    if (file.exists()) {\n      String[] files = file.list();\n      for (String f : files) {\n        File jarFile = new File(dir + File.separator + f);\n        if (jarFile.isDirectory()) addToClassPath(cpV, jarFile.getCanonicalPath());\n        else {\n          cpV.addElement(new URL(\"file:\" + dir + File.separator + f));\n        }\n      }\n    }\n  } catch (IOException e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  File f = new File(dir);\n  File[] jars = f.listFiles();\n  for (int i = 0; i < jars.length; i++) {\n    File f2 = jars[i];\n    if (f2.isDirectory()) {\n      addToClassPath(cpV, f2.getAbsolutePath());\n    } else {\n      String jarName = f2.getAbsolutePath().replace(\"\\\\\", \"/\");\n      if (jarName.endsWith(\".jar\")) {\n        try {\n          cpV.add(new URL(\"jar:file:\" + jarName + \"!/\"));\n        } catch (MalformedURLException e) {\n          e.printStackTrace();\n        }\n      }\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  File dirFile = new File(dir);\n  if (!dirFile.exists()) {\n    throw new IllegalArgumentException(\"The dir does not exist: \" + dir);\n  }\n  if (!dirFile.isDirectory()) {\n    throw new IllegalArgumentException(\"The dir is not a directory: \" + dir);\n  }\n  File[] jarFiles =\n      dirFile.listFiles(\n          new FilenameFilter() {\n            public boolean accept(File dir, String name) {\n              return name.endsWith(\".jar\");\n            }\n          });\n  if (jarFiles == null) {\n    return;\n  }\n  for (int i = 0; i < jarFiles.length; i++) {\n    try {\n      URL url = jarFiles[i].toURI().toURL();\n      cpV.add(url);\n    } catch (MalformedURLException e) {\n      throw new IllegalArgumentException(\n          \"Cannot add to classpath: \" + jarFiles[i].getAbsolutePath(), e);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n", "method_name": "addToClassPath", "codes": ["@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ String[] files = dir.split(\"\\\\\\\\\"); for (int i = 0; i < files.length; i++) { String file = files[i]; if (file.endsWith(\".jar\")) { addToClassPath(cpV, new File(file).getAbsolutePath()); } else { cpV.add(new File(file).getAbsoluteFile().toURI().toURL()); } } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ File f = new File(dir); if (!f.exists()) { return; } File[] files = f.listFiles(); if (files != null) { for (File file : files) { if (file.isDirectory()) { addToClassPath(cpV, file.getAbsolutePath()); } else { cpV.add(file.toURI().toURL()); } } } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ try { File f = new File(dir); if (f.isDirectory()) { for (File f2 : f.listFiles()) { addToClassPath(cpV, f2.getAbsolutePath()); } } else { cpV.add(new URL(\"file:\" + dir)); } } catch (MalformedURLException e) { throw new RuntimeException(e); } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ if (dir == null) return; String[] dirs = dir.split(\";\"); for (int i = 0; i < dirs.length; i++) { String d = dirs[i].trim(); if (d.length() == 0) continue; File f = new File(d); if (f.isAbsolute()) { cpV.add(f.toURI().toURL()); continue; } try { cpV.add(f.toURI().toURL()); } catch (MalformedURLException e) { } } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ if (dir == null) { return; } File f = new File(dir); if (!f.exists()) { return; } File[] jars = f.listFiles(new FilenameFilter() { public boolean accept(File dir, String name) { return name.endsWith(\".jar\"); } }); if (jars == null) { return; } for (File jar : jars) { if (jar.isFile()) { try { cpV.add(jar.toURI().toURL()); } catch (MalformedURLException e) { } } } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ File dirF = new File(dir); if (!dirF.exists() || !dirF.isDirectory()) { return; } String[] files = dirF.list(); for (int i = 0; i < files.length; i++) { File f = new File(dirF, files[i]); if (f.isDirectory()) { addToClassPath(cpV, f.getPath()); } else { try { cpV.addElement(new URL(\"file:\" + f.getPath())); } catch (MalformedURLException e) { throw new RuntimeException(e.getMessage()); } } } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ File f = new File(dir); if (f.isDirectory()) { File[] fs = f.listFiles(); for (int i = 0; i < fs.length; i++) addToClassPath(cpV, fs[i].getAbsolutePath()); } else if (f.isFile()) { try { cpV.addElement(f.toURI().toURL()); } catch (MalformedURLException e) { e.printStackTrace(); } } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ try { File file = new File(dir); if (file.exists()) { String[] files = file.list(); for (String f : files) { File jarFile = new File(dir + File.separator + f); if (jarFile.isDirectory()) addToClassPath(cpV, jarFile.getCanonicalPath()); else { cpV.addElement(new URL(\"file:\" + dir + File.separator + f)); } } } } catch (IOException e) { e.printStackTrace(); } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ File f = new File(dir); File[] jars = f.listFiles(); for (int i = 0; i < jars.length; i++) { File f2 = jars[i]; if (f2.isDirectory()) { addToClassPath(cpV, f2.getAbsolutePath()); } else { String jarName = f2.getAbsolutePath().replace(\"\\\\\", \"/\"); if (jarName.endsWith(\".jar\")) { try { cpV.add(new URL(\"jar:file:\" + jarName + \"!/\")); } catch (MalformedURLException e) { e.printStackTrace(); } } } } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ File dirFile = new File(dir); if (!dirFile.exists()) { throw new IllegalArgumentException(\"The dir does not exist: \" + dir); } if (!dirFile.isDirectory()) { throw new IllegalArgumentException(\"The dir is not a directory: \" + dir); } File[] jarFiles = dirFile.listFiles(new FilenameFilter() { public boolean accept(File dir, String name) { return name.endsWith(\".jar\"); } }); if (jarFiles == null) { return; } for (int i = 0; i < jarFiles.length; i++) { try { URL url = jarFiles[i].toURI().toURL(); cpV.add(url); } catch (MalformedURLException e) { throw new IllegalArgumentException(\"Cannot add to classpath: \" + jarFiles[i].getAbsolutePath(), e); } } }"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec01745c", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String capitalize(String name) {\n  if (name == null) {\n    return null;\n  }\n  if (name.length() == 0) {\n    return name;\n  }\n  return Character.toUpperCase(name.charAt(0)) + name.substring(1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String capitalize(String name) {\n  if (name == null || name.length() == 0) return name;\n  char first = name.charAt(0);\n  char second = Character.toUpperCase(first);\n  name = second + name.substring(1);\n  return name;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String capitalize(String name) {\n  if (name == null || name.length() == 0) {\n    return name;\n  }\n  char firstChar = name.charAt(0);\n  if (Character.isUpperCase(firstChar)) {\n    return name;\n  } else {\n    return Character.toUpperCase(firstChar) + name.substring(1);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String capitalize(String name) {\n  return Introspector.decapitalize(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String capitalize(String name) {\n  if (name == null || name.length() == 0) {\n    return name;\n  }\n  char[] chars = name.toCharArray();\n  chars[0] = Character.toUpperCase(chars[0]);\n  return new String(chars);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String capitalize(String name) {\n  if (name == null) {\n    return null;\n  }\n  if (name.length() == 0) {\n    return name;\n  }\n  char[] chars = name.toCharArray();\n  chars[0] = Character.toUpperCase(chars[0]);\n  return new String(chars);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String capitalize(String name) {\n  StringBuilder sb = new StringBuilder(name.length());\n  char[] chars = name.toCharArray();\n  for (int i = 0; i < chars.length; i++) {\n    char c = chars[i];\n    if (Character.isUpperCase(c)) {\n      sb.append(' ');\n      sb.append(Character.toLowerCase(c));\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name) {\n  if (name == null || name.length() == 0) {\n    return name;\n  }\n  char[] chars = name.toCharArray();\n  chars[0] = Character.toUpperCase(chars[0]);\n  return new String(chars);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String capitalize(String name) {\n  return Introspector.decapitalize(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String capitalize(String name) {\n  if (name == null) {\n    return null;\n  }\n  return name.substring(0, 1).toUpperCase() + name.substring(1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Reverse of Introspector.decapitalize\n */\n", "method_name": "capitalize", "codes": ["public static String capitalize(String name){ if (name == null) { return null; } if (name.length() == 0) { return name; } return Character.toUpperCase(name.charAt(0)) + name.substring(1); }", "public static String capitalize(String name){ if (name == null || name.length() == 0) return name; char first = name.charAt(0); char second = Character.toUpperCase(first); name = second + name.substring(1); return name; }", "public static String capitalize(String name){ if (name == null || name.length() == 0) { return name; } char firstChar = name.charAt(0); if (Character.isUpperCase(firstChar)) { return name; } else { return Character.toUpperCase(firstChar) + name.substring(1); } }", "public static String capitalize(String name){ return Introspector.decapitalize(name); }", "public static String capitalize(String name){ if (name == null || name.length() == 0) { return name; } char[] chars = name.toCharArray(); chars[0] = Character.toUpperCase(chars[0]); return new String(chars); }", "public static String capitalize(String name){ if (name == null) { return null; } if (name.length() == 0) { return name; } char[] chars = name.toCharArray(); chars[0] = Character.toUpperCase(chars[0]); return new String(chars); }", "public static String capitalize(String name){ StringBuilder sb = new StringBuilder(name.length()); char[] chars = name.toCharArray(); for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (Character.isUpperCase(c)) { sb.append(' '); sb.append(Character.toLowerCase(c)); } else { sb.append(c); } } return sb.toString(); }", "public static String capitalize(String name){ if (name == null || name.length() == 0) { return name; } char[] chars = name.toCharArray(); chars[0] = Character.toUpperCase(chars[0]); return new String(chars); }", "public static String capitalize(String name){ return Introspector.decapitalize(name); }", "public static String capitalize(String name){ if (name == null) { return null; } return name.substring(0, 1).toUpperCase() + name.substring(1); }"], "code_level": "slib_runnable", "_id": "636766821a6d9265ec0174bf", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  StringBuilder out = new StringBuilder(str.length());\n  int sz = str.length();\n  StringBuilder unicode = new StringBuilder(4);\n  boolean hadSlash = false;\n  boolean inUnicode = false;\n  for (int i = 0; i < sz; i++) {\n    char ch = str.charAt(i);\n    if (inUnicode) {\n      unicode.append(ch);\n      if (unicode.length() == 4) {\n        int value = Integer.parseInt(unicode.toString(), 16);\n        if (value < 0x20 || value > 0x7f) {\n          out.append('\\\\');\n          out.append('u');\n          out.append(toHex(value));\n          hadSlash = false;\n          unicode.setLength(0);\n          continue;\n        }\n        out.append((char) value);\n        hadSlash = false;\n        unicode.setLength(0);\n      }\n      continue;\n    }\n    if (hadSlash) {\n      hadSlash = false;\n      switch (ch) {\n        case '\\\\':\n          out.append('\\\\');\n          break;\n        case '\\'':\n          out.append('\\'');\n          break;\n        case '\"':\n          out.append('\"');\n          break;\n        case 'r':\n          out.append('\\r');\n          break;\n        case 'n':\n          out.append('\\n');\n          break;\n        case 'f':\n          out.append('\\f');\n          break;\n        case 't':\n          out.append('\\t');\n          break;\n        case 'b':\n          out.append('\\b');\n          break;\n        case 'u':\n          {\n            int value = 0;\n            for (int j = 0; j < 4; j++) {\n              int v = Character.digit(str.charAt(i + j), 16);\n              if (v < 0) {\n                break;\n              }\n              value = 10 * value + v;\n            }\n            out.append((char) value);\n            inUnicode = true;\n            break;\n          }\n        default:\n          out.append(ch);\n          break;\n      }\n      continue;\n    } else {\n      hadSlash = true;\n    }\n    out.append(ch);\n  }\n  return out.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  StringBuffer sb = new StringBuffer(str.length());\n  StringReader sr = new StringReader(str);\n  char[] cbuf = new char[1024];\n  int n = -1;\n  while ((n = sr.read(cbuf)) != -1) {\n    sb.append(cbuf, 0, n);\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  return unescapeJava(str.toCharArray());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  return unescapeJava(str, true, true, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  return unescapeJava(str, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  StringBuffer unicode = new StringBuffer();\n  int sz = str.length();\n  boolean hadSlash = false;\n  boolean inUnicode = false;\n  for (int i = 0; i < sz; i++) {\n    char ch = str.charAt(i);\n    if (inUnicode) {\n      if (ch == '\\\\') {\n        hadSlash = !hadSlash;\n      } else if (hadSlash) {\n        unicode.append(ch);\n      } else {\n        unicode.append(\"\\\\u\");\n        String s = Integer.toHexString(ch);\n        for (int j = 0; j < 4 - s.length(); j++) {\n          s = \"0\" + s;\n        }\n        unicode.append(s);\n      }\n      inUnicode = false;\n    } else if (ch == '\\\\') {\n      inUnicode = true;\n    } else {\n      unicode.append(ch);\n    }\n  }\n  return unicode.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) return null;\n  StringBuilder out = new StringBuilder(str.length());\n  int last = 0;\n  int i = 0;\n  char ch;\n  while (i < str.length()) {\n    ch = str.charAt(i);\n    if (ch == '\\\\') {\n      if (i + 1 < str.length() && str.charAt(i + 1) == 'u') {\n        i += 2;\n        ch = (char) Integer.parseInt(str.substring(last, i), 16);\n        last = i;\n      }\n    }\n    out.append(ch);\n    i++;\n  }\n  return out.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  StringBuilder out = new StringBuilder(str.length());\n  int last = 0;\n  char ch;\n  for (int i = 0; i < str.length(); i++) {\n    ch = str.charAt(i);\n    if (ch == '\\\\') {\n      i++;\n      if (i >= str.length()) {\n        throw new IllegalArgumentException(\"Invalid escape sequence at index \" + i + \": \" + str);\n      }\n      ch = str.charAt(i);\n      switch (ch) {\n        case 'u':\n          i += 2;\n          if (i >= str.length()) {\n            throw new IllegalArgumentException(\n                \"Invalid escape sequence at index \" + i + \": \" + str);\n          }\n          int u = Character.digit(str.charAt(i++), 16);\n          if (u == -1) {\n            throw new IllegalArgumentException(\n                \"Invalid escape sequence at index \" + i + \": \" + str);\n          }\n          ch = (char) ((u << 4) + Character.digit(str.charAt(i++), 16));\n          break;\n        default:\n          throw new IllegalArgumentException(\n              \"Invalid escape sequence at index \" + i + \": \" + str);\n      }\n    }\n    out.append(ch);\n    last = i;\n  }\n  if (last != str.length()) {\n    throw new IllegalArgumentException(\"Invalid escape sequence at end of string: \" + str);\n  }\n  return out.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  return unescapeJava(str, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) return null;\n  StringWriter writer = new StringWriter();\n  unescapeJava(str, writer);\n  return writer.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code> into a newline character, unless the <code>'\\'</code> is preceded by another <code>'\\'</code>.</p>\n * @param str the <code>String</code> to unescape, may be null\n * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n */\n", "method_name": "unescapeJava", "codes": ["public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } StringBuilder out = new StringBuilder(str.length()); int sz = str.length(); StringBuilder unicode = new StringBuilder(4); boolean hadSlash = false; boolean inUnicode = false; for (int i = 0; i < sz; i++) { char ch = str.charAt(i); if (inUnicode) { unicode.append(ch); if (unicode.length() == 4) { int value = Integer.parseInt(unicode.toString(), 16); if (value < 0x20 || value > 0x7f) { out.append('\\\\'); out.append('u'); out.append(toHex(value)); hadSlash = false; unicode.setLength(0); continue; } out.append((char) value); hadSlash = false; unicode.setLength(0); } continue; } if (hadSlash) { hadSlash = false; switch(ch) { case '\\\\': out.append('\\\\'); break; case '\\'': out.append('\\''); break; case '\"': out.append('\"'); break; case 'r': out.append('\\r'); break; case 'n': out.append('\\n'); break; case 'f': out.append('\\f'); break; case 't': out.append('\\t'); break; case 'b': out.append('\\b'); break; case 'u': { int value = 0; for (int j = 0; j < 4; j++) { int v = Character.digit(str.charAt(i + j), 16); if (v < 0) { break; } value = 10 * value + v; } out.append((char) value); inUnicode = true; break; } default: out.append(ch); break; } continue; } else { hadSlash = true; } out.append(ch); } return out.toString(); }", "public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } StringBuffer sb = new StringBuffer(str.length()); StringReader sr = new StringReader(str); char[] cbuf = new char[1024]; int n = -1; while ((n = sr.read(cbuf)) != -1) { sb.append(cbuf, 0, n); } return sb.toString(); }", "public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } return unescapeJava(str.toCharArray()); }", "public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } return unescapeJava(str, true, true, true); }", "public static String unescapeJava(String str) throws Exception { return unescapeJava(str, false); }", "public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } StringBuffer unicode = new StringBuffer(); int sz = str.length(); boolean hadSlash = false; boolean inUnicode = false; for (int i = 0; i < sz; i++) { char ch = str.charAt(i); if (inUnicode) { if (ch == '\\\\') { hadSlash = !hadSlash; } else if (hadSlash) { unicode.append(ch); } else { unicode.append(\"\\\\u\"); String s = Integer.toHexString(ch); for (int j = 0; j < 4 - s.length(); j++) { s = \"0\" + s; } unicode.append(s); } inUnicode = false; } else if (ch == '\\\\') { inUnicode = true; } else { unicode.append(ch); } } return unicode.toString(); }", "public static String unescapeJava(String str) throws Exception { if (str == null) return null; StringBuilder out = new StringBuilder(str.length()); int last = 0; int i = 0; char ch; while (i < str.length()) { ch = str.charAt(i); if (ch == '\\\\') { if (i + 1 < str.length() && str.charAt(i + 1) == 'u') { i += 2; ch = (char) Integer.parseInt(str.substring(last, i), 16); last = i; } } out.append(ch); i++; } return out.toString(); }", "public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } StringBuilder out = new StringBuilder(str.length()); int last = 0; char ch; for (int i = 0; i < str.length(); i++) { ch = str.charAt(i); if (ch == '\\\\') { i++; if (i >= str.length()) { throw new IllegalArgumentException(\"Invalid escape sequence at index \" + i + \": \" + str); } ch = str.charAt(i); switch(ch) { case 'u': i += 2; if (i >= str.length()) { throw new IllegalArgumentException(\"Invalid escape sequence at index \" + i + \": \" + str); } int u = Character.digit(str.charAt(i++), 16); if (u == -1) { throw new IllegalArgumentException(\"Invalid escape sequence at index \" + i + \": \" + str); } ch = (char) ((u << 4) + Character.digit(str.charAt(i++), 16)); break; default: throw new IllegalArgumentException(\"Invalid escape sequence at index \" + i + \": \" + str); } } out.append(ch); last = i; } if (last != str.length()) { throw new IllegalArgumentException(\"Invalid escape sequence at end of string: \" + str); } return out.toString(); }", "public static String unescapeJava(String str) throws Exception { return unescapeJava(str, true); }", "public static String unescapeJava(String str) throws Exception { if (str == null) return null; StringWriter writer = new StringWriter(); unescapeJava(str, writer); return writer.toString(); }"], "code_level": "slib_runnable", "_id": "6367667d1a6d9265ec017401", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private static char decodeHexNibble(final char c) {\n  return (char) ((c >> 4) & 0x0F);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c;\n  } else if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  } else if (c >= 'a' && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  } else {\n    throw new IllegalArgumentException(\"Hexadecimal number must be in the range {0-9a-fA-F}.\");\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return (char) (c - '0');\n  }\n  if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  }\n  if (c >= 'a' && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  }\n  throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return (char) (c - '0');\n  }\n  if (c >= 'a' && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  }\n  if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  }\n  throw new IllegalArgumentException(\"Invalid hexadecimal character in input.\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return (char) (c - '0');\n  } else if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  } else {\n    throw new IllegalArgumentException(\"Invalid hexadecimal number '\" + c + \"'\");\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if ((c >= '0') && (c <= '9')) {\n    return (char) (c - '0');\n  }\n  if ((c >= 'a') && (c <= 'f')) {\n    return (char) (c - 'a' + 10);\n  }\n  if ((c >= 'A') && (c <= 'F')) {\n    return (char) (c - 'A' + 10);\n  }\n  throw new IllegalArgumentException(\"Illegal hexadecimal number in decodeHexNibble: \" + c);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return (char) (c - '0');\n  } else if (c >= 'a' && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  } else if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  } else {\n    throw new IllegalArgumentException(\n        \"The character \" + c + \" is not a valid hexadecimal number\");\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  return (char) (c < '0' ? (c - '0') : (c - 'A' + 10));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return (char) (c - '0');\n  }\n  if (c >= 'a' && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  }\n  if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  }\n  return Character.MAX_VALUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  return (char) (((c >>> 4) & 0xF) | ((c << 4) & 0xF0));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}.\n * @return The hexadecimal value represented in the ASCII charactergiven, or  {@link Character#MAX_VALUE} if the character is invalid.\n */\n", "method_name": "decodeHexNibble", "codes": ["private static char decodeHexNibble(final char c){ return (char) ((c >> 4) & 0x0F); }", "private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return c; } else if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } else if (c >= 'a' && c <= 'f') { return (char) (c - 'a' + 10); } else { throw new IllegalArgumentException(\"Hexadecimal number must be in the range {0-9a-fA-F}.\"); } }", "private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return (char) (c - '0'); } if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } if (c >= 'a' && c <= 'f') { return (char) (c - 'a' + 10); } throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c); }", "private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return (char) (c - '0'); } if (c >= 'a' && c <= 'f') { return (char) (c - 'a' + 10); } if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } throw new IllegalArgumentException(\"Invalid hexadecimal character in input.\"); }", "private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return (char) (c - '0'); } else if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } else { throw new IllegalArgumentException(\"Invalid hexadecimal number '\" + c + \"'\"); } }", "private static char decodeHexNibble(final char c){ if ((c >= '0') && (c <= '9')) { return (char) (c - '0'); } if ((c >= 'a') && (c <= 'f')) { return (char) (c - 'a' + 10); } if ((c >= 'A') && (c <= 'F')) { return (char) (c - 'A' + 10); } throw new IllegalArgumentException(\"Illegal hexadecimal number in decodeHexNibble: \" + c); }", "private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return (char) (c - '0'); } else if (c >= 'a' && c <= 'f') { return (char) (c - 'a' + 10); } else if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } else { throw new IllegalArgumentException(\"The character \" + c + \" is not a valid hexadecimal number\"); } }", "private static char decodeHexNibble(final char c){ return (char) (c < '0' ? (c - '0') : (c - 'A' + 10)); }", "private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return (char) (c - '0'); } if (c >= 'a' && c <= 'f') { return (char) (c - 'a' + 10); } if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } return Character.MAX_VALUE; }", "private static char decodeHexNibble(final char c){ return (char) (((c >>> 4) & 0xF) | ((c << 4) & 0xF0)); }"], "code_level": "slib_runnable", "_id": "636766851a6d9265ec01751b", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    if (actualTypeArguments != null && actualTypeArguments.length == 1) {\n      Type actualTypeArgument = actualTypeArguments[0];\n      if (actualTypeArgument instanceof Class<?>) {\n        return (Class<?>[])\n            ArrayUtils.add(new Class<?>[] {(Class<?>) actualTypeArgument}, targetType);\n      }\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    if (actualTypeArguments.length == 1) {\n      Type actualTypeArgument = actualTypeArguments[0];\n      if (actualTypeArgument instanceof Class) {\n        return (Class<?>[])\n            ArrayUtils.add(new Class<?>[] {(Class<?>) actualTypeArgument}, targetType);\n      }\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof Class) {\n    return new Class[] {(Class<?>) genericType};\n  } else if (genericType instanceof ParameterizedType) {\n    Type[] actualTypeArguments = ((ParameterizedType) genericType).getActualTypeArguments();\n    Class<?>[] arguments = new Class[actualTypeArguments.length];\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n      arguments[i] = resolveType(actualTypeArguments[i], targetType);\n    }\n    return arguments;\n  } else if (genericType instanceof GenericArrayType) {\n    GenericArrayType genericArrayType = (GenericArrayType) genericType;\n    Class<?> componentType = resolveType(genericArrayType.getGenericComponentType(), targetType);\n    return Arrays.stream(\n            resolveArguments(genericArrayType.getGenericComponentType(), componentType))\n        .toArray(Class[]::new);\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  Class<?>[] args = resolveArguments(genericType);\n  if (args != null) {\n    return args;\n  }\n  if (targetType.isArray()) {\n    return new Class<?>[] {targetType.getComponentType()};\n  }\n  if (targetType.isPrimitive()) {\n    if (targetType == boolean.class) {\n      return new Class<?>[] {Boolean.FALSE};\n    } else if (targetType == byte.class) {\n      return new Class<?>[] {Byte.valueOf((byte) 0)};\n    } else if (targetType == char.class) {\n      return new Class<?>[] {Character.valueOf('\\0')};\n    } else if (targetType == short.class) {\n      return new Class<?>[] {Short.valueOf((short) 0)};\n    } else if (targetType == int.class) {\n      return new Class<?>[] {Integer.valueOf(0)};\n    } else if (targetType == long.class) {\n      return new Class<?>[] {Long.valueOf(0L)};\n    } else if (targetType == float.class) {\n      return new Class<?>[] {Float.valueOf(0.0f)};\n    } else if (targetType == double.class) {\n      return new Class<?>[] {Double.valueOf(0.0)};\n    } else {\n      return new Class<?>[] {targetType};\n    }\n  }\n  if (targetType.isEnum()) {\n    return new Class<?>[] {targetType};\n  }\n  if (targetType.isArray()) {\n    return new Class<?>[] {targetType.getComponentType()};\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  return resolveArguments(genericType, targetType, new ArrayList<Class<?>>());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    return resolveArguments((ParameterizedType) genericType, targetType);\n  } else if (genericType instanceof TypeVariable) {\n    return resolveArguments((TypeVariable) genericType, targetType);\n  } else {\n    return null;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  Type[] arguments = resolveGenericArguments(genericType, targetType);\n  if (arguments != null) {\n    Class<?>[] argumentClasses = new Class<?>[arguments.length];\n    for (int i = 0; i < arguments.length; i++) {\n      argumentClasses[i] = (Class<?>) arguments[i];\n    }\n    return argumentClasses;\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    if (parameterizedType.getRawType().isAssignableFrom(targetType)) {\n      Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n      if (actualTypeArguments == null || actualTypeArguments.length == 0) {\n        return null;\n      }\n      Class<?>[] result = new Class<?>[actualTypeArguments.length];\n      for (int i = 0; i < actualTypeArguments.length; i++) {\n        if (actualTypeArguments[i] instanceof TypeVariable) {\n          result[i] = resolveTypeVariable((TypeVariable) actualTypeArguments[i], targetType);\n        } else if (actualTypeArguments[i] instanceof Class) {\n          result[i] = (Class<?>) actualTypeArguments[i];\n        } else {\n          result[i] = resolveClass(actualTypeArguments[i], targetType);\n        }\n      }\n      return result;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Class<?>[] argumentTypes = resolveTypeArguments(parameterizedType, targetType);\n    if (argumentTypes != null) {\n      return argumentTypes;\n    }\n  } else if (genericType instanceof GenericArrayType) {\n    GenericArrayType arrayType = (GenericArrayType) genericType;\n    Class<?> componentType =\n        resolveTypeArguments(arrayType.getGenericComponentType(), targetType);\n    if (componentType != null) {\n      return new Class<?>[] {componentType};\n    }\n  } else if (genericType instanceof TypeVariable) {\n    TypeVariable<?> typeVariable = (TypeVariable<?>) genericType;\n    Type[] bounds = targetType.getTypeParameters()[typeVariable.getIndex()];\n    if (bounds != null) {\n      Class<?> componentType = resolveTypeArguments(bounds[0], targetType);\n      if (componentType != null) {\n        return new Class<?>[] {componentType};\n      }\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Type[] typeArgs = parameterizedType.getActualTypeArguments();\n    if (typeArgs != null && typeArgs.length > 0) {\n      Class<?>[] result = new Class<?>[typeArgs.length];\n      for (int i = 0; i < typeArgs.length; i++) {\n        result[i] = resolveArgument(typeArgs[i], targetType);\n      }\n      return result;\n    }\n  }\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.\n */\n", "method_name": "resolveArguments", "codes": ["public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments != null && actualTypeArguments.length == 1) { Type actualTypeArgument = actualTypeArguments[0]; if (actualTypeArgument instanceof Class<?>) { return (Class<?>[]) ArrayUtils.add(new Class<?>[] { (Class<?>) actualTypeArgument }, targetType); } } } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments.length == 1) { Type actualTypeArgument = actualTypeArguments[0]; if (actualTypeArgument instanceof Class) { return (Class<?>[]) ArrayUtils.add(new Class<?>[] { (Class<?>) actualTypeArgument }, targetType); } } } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof Class) { return new Class[] { (Class<?>) genericType }; } else if (genericType instanceof ParameterizedType) { Type[] actualTypeArguments = ((ParameterizedType) genericType).getActualTypeArguments(); Class<?>[] arguments = new Class[actualTypeArguments.length]; for (int i = 0; i < actualTypeArguments.length; i++) { arguments[i] = resolveType(actualTypeArguments[i], targetType); } return arguments; } else if (genericType instanceof GenericArrayType) { GenericArrayType genericArrayType = (GenericArrayType) genericType; Class<?> componentType = resolveType(genericArrayType.getGenericComponentType(), targetType); return Arrays.stream(resolveArguments(genericArrayType.getGenericComponentType(), componentType)).toArray(Class[]::new); } else { return null; } }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ Class<?>[] args = resolveArguments(genericType); if (args != null) { return args; } if (targetType.isArray()) { return new Class<?>[] { targetType.getComponentType() }; } if (targetType.isPrimitive()) { if (targetType == boolean.class) { return new Class<?>[] { Boolean.FALSE }; } else if (targetType == byte.class) { return new Class<?>[] { Byte.valueOf((byte) 0) }; } else if (targetType == char.class) { return new Class<?>[] { Character.valueOf('\\0') }; } else if (targetType == short.class) { return new Class<?>[] { Short.valueOf((short) 0) }; } else if (targetType == int.class) { return new Class<?>[] { Integer.valueOf(0) }; } else if (targetType == long.class) { return new Class<?>[] { Long.valueOf(0L) }; } else if (targetType == float.class) { return new Class<?>[] { Float.valueOf(0.0f) }; } else if (targetType == double.class) { return new Class<?>[] { Double.valueOf(0.0) }; } else { return new Class<?>[] { targetType }; } } if (targetType.isEnum()) { return new Class<?>[] { targetType }; } if (targetType.isArray()) { return new Class<?>[] { targetType.getComponentType() }; } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ return resolveArguments(genericType, targetType, new ArrayList<Class<?>>()); }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { return resolveArguments((ParameterizedType) genericType, targetType); } else if (genericType instanceof TypeVariable) { return resolveArguments((TypeVariable) genericType, targetType); } else { return null; } }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ Type[] arguments = resolveGenericArguments(genericType, targetType); if (arguments != null) { Class<?>[] argumentClasses = new Class<?>[arguments.length]; for (int i = 0; i < arguments.length; i++) { argumentClasses[i] = (Class<?>) arguments[i]; } return argumentClasses; } else { return null; } }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; if (parameterizedType.getRawType().isAssignableFrom(targetType)) { Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments == null || actualTypeArguments.length == 0) { return null; } Class<?>[] result = new Class<?>[actualTypeArguments.length]; for (int i = 0; i < actualTypeArguments.length; i++) { if (actualTypeArguments[i] instanceof TypeVariable) { result[i] = resolveTypeVariable((TypeVariable) actualTypeArguments[i], targetType); } else if (actualTypeArguments[i] instanceof Class) { result[i] = (Class<?>) actualTypeArguments[i]; } else { result[i] = resolveClass(actualTypeArguments[i], targetType); } } return result; } } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Class<?>[] argumentTypes = resolveTypeArguments(parameterizedType, targetType); if (argumentTypes != null) { return argumentTypes; } } else if (genericType instanceof GenericArrayType) { GenericArrayType arrayType = (GenericArrayType) genericType; Class<?> componentType = resolveTypeArguments(arrayType.getGenericComponentType(), targetType); if (componentType != null) { return new Class<?>[] { componentType }; } } else if (genericType instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) genericType; Type[] bounds = targetType.getTypeParameters()[typeVariable.getIndex()]; if (bounds != null) { Class<?> componentType = resolveTypeArguments(bounds[0], targetType); if (componentType != null) { return new Class<?>[] { componentType }; } } } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Type[] typeArgs = parameterizedType.getActualTypeArguments(); if (typeArgs != null && typeArgs.length > 0) { Class<?>[] result = new Class<?>[typeArgs.length]; for (int i = 0; i < typeArgs.length; i++) { result[i] = resolveArgument(typeArgs[i], targetType); } return result; } } return null; }"], "code_level": "class_runnable", "_id": "636766821a6d9265ec0174b6", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  Type bound = typeVariable.getBounds()[0];\n  if (bound == null) {\n    throw new IllegalArgumentException(\"No type bounds for type variable \" + typeVariable);\n  }\n  return resolveBound(bound);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  Type[] bounds = typeVariable.getBounds();\n  if (bounds.length == 0) {\n    return Unknown.class;\n  } else if (bounds.length == 1) {\n    return resolveBound(bounds[0]);\n  } else {\n    throw new IllegalArgumentException(\"More than one bound for \" + typeVariable);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  return resolveBound(typeVariable, Unknown.class);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  if (typeVariable.getBounds().length == 0) {\n    return Unknown.class;\n  }\n  return resolveBound(typeVariable.getBounds()[0]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  Type[] bounds = typeVariable.getBounds();\n  if (bounds.length == 0) {\n    return Unknown.class;\n  }\n  return bounds[0];\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  Assert.notNull(typeVariable, \"TypeVariable must not be null\");\n  return resolveBound(typeVariable.getBounds(), typeVariable);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  Type[] bounds = typeVariable.getBounds();\n  if (bounds.length == 0) {\n    return Unknown.class;\n  }\n  return bounds[0];\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  if (typeVariable.getBounds().length == 0) {\n    return Unknown.class;\n  }\n  return typeVariable.getBounds()[0];\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  Type type = typeVariable.getBounds()[0];\n  if (type instanceof TypeVariable) {\n    type = resolveBound((TypeVariable) type);\n  }\n  if (type instanceof Class) {\n    return ((Class<?>) type).getGenericSuperclass();\n  } else if (type instanceof ParameterizedType) {\n    return ((ParameterizedType) type).getRawType();\n  } else {\n    throw new IllegalArgumentException(\"Invalid type variable \" + typeVariable);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  return resolveBound(typeVariable, Unknown.class);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Resolves the first bound for the  {@code typeVariable}, returning  {@code Unknown.class} if nonecan be resolved.\n */\n", "method_name": "resolveBound", "codes": ["public static Type resolveBound(TypeVariable<?> typeVariable){ Type bound = typeVariable.getBounds()[0]; if (bound == null) { throw new IllegalArgumentException(\"No type bounds for type variable \" + typeVariable); } return resolveBound(bound); }", "public static Type resolveBound(TypeVariable<?> typeVariable){ Type[] bounds = typeVariable.getBounds(); if (bounds.length == 0) { return Unknown.class; } else if (bounds.length == 1) { return resolveBound(bounds[0]); } else { throw new IllegalArgumentException(\"More than one bound for \" + typeVariable); } }", "public static Type resolveBound(TypeVariable<?> typeVariable){ return resolveBound(typeVariable, Unknown.class); }", "public static Type resolveBound(TypeVariable<?> typeVariable){ if (typeVariable.getBounds().length == 0) { return Unknown.class; } return resolveBound(typeVariable.getBounds()[0]); }", "public static Type resolveBound(TypeVariable<?> typeVariable){ Type[] bounds = typeVariable.getBounds(); if (bounds.length == 0) { return Unknown.class; } return bounds[0]; }", "public static Type resolveBound(TypeVariable<?> typeVariable){ Assert.notNull(typeVariable, \"TypeVariable must not be null\"); return resolveBound(typeVariable.getBounds(), typeVariable); }", "public static Type resolveBound(TypeVariable<?> typeVariable){ Type[] bounds = typeVariable.getBounds(); if (bounds.length == 0) { return Unknown.class; } return bounds[0]; }", "public static Type resolveBound(TypeVariable<?> typeVariable){ if (typeVariable.getBounds().length == 0) { return Unknown.class; } return typeVariable.getBounds()[0]; }", "public static Type resolveBound(TypeVariable<?> typeVariable){ Type type = typeVariable.getBounds()[0]; if (type instanceof TypeVariable) { type = resolveBound((TypeVariable) type); } if (type instanceof Class) { return ((Class<?>) type).getGenericSuperclass(); } else if (type instanceof ParameterizedType) { return ((ParameterizedType) type).getRawType(); } else { throw new IllegalArgumentException(\"Invalid type variable \" + typeVariable); } }", "public static Type resolveBound(TypeVariable<?> typeVariable){ return resolveBound(typeVariable, Unknown.class); }"], "code_level": "slib_runnable", "_id": "6367667d1a6d9265ec01741d", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequest(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  if (request == null) return null;\n  try {\n    return new AtmosphereRequest(request, new AtmosphereHandlerWrapper(request, null));\n  } catch (Throwable e) {\n    logger.warn(\"\", e);\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  if (request instanceof AtmosphereRequest) {\n    return (AtmosphereRequest) request;\n  }\n  return new AtmosphereRequestImpl(request, AtmosphereFramework.class.getClassLoader());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Wrap an  {@link HttpServletRequest}.\n * @param request {@link HttpServletRequest}\n * @return an {@link AtmosphereRequest}\n */\n", "method_name": "wrap", "codes": ["public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequest(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ if (request == null) return null; try { return new AtmosphereRequest(request, new AtmosphereHandlerWrapper(request, null)); } catch (Throwable e) { logger.warn(\"\", e); return null; } }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ if (request instanceof AtmosphereRequest) { return (AtmosphereRequest) request; } return new AtmosphereRequestImpl(request, AtmosphereFramework.class.getClassLoader()); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request); }"], "code_level": "class_runnable", "_id": "636766821a6d9265ec0174d2", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  return removeAtmosphereHandler(mapping, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  synchronized (atmosphereHandlersLock) {\n    AtmosphereHandler handler = this.atmosphereHandlers.remove(mapping);\n    if (handler != null) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Removing AtmosphereHandler {}\", mapping);\n      }\n      if (!mapping.startsWith(\"/\")) {\n        mapping = \"/\" + mapping;\n      }\n      try {\n        mapping = URLDecoder.decode(mapping, \"UTF-8\");\n      } catch (UnsupportedEncodingException e) {\n        logger.error(\"Encoding exception\", e);\n      }\n      if (!mapping.startsWith(\"/\")) {\n        mapping = \"/\" + mapping;\n      }\n      if (!mapping.equals(\"/\")) {\n        mapping = \"/\" + mapping;\n      }\n      if (!mapping.startsWith(\"*.\")) {\n        for (String prefix : mapping.split(\"/\")) {\n          if (!webSocketHandlers.containsKey(prefix)) {\n            if (logger.isWarnEnabled()) {\n              logger.warn(\"Unknown WebSocketHandler mapping {}, ignoring\", mapping);\n            }\n            continue;\n          }\n          if (!mapping.endsWith(\"*\")) {\n            mapping = mapping + \"/\";\n          }\n          WebSocketHandler wsHandler = webSocketHandlers.get(prefix);\n          if (wsHandler instanceof AtmosphereHandlerWrapper) {\n            AtmosphereHandlerWrapper wsHandlerWrapper = (AtmosphereHandlerWrapper) wsHandler;\n            if (!wsHandlerWrapper.isAtmosphereResource()) {\n              logger.warn(\n                  \"WebSocketHandler {} cannot be used in a AtmosphereHandlerWrapper\", wsHandler);\n              continue;\n            }\n          }\n          if (wsHandler instanceof AtmosphereHandlerAdapter) {\n            AtmosphereHandlerAdapter wsHandlerWrapper = (AtmosphereHandlerAdapter) wsHandler;\n            if (!wsHandlerWrapper.isAtmosphereResource()) {\n              logger.warn(\n                  \"WebSocketHandler {} cannot be used in a AtmosphereHandlerAdapter\", wsHandler);\n              continue;\n            }\n          }\n          try {\n            AtmosphereHandlerAdapter.class\n                .getMethod(\"destroy\", String.class)\n                .invoke(wsHandler, mapping);\n          } catch (Exception ex) {\n            logger.warn(\"Failed to destroy WebSocketHandler {}\", mapping, ex);\n          }\n        }\n      }\n    }\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  AtmosphereHandlerWrapper aw = (AtmosphereHandlerWrapper) mappings.remove(mapping);\n  if (aw == null) return this;\n  aw.destroy();\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  if (mapping == null) return this;\n  for (AtmosphereHandlerWrapper w : broadcaster.removeAtmosphereHandlers(mapping)) {\n    if (w.getAtmosphereHandler() == null) continue;\n    w.getAtmosphereHandler().destroy();\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  if (!framework.initialized) {\n    return this;\n  }\n  AtmosphereHandlerWrapper aw = framework.atmosphereHandlers.remove(mapping);\n  if (aw == null) {\n    return this;\n  }\n  aw.atmosphereHandler.destroy();\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  if (mapping == null) return this;\n  AtmosphereHandlerWrapper w = map(mapping, mappings);\n  if (w == null) return this;\n  if (w.atmosphereHandler != null) {\n    w.atmosphereHandler.destroy();\n  }\n  w.atmosphereHandler = null;\n  w.atmosphereConfig = null;\n  w.removeInitParameter(ApplicationConfig.SUSPEND_ON_INIT);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  return this.removeAtmosphereHandler(mapping, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  AtmosphereHandlerWrapper handlerWrapper = broadcaster.removeAtmosphereHandler(mapping);\n  if (handlerWrapper != null) {\n    handlerWrapper.destroy();\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  synchronized (atmosphereHandlers) {\n    return (AtmosphereFramework) removeAtmosphereHandler(mapping, mapping);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  if (mapping.startsWith(\"/\")) {\n    mapping = mapping.substring(1);\n  }\n  if (mapping.endsWith(\"/\")) {\n    mapping = mapping.substring(0, mapping.length() - 1);\n  }\n  if (mapping.equals(\"/\")) {\n    mapping = \"/\";\n  }\n  for (Map.Entry<String, AtmosphereHandlerWrapper> entry : mappings.entrySet()) {\n    if (entry.getKey().equals(mapping)) {\n      AtmosphereHandlerWrapper wrapper = entry.getValue();\n      if (wrapper.removeAtmosphereHandler()) {\n        logger.debug(\"Removed AtmosphereHandler {}\", mapping);\n        return this;\n      }\n    }\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Remove an  {@link AtmosphereHandler}.\n * @param mapping the mapping used when invoking {@link #addAtmosphereHandler(String,AtmosphereHandler)};\n * @return true if removed\n */\n", "method_name": "removeAtmosphereHandler", "codes": ["public AtmosphereFramework removeAtmosphereHandler(String mapping){ return removeAtmosphereHandler(mapping, false); }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ synchronized (atmosphereHandlersLock) { AtmosphereHandler handler = this.atmosphereHandlers.remove(mapping); if (handler != null) { if (logger.isDebugEnabled()) { logger.debug(\"Removing AtmosphereHandler {}\", mapping); } if (!mapping.startsWith(\"/\")) { mapping = \"/\" + mapping; } try { mapping = URLDecoder.decode(mapping, \"UTF-8\"); } catch (UnsupportedEncodingException e) { logger.error(\"Encoding exception\", e); } if (!mapping.startsWith(\"/\")) { mapping = \"/\" + mapping; } if (!mapping.equals(\"/\")) { mapping = \"/\" + mapping; } if (!mapping.startsWith(\"*.\")) { for (String prefix : mapping.split(\"/\")) { if (!webSocketHandlers.containsKey(prefix)) { if (logger.isWarnEnabled()) { logger.warn(\"Unknown WebSocketHandler mapping {}, ignoring\", mapping); } continue; } if (!mapping.endsWith(\"*\")) { mapping = mapping + \"/\"; } WebSocketHandler wsHandler = webSocketHandlers.get(prefix); if (wsHandler instanceof AtmosphereHandlerWrapper) { AtmosphereHandlerWrapper wsHandlerWrapper = (AtmosphereHandlerWrapper) wsHandler; if (!wsHandlerWrapper.isAtmosphereResource()) { logger.warn(\"WebSocketHandler {} cannot be used in a AtmosphereHandlerWrapper\", wsHandler); continue; } } if (wsHandler instanceof AtmosphereHandlerAdapter) { AtmosphereHandlerAdapter wsHandlerWrapper = (AtmosphereHandlerAdapter) wsHandler; if (!wsHandlerWrapper.isAtmosphereResource()) { logger.warn(\"WebSocketHandler {} cannot be used in a AtmosphereHandlerAdapter\", wsHandler); continue; } } try { AtmosphereHandlerAdapter.class.getMethod(\"destroy\", String.class).invoke(wsHandler, mapping); } catch (Exception ex) { logger.warn(\"Failed to destroy WebSocketHandler {}\", mapping, ex); } } } } } return this; }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ AtmosphereHandlerWrapper aw = (AtmosphereHandlerWrapper) mappings.remove(mapping); if (aw == null) return this; aw.destroy(); return this; }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ if (mapping == null) return this; for (AtmosphereHandlerWrapper w : broadcaster.removeAtmosphereHandlers(mapping)) { if (w.getAtmosphereHandler() == null) continue; w.getAtmosphereHandler().destroy(); } return this; }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ if (!framework.initialized) { return this; } AtmosphereHandlerWrapper aw = framework.atmosphereHandlers.remove(mapping); if (aw == null) { return this; } aw.atmosphereHandler.destroy(); return this; }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ if (mapping == null) return this; AtmosphereHandlerWrapper w = map(mapping, mappings); if (w == null) return this; if (w.atmosphereHandler != null) { w.atmosphereHandler.destroy(); } w.atmosphereHandler = null; w.atmosphereConfig = null; w.removeInitParameter(ApplicationConfig.SUSPEND_ON_INIT); return this; }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ return this.removeAtmosphereHandler(mapping, false); }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ AtmosphereHandlerWrapper handlerWrapper = broadcaster.removeAtmosphereHandler(mapping); if (handlerWrapper != null) { handlerWrapper.destroy(); } return this; }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ synchronized (atmosphereHandlers) { return (AtmosphereFramework) removeAtmosphereHandler(mapping, mapping); } }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ if (mapping.startsWith(\"/\")) { mapping = mapping.substring(1); } if (mapping.endsWith(\"/\")) { mapping = mapping.substring(0, mapping.length() - 1); } if (mapping.equals(\"/\")) { mapping = \"/\"; } for (Map.Entry<String, AtmosphereHandlerWrapper> entry : mappings.entrySet()) { if (entry.getKey().equals(mapping)) { AtmosphereHandlerWrapper wrapper = entry.getValue(); if (wrapper.removeAtmosphereHandler()) { logger.debug(\"Removed AtmosphereHandler {}\", mapping); return this; } } } return this; }"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec017458", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "protected Object filter(Object msg) {\n  if (msg instanceof Message) {\n    Message m = (Message) msg;\n    if (m.getType().equals(Message.Type.REQUEST)) {\n      if (m.getSender().equals(peerId)) {\n        return m;\n      }\n    }\n  }\n  return msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg instanceof Event) {\n    Event event = (Event) msg;\n    if (filters.size() == 0) {\n      return null;\n    }\n    EventFilter filter = filters.get(0);\n    if (filter.accepts(event)) {\n      return null;\n    }\n  }\n  return msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  if (this.broadcastFilter != null) {\n    return this.broadcastFilter.filter(msg);\n  }\n  return msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  BroadcastFilter filter = this.filter;\n  if (filter != null) {\n    return filter.filter(msg);\n  } else {\n    return msg;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg instanceof Message) {\n    return filter((Message) msg);\n  } else {\n    return msg;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg instanceof ByteBuffer) {\n    return filter((ByteBuffer) msg);\n  } else if (msg instanceof byte[]) {\n    return filter((byte[]) msg);\n  } else if (msg instanceof ByteBuffer[]) {\n    return filter((ByteBuffer[]) msg);\n  } else if (msg instanceof byte[][]) {\n    return filter((byte[][]) msg);\n  } else if (msg instanceof byte[][][]) {\n    return filter((byte[][][]) msg);\n  } else if (msg instanceof byte[][][][]) {\n    return filter((byte[][][][]) msg);\n  } else if (msg instanceof byte[][][][][]) {\n    return filter((byte[][][][][]) msg);\n  } else {\n    return msg;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  return msg;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Object filter(Object msg) {\n  if (!(msg instanceof String)) {\n    return msg;\n  }\n  if (!this.filter.isEmpty()) {\n    String filterStr = (String) msg;\n    if (filterStr.startsWith(this.filter)) {\n      return this.filter.substring(this.filter.length());\n    }\n  }\n  return msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg instanceof Invocation) {\n    return filter((Invocation) msg);\n  } else if (msg instanceof InvocationContext) {\n    return filter((InvocationContext) msg);\n  } else {\n    return msg;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  return msg;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Invoke the  {@link BroadcastFilter}\n * @param msg\n * @return\n */\n", "method_name": "filter", "codes": ["protected Object filter(Object msg){ if (msg instanceof Message) { Message m = (Message) msg; if (m.getType().equals(Message.Type.REQUEST)) { if (m.getSender().equals(peerId)) { return m; } } } return msg; }", "protected Object filter(Object msg){ if (msg instanceof Event) { Event event = (Event) msg; if (filters.size() == 0) { return null; } EventFilter filter = filters.get(0); if (filter.accepts(event)) { return null; } } return msg; }", "protected Object filter(Object msg){ if (this.broadcastFilter != null) { return this.broadcastFilter.filter(msg); } return msg; }", "protected Object filter(Object msg){ BroadcastFilter filter = this.filter; if (filter != null) { return filter.filter(msg); } else { return msg; } }", "protected Object filter(Object msg){ if (msg instanceof Message) { return filter((Message) msg); } else { return msg; } }", "protected Object filter(Object msg){ if (msg instanceof ByteBuffer) { return filter((ByteBuffer) msg); } else if (msg instanceof byte[]) { return filter((byte[]) msg); } else if (msg instanceof ByteBuffer[]) { return filter((ByteBuffer[]) msg); } else if (msg instanceof byte[][]) { return filter((byte[][]) msg); } else if (msg instanceof byte[][][]) { return filter((byte[][][]) msg); } else if (msg instanceof byte[][][][]) { return filter((byte[][][][]) msg); } else if (msg instanceof byte[][][][][]) { return filter((byte[][][][][]) msg); } else { return msg; } }", "protected Object filter(Object msg){ return msg; }", "protected Object filter(Object msg){ if (!(msg instanceof String)) { return msg; } if (!this.filter.isEmpty()) { String filterStr = (String) msg; if (filterStr.startsWith(this.filter)) { return this.filter.substring(this.filter.length()); } } return msg; }", "protected Object filter(Object msg){ if (msg instanceof Invocation) { return filter((Invocation) msg); } else if (msg instanceof InvocationContext) { return filter((InvocationContext) msg); } else { return msg; } }", "protected Object filter(Object msg){ return msg; }"], "code_level": "project_runnable", "_id": "636766821a6d9265ec0174b3", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor interceptor : interceptorList) {\n    if (c.isAssignableFrom(interceptor.getClass())) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  if (interceptorList != null && interceptorList.size() > 0) {\n    for (AtmosphereInterceptor interceptor : interceptorList) {\n      if (c.isAssignableFrom(interceptor.getClass())) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().equals(c)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  boolean duplicate = false;\n  for (AtmosphereInterceptor i : interceptorList) {\n    if (i.getClass().equals(c)) {\n      duplicate = true;\n      break;\n    }\n  }\n  if (!duplicate) {\n    interceptorList.add(\n        new AtmosphereInterceptorAdapter() {\n          @Override\n          public void onStateChange(AtmosphereResourceEvent event) throws IOException {\n            if (event.isCancelled()) {\n              return;\n            }\n            if (event.isResuming()) {\n              return;\n            }\n            if (event.isClosing()) {\n              return;\n            }\n            if (event.isResumed()) {\n              logger.trace(\"Stopping AtmosphereResource {}\", event.getResource());\n              AtmosphereResourceImpl r = (AtmosphereResourceImpl) event.getResource();\n              r.destroy();\n            }\n          }\n\n          @Override\n          public void onDisconnect(AtmosphereResourceEvent event) {\n            if (event.isCancelled()) {\n              return;\n            }\n            if (event.isResuming()) {\n              return;\n            }\n            if (event.isClosing()) {\n              return;\n            }\n            if (event.isResumed()) {\n              logger.trace(\"Stopping AtmosphereResource {}\", event.getResource());\n              AtmosphereResourceImpl r = (AtmosphereResourceImpl) event.getResource();\n              r.destroy();\n            }\n          }\n\n          @Override\n          public void onBroadcast(AtmosphereResourceEvent event) {\n            if (event.isCancelled()) {\n              return;\n            }\n            if (event.isResuming()) {\n              return;\n            }\n            if (event.isClosing()) {\n              return;\n            }\n            if (event.isResumed()) {\n              logger.trace(\"Stopping AtmosphereResource {}\", event.getResource());\n              AtmosphereResourceImpl r = (AtmosphereResourceImpl) event.getResource();\n              r.destroy();\n            }\n          }\n\n          @Override\n          public void onRequest(AtmosphereResourceEvent event) throws IOException {\n            if (event.isCancelled()) {\n              return;\n            }\n            if (event.isResuming()) {\n              return;\n            }\n            if (event.isClosing()) {\n              return;\n            }\n            if (event.isResumed()) {\n              logger.trace(\"Stopping AtmosphereResource {}\", event.getResource());\n              AtmosphereResourceImpl r = (AtmosphereResourceImpl) event.getResource();\n              r.destroy();\n            }\n          }\n        });\n  }\n  return duplicate;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  if (interceptorList.size() > 1) {\n    for (final AtmosphereInterceptor a : interceptorList) {\n      if (a.getClass().equals(c)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().equals(c)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  boolean duplicate = false;\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().getName().equals(c.getName())) {\n      duplicate = true;\n      break;\n    }\n  }\n  return duplicate;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor i : interceptorList) {\n    if (i.getClass().getName().equals(c.getName())) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor i : interceptorList) {\n    if (c.isAssignableFrom(i.getClass())) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  boolean duplicate = false;\n  for (AtmosphereInterceptor interceptor : interceptorList) {\n    if (interceptor.getClass() == c) {\n      duplicate = true;\n      break;\n    }\n  }\n  return duplicate;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor} implementation class.</p>\n * @param interceptorList the interceptors\n * @param c               the interceptor class\n * @return {@code false} if an instance of the class already exists in the list, {@code true} otherwise\n */\n", "method_name": "checkDuplicate", "codes": ["private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor interceptor : interceptorList) { if (c.isAssignableFrom(interceptor.getClass())) { return true; } } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ if (interceptorList != null && interceptorList.size() > 0) { for (AtmosphereInterceptor interceptor : interceptorList) { if (c.isAssignableFrom(interceptor.getClass())) { return true; } } } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().equals(c)) { return true; } } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ boolean duplicate = false; for (AtmosphereInterceptor i : interceptorList) { if (i.getClass().equals(c)) { duplicate = true; break; } } if (!duplicate) { interceptorList.add(new AtmosphereInterceptorAdapter() { @Override public void onStateChange(AtmosphereResourceEvent event) throws IOException { if (event.isCancelled()) { return; } if (event.isResuming()) { return; } if (event.isClosing()) { return; } if (event.isResumed()) { logger.trace(\"Stopping AtmosphereResource {}\", event.getResource()); AtmosphereResourceImpl r = (AtmosphereResourceImpl) event.getResource(); r.destroy(); } } @Override public void onDisconnect(AtmosphereResourceEvent event) { if (event.isCancelled()) { return; } if (event.isResuming()) { return; } if (event.isClosing()) { return; } if (event.isResumed()) { logger.trace(\"Stopping AtmosphereResource {}\", event.getResource()); AtmosphereResourceImpl r = (AtmosphereResourceImpl) event.getResource(); r.destroy(); } } @Override public void onBroadcast(AtmosphereResourceEvent event) { if (event.isCancelled()) { return; } if (event.isResuming()) { return; } if (event.isClosing()) { return; } if (event.isResumed()) { logger.trace(\"Stopping AtmosphereResource {}\", event.getResource()); AtmosphereResourceImpl r = (AtmosphereResourceImpl) event.getResource(); r.destroy(); } } @Override public void onRequest(AtmosphereResourceEvent event) throws IOException { if (event.isCancelled()) { return; } if (event.isResuming()) { return; } if (event.isClosing()) { return; } if (event.isResumed()) { logger.trace(\"Stopping AtmosphereResource {}\", event.getResource()); AtmosphereResourceImpl r = (AtmosphereResourceImpl) event.getResource(); r.destroy(); } } }); } return duplicate; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ if (interceptorList.size() > 1) { for (final AtmosphereInterceptor a : interceptorList) { if (a.getClass().equals(c)) { return true; } } } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().equals(c)) { return true; } } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ boolean duplicate = false; for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().getName().equals(c.getName())) { duplicate = true; break; } } return duplicate; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor i : interceptorList) { if (i.getClass().getName().equals(c.getName())) { return true; } } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor i : interceptorList) { if (c.isAssignableFrom(i.getClass())) { return true; } } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ boolean duplicate = false; for (AtmosphereInterceptor interceptor : interceptorList) { if (interceptor.getClass() == c) { duplicate = true; break; } } return duplicate; }"], "code_level": "project_runnable", "_id": "636766811a6d9265ec017499", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public boolean hasBytes() {\n  return (_bytes != null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return hasBytes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return ((body instanceof byte[]));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return hasBytes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return (bytes != null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return hasBytes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return byteArray != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return !bytes.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return mHasBytes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return hasBytes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * True is the body is a byte array\n * @return True is the body is a byte array\n */\n", "method_name": "hasBytes", "codes": ["public boolean hasBytes(){ return (_bytes != null); }", "public boolean hasBytes(){ return hasBytes; }", "public boolean hasBytes(){ return ((body instanceof byte[])); }", "public boolean hasBytes(){ return hasBytes; }", "public boolean hasBytes(){ return (bytes != null); }", "public boolean hasBytes(){ return hasBytes; }", "public boolean hasBytes(){ return byteArray != null; }", "public boolean hasBytes(){ return !bytes.isEmpty(); }", "public boolean hasBytes(){ return mHasBytes; }", "public boolean hasBytes(){ return hasBytes; }"], "code_level": "class_runnable", "_id": "6367667c1a6d9265ec0173f7", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  return lookup(r, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String s = r.getParameter(\"meteor\");\n  if (s != null) {\n    return (Meteor) PluginManager.getInstance().get(s);\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String s = r.getParameter(\"meteor\");\n  if (s != null) {\n    return lookup(s);\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String m = r.getParameter(\"meteor\");\n  if (m != null) {\n    String[] ms = m.split(\",\");\n    if (ms.length == 2) {\n      String mn = ms[0].trim();\n      String md = ms[1].trim();\n      try {\n        return new Meteor(mn, md);\n      } catch (IllegalArgumentException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String id = r.getParameter(\"id\");\n  if (id != null) {\n    return Meteor.find(Long.parseLong(id));\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String id = r.getParameter(\"id\");\n  if (id == null || id.isEmpty()) return null;\n  String name = r.getParameter(\"name\");\n  if (name == null || name.isEmpty()) return null;\n  String type = r.getParameter(\"type\");\n  if (type == null || type.isEmpty()) return null;\n  String address = r.getParameter(\"address\");\n  if (address == null || address.isEmpty()) return null;\n  String status = r.getParameter(\"status\");\n  if (status == null || status.isEmpty()) return null;\n  String owner = r.getParameter(\"owner\");\n  if (owner == null || owner.isEmpty()) return null;\n  String description = r.getParameter(\"description\");\n  if (description == null || description.isEmpty()) return null;\n  String location = r.getParameter(\"location\");\n  if (location == null || location.isEmpty()) return null;\n  String rssUrl = r.getParameter(\"rssUrl\");\n  if (rssUrl == null || rssUrl.isEmpty()) return null;\n  return new Meteor(id, name, type, address, status, owner, description, location, rssUrl);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  if (r.getParameter(\"id\") != null) {\n    return Meteor.find(Integer.parseInt(r.getParameter(\"id\")));\n  } else if (r.getParameter(\"name\") != null) {\n    return Meteor.find(r.getParameter(\"name\"));\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  return lookup(r.getParameter(\"id\"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String id = r.getParameter(\"id\");\n  String uid = r.getParameter(\"uid\");\n  String name = r.getParameter(\"name\");\n  String description = r.getParameter(\"description\");\n  String type = r.getParameter(\"type\");\n  String location = r.getParameter(\"location\");\n  String url = r.getParameter(\"url\");\n  String image = r.getParameter(\"image\");\n  String user = r.getParameter(\"user\");\n  String password = r.getParameter(\"password\");\n  String slug = r.getParameter(\"slug\");\n  if (id == null\n      || uid == null\n      || name == null\n      || description == null\n      || type == null\n      || location == null\n      || url == null\n      || image == null\n      || user == null\n      || password == null\n      || slug == null) {\n    return null;\n  }\n  return new Meteor(id, uid, name, description, type, location, url, image, user, password, slug);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){ String uri = r.getRequestURI(); if (uri.startsWith(\"/\")) { uri = uri.substring(1); } String s = uri.substring(uri.lastIndexOf(\"/\") + 1); if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.startsWith(\"?\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\".\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"#\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.startsWith(\":\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"?\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"?\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Retrieve an instance of  {@link Meteor} based on the {@link HttpServletRequest}.\n * @param r {@link HttpServletRequest}\n * @return a {@link Meteor} or null if not found\n */\n", "method_name": "lookup", "codes": ["public static Meteor lookup(HttpServletRequest r){ return lookup(r, true); }", "public static Meteor lookup(HttpServletRequest r){ String s = r.getParameter(\"meteor\"); if (s != null) { return (Meteor) PluginManager.getInstance().get(s); } return null; }", "public static Meteor lookup(HttpServletRequest r){ String s = r.getParameter(\"meteor\"); if (s != null) { return lookup(s); } else { return null; } }", "public static Meteor lookup(HttpServletRequest r){ String m = r.getParameter(\"meteor\"); if (m != null) { String[] ms = m.split(\",\"); if (ms.length == 2) { String mn = ms[0].trim(); String md = ms[1].trim(); try { return new Meteor(mn, md); } catch (IllegalArgumentException e) { e.printStackTrace(); } } } return null; }", "public static Meteor lookup(HttpServletRequest r){ String id = r.getParameter(\"id\"); if (id != null) { return Meteor.find(Long.parseLong(id)); } return null; }", "public static Meteor lookup(HttpServletRequest r){ String id = r.getParameter(\"id\"); if (id == null || id.isEmpty()) return null; String name = r.getParameter(\"name\"); if (name == null || name.isEmpty()) return null; String type = r.getParameter(\"type\"); if (type == null || type.isEmpty()) return null; String address = r.getParameter(\"address\"); if (address == null || address.isEmpty()) return null; String status = r.getParameter(\"status\"); if (status == null || status.isEmpty()) return null; String owner = r.getParameter(\"owner\"); if (owner == null || owner.isEmpty()) return null; String description = r.getParameter(\"description\"); if (description == null || description.isEmpty()) return null; String location = r.getParameter(\"location\"); if (location == null || location.isEmpty()) return null; String rssUrl = r.getParameter(\"rssUrl\"); if (rssUrl == null || rssUrl.isEmpty()) return null; return new Meteor(id, name, type, address, status, owner, description, location, rssUrl); }", "public static Meteor lookup(HttpServletRequest r){ if (r.getParameter(\"id\") != null) { return Meteor.find(Integer.parseInt(r.getParameter(\"id\"))); } else if (r.getParameter(\"name\") != null) { return Meteor.find(r.getParameter(\"name\")); } else { return null; } }", "public static Meteor lookup(HttpServletRequest r){ return lookup(r.getParameter(\"id\")); }", "public static Meteor lookup(HttpServletRequest r){ String id = r.getParameter(\"id\"); String uid = r.getParameter(\"uid\"); String name = r.getParameter(\"name\"); String description = r.getParameter(\"description\"); String type = r.getParameter(\"type\"); String location = r.getParameter(\"location\"); String url = r.getParameter(\"url\"); String image = r.getParameter(\"image\"); String user = r.getParameter(\"user\"); String password = r.getParameter(\"password\"); String slug = r.getParameter(\"slug\"); if (id == null || uid == null || name == null || description == null || type == null || location == null || url == null || image == null || user == null || password == null || slug == null) { return null; } return new Meteor(id, uid, name, description, type, location, url, image, user, password, slug); }", "public static Meteor lookup(HttpServletRequest r){ String uri = r.getRequestURI(); if (uri.startsWith(\"/\")) { uri = uri.substring(1); } String s = uri.substring(uri.lastIndexOf(\"/\") + 1); if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.startsWith(\"?\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\".\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"#\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.startsWith(\":\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"?\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"?\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if (s.endsWith(\".jsp\")) { s = s.substring(0, s.length() - 4); } if (s.startsWith(\"/\")) { s = s.substring(1); } if"], "code_level": "class_runnable", "_id": "6367667d1a6d9265ec0173ff", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (e instanceof AtmosphereResourceEventListenerAdapter) {\n    return this;\n  }\n  if (eventListeners == null) {\n    eventListeners = new CopyOnWriteArrayList<AtmosphereResourceEventListener>();\n  }\n  eventListeners.add(e);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  return this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (e.getClass().isAssignableFrom(AtmosphereResourceEventListenerImpl.class)) {\n    logger.info(\"Ignoring {} because of the impl class\", e.getClass().getName());\n    return this;\n  }\n  if (e.getClass().isAssignableFrom(AtmosphereResourceImpl.class)) {\n    logger.info(\"Ignoring {} because of the impl class\", e.getClass().getName());\n    return this;\n  }\n  logger.info(\"Adding {} to the AtmosphereResource\", e.getClass().getName());\n  if (listeners.contains(e)) {\n    logger.warn(\"{} already has an event listener\", e.getClass().getName());\n    return this;\n  }\n  listeners.add(e);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  logger.trace(\"adding {}\", e);\n  if (e instanceof AtmosphereResourceEventListenerWrapper) {\n    AtmosphereResourceEventListenerWrapper aw = (AtmosphereResourceEventListenerWrapper) e;\n    if (aw.getAtmosphereResource() == this) {\n      return this;\n    }\n  }\n  if (e instanceof AtmosphereResourceEventListenerWrapperWrapper) {\n    AtmosphereResourceEventListenerWrapperWrapper aww =\n        (AtmosphereResourceEventListenerWrapperWrapper) e;\n    if (aww.getAtmosphereResource() == this) {\n      return this;\n    }\n  }\n  if (eventListeners == null) {\n    eventListeners = new ArrayList<AtmosphereResourceEventListener>();\n  }\n  eventListeners.add(e);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (e == null) return this;\n  if (!listeners.contains(e)) listeners.add(e);\n  return this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  return new AtmosphereResourceImpl(\n      this,\n      e,\n      broadcaster,\n      config,\n      broadcaster.getAtmosphereConfig(),\n      broadcaster.getAtmosphereConfig().framework().getAtmosphereConfig());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (e == null) {\n    throw new IllegalArgumentException(\"event listener cannot be null\");\n  }\n  if (e.getClass() == AtmosphereResourceEventListener.class) {\n    if (eventListeners.contains(e)) {\n      return this;\n    }\n    eventListeners.add(e);\n  } else {\n    logger.warn(\n        \"Cannot add a listener: \"\n            + e.getClass().getName()\n            + \". Only supported listeners are \"\n            + AtmosphereResourceEventListener.class.getName()\n            + \", \"\n            + AtmosphereResourceEventListener.class.getName()\n            + \". This is likely a bug in the framework.\");\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (e instanceof AtmosphereResourceEventListenerImpl) {\n    return this;\n  }\n  synchronized (listeners) {\n    listeners.add(e);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (eventListeners == null) {\n    eventListeners = new ArrayList<AtmosphereResourceEventListener>();\n  }\n  eventListeners.add(e);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  return this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Add a  {@link AtmosphereResourceEventListener}.\n * @param e an instance of AtmosphereResourceEventListener\n */\n", "method_name": "addEventListener", "codes": ["@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (e instanceof AtmosphereResourceEventListenerAdapter) { return this; } if (eventListeners == null) { eventListeners = new CopyOnWriteArrayList<AtmosphereResourceEventListener>(); } eventListeners.add(e); return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (e.getClass().isAssignableFrom(AtmosphereResourceEventListenerImpl.class)) { logger.info(\"Ignoring {} because of the impl class\", e.getClass().getName()); return this; } if (e.getClass().isAssignableFrom(AtmosphereResourceImpl.class)) { logger.info(\"Ignoring {} because of the impl class\", e.getClass().getName()); return this; } logger.info(\"Adding {} to the AtmosphereResource\", e.getClass().getName()); if (listeners.contains(e)) { logger.warn(\"{} already has an event listener\", e.getClass().getName()); return this; } listeners.add(e); return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ logger.trace(\"adding {}\", e); if (e instanceof AtmosphereResourceEventListenerWrapper) { AtmosphereResourceEventListenerWrapper aw = (AtmosphereResourceEventListenerWrapper) e; if (aw.getAtmosphereResource() == this) { return this; } } if (e instanceof AtmosphereResourceEventListenerWrapperWrapper) { AtmosphereResourceEventListenerWrapperWrapper aww = (AtmosphereResourceEventListenerWrapperWrapper) e; if (aww.getAtmosphereResource() == this) { return this; } } if (eventListeners == null) { eventListeners = new ArrayList<AtmosphereResourceEventListener>(); } eventListeners.add(e); return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (e == null) return this; if (!listeners.contains(e)) listeners.add(e); return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ return new AtmosphereResourceImpl(this, e, broadcaster, config, broadcaster.getAtmosphereConfig(), broadcaster.getAtmosphereConfig().framework().getAtmosphereConfig()); }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (e == null) { throw new IllegalArgumentException(\"event listener cannot be null\"); } if (e.getClass() == AtmosphereResourceEventListener.class) { if (eventListeners.contains(e)) { return this; } eventListeners.add(e); } else { logger.warn(\"Cannot add a listener: \" + e.getClass().getName() + \". Only supported listeners are \" + AtmosphereResourceEventListener.class.getName() + \", \" + AtmosphereResourceEventListener.class.getName() + \". This is likely a bug in the framework.\"); } return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (e instanceof AtmosphereResourceEventListenerImpl) { return this; } synchronized (listeners) { listeners.add(e); } return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (eventListeners == null) { eventListeners = new ArrayList<AtmosphereResourceEventListener>(); } eventListeners.add(e); return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ return this; }"], "code_level": "project_runnable", "_id": "6367667c1a6d9265ec0173fb", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) return null;\n  try {\n    return new FileInputStream(files.get(index++));\n  } catch (FileNotFoundException e) {\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (currentFile != null) {\n    if (currentFile.isDirectory()) {\n      currentFile = currentFile.getParentFile();\n    } else {\n      currentFile = currentFile.getParentFile();\n    }\n  }\n  return new FileInputStream(currentFile);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (hasNext()) {\n    File f = new File(path + \"/\" + iterator.next());\n    if (!f.exists()) {\n      return null;\n    }\n    return new FileInputStream(f);\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (hasNext()) {\n    final java.io.File file = files.next();\n    return new FileInputStream(file);\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!files.hasNext()) {\n    return null;\n  }\n  return new BufferedInputStream(new FileInputStream(files.next()));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (files.size() == 0) {\n    return null;\n  }\n  return new FileInputStream(files.remove(0));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (currentFile == null) {\n    throw new NoSuchElementException();\n  } else if (currentFile.isFile()) {\n    return new FileInputStream(currentFile);\n  } else {\n    return new FileInputStream(new File(currentDir, currentFile.getName()));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) return null;\n  return new FileInputStream(files[idx++]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) {\n    return null;\n  }\n  final File file = fileQueue.poll();\n  if (file == null) {\n    return null;\n  }\n  try (final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(file))) {\n    return stream;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) {\n    return null;\n  }\n  try {\n    return new BufferedInputStream(new FileInputStream(f));\n  } catch (FileNotFoundException e) {\n    throw new IOException(\"Could not open file \" + f, e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Return the next  {@link java.io.File} object or {@code null} if no more files areavailable.\n */\n", "method_name": "next", "codes": ["public InputStream next() throws IOException { if (!hasNext()) return null; try { return new FileInputStream(files.get(index++)); } catch (FileNotFoundException e) { } return null; }", "public InputStream next() throws IOException { if (currentFile != null) { if (currentFile.isDirectory()) { currentFile = currentFile.getParentFile(); } else { currentFile = currentFile.getParentFile(); } } return new FileInputStream(currentFile); }", "public InputStream next() throws IOException { if (hasNext()) { File f = new File(path + \"/\" + iterator.next()); if (!f.exists()) { return null; } return new FileInputStream(f); } return null; }", "public InputStream next() throws IOException { if (hasNext()) { final java.io.File file = files.next(); return new FileInputStream(file); } return null; }", "public InputStream next() throws IOException { if (!files.hasNext()) { return null; } return new BufferedInputStream(new FileInputStream(files.next())); }", "public InputStream next() throws IOException { if (files.size() == 0) { return null; } return new FileInputStream(files.remove(0)); }", "public InputStream next() throws IOException { if (currentFile == null) { throw new NoSuchElementException(); } else if (currentFile.isFile()) { return new FileInputStream(currentFile); } else { return new FileInputStream(new File(currentDir, currentFile.getName())); } }", "public InputStream next() throws IOException { if (!hasNext()) return null; return new FileInputStream(files[idx++]); }", "public InputStream next() throws IOException { if (!hasNext()) { return null; } final File file = fileQueue.poll(); if (file == null) { return null; } try (final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(file))) { return stream; } }", "public InputStream next() throws IOException { if (!hasNext()) { return null; } try { return new BufferedInputStream(new FileInputStream(f)); } catch (FileNotFoundException e) { throw new IOException(\"Could not open file \" + f, e); } }"], "code_level": "class_runnable", "_id": "636766811a6d9265ec017496", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private static File[] classPath() {\n  String classpath = System.getProperty(\"java.class.path\");\n  if (classpath == null) {\n    return null;\n  } else {\n    return classpath.split(File.pathSeparator);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  try {\n    return java.lang.ClassLoader.getSystemClassLoader().getURLs();\n  } catch (IOException e) {\n    throw new RuntimeException(e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  if (System.getProperty(\"java.class.path\") == null) {\n    return new File[] {new File(\".\"), new File(\".\").getParentFile()};\n  }\n  return new File[] {new File(System.getProperty(\"java.class.path\"))};\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static File[] classPath() {\n  return new File[] {\n    new File(System.getProperty(\"java.class.path\")),\n    new File(System.getProperty(\"java.home\")),\n    new File(System.getProperty(\"user.dir\")),\n    new File(\"/usr/lib/jvm\"),\n    new File(\"/usr/lib/jvm/java\"),\n    new File(\"/usr/lib/jvm/jre\"),\n    new File(\"/usr/lib/jvm/jre/lib\"),\n    new File(\"/usr/lib/jvm/jre/jre\"),\n    new File(\"/usr/lib/jvm/jre/jre/lib\"),\n    new File(\"/usr/lib/jvm/jre/jre/lib/jre\"),\n    new File(\"/usr/lib/jvm/jre/jre/lib/jre/jre\"),\n    new File(\"/usr/lib/jvm/jre/jre/jre/lib/jre/jre\"),\n    new File(\"/usr/lib/jvm/jre/jre/jre/lib/jre/jre/jre/jre\"),\n    new File(\"/usr/lib/jvm/jre/jre/jre/lib/jre/jre/jre/jre/jre\"),\n    new File(\"/usr/lib/jvm/jre/jre/jre/lib/jre/jre/jre/jre/jre/jre\")\n  };\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  String classPath = System.getProperty(\"java.class.path\");\n  StringTokenizer tokenizer = new StringTokenizer(classPath, File.pathSeparator);\n  List<File> fileList = new ArrayList<>();\n  while (tokenizer.hasMoreTokens()) {\n    fileList.add(new File(tokenizer.nextToken()));\n  }\n  return fileList.toArray(new File[fileList.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  String classPath = System.getProperty(\"java.class.path\");\n  File[] classPathFiles = new File[classPath.length()];\n  for (int i = 0; i < classPath.length(); i++) {\n    if (classPath.charAt(i) == File.pathSeparatorChar) {\n      classPathFiles[i] = new File(classPath.substring(0, i));\n    } else {\n      classPathFiles[i] =\n          new File(classPath.substring(0, i) + File.pathSeparator + classPath.substring(i + 1));\n    }\n  }\n  return classPathFiles;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  String classPath = System.getProperty(\"java.class.path\");\n  return classPath.split(File.pathSeparator);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  final ClassLoader cl = ClassLoader.getSystemClassLoader();\n  final URL[] urls = new URL[0];\n  if (cl != null) {\n    urls = cl.getURLs();\n  }\n  final List<File> files = new ArrayList<>();\n  for (final URL url : urls) {\n    final File file = new File(url.getFile());\n    if (file.isDirectory()) {\n      files.add(file);\n    }\n  }\n  return files.toArray(new File[files.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath(){ String javaHome = System.getProperty(\"java.home\"); String jreHome = System.getProperty(\"java.vm.home\"); String jreVmName = System.getProperty(\"java.vm.name\"); String jreVmVendor = System.getProperty(\"java.vm.vendor\"); String jreVmVersion = System.getProperty(\"java.vm.version\"); String jreVmSpecificationVersion = System.getProperty(\"java.vm.specification.version\"); String jreVmSpecificationVendor = System.getProperty(\"java.vm.specification.vendor\"); String jreVmSpecificationVendorSpecificParameters = System.getProperty(\"java.vm.specification.vendor.specification.parameters\"); String jreVmSpecificationVendorSpecificParametersValue = System.getProperty(\"java.vm.specification.vendor.specification.parameters.value\"); String jreVmSpecificationVendorSpecificParametersVersion = System.getProperty(\"java.vm.specification.vendor.specification.parameters.version\"); String jreVmSpecificationVendorSpecificParametersVersionValue = System.getProperty(\"java.vm.specification.vendor.specification.parameters.version.value\"); String jreVmSpecificationVendorSpecificParametersVendor = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor\"); String jreVmSpecificationVendorSpecificParametersVendorVersion = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.version\"); String jreVmSpecificationVendorSpecificParametersVendorVersionValue = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.version.value\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParameters = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.specification.parameters\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParametersValue = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.specification.parameters.value\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParametersVersion = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.specification.parameters.version\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParametersVersionValue = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.specification.parameters.version.value\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParametersVendor = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.specification.parameters.vendor\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParametersVendorVersion = System.getProperty(\"java.vm.specification.vendor.specification.", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  return Thread.currentThread().getContextClassLoader().getResources(\"\").stream()\n      .map(\n          resource -> {\n            try {\n              return new File(resource.toURI());\n            } catch (URISyntaxException e) {\n              throw new IllegalStateException(e);\n            }\n          })\n      .toArray(File[]::new);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the class path of the current JVM instance as an array of  {@link File} objects.\n */\n", "method_name": "classPath", "codes": ["private static File[] classPath(){ String classpath = System.getProperty(\"java.class.path\"); if (classpath == null) { return null; } else { return classpath.split(File.pathSeparator); } }", "private static File[] classPath(){ try { return java.lang.ClassLoader.getSystemClassLoader().getURLs(); } catch (IOException e) { throw new RuntimeException(e); } }", "private static File[] classPath(){ if (System.getProperty(\"java.class.path\") == null) { return new File[] { new File(\".\"), new File(\".\").getParentFile() }; } return new File[] { new File(System.getProperty(\"java.class.path\")) }; }", "private static File[] classPath(){ return new File[] { new File(System.getProperty(\"java.class.path\")), new File(System.getProperty(\"java.home\")), new File(System.getProperty(\"user.dir\")), new File(\"/usr/lib/jvm\"), new File(\"/usr/lib/jvm/java\"), new File(\"/usr/lib/jvm/jre\"), new File(\"/usr/lib/jvm/jre/lib\"), new File(\"/usr/lib/jvm/jre/jre\"), new File(\"/usr/lib/jvm/jre/jre/lib\"), new File(\"/usr/lib/jvm/jre/jre/lib/jre\"), new File(\"/usr/lib/jvm/jre/jre/lib/jre/jre\"), new File(\"/usr/lib/jvm/jre/jre/jre/lib/jre/jre\"), new File(\"/usr/lib/jvm/jre/jre/jre/lib/jre/jre/jre/jre\"), new File(\"/usr/lib/jvm/jre/jre/jre/lib/jre/jre/jre/jre/jre\"), new File(\"/usr/lib/jvm/jre/jre/jre/lib/jre/jre/jre/jre/jre/jre\") }; }", "private static File[] classPath(){ String classPath = System.getProperty(\"java.class.path\"); StringTokenizer tokenizer = new StringTokenizer(classPath, File.pathSeparator); List<File> fileList = new ArrayList<>(); while (tokenizer.hasMoreTokens()) { fileList.add(new File(tokenizer.nextToken())); } return fileList.toArray(new File[fileList.size()]); }", "private static File[] classPath(){ String classPath = System.getProperty(\"java.class.path\"); File[] classPathFiles = new File[classPath.length()]; for (int i = 0; i < classPath.length(); i++) { if (classPath.charAt(i) == File.pathSeparatorChar) { classPathFiles[i] = new File(classPath.substring(0, i)); } else { classPathFiles[i] = new File(classPath.substring(0, i) + File.pathSeparator + classPath.substring(i + 1)); } } return classPathFiles; }", "private static File[] classPath(){ String classPath = System.getProperty(\"java.class.path\"); return classPath.split(File.pathSeparator); }", "private static File[] classPath(){ final ClassLoader cl = ClassLoader.getSystemClassLoader(); final URL[] urls = new URL[0]; if (cl != null) { urls = cl.getURLs(); } final List<File> files = new ArrayList<>(); for (final URL url : urls) { final File file = new File(url.getFile()); if (file.isDirectory()) { files.add(file); } } return files.toArray(new File[files.size()]); }", "private static File[] classPath(){ String javaHome = System.getProperty(\"java.home\"); String jreHome = System.getProperty(\"java.vm.home\"); String jreVmName = System.getProperty(\"java.vm.name\"); String jreVmVendor = System.getProperty(\"java.vm.vendor\"); String jreVmVersion = System.getProperty(\"java.vm.version\"); String jreVmSpecificationVersion = System.getProperty(\"java.vm.specification.version\"); String jreVmSpecificationVendor = System.getProperty(\"java.vm.specification.vendor\"); String jreVmSpecificationVendorSpecificParameters = System.getProperty(\"java.vm.specification.vendor.specification.parameters\"); String jreVmSpecificationVendorSpecificParametersValue = System.getProperty(\"java.vm.specification.vendor.specification.parameters.value\"); String jreVmSpecificationVendorSpecificParametersVersion = System.getProperty(\"java.vm.specification.vendor.specification.parameters.version\"); String jreVmSpecificationVendorSpecificParametersVersionValue = System.getProperty(\"java.vm.specification.vendor.specification.parameters.version.value\"); String jreVmSpecificationVendorSpecificParametersVendor = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor\"); String jreVmSpecificationVendorSpecificParametersVendorVersion = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.version\"); String jreVmSpecificationVendorSpecificParametersVendorVersionValue = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.version.value\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParameters = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.specification.parameters\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParametersValue = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.specification.parameters.value\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParametersVersion = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.specification.parameters.version\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParametersVersionValue = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.specification.parameters.version.value\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParametersVendor = System.getProperty(\"java.vm.specification.vendor.specification.parameters.vendor.specification.parameters.vendor\"); String jreVmSpecificationVendorSpecificParametersVendorSpecificParametersVendorVersion = System.getProperty(\"java.vm.specification.vendor.specification.", "private static File[] classPath(){ return Thread.currentThread().getContextClassLoader().getResources(\"\").stream().map(resource -> { try { return new File(resource.toURI()); } catch (URISyntaxException e) { throw new IllegalStateException(e); } }).toArray(File[]::new); }"], "code_level": "slib_runnable", "_id": "636766821a6d9265ec0174c9", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  if (in == null) {\n    throw new IllegalArgumentException(\"in == null\");\n  }\n  if (in.markSupported()) {\n    in.mark(Integer.MAX_VALUE);\n  }\n  final byte[] buf = new byte[BUF_SIZE];\n  int read;\n  while ((read = in.read(buf)) != -1) {\n    if (read < BUF_SIZE) {\n      System.arraycopy(buf, 0, buffer, pointer, read);\n      pointer += read;\n    } else {\n      throw new IOException(\"Read \" + read + \" bytes of data from \" + this);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  if (in == null) {\n    throw new IllegalArgumentException(\"InputStream is null\");\n  }\n  if (in.markSupported()) {\n    in.mark(Integer.MAX_VALUE);\n  }\n  if (in.available() > 0) {\n    throw new IOException(\"InputStream is not empty\");\n  }\n  this.buffer = new byte[this.bufferSize];\n  int read = in.read(this.buffer, 0, this.bufferSize);\n  if (read < 0) {\n    throw new IOException(\"InputStream is empty\");\n  }\n  if (in.markSupported()) {\n    in.reset();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  if (buffer != null) {\n    buffer.clear();\n  }\n  if (in == null) {\n    throw new IllegalArgumentException(\"Input stream cannot be null\");\n  }\n  final int n = in.read(buffer);\n  if (n <= 0) {\n    throw new EOFException();\n  }\n  buffer.flip();\n  reset(n);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  final byte[] buf = new byte[bufferSize];\n  int read;\n  while ((read = in.read(buf)) >= 0) {\n    if (read == 0) {\n      return;\n    }\n  }\n  in.close();\n  final ByteArrayInputStream bais = new ByteArrayInputStream(buf);\n  this.readFrom(bais);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  int length = 0;\n  final int read;\n  while ((read = in.read(buffer, length, buffer.length - length)) != -1) {\n    length += read;\n  }\n  this.setLength(length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  readFrom(in, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException { int i; byte[] buffer = new byte[4]; while ((i = in.read(buffer)) != -1) { if (i == 0) { return; } buffer[0] = buffer[1]; buffer[1] = buffer[2]; buffer[2] = buffer[3]; buffer[3] = buffer[4]; buffer[4] = buffer[5]; buffer[5] = buffer[6]; buffer[6] = buffer[7]; buffer[7] = buffer[8]; buffer[8] = buffer[9]; buffer[9] = buffer[10]; buffer[10] = buffer[11]; buffer[11] = buffer[12]; buffer[12] = buffer[13]; buffer[13] = buffer[14]; buffer[14] = buffer[15]; buffer[15] = buffer[16]; buffer[16] = buffer[17]; buffer[17] = buffer[18]; buffer[18] = buffer[19]; buffer[19] = buffer[20]; buffer[20] = buffer[21]; buffer[21] = buffer[22]; buffer[22] = buffer[23]; buffer[23] = buffer[24]; buffer[24] = buffer[25]; buffer[25] = buffer[26]; buffer[26] = buffer[27]; buffer[27] = buffer[28]; buffer[28] = buffer[29]; buffer[29] = buffer[30]; buffer[30] = buffer[31]; buffer[31] = buffer[32]; buffer[32] = buffer[33]; buffer[33] = buffer[34]; buffer[34] = buffer[35]; buffer[35] = buffer[36]; buffer[36] = buffer[37]; buffer[37] = buffer[38]; buffer[38] = buffer[39]; buffer[39] = buffer[40]; buffer[40] = buffer[41]; buffer[41] = buffer[42]; buffer[42] = buffer[43]; buffer[43] = buffer[44]; buffer[44] = buffer[45]; buffer[45] = buffer[46]; buffer[46] = buffer[47]; buffer[47] = buffer[48]; buffer[48] = buffer[49]; buffer[49] = buffer[50]; buffer[50] = buffer[51]; buffer[51] = buffer[52]; buffer[52] = buffer[53]; buffer[53] = buffer[54]; buffer[54] = buffer[55]; buffer[55] = buffer[56]; buffer[56] = buffer[57]; buffer[57] = buffer[58]; buffer[58] = buffer[59]; buffer[59] = buffer[60]; buffer[60] = buffer[61]; buffer[61] = buffer[62]; buffer[62] = buffer[63]; buffer[63] = buffer[64]; buffer[64] = buffer[65]; buffer[65] = buffer[66]; buffer[66] = buffer[67]; buffer[67] = buffer[68]; buffer[68] = buffer[69]; buffer[69] = buffer[70]; buffer[70] = buffer[71]; buffer[71] = buffer[72]; buffer[72] = buffer[73]; buffer[73] = buffer[74]; buffer[74] = buffer[75]; buffer[75] = buffer[76]; buffer[76] = buffer[77]; buffer[77] = buffer[78]; buffer[78] = buffer[79]; buffer[79] = buffer[80]; buffer[80] = buffer[81]; buffer[81] = buffer[82]; buffer[82] = buffer[83]; buffer[83] = buffer[84]; buffer[84] = buffer[85]; buffer[85] = buffer[86]; buffer[86] = buffer[87]; buffer[87] = buffer[88]; buffer[88] = buffer[89]; buffer[89] = buffer[90]; buffer[90] = buffer", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  int i;\n  int pos = 0;\n  final int size = this.size;\n  final byte[] b = this.data;\n  int c;\n  while ((c = in.read()) != -1) {\n    if (c <= 0x7f) {\n      b[pos++] = (byte) c;\n    } else if (c <= 0x7ff) {\n      b[pos++] = (byte) (0xc0 | (c >> 6));\n      b[pos++] = (byte) (0x80 | (c & 0x3f));\n    } else if (c <= 0xffff) {\n      b[pos++] = (byte) (0xe0 | (c >> 12));\n      b[pos++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n      b[pos++] = (byte) (0x80 | (c & 0x3f));\n    } else if (c <= 0xffffff) {\n      b[pos++] = (byte) (0xf0 | (c >> 18));\n      b[pos++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n      b[pos++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n      b[pos++] = (byte) (0x80 | (c & 0x3f));\n    } else {\n      b[pos++] = (byte) (0xf1 | (c >> 24));\n      b[pos++] = (byte) (0x80 | ((c >> 20) & 0x3f));\n      b[pos++] = (byte) (0x80 | ((c >> 16) & 0x3f));\n      b[pos++] = (byte) (0x80 | ((c >> 8) & 0x3f));\n      b[pos++] = (byte) (0x80 | (c & 0x3f));\n    }\n  }\n  if (pos != size) {\n    throw new IOException(\"Unexpected byte count: \" + pos + \" != \" + size);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  byte[] buffer = new byte[this.size];\n  int read = in.read(buffer);\n  if (read != this.size) {\n    throw new IOException(\"Size mismatch: \" + read + \" != \" + this.size);\n  }\n  this.buffer = buffer;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  int numBytes;\n  byte[] b = new byte[BUFFER_SIZE];\n  while ((numBytes = in.read(b)) != -1) {\n    writeTo(b, 0, numBytes);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Clear and fill the buffer of this  {@code ClassFileBuffer} with thesupplied byte stream. The read pointer is reset to the start of the byte array.\n */\n", "method_name": "readFrom", "codes": ["public void readFrom(final InputStream in) throws IOException { if (in == null) { throw new IllegalArgumentException(\"in == null\"); } if (in.markSupported()) { in.mark(Integer.MAX_VALUE); } final byte[] buf = new byte[BUF_SIZE]; int read; while ((read = in.read(buf)) != -1) { if (read < BUF_SIZE) { System.arraycopy(buf, 0, buffer, pointer, read); pointer += read; } else { throw new IOException(\"Read \" + read + \" bytes of data from \" + this); } } }", "public void readFrom(final InputStream in) throws IOException { if (in == null) { throw new IllegalArgumentException(\"InputStream is null\"); } if (in.markSupported()) { in.mark(Integer.MAX_VALUE); } if (in.available() > 0) { throw new IOException(\"InputStream is not empty\"); } this.buffer = new byte[this.bufferSize]; int read = in.read(this.buffer, 0, this.bufferSize); if (read < 0) { throw new IOException(\"InputStream is empty\"); } if (in.markSupported()) { in.reset(); } }", "public void readFrom(final InputStream in) throws IOException { if (buffer != null) { buffer.clear(); } if (in == null) { throw new IllegalArgumentException(\"Input stream cannot be null\"); } final int n = in.read(buffer); if (n <= 0) { throw new EOFException(); } buffer.flip(); reset(n); }", "public void readFrom(final InputStream in) throws IOException { final byte[] buf = new byte[bufferSize]; int read; while ((read = in.read(buf)) >= 0) { if (read == 0) { return; } } in.close(); final ByteArrayInputStream bais = new ByteArrayInputStream(buf); this.readFrom(bais); }", "public void readFrom(final InputStream in) throws IOException { int length = 0; final int read; while ((read = in.read(buffer, length, buffer.length - length)) != -1) { length += read; } this.setLength(length); }", "public void readFrom(final InputStream in) throws IOException { readFrom(in, 0); }", "public void readFrom(final InputStream in) throws IOException { int i; byte[] buffer = new byte[4]; while ((i = in.read(buffer)) != -1) { if (i == 0) { return; } buffer[0] = buffer[1]; buffer[1] = buffer[2]; buffer[2] = buffer[3]; buffer[3] = buffer[4]; buffer[4] = buffer[5]; buffer[5] = buffer[6]; buffer[6] = buffer[7]; buffer[7] = buffer[8]; buffer[8] = buffer[9]; buffer[9] = buffer[10]; buffer[10] = buffer[11]; buffer[11] = buffer[12]; buffer[12] = buffer[13]; buffer[13] = buffer[14]; buffer[14] = buffer[15]; buffer[15] = buffer[16]; buffer[16] = buffer[17]; buffer[17] = buffer[18]; buffer[18] = buffer[19]; buffer[19] = buffer[20]; buffer[20] = buffer[21]; buffer[21] = buffer[22]; buffer[22] = buffer[23]; buffer[23] = buffer[24]; buffer[24] = buffer[25]; buffer[25] = buffer[26]; buffer[26] = buffer[27]; buffer[27] = buffer[28]; buffer[28] = buffer[29]; buffer[29] = buffer[30]; buffer[30] = buffer[31]; buffer[31] = buffer[32]; buffer[32] = buffer[33]; buffer[33] = buffer[34]; buffer[34] = buffer[35]; buffer[35] = buffer[36]; buffer[36] = buffer[37]; buffer[37] = buffer[38]; buffer[38] = buffer[39]; buffer[39] = buffer[40]; buffer[40] = buffer[41]; buffer[41] = buffer[42]; buffer[42] = buffer[43]; buffer[43] = buffer[44]; buffer[44] = buffer[45]; buffer[45] = buffer[46]; buffer[46] = buffer[47]; buffer[47] = buffer[48]; buffer[48] = buffer[49]; buffer[49] = buffer[50]; buffer[50] = buffer[51]; buffer[51] = buffer[52]; buffer[52] = buffer[53]; buffer[53] = buffer[54]; buffer[54] = buffer[55]; buffer[55] = buffer[56]; buffer[56] = buffer[57]; buffer[57] = buffer[58]; buffer[58] = buffer[59]; buffer[59] = buffer[60]; buffer[60] = buffer[61]; buffer[61] = buffer[62]; buffer[62] = buffer[63]; buffer[63] = buffer[64]; buffer[64] = buffer[65]; buffer[65] = buffer[66]; buffer[66] = buffer[67]; buffer[67] = buffer[68]; buffer[68] = buffer[69]; buffer[69] = buffer[70]; buffer[70] = buffer[71]; buffer[71] = buffer[72]; buffer[72] = buffer[73]; buffer[73] = buffer[74]; buffer[74] = buffer[75]; buffer[75] = buffer[76]; buffer[76] = buffer[77]; buffer[77] = buffer[78]; buffer[78] = buffer[79]; buffer[79] = buffer[80]; buffer[80] = buffer[81]; buffer[81] = buffer[82]; buffer[82] = buffer[83]; buffer[83] = buffer[84]; buffer[84] = buffer[85]; buffer[85] = buffer[86]; buffer[86] = buffer[87]; buffer[87] = buffer[88]; buffer[88] = buffer[89]; buffer[89] = buffer[90]; buffer[90] = buffer", "public void readFrom(final InputStream in) throws IOException { int i; int pos = 0; final int size = this.size; final byte[] b = this.data; int c; while ((c = in.read()) != -1) { if (c <= 0x7f) { b[pos++] = (byte) c; } else if (c <= 0x7ff) { b[pos++] = (byte) (0xc0 | (c >> 6)); b[pos++] = (byte) (0x80 | (c & 0x3f)); } else if (c <= 0xffff) { b[pos++] = (byte) (0xe0 | (c >> 12)); b[pos++] = (byte) (0x80 | ((c >> 6) & 0x3f)); b[pos++] = (byte) (0x80 | (c & 0x3f)); } else if (c <= 0xffffff) { b[pos++] = (byte) (0xf0 | (c >> 18)); b[pos++] = (byte) (0x80 | ((c >> 12) & 0x3f)); b[pos++] = (byte) (0x80 | ((c >> 6) & 0x3f)); b[pos++] = (byte) (0x80 | (c & 0x3f)); } else { b[pos++] = (byte) (0xf1 | (c >> 24)); b[pos++] = (byte) (0x80 | ((c >> 20) & 0x3f)); b[pos++] = (byte) (0x80 | ((c >> 16) & 0x3f)); b[pos++] = (byte) (0x80 | ((c >> 8) & 0x3f)); b[pos++] = (byte) (0x80 | (c & 0x3f)); } } if (pos != size) { throw new IOException(\"Unexpected byte count: \" + pos + \" != \" + size); } }", "public void readFrom(final InputStream in) throws IOException { byte[] buffer = new byte[this.size]; int read = in.read(buffer); if (read != this.size) { throw new IOException(\"Size mismatch: \" + read + \" != \" + this.size); } this.buffer = buffer; }", "public void readFrom(final InputStream in) throws IOException { int numBytes; byte[] b = new byte[BUFFER_SIZE]; while ((numBytes = in.read(b)) != -1) { writeTo(b, 0, numBytes); } }"], "code_level": "class_runnable", "_id": "636766801a6d9265ec017482", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private void addReverse(final InputStream[] files) {\n  if (files != null) {\n    for (int i = files.length - 1; i >= 0; i--) {\n      addReverse(files[i]);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  final ArrayList<String> srcFiles = new ArrayList<String>();\n  for (final InputStream f : files) {\n    srcFiles.add(f.toString());\n  }\n  Collections.sort(\n      srcFiles,\n      new Comparator<String>() {\n        @Override\n        public int compare(final String o1, final String o2) {\n          return o2.compareTo(o1);\n        }\n      });\n  for (final String f : srcFiles) {\n    addFile(f);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = 0; i < files.length; i++) {\n    final InputStream in = files[i];\n    if (in == null) {\n      continue;\n    }\n    try {\n      final JarInputStream jarIn = new JarInputStream(in);\n      final JarEntry entry = jarIn.getNextJarEntry();\n      while (entry != null) {\n        final String name = entry.getName();\n        if (name.endsWith(\".class\")) {\n          final String className = name.replace('/', '.').substring(0, name.length() - 6);\n          try {\n            final Class clazz = Class.forName(className);\n            if (!Modifier.isAbstract(clazz.getModifiers())) {\n              final Object instance = clazz.newInstance();\n              if (instance instanceof IClassLoader) {\n                classLoaders.put(clazz, (IClassLoader) instance);\n              } else {\n                throw new ClassNotFoundException(\n                    \"Unable to load class '\"\n                        + className\n                        + \"' from jar '\"\n                        + entry.getName()\n                        + \"'\");\n              }\n            }\n          } catch (final ClassNotFoundException e) {\n          } catch (final Exception e) {\n          }\n        }\n        entry = jarIn.getNextJarEntry();\n      }\n      jarIn.close();\n    } catch (final Exception e) {\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = 0; i < files.length; i++) {\n    final File file = new File(files[i].getPath());\n    final String name = file.getName();\n    if (!name.endsWith(\".jar\")) {\n      continue;\n    }\n    final String jarName = name.substring(0, name.length() - 6);\n    addReverse(jarName, files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = 0; i < files.length; i++) {\n    addReverse(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = 0; i < files.length; i++) {\n    final InputStream file = files[i];\n    if (file == null) {\n      continue;\n    }\n    final byte[] b = new byte[file.available()];\n    file.read(b);\n    final String filename = new String(b, Charset.forName(\"UTF-8\"));\n    if (filename.equals(\"\")) {\n      continue;\n    }\n    final byte[] f = filename.getBytes(Charset.forName(\"UTF-8\"));\n    final String fname = new String(f, Charset.forName(\"UTF-8\"));\n    if (fname.equals(\"\")) {\n      continue;\n    }\n    final String[] s = filename.split(\"/\");\n    final String sname = s[s.length - 1];\n    if (sname.equals(\"\")) {\n      continue;\n    }\n    final String spath = \"/\" + sname + sname + \".jar\";\n    if (!addFile(spath, f)) {\n      addFile(spath, b);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  if (files == null) return;\n  final List<InputStream> list = new ArrayList<InputStream>(files.length);\n  for (final InputStream file : files) list.add(file);\n  Collections.reverse(list);\n  addReverse(list.toArray(new InputStream[0]));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  if (files == null || files.length == 0) return;\n  final List<InputStream> list = Arrays.asList(files);\n  Collections.reverse(list);\n  for (final InputStream file : list) {\n    if (file != null) addFile(file);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = 0; i < files.length; i++) {\n    if (files[i] != null) {\n      add(files[i], reverseFiles.get(i));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    addReverse(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add the specified files in reverse order.\n */\n", "method_name": "addReverse", "codes": ["private void addReverse(final InputStream[] files){ if (files != null) { for (int i = files.length - 1; i >= 0; i--) { addReverse(files[i]); } } }", "private void addReverse(final InputStream[] files){ final ArrayList<String> srcFiles = new ArrayList<String>(); for (final InputStream f : files) { srcFiles.add(f.toString()); } Collections.sort(srcFiles, new Comparator<String>() { @Override public int compare(final String o1, final String o2) { return o2.compareTo(o1); } }); for (final String f : srcFiles) { addFile(f); } }", "private void addReverse(final InputStream[] files){ for (int i = 0; i < files.length; i++) { final InputStream in = files[i]; if (in == null) { continue; } try { final JarInputStream jarIn = new JarInputStream(in); final JarEntry entry = jarIn.getNextJarEntry(); while (entry != null) { final String name = entry.getName(); if (name.endsWith(\".class\")) { final String className = name.replace('/', '.').substring(0, name.length() - 6); try { final Class clazz = Class.forName(className); if (!Modifier.isAbstract(clazz.getModifiers())) { final Object instance = clazz.newInstance(); if (instance instanceof IClassLoader) { classLoaders.put(clazz, (IClassLoader) instance); } else { throw new ClassNotFoundException(\"Unable to load class '\" + className + \"' from jar '\" + entry.getName() + \"'\"); } } } catch (final ClassNotFoundException e) { } catch (final Exception e) { } } entry = jarIn.getNextJarEntry(); } jarIn.close(); } catch (final Exception e) { } } }", "private void addReverse(final InputStream[] files){ for (int i = 0; i < files.length; i++) { final File file = new File(files[i].getPath()); final String name = file.getName(); if (!name.endsWith(\".jar\")) { continue; } final String jarName = name.substring(0, name.length() - 6); addReverse(jarName, files[i]); } }", "private void addReverse(final InputStream[] files){ for (int i = 0; i < files.length; i++) { addReverse(files[i]); } }", "private void addReverse(final InputStream[] files){ for (int i = 0; i < files.length; i++) { final InputStream file = files[i]; if (file == null) { continue; } final byte[] b = new byte[file.available()]; file.read(b); final String filename = new String(b, Charset.forName(\"UTF-8\")); if (filename.equals(\"\")) { continue; } final byte[] f = filename.getBytes(Charset.forName(\"UTF-8\")); final String fname = new String(f, Charset.forName(\"UTF-8\")); if (fname.equals(\"\")) { continue; } final String[] s = filename.split(\"/\"); final String sname = s[s.length - 1]; if (sname.equals(\"\")) { continue; } final String spath = \"/\" + sname + sname + \".jar\"; if (!addFile(spath, f)) { addFile(spath, b); } } }", "private void addReverse(final InputStream[] files){ if (files == null) return; final List<InputStream> list = new ArrayList<InputStream>(files.length); for (final InputStream file : files) list.add(file); Collections.reverse(list); addReverse(list.toArray(new InputStream[0])); }", "private void addReverse(final InputStream[] files){ if (files == null || files.length == 0) return; final List<InputStream> list = Arrays.asList(files); Collections.reverse(list); for (final InputStream file : list) { if (file != null) addFile(file); } }", "private void addReverse(final InputStream[] files){ for (int i = 0; i < files.length; i++) { if (files[i] != null) { add(files[i], reverseFiles.get(i)); } } }", "private void addReverse(final InputStream[] files){ for (int i = files.length - 1; i >= 0; i--) { addReverse(files[i]); } }"], "code_level": "class_runnable", "_id": "636766801a6d9265ec017477", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private void addReverse(final File[] files) {\n  Arrays.sort(\n      files,\n      new Comparator<File>() {\n        @Override\n        public int compare(final File f1, final File f2) {\n          return f1.getName().compareTo(f2.getName());\n        }\n      });\n  for (final File file : files) {\n    if (!file.isDirectory()) {\n      this.files.add(file);\n    } else {\n      addReverse(file.listFiles());\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (int i = 0; i < files.length; i++) {\n    add(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (int i = 0; i < files.length; i++) {\n    add(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  if (files != null) {\n    for (int i = files.length - 1; i >= 0; i--) {\n      add(files[i]);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  Collections.addAll(this.reverse, files);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    add(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (int i = 0; i < files.length; i++) {\n    add(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    add(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    add(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  if (files == null || files.length <= 0) {\n    return;\n  }\n  for (int i = 0; i < files.length; i++) {\n    addReverse(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add the specified files in reverse order.\n */\n", "method_name": "addReverse", "codes": ["private void addReverse(final File[] files){ Arrays.sort(files, new Comparator<File>() { @Override public int compare(final File f1, final File f2) { return f1.getName().compareTo(f2.getName()); } }); for (final File file : files) { if (!file.isDirectory()) { this.files.add(file); } else { addReverse(file.listFiles()); } } }", "private void addReverse(final File[] files){ for (int i = 0; i < files.length; i++) { add(files[i]); } }", "private void addReverse(final File[] files){ for (int i = 0; i < files.length; i++) { add(files[i]); } }", "private void addReverse(final File[] files){ if (files != null) { for (int i = files.length - 1; i >= 0; i--) { add(files[i]); } } }", "private void addReverse(final File[] files){ Collections.addAll(this.reverse, files); }", "private void addReverse(final File[] files){ for (int i = files.length - 1; i >= 0; i--) { add(files[i]); } }", "private void addReverse(final File[] files){ for (int i = 0; i < files.length; i++) { add(files[i]); } }", "private void addReverse(final File[] files){ for (int i = files.length - 1; i >= 0; i--) { add(files[i]); } }", "private void addReverse(final File[] files){ for (int i = files.length - 1; i >= 0; i--) { add(files[i]); } }", "private void addReverse(final File[] files){ if (files == null || files.length <= 0) { return; } for (int i = 0; i < files.length; i++) { addReverse(files[i]); } }"], "code_level": "class_runnable", "_id": "636766831a6d9265ec0174eb", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return this.lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return this.lastWriteTimeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return this.lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * The last time, in milliseconds, a write operation occurred.\n * @return this\n */\n", "method_name": "lastWriteTimeStampInMilliseconds", "codes": ["public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStamp; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStampInMilliseconds; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStamp; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStampInMilliseconds; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStamp; }", "public long lastWriteTimeStampInMilliseconds(){ return this.lastWriteTimeStampInMilliseconds; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStamp; }", "public long lastWriteTimeStampInMilliseconds(){ return this.lastWriteTimeStamp; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStamp; }", "public long lastWriteTimeStampInMilliseconds(){ return this.lastWriteTimeStampInMilliseconds; }"], "code_level": "class_runnable", "_id": "6367667e1a6d9265ec01743a", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) {\n    r.getRequest()\n        .getAttributes()\n        .put(AtmosphereResource.TRANSPORT, AtmosphereResource.TRANSPORT.WEBSOCKET);\n  }\n  return Action.CONTINUE;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  r.suspend(new AtmosphereResourceEventImpl(r, AtmosphereResourceEvent.RESUME, null));\n  return Action.CONTINUE;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (r.transport() == AtmosphereResource.TRANSPORT.LONG_POLLING) {\n    return Action.CONTINUE;\n  }\n  return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) {\n    return Action.CONTINUE;\n  }\n  return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  AtmosphereRequest request = r.getRequest();\n  if (request.getAttribute(AtmosphereResource.TRANSPORT)\n      == AtmosphereResource.TRANSPORT.WEBSOCKET) {\n    return Action.CONTINUE;\n  } else {\n    return Action.CANCELLED;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) {\n    return Action.CONTINUE;\n  }\n  return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (AtmosphereResource.TRANSPORT.CUSTOM.equals(r.transport())) {\n    return Action.CONTINUE;\n  } else {\n    return Action.CONTINUE;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  AtmosphereRequest request = r.getRequest();\n  boolean isTransportSuspended =\n      AtmosphereResource.TRANSPORT.TRANSIENT.equals(request.getHeader(HeaderConfig.TRANSPORT));\n  if (!isTransportSuspended) {\n    logger.trace(\"Resuming resource {}\", r.uuid());\n    r.suspend();\n    return Action.CONTINUE;\n  }\n  return Action.CANCELLED;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) {\n    return Action.CONTINUE;\n  }\n  return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  AtmosphereRequest req = r.getRequest();\n  AtmosphereResponse res = r.getResponse();\n  if (!req.getHeader(\"X-ATMOSPHERE-TRANSPORT\").equals(\"websocket\")) {\n    res.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n    return Action.CONTINUE;\n  }\n  return Action.CONTINUE;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Automatically suspend the  {@link AtmosphereResource} based on {@link AtmosphereResource.TRANSPORT} value.\n * @param r a {@link AtmosphereResource}\n * @return {@link Action#CONTINUE}\n */\n", "method_name": "inspect", "codes": ["@Override public Action inspect(AtmosphereResource r){ if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) { r.getRequest().getAttributes().put(AtmosphereResource.TRANSPORT, AtmosphereResource.TRANSPORT.WEBSOCKET); } return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ r.suspend(new AtmosphereResourceEventImpl(r, AtmosphereResourceEvent.RESUME, null)); return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ if (r.transport() == AtmosphereResource.TRANSPORT.LONG_POLLING) { return Action.CONTINUE; } return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) { return Action.CONTINUE; } return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ AtmosphereRequest request = r.getRequest(); if (request.getAttribute(AtmosphereResource.TRANSPORT) == AtmosphereResource.TRANSPORT.WEBSOCKET) { return Action.CONTINUE; } else { return Action.CANCELLED; } }", "@Override public Action inspect(AtmosphereResource r){ if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) { return Action.CONTINUE; } return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ if (AtmosphereResource.TRANSPORT.CUSTOM.equals(r.transport())) { return Action.CONTINUE; } else { return Action.CONTINUE; } }", "@Override public Action inspect(AtmosphereResource r){ AtmosphereRequest request = r.getRequest(); boolean isTransportSuspended = AtmosphereResource.TRANSPORT.TRANSIENT.equals(request.getHeader(HeaderConfig.TRANSPORT)); if (!isTransportSuspended) { logger.trace(\"Resuming resource {}\", r.uuid()); r.suspend(); return Action.CONTINUE; } return Action.CANCELLED; }", "@Override public Action inspect(AtmosphereResource r){ if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) { return Action.CONTINUE; } return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ AtmosphereRequest req = r.getRequest(); AtmosphereResponse res = r.getResponse(); if (!req.getHeader(\"X-ATMOSPHERE-TRANSPORT\").equals(\"websocket\")) { res.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED); return Action.CONTINUE; } return Action.CONTINUE; }"], "code_level": "project_runnable", "_id": "636766851a6d9265ec017515", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (isEmpty(array)) {\n    return array;\n  }\n  String[] trimmedArray = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    if (!isEmpty(element)) {\n      trimmedArray[i] = element.trim();\n    }\n  }\n  return trimmedArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (array == null) {\n    return null;\n  }\n  int size = array.length;\n  String[] trimmedArray = new String[size];\n  for (int i = 0; i < size; i++) {\n    String element = array[i];\n    if (!StringUtils.hasLength(element)) {\n      continue;\n    }\n    element = element.trim();\n    trimmedArray[i] = element;\n  }\n  return trimmedArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] trimmedArray = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i].trim();\n    if (element.length() > 0) {\n      trimmedArray[i] = element;\n    }\n  }\n  return trimmedArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_STRING_ARRAY;\n  }\n  int length = array.length;\n  for (int i = 0; i < length; i++) {\n    String element = array[i];\n    array[i] = StringUtils.trimWhitespace(element);\n  }\n  return array;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] trimmedArray = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    while (element.indexOf(46) != -1) {\n      element = element.substring(0, element.indexOf(46));\n    }\n    trimmedArray[i] = element;\n  }\n  return trimmedArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (ObjectUtils.isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (isEmpty(array)) {\n    return array;\n  }\n  String[] trimmedArray = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    trim(element);\n    trimmedArray[i] = element;\n  }\n  return trimmedArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (ObjectUtils.isEmpty(array)) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] trimmedArray = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i].trim();\n    if (isNotEmpty(element)) {\n      trimmedArray[i] = element;\n    }\n  }\n  return trimmedArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.\n * @param array the original String array\n * @return the resulting array (of the same size) with trimmed elements\n */\n", "method_name": "trimArrayElements", "codes": ["public static String[] trimArrayElements(String[] array){ if (isEmpty(array)) { return EMPTY_STRING_ARRAY; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (isEmpty(array)) { return array; } String[] trimmedArray = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; if (!isEmpty(element)) { trimmedArray[i] = element.trim(); } } return trimmedArray; }", "public static String[] trimArrayElements(String[] array){ if (array == null) { return null; } int size = array.length; String[] trimmedArray = new String[size]; for (int i = 0; i < size; i++) { String element = array[i]; if (!StringUtils.hasLength(element)) { continue; } element = element.trim(); trimmedArray[i] = element; } return trimmedArray; }", "public static String[] trimArrayElements(String[] array){ if (isEmpty(array)) { return EMPTY_STRING_ARRAY; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (isEmpty(array)) { return EMPTY_STRING_ARRAY; } String[] trimmedArray = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i].trim(); if (element.length() > 0) { trimmedArray[i] = element; } } return trimmedArray; }", "public static String[] trimArrayElements(String[] array){ if (isEmpty(array)) { return EMPTY_STRING_ARRAY; } int length = array.length; for (int i = 0; i < length; i++) { String element = array[i]; array[i] = StringUtils.trimWhitespace(element); } return array; }", "public static String[] trimArrayElements(String[] array){ if (isEmpty(array)) { return EMPTY_STRING_ARRAY; } String[] trimmedArray = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; while (element.indexOf(46) != -1) { element = element.substring(0, element.indexOf(46)); } trimmedArray[i] = element; } return trimmedArray; }", "public static String[] trimArrayElements(String[] array){ if (ObjectUtils.isEmpty(array)) { return new String[0]; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (isEmpty(array)) { return array; } String[] trimmedArray = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; trim(element); trimmedArray[i] = element; } return trimmedArray; }", "public static String[] trimArrayElements(String[] array){ if (ObjectUtils.isEmpty(array)) { return EMPTY_STRING_ARRAY; } String[] trimmedArray = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i].trim(); if (isNotEmpty(element)) { trimmedArray[i] = element; } } return trimmedArray; }"], "code_level": "self_contained", "_id": "6367676d1a6d9265ec018229", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  int arraySize = array.length;\n  for (int i = 0; i < arraySize; i++) {\n    hash = MULTIPLIER * hash + hashCode(array[i]);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + Long.hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  int arraySize = array.length;\n  for (int i = 0; i < arraySize; i++) {\n    hash = MULTIPLIER * hash + hashCode(array[i]);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  int arraySize = array.length;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  int arraySize = array.length;\n  for (int i = 0; i < arraySize; i++) {\n    hash = MULTIPLIER * hash + hashCode(array[i]);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  int arraySize = array.length;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + Long.hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.\n * @param array the long array to obtain a hashcode\n * @return the long array's hashcode, which could be 0 if the array is null.\n */\n", "method_name": "nullSafeHashCode", "codes": ["public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; int arraySize = array.length; for (int i = 0; i < arraySize; i++) { hash = MULTIPLIER * hash + hashCode(array[i]); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + Long.hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; int arraySize = array.length; for (int i = 0; i < arraySize; i++) { hash = MULTIPLIER * hash + hashCode(array[i]); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; int arraySize = array.length; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; int arraySize = array.length; for (int i = 0; i < arraySize; i++) { hash = MULTIPLIER * hash + hashCode(array[i]); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; int arraySize = array.length; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + Long.hashCode(element); } return hash; }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181aa", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWith(str, prefix, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.startsWith(prefix)) {\n    return true;\n  }\n  if (str.length() < prefix.length()) {\n    return false;\n  }\n  String lcStr = str.substring(0, prefix.length()).toLowerCase();\n  String lcPrefix = prefix.toLowerCase();\n  return lcStr.equals(lcPrefix);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWithIgnoreCase(str, prefix, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWith(str, prefix, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWith(str, prefix, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWithIgnoreCase(str, prefix, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWithIgnoreCase(str, prefix, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWith(str, prefix, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWith(str, prefix, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWith(str, prefix, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @param str the String to check\n * @param prefix the prefix to look for\n * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @see java.lang.String#startsWith\n */\n", "method_name": "startsWithIgnoreCase", "codes": ["public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWith(str, prefix, true); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ if (str == null || prefix == null) { return false; } if (str.startsWith(prefix)) { return true; } if (str.length() < prefix.length()) { return false; } String lcStr = str.substring(0, prefix.length()).toLowerCase(); String lcPrefix = prefix.toLowerCase(); return lcStr.equals(lcPrefix); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWithIgnoreCase(str, prefix, false); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWith(str, prefix, true); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWith(str, prefix, false); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWithIgnoreCase(str, prefix, false); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWithIgnoreCase(str, prefix, false); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWith(str, prefix, true); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWith(str, prefix, true); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWith(str, prefix, true); }"], "code_level": "self_contained", "_id": "6367676b1a6d9265ec0181df", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (candidates == null) {\n    return null;\n  }\n  if (source == null || candidates.size() == 0) {\n    return null;\n  }\n  Object result = null;\n  for (Object candidate : candidates) {\n    if (source.contains(candidate)) {\n      result = candidate;\n      break;\n    }\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (source == null) {\n    return null;\n  }\n  if (candidates == null) {\n    return source.iterator().next();\n  }\n  Iterator iterator = candidates.iterator();\n  while (iterator.hasNext()) {\n    Object candidate = iterator.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (candidates.isEmpty()) {\n    return null;\n  }\n  Object firstMatch = null;\n  Iterator iterator = candidates.iterator();\n  while (iterator.hasNext()) {\n    Object candidate = iterator.next();\n    if (source.contains(candidate)) {\n      if (firstMatch == null) {\n        firstMatch = candidate;\n      } else {\n        throw new IllegalStateException(\"Multiple matches for \" + candidate);\n      }\n    }\n  }\n  return firstMatch;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (source == null || candidates == null) {\n    return null;\n  }\n  Iterator iter = candidates.iterator();\n  while (iter.hasNext()) {\n    Object candidate = iter.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  Iterator iter = candidates.iterator();\n  while (iter.hasNext()) {\n    Object candidate = iter.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (CollectionUtils.isEmpty(candidates)) {\n    return null;\n  }\n  Object firstMatch = null;\n  Iterator iterator = candidates.iterator();\n  while (iterator.hasNext()) {\n    Object candidate = iterator.next();\n    if (source.contains(candidate)) {\n      if (firstMatch == null) {\n        firstMatch = candidate;\n      } else {\n        return null;\n      }\n    }\n  }\n  return firstMatch;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (candidates.isEmpty()) {\n    return null;\n  }\n  Iterator iter = candidates.iterator();\n  while (iter.hasNext()) {\n    Object candidate = iter.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (source == null || candidates == null) {\n    return null;\n  }\n  Iterator iter = candidates.iterator();\n  while (iter.hasNext()) {\n    Object candidate = iter.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (isEmpty(source)) {\n    return null;\n  }\n  if (isEmpty(candidates)) {\n    return source.iterator().next();\n  }\n  Iterator iter = candidates.iterator();\n  while (iter.hasNext()) {\n    Object candidate = iter.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  Iterator iter = candidates.iterator();\n  while (iter.hasNext()) {\n    Object candidate = iter.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.\n * @param source the source Collection\n * @param candidates the candidates to search for\n * @return the first present object, or <code>null</code> if not found\n */\n", "method_name": "findFirstMatch", "codes": ["public static Object findFirstMatch(Collection source,Collection candidates){ if (candidates == null) { return null; } if (source == null || candidates.size() == 0) { return null; } Object result = null; for (Object candidate : candidates) { if (source.contains(candidate)) { result = candidate; break; } } return result; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (source == null) { return null; } if (candidates == null) { return source.iterator().next(); } Iterator iterator = candidates.iterator(); while (iterator.hasNext()) { Object candidate = iterator.next(); if (source.contains(candidate)) { return candidate; } } return null; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (candidates.isEmpty()) { return null; } Object firstMatch = null; Iterator iterator = candidates.iterator(); while (iterator.hasNext()) { Object candidate = iterator.next(); if (source.contains(candidate)) { if (firstMatch == null) { firstMatch = candidate; } else { throw new IllegalStateException(\"Multiple matches for \" + candidate); } } } return firstMatch; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (source == null || candidates == null) { return null; } Iterator iter = candidates.iterator(); while (iter.hasNext()) { Object candidate = iter.next(); if (source.contains(candidate)) { return candidate; } } return null; }", "public static Object findFirstMatch(Collection source,Collection candidates){ Iterator iter = candidates.iterator(); while (iter.hasNext()) { Object candidate = iter.next(); if (source.contains(candidate)) { return candidate; } } return null; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (CollectionUtils.isEmpty(candidates)) { return null; } Object firstMatch = null; Iterator iterator = candidates.iterator(); while (iterator.hasNext()) { Object candidate = iterator.next(); if (source.contains(candidate)) { if (firstMatch == null) { firstMatch = candidate; } else { return null; } } } return firstMatch; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (candidates.isEmpty()) { return null; } Iterator iter = candidates.iterator(); while (iter.hasNext()) { Object candidate = iter.next(); if (source.contains(candidate)) { return candidate; } } return null; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (source == null || candidates == null) { return null; } Iterator iter = candidates.iterator(); while (iter.hasNext()) { Object candidate = iter.next(); if (source.contains(candidate)) { return candidate; } } return null; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (isEmpty(source)) { return null; } if (isEmpty(candidates)) { return source.iterator().next(); } Iterator iter = candidates.iterator(); while (iter.hasNext()) { Object candidate = iter.next(); if (source.contains(candidate)) { return candidate; } } return null; }", "public static Object findFirstMatch(Collection source,Collection candidates){ Iterator iter = candidates.iterator(); while (iter.hasNext()) { Object candidate = iter.next(); if (source.contains(candidate)) { return candidate; } } return null; }"], "code_level": "class_runnable", "_id": "6367676b1a6d9265ec0181e2", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Trim trailing whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "method_name": "trimTrailingWhitespace", "codes": ["public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }"], "code_level": "class_runnable", "_id": "6367676b1a6d9265ec0181ee", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return quote((String) obj);\n  } else {\n    return obj;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return quote((String) obj);\n  } else if (obj instanceof Object[]) {\n    return quoteArray((Object[]) obj);\n  } else if (obj instanceof boolean[]) {\n    return quoteBooleanArray((boolean[]) obj);\n  } else if (obj instanceof byte[]) {\n    return quoteByteArray((byte[]) obj);\n  } else if (obj instanceof char[]) {\n    return quoteCharArray((char[]) obj);\n  } else if (obj instanceof double[]) {\n    return quoteDoubleArray((double[]) obj);\n  } else if (obj instanceof float[]) {\n    return quoteFloatArray((float[]) obj);\n  } else if (obj instanceof int[]) {\n    return quoteIntArray((int[]) obj);\n  } else if (obj instanceof long[]) {\n    return quoteLongArray((long[]) obj);\n  } else if (obj instanceof short[]) {\n    return quoteShortArray((short[]) obj);\n  } else {\n    return obj;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return quote((String) obj);\n  }\n  return obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (isString(obj)) {\n    return obj;\n  } else {\n    return quote(obj);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return quote((String) obj);\n  } else {\n    return obj;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return quote((String) obj);\n  } else {\n    return obj;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return quote((String) obj);\n  } else {\n    return obj;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  return quoteIfString(obj, \"\\\"\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return quote((String) obj);\n  } else {\n    return obj;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (!(obj instanceof String)) {\n    return obj;\n  }\n  String str = (String) obj;\n  int length = str.length();\n  StringBuilder sb = new StringBuilder(length + 50);\n  sb.append('\"');\n  for (int i = 0; i < length; i++) {\n    char ch = str.charAt(i);\n    switch (ch) {\n      case '\"':\n        sb.append(\"\\\\\\\"\");\n        break;\n      case '\\\\':\n        sb.append(\"\\\\\\\\\");\n        break;\n      case '/':\n        sb.append(\"\\\\/\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      default:\n        if (ch < ' ') {\n          sb.append(\"\\\\u\" + String.format(\"%03x\", Integer.valueOf(ch)));\n        } else {\n          sb.append(ch);\n        }\n    }\n  }\n  sb.append('\"');\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.\n * @param obj the input Object (e.g. \"myString\")\n * @return the quoted String (e.g. \"'myString'\"),or the input object as-is if not a String\n */\n", "method_name": "quoteIfString", "codes": ["public static Object quoteIfString(Object obj){ if (obj instanceof String) { return quote((String) obj); } else { return obj; } }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return quote((String) obj); } else if (obj instanceof Object[]) { return quoteArray((Object[]) obj); } else if (obj instanceof boolean[]) { return quoteBooleanArray((boolean[]) obj); } else if (obj instanceof byte[]) { return quoteByteArray((byte[]) obj); } else if (obj instanceof char[]) { return quoteCharArray((char[]) obj); } else if (obj instanceof double[]) { return quoteDoubleArray((double[]) obj); } else if (obj instanceof float[]) { return quoteFloatArray((float[]) obj); } else if (obj instanceof int[]) { return quoteIntArray((int[]) obj); } else if (obj instanceof long[]) { return quoteLongArray((long[]) obj); } else if (obj instanceof short[]) { return quoteShortArray((short[]) obj); } else { return obj; } }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return quote((String) obj); } return obj; }", "public static Object quoteIfString(Object obj){ if (isString(obj)) { return obj; } else { return quote(obj); } }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return quote((String) obj); } else { return obj; } }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return quote((String) obj); } else { return obj; } }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return quote((String) obj); } else { return obj; } }", "public static Object quoteIfString(Object obj){ return quoteIfString(obj, \"\\\"\"); }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return quote((String) obj); } else { return obj; } }", "public static Object quoteIfString(Object obj){ if (!(obj instanceof String)) { return obj; } String str = (String) obj; int length = str.length(); StringBuilder sb = new StringBuilder(length + 50); sb.append('\"'); for (int i = 0; i < length; i++) { char ch = str.charAt(i); switch(ch) { case '\"': sb.append(\"\\\\\\\"\"); break; case '\\\\': sb.append(\"\\\\\\\\\"); break; case '/': sb.append(\"\\\\/\"); break; case '\\b': sb.append(\"\\\\b\"); break; case '\\f': sb.append(\"\\\\f\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; default: if (ch < ' ') { sb.append(\"\\\\u\" + String.format(\"%03x\", Integer.valueOf(ch))); } else { sb.append(ch); } } } sb.append('\"'); return sb.toString(); }"], "code_level": "class_runnable", "_id": "6367676a1a6d9265ec0181bf", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Trim leading whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "method_name": "trimLeadingWhitespace", "codes": ["public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }"], "code_level": "class_runnable", "_id": "6367676a1a6d9265ec0181cd", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  Vector<String> v = new Vector<String>();\n  while (enumeration.hasMoreElements()) {\n    v.addElement(enumeration.nextElement());\n  }\n  return v.toArray(new String[v.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  Vector<String> vector = new Vector<String>();\n  while (enumeration.hasMoreElements()) {\n    vector.add(enumeration.nextElement());\n  }\n  return vector.toArray(new String[vector.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = Collections.list(enumeration);\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Copy the given Enumeration into a String array. The Enumeration must contain String elements only.\n * @param enumeration the Enumeration to copy\n * @return the String array (<code>null</code> if the passed-inEnumeration was <code>null</code>)\n */\n", "method_name": "toStringArray", "codes": ["public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } Vector<String> v = new Vector<String>(); while (enumeration.hasMoreElements()) { v.addElement(enumeration.nextElement()); } return v.toArray(new String[v.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } Vector<String> vector = new Vector<String>(); while (enumeration.hasMoreElements()) { vector.add(enumeration.nextElement()); } return vector.toArray(new String[vector.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = Collections.list(enumeration); return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }"], "code_level": "slib_runnable", "_id": "636767691a6d9265ec0181ae", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString == null) {\n    return null;\n  }\n  StringBuffer out = new StringBuffer();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      out.append(c);\n    }\n  }\n  return out.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (!hasLength(inString) || !hasLength(charsToDelete)) {\n    return inString;\n  }\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if ((inString == null) || (charsToDelete == null)) {\n    return inString;\n  }\n  StringBuffer out = new StringBuffer(inString.length());\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      out.append(c);\n    }\n  }\n  return out.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if ((inString == null) || (charsToDelete == null)) {\n    return inString;\n  }\n  StringBuffer out = new StringBuffer(inString.length());\n  for (int i = 0; i < inString.length(); i++) {\n    char ch = inString.charAt(i);\n    if (charsToDelete.indexOf(ch) == -1) {\n      out.append(ch);\n    }\n  }\n  return out.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (!hasLength(inString) || !hasLength(charsToDelete)) {\n    return inString;\n  }\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString == null) {\n    return null;\n  }\n  StringBuffer outBuffer = new StringBuffer();\n  for (int i = 0; i < inString.length(); i++) {\n    char aChar = inString.charAt(i);\n    if (charsToDelete.indexOf(aChar) == -1) {\n      outBuffer.append(aChar);\n    }\n  }\n  return outBuffer.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if ((inString == null) || (charsToDelete == null)) {\n    return null;\n  }\n  StringBuffer outBuffer = new StringBuffer();\n  for (int i = 0; i < inString.length(); i++) {\n    char aChar = inString.charAt(i);\n    if (charsToDelete.indexOf(aChar) == -1) {\n      outBuffer.append(aChar);\n    }\n  }\n  return outBuffer.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (!hasLength(inString) || !hasLength(charsToDelete)) {\n    return inString;\n  }\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (!hasLength(inString) || !hasLength(charsToDelete)) {\n    return inString;\n  }\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    boolean isDelete = true;\n    for (int j = 0; j < charsToDelete.length(); j++) {\n      if (c == charsToDelete.charAt(j)) {\n        isDelete = false;\n        break;\n      }\n    }\n    if (isDelete) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (!hasLength(inString) || !hasLength(charsToDelete)) {\n    return inString;\n  }\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    boolean delete = true;\n    for (int j = 0; j < charsToDelete.length(); j++) {\n      if (c == charsToDelete.charAt(j)) {\n        delete = false;\n        break;\n      }\n    }\n    if (delete) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Delete any character in a given String.\n * @param inString the original String\n * @param charsToDelete a set of characters to delete.E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n * @return the resulting String\n */\n", "method_name": "deleteAny", "codes": ["public static String deleteAny(String inString,String charsToDelete){ if (inString == null) { return null; } StringBuffer out = new StringBuffer(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { out.append(c); } } return out.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (!hasLength(inString) || !hasLength(charsToDelete)) { return inString; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { sb.append(c); } } return sb.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if ((inString == null) || (charsToDelete == null)) { return inString; } StringBuffer out = new StringBuffer(inString.length()); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { out.append(c); } } return out.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if ((inString == null) || (charsToDelete == null)) { return inString; } StringBuffer out = new StringBuffer(inString.length()); for (int i = 0; i < inString.length(); i++) { char ch = inString.charAt(i); if (charsToDelete.indexOf(ch) == -1) { out.append(ch); } } return out.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (!hasLength(inString) || !hasLength(charsToDelete)) { return inString; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { sb.append(c); } } return sb.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (inString == null) { return null; } StringBuffer outBuffer = new StringBuffer(); for (int i = 0; i < inString.length(); i++) { char aChar = inString.charAt(i); if (charsToDelete.indexOf(aChar) == -1) { outBuffer.append(aChar); } } return outBuffer.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if ((inString == null) || (charsToDelete == null)) { return null; } StringBuffer outBuffer = new StringBuffer(); for (int i = 0; i < inString.length(); i++) { char aChar = inString.charAt(i); if (charsToDelete.indexOf(aChar) == -1) { outBuffer.append(aChar); } } return outBuffer.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (!hasLength(inString) || !hasLength(charsToDelete)) { return inString; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { sb.append(c); } } return sb.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (!hasLength(inString) || !hasLength(charsToDelete)) { return inString; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); boolean isDelete = true; for (int j = 0; j < charsToDelete.length(); j++) { if (c == charsToDelete.charAt(j)) { isDelete = false; break; } } if (isDelete) { sb.append(c); } } return sb.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (!hasLength(inString) || !hasLength(charsToDelete)) { return inString; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); boolean delete = true; for (int j = 0; j < charsToDelete.length(); j++) { if (c == charsToDelete.charAt(j)) { delete = false; break; } } if (delete) { sb.append(c); } } return sb.toString(); }"], "code_level": "class_runnable", "_id": "6367676c1a6d9265ec01820b", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  return collection != null && collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  return collection != null && collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    return false;\n  }\n  if (element == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection != null && element != null) {\n    for (Iterator iter = collection.iterator(); iter.hasNext(); ) {\n      Object candidate = iter.next();\n      if (candidate == element) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    return false;\n  }\n  if (element == null) {\n    for (Iterator it = collection.iterator(); it.hasNext(); ) {\n      Object candidate = it.next();\n      if (candidate == null) {\n        return true;\n      }\n    }\n  } else {\n    for (Iterator it = collection.iterator(); it.hasNext(); ) {\n      if (element.equals(it.next())) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Check whether the given Collection contains the given element instance. <p>Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.\n * @param collection the Collection to check\n * @param element the element to look for\n * @return <code>true</code> if found, <code>false</code> else\n */\n", "method_name": "containsInstance", "codes": ["public static boolean containsInstance(Collection collection,Object element){ return collection != null && collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ return collection != null && collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { return false; } if (element == null) { return false; } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection != null && element != null) { for (Iterator iter = collection.iterator(); iter.hasNext(); ) { Object candidate = iter.next(); if (candidate == element) { return true; } } } return false; }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { return false; } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { return false; } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { return false; } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { return false; } if (element == null) { for (Iterator it = collection.iterator(); it.hasNext(); ) { Object candidate = it.next(); if (candidate == null) { return true; } } } else { for (Iterator it = collection.iterator(); it.hasNext(); ) { if (element.equals(it.next())) { return true; } } } return false; }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { return false; } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { return false; } return collection.contains(element); }"], "code_level": "slib_runnable", "_id": "6367676c1a6d9265ec018223", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if (ObjectUtils.isEmpty(array1)) {\n    return array2;\n  }\n  if (ObjectUtils.isEmpty(array2)) {\n    return array1;\n  }\n  List<String> result = new ArrayList<String>();\n  result.addAll(Arrays.asList(array1));\n  for (String str : array2) {\n    if (!result.contains(str)) {\n      result.add(str);\n    }\n  }\n  return toStringArray(result);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if (ObjectUtils.isEmpty(array1)) {\n    return array2;\n  }\n  if (ObjectUtils.isEmpty(array2)) {\n    return array1;\n  }\n  String[] newArr = new String[array1.length + array2.length];\n  System.arraycopy(array1, 0, newArr, 0, array1.length);\n  System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if (array1 == null || array2 == null) {\n    return clone(array1);\n  }\n  int array1Length = array1.length;\n  int array2Length = array2.length;\n  List<String> result = new ArrayList<String>(array1Length + array2Length);\n  result.addAll(Arrays.asList(array1));\n  for (int i = 0; i < array2Length; i++) {\n    result.add(array2[i]);\n  }\n  return result.toArray(new String[result.size()]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if (array1 == null || array2 == null) {\n    return null;\n  }\n  int array1Length = array1.length;\n  int array2Length = array2.length;\n  List<String> result = new ArrayList<String>(array1Length + array2Length);\n  for (int i = 0; i < array1Length; i++) {\n    result.add(array1[i]);\n  }\n  for (int i = 0; i < array2Length; i++) {\n    result.add(array2[i]);\n  }\n  return toStringArray(result);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if (array1 == null || array2 == null) {\n    return null;\n  }\n  int array1Length = array1.length;\n  int array2Length = array2.length;\n  String[] result = new String[array1Length + array2Length];\n  System.arraycopy(array1, 0, result, 0, array1Length);\n  System.arraycopy(array2, 0, result, array1Length, array2Length);\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if (array1 == null || array2 == null) {\n    return (array1 == null ? array2 : array1);\n  }\n  int array1Length = array1.length;\n  int array2Length = array2.length;\n  String[] result = new String[array1Length + array2Length];\n  System.arraycopy(array1, 0, result, 0, array1Length);\n  if (array2Length > 0) {\n    System.arraycopy(array2, 0, result, array1Length, array2Length);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if (array1 == null || array2 == null) {\n    return null;\n  }\n  int array1Length = array1.length;\n  int array2Length = array2.length;\n  String[] result = new String[array1Length + array2Length];\n  System.arraycopy(array1, 0, result, 0, array1Length);\n  System.arraycopy(array2, 0, result, array1Length, array2Length);\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if (array1 == null || array2 == null) {\n    return null;\n  }\n  int array1Length = array1.length;\n  int array2Length = array2.length;\n  String[] newArr = new String[array1Length + array2Length];\n  System.arraycopy(array1, 0, newArr, 0, array1Length);\n  System.arraycopy(array2, 0, newArr, array1Length, array2Length);\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if (ObjectUtils.isEmpty(array1)) {\n    return array2;\n  }\n  if (ObjectUtils.isEmpty(array2)) {\n    return array1;\n  }\n  List<String> result = new ArrayList<String>();\n  result.addAll(Arrays.asList(array1));\n  for (String str : array2) {\n    if (!result.contains(str)) {\n      result.add(str);\n    }\n  }\n  return toStringArray(result);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if (array1 == null || array2 == null) {\n    return clone(array1);\n  }\n  int array1Length = array1.length;\n  int array2Length = array2.length;\n  String[] newArr = new String[array1Length + array2Length];\n  System.arraycopy(array1, 0, newArr, 0, array1Length);\n  System.arraycopy(array2, 0, newArr, array1Length, array2Length);\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.\n * @param array1 the first array (can be <code>null</code>)\n * @param array2 the second array (can be <code>null</code>)\n * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n */\n", "method_name": "concatenateStringArrays", "codes": ["public static String[] concatenateStringArrays(String[] array1,String[] array2){ if (ObjectUtils.isEmpty(array1)) { return array2; } if (ObjectUtils.isEmpty(array2)) { return array1; } List<String> result = new ArrayList<String>(); result.addAll(Arrays.asList(array1)); for (String str : array2) { if (!result.contains(str)) { result.add(str); } } return toStringArray(result); }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ if (ObjectUtils.isEmpty(array1)) { return array2; } if (ObjectUtils.isEmpty(array2)) { return array1; } String[] newArr = new String[array1.length + array2.length]; System.arraycopy(array1, 0, newArr, 0, array1.length); System.arraycopy(array2, 0, newArr, array1.length, array2.length); return newArr; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ if (array1 == null || array2 == null) { return clone(array1); } int array1Length = array1.length; int array2Length = array2.length; List<String> result = new ArrayList<String>(array1Length + array2Length); result.addAll(Arrays.asList(array1)); for (int i = 0; i < array2Length; i++) { result.add(array2[i]); } return result.toArray(new String[result.size()]); }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ if (array1 == null || array2 == null) { return null; } int array1Length = array1.length; int array2Length = array2.length; List<String> result = new ArrayList<String>(array1Length + array2Length); for (int i = 0; i < array1Length; i++) { result.add(array1[i]); } for (int i = 0; i < array2Length; i++) { result.add(array2[i]); } return toStringArray(result); }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ if (array1 == null || array2 == null) { return null; } int array1Length = array1.length; int array2Length = array2.length; String[] result = new String[array1Length + array2Length]; System.arraycopy(array1, 0, result, 0, array1Length); System.arraycopy(array2, 0, result, array1Length, array2Length); return result; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ if (array1 == null || array2 == null) { return (array1 == null ? array2 : array1); } int array1Length = array1.length; int array2Length = array2.length; String[] result = new String[array1Length + array2Length]; System.arraycopy(array1, 0, result, 0, array1Length); if (array2Length > 0) { System.arraycopy(array2, 0, result, array1Length, array2Length); } return result; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ if (array1 == null || array2 == null) { return null; } int array1Length = array1.length; int array2Length = array2.length; String[] result = new String[array1Length + array2Length]; System.arraycopy(array1, 0, result, 0, array1Length); System.arraycopy(array2, 0, result, array1Length, array2Length); return result; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ if (array1 == null || array2 == null) { return null; } int array1Length = array1.length; int array2Length = array2.length; String[] newArr = new String[array1Length + array2Length]; System.arraycopy(array1, 0, newArr, 0, array1Length); System.arraycopy(array2, 0, newArr, array1Length, array2Length); return newArr; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ if (ObjectUtils.isEmpty(array1)) { return array2; } if (ObjectUtils.isEmpty(array2)) { return array1; } List<String> result = new ArrayList<String>(); result.addAll(Arrays.asList(array1)); for (String str : array2) { if (!result.contains(str)) { result.add(str); } } return toStringArray(result); }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ if (array1 == null || array2 == null) { return clone(array1); } int array1Length = array1.length; int array2Length = array2.length; String[] newArr = new String[array1Length + array2Length]; System.arraycopy(array1, 0, newArr, 0, array1Length); System.arraycopy(array2, 0, newArr, array1Length, array2Length); return newArr; }"], "code_level": "slib_runnable", "_id": "6367676c1a6d9265ec018204", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (ObjectUtils.isEmpty(array)) {\n    return new String[] {str};\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (ObjectUtils.isEmpty(array)) {\n    return new String[] {str};\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (array == null) {\n    return clone(str);\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (array == null) {\n    return clone(str);\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (array == null) {\n    return new String[] {str};\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if ((array == null) || (str == null)) {\n    return clone(array);\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (ObjectUtils.isEmpty(array)) {\n    return new String[] {str};\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (array == null) {\n    return new String[] {str};\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if ((array == null) || (str == null)) {\n    return clone(array);\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (array == null) {\n    return new String[] {str};\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.\n * @param array the array to append to (can be <code>null</code>)\n * @param str the String to append\n * @return the new array (never <code>null</code>)\n */\n", "method_name": "addStringToArray", "codes": ["public static String[] addStringToArray(String[] array,String str){ if (ObjectUtils.isEmpty(array)) { return new String[] { str }; } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ if (ObjectUtils.isEmpty(array)) { return new String[] { str }; } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ if (array == null) { return clone(str); } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ if (array == null) { return clone(str); } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ if (array == null) { return new String[] { str }; } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ if ((array == null) || (str == null)) { return clone(array); } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ if (ObjectUtils.isEmpty(array)) { return new String[] { str }; } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ if (array == null) { return new String[] { str }; } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ if ((array == null) || (str == null)) { return clone(array); } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ if (array == null) { return new String[] { str }; } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }"], "code_level": "slib_runnable", "_id": "6367676a1a6d9265ec0181d4", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n    return 0;\n  }\n  int count = 0;\n  int pos = 0;\n  while ((pos = str.indexOf(sub, pos)) != -1) {\n    ++count;\n    pos += sub.length();\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  int count = 0;\n  if (str == null || sub == null) {\n    return count;\n  }\n  int idx = str.indexOf(sub);\n  while (idx != -1) {\n    count++;\n    idx = str.indexOf(sub, idx + sub.length());\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null) {\n    return 0;\n  }\n  if (sub == null) {\n    return 0;\n  }\n  int count = 0;\n  int idx = 0;\n  while ((idx = str.indexOf(sub, idx)) != -1) {\n    count++;\n    idx += sub.length();\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null || sub == null) {\n    return 0;\n  }\n  int count = 0;\n  int idx = 0;\n  while ((idx = str.indexOf(sub, idx)) != -1) {\n    count++;\n    idx += sub.length();\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null || sub == null) {\n    throw new IllegalArgumentException(\"null argument\");\n  }\n  int count = 0;\n  int idx = 0;\n  while ((idx = str.indexOf(sub, idx)) != -1) {\n    count++;\n    idx += sub.length();\n  }\n  return count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n    return 0;\n  }\n  int count = 0;\n  int idx = 0;\n  while ((idx = str.indexOf(sub, idx)) != -1) {\n    count++;\n    idx += sub.length();\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null || sub == null || sub.length() == 0) {\n    return 0;\n  }\n  int count = 0;\n  int idx = 0;\n  while ((idx = str.indexOf(sub, idx)) != -1) {\n    count++;\n    idx += sub.length();\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null || sub == null) {\n    return 0;\n  }\n  int count = 0;\n  int idx = 0;\n  while ((idx = str.indexOf(sub, idx)) != -1) {\n    count++;\n    idx += sub.length();\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null || sub == null) {\n    return 0;\n  }\n  int count = 0;\n  int idx = 0;\n  while ((idx = str.indexOf(sub, idx)) != -1) {\n    count++;\n    idx += sub.length();\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null || sub == null) {\n    return 0;\n  }\n  int count = 0;\n  int idx = 0;\n  while ((idx = str.indexOf(sub, idx)) != -1) {\n    idx += sub.length();\n    count++;\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the number of occurrences the substring  {@code sub} appears in string {@code str}.\n * @param str string to search in. Return 0 if this is null.\n * @param sub string to search for. Return 0 if this is null.\n * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n */\n", "method_name": "countOccurrencesOf", "codes": ["public static int countOccurrencesOf(String str,String sub){ if (str == null || sub == null || str.length() == 0 || sub.length() == 0) { return 0; } int count = 0; int pos = 0; while ((pos = str.indexOf(sub, pos)) != -1) { ++count; pos += sub.length(); } return count; }", "public static int countOccurrencesOf(String str,String sub){ int count = 0; if (str == null || sub == null) { return count; } int idx = str.indexOf(sub); while (idx != -1) { count++; idx = str.indexOf(sub, idx + sub.length()); } return count; }", "public static int countOccurrencesOf(String str,String sub){ if (str == null) { return 0; } if (sub == null) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != -1) { count++; idx += sub.length(); } return count; }", "public static int countOccurrencesOf(String str,String sub){ if (str == null || sub == null) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != -1) { count++; idx += sub.length(); } return count; }", "public static int countOccurrencesOf(String str,String sub){ if (str == null || sub == null) { throw new IllegalArgumentException(\"null argument\"); } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != -1) { count++; idx += sub.length(); } return count; }", "public static int countOccurrencesOf(String str,String sub){ if (str == null || sub == null || str.length() == 0 || sub.length() == 0) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != -1) { count++; idx += sub.length(); } return count; }", "public static int countOccurrencesOf(String str,String sub){ if (str == null || sub == null || sub.length() == 0) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != -1) { count++; idx += sub.length(); } return count; }", "public static int countOccurrencesOf(String str,String sub){ if (str == null || sub == null) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != -1) { count++; idx += sub.length(); } return count; }", "public static int countOccurrencesOf(String str,String sub){ if (str == null || sub == null) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != -1) { count++; idx += sub.length(); } return count; }", "public static int countOccurrencesOf(String str,String sub){ if (str == null || sub == null) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != -1) { idx += sub.length(); count++; } return count; }"], "code_level": "self_contained", "_id": "6367676b1a6d9265ec0181dd", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int exIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  int filenameIndex = path.lastIndexOf(FILENAME_SEPARATOR);\n  if (exIndex == -1 || filenameIndex == -1) {\n    return path;\n  }\n  return path.substring(0, exIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  int nameIndex = path.lastIndexOf(NAME_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  if (nameIndex == -1) {\n    return path.substring(0, extIndex);\n  }\n  return path.substring(0, extIndex) + path.substring(nameIndex + 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  int pos = path.lastIndexOf('.');\n  if (pos == -1) {\n    return path;\n  }\n  return path.substring(0, pos);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int lastSeparator = path.lastIndexOf(FOLDER_SEPARATOR);\n  int nameEnd = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (nameEnd == -1) {\n    return path;\n  }\n  if (lastSeparator == -1 || nameEnd == lastSeparator) {\n    return path;\n  }\n  return path.substring(0, nameEnd);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extPos = path.lastIndexOf(EXTENSION_SEPARATOR);\n  int namePos = path.lastIndexOf(NAME_SEPARATOR);\n  if (extPos == -1) {\n    return path;\n  }\n  if (namePos == -1) {\n    return path.substring(0, extPos);\n  }\n  return path.substring(0, extPos) + path.substring(namePos + 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Strip the filename extension from the given path, e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n * @param path the file path (may be <code>null</code>)\n * @return the path with stripped filename extension,or <code>null</code> if none\n */\n", "method_name": "stripFilenameExtension", "codes": ["public static String stripFilenameExtension(String path){ if (path == null) { return null; } int exIndex = path.lastIndexOf(EXTENSION_SEPARATOR); int filenameIndex = path.lastIndexOf(FILENAME_SEPARATOR); if (exIndex == -1 || filenameIndex == -1) { return path; } return path.substring(0, exIndex); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); int nameIndex = path.lastIndexOf(NAME_SEPARATOR); if (extIndex == -1) { return path; } if (nameIndex == -1) { return path.substring(0, extIndex); } return path.substring(0, extIndex) + path.substring(nameIndex + 1); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }", "public static String stripFilenameExtension(String path){ int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }", "public static String stripFilenameExtension(String path){ int pos = path.lastIndexOf('.'); if (pos == -1) { return path; } return path.substring(0, pos); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int lastSeparator = path.lastIndexOf(FOLDER_SEPARATOR); int nameEnd = path.lastIndexOf(EXTENSION_SEPARATOR); if (nameEnd == -1) { return path; } if (lastSeparator == -1 || nameEnd == lastSeparator) { return path; } return path.substring(0, nameEnd); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extPos = path.lastIndexOf(EXTENSION_SEPARATOR); int namePos = path.lastIndexOf(NAME_SEPARATOR); if (extPos == -1) { return path; } if (namePos == -1) { return path.substring(0, extPos); } return path.substring(0, extPos) + path.substring(namePos + 1); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }", "public static String stripFilenameExtension(String path){ int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }"], "code_level": "class_runnable", "_id": "6367676c1a6d9265ec018220", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (isEmpty(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (str == null) {\n    return null;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (str == null) {\n    return null;\n  }\n  if (str.length() == 0) {\n    return EMPTY;\n  }\n  int index = str.indexOf(leadingCharacter);\n  if (index == -1) {\n    return str;\n  }\n  return str.substring(index + 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Trim all occurrences of the supplied leading character from the given String.\n * @param str the String to check\n * @param leadingCharacter the leading character to be trimmed\n * @return the trimmed String\n */\n", "method_name": "trimLeadingCharacter", "codes": ["public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (isEmpty(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (str == null) { return null; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (str == null) { return null; } if (str.length() == 0) { return EMPTY; } int index = str.indexOf(leadingCharacter); if (index == -1) { return str; } return str.substring(index + 1); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181a7", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, -1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  if (toSplit == null) {\n    return null;\n  }\n  if (delimiter == null) {\n    return new String[] {toSplit};\n  }\n  int offset = toSplit.indexOf(delimiter);\n  if (offset < 0) {\n    return null;\n  }\n  String beforeDelimiter = toSplit.substring(0, offset);\n  String afterDelimiter = toSplit.substring(offset + delimiter.length());\n  return new String[] {beforeDelimiter, afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  if (toSplit == null) {\n    return null;\n  }\n  int offset = toSplit.indexOf(delimiter);\n  if (offset < 0) {\n    return null;\n  }\n  String beforeDelimiter = toSplit.substring(0, offset);\n  String afterDelimiter = toSplit.substring(offset + delimiter.length());\n  return new String[] {beforeDelimiter, afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, 2);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, -1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return splitWorker(toSplit, delimiter, -1, false, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, -1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  if ((toSplit == null) || (delimiter == null)) {\n    return null;\n  }\n  int offset = toSplit.indexOf(delimiter);\n  if ((offset < 0) || (offset >= toSplit.length())) {\n    return null;\n  }\n  String beforeDelimiter = toSplit.substring(0, offset);\n  String afterDelimiter = toSplit.substring(offset + delimiter.length());\n  return new String[] {beforeDelimiter, afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.\n * @param toSplit the string to split\n * @param delimiter to split the string up with\n * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String\n */\n", "method_name": "split", "codes": ["public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, false); }", "public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, -1); }", "public static String[] split(String toSplit,String delimiter){ if (toSplit == null) { return null; } if (delimiter == null) { return new String[] { toSplit }; } int offset = toSplit.indexOf(delimiter); if (offset < 0) { return null; } String beforeDelimiter = toSplit.substring(0, offset); String afterDelimiter = toSplit.substring(offset + delimiter.length()); return new String[] { beforeDelimiter, afterDelimiter }; }", "public static String[] split(String toSplit,String delimiter){ if (toSplit == null) { return null; } int offset = toSplit.indexOf(delimiter); if (offset < 0) { return null; } String beforeDelimiter = toSplit.substring(0, offset); String afterDelimiter = toSplit.substring(offset + delimiter.length()); return new String[] { beforeDelimiter, afterDelimiter }; }", "public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, 2); }", "public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, 0); }", "public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, -1); }", "public static String[] split(String toSplit,String delimiter){ return splitWorker(toSplit, delimiter, -1, false, false); }", "public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, -1); }", "public static String[] split(String toSplit,String delimiter){ if ((toSplit == null) || (delimiter == null)) { return null; } int offset = toSplit.indexOf(delimiter); if ((offset < 0) || (offset >= toSplit.length())) { return null; } String beforeDelimiter = toSplit.substring(0, offset); String afterDelimiter = toSplit.substring(offset + delimiter.length()); return new String[] { beforeDelimiter, afterDelimiter }; }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181a6", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. \"/\" separators).\n * @param path the path to start from (usually a full file path)\n * @param relativePath the relative path to apply(relative to the full file path above)\n * @return the full file path that results from applying the relative path\n */\n", "method_name": "applyRelativePath", "codes": ["public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181ac", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index >= 0\n      && index <= str.length()\n      && str.toString().regionMatches(true, index, substring, 0, substring.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index + substring.length() <= str.length()\n      && str.subSequence(index, index + substring.length()).equals(substring);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index >= 0\n      && str.length() > index\n      && str.toString().regionMatches(true, index, substring, 0, substring.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index + substring.length() <= str.length()\n      && str.toString().substring(index, index + substring.length()).equals(substring.toString());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index >= 0\n      && index < str.length()\n      && str.toString().regionMatches(true, index, substring, 0, substring.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index >= 0\n      && index <= str.length()\n      && str.toString().regionMatches(true, index, substring, 0, substring.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index >= 0\n      && index <= str.length()\n      && str.toString().regionMatches(true, index, substring, 0, substring.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index + substring.length() <= str.length()\n      && str.toString().substring(index, index + substring.length()).equals(substring.toString());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index + substring.length() > str.length()\n      || str.subSequence(index, index + substring.length()).equals(substring);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index >= 0\n      && index <= str.length()\n      && str.subSequence(index, index + substring.length()).equals(substring);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns  {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n * @param str the original string (or StringBuilder)\n * @param index the index in the original string to start matching against\n * @param substring the substring to match at the given index\n * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n */\n", "method_name": "substringMatch", "codes": ["public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index >= 0 && index <= str.length() && str.toString().regionMatches(true, index, substring, 0, substring.length()); }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index + substring.length() <= str.length() && str.subSequence(index, index + substring.length()).equals(substring); }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index >= 0 && str.length() > index && str.toString().regionMatches(true, index, substring, 0, substring.length()); }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index + substring.length() <= str.length() && str.toString().substring(index, index + substring.length()).equals(substring.toString()); }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index >= 0 && index < str.length() && str.toString().regionMatches(true, index, substring, 0, substring.length()); }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index >= 0 && index <= str.length() && str.toString().regionMatches(true, index, substring, 0, substring.length()); }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index >= 0 && index <= str.length() && str.toString().regionMatches(true, index, substring, 0, substring.length()); }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index + substring.length() <= str.length() && str.toString().substring(index, index + substring.length()).equals(substring.toString()); }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index + substring.length() > str.length() || str.subSequence(index, index + substring.length()).equals(substring); }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index >= 0 && index <= str.length() && str.subSequence(index, index + substring.length()).equals(substring); }"], "code_level": "slib_runnable", "_id": "6367676b1a6d9265ec0181e9", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      for (int i = 0; i < files.length; i++) {\n        deleteFile(files[i].getAbsolutePath());\n      }\n    }\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  if (fileName != null) {\n    File file = new File(fileName);\n    if (file.exists()) {\n      if (file.isFile()) {\n        file.delete();\n      } else {\n        if (file.isDirectory()) {\n          File[] files = file.listFiles();\n          for (int i = 0; i < files.length; i++) {\n            deleteFile(files[i].getPath());\n          }\n        }\n        file.delete();\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  if (fileName != null) {\n    try {\n      File file = new File(fileName);\n      if (file.exists()) {\n        if (file.delete()) {\n          System.out.println(\"File \" + fileName + \" deleted successfully.\");\n        } else {\n          System.out.println(\"Failed to delete file.\");\n        }\n      } else {\n        System.out.println(\"File \" + fileName + \" does not exist.\");\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  } else {\n    System.out.println(\"File name is null.\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (!file.exists()) return;\n  if (file.isDirectory()) {\n    for (File f : file.listFiles()) {\n      deleteFile(f.getAbsolutePath());\n    }\n  }\n  file.delete();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Delete's the specified file if it exists \n */\n", "method_name": "deleteFile", "codes": ["protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { if (file.isDirectory()) { File[] files = file.listFiles(); for (int i = 0; i < files.length; i++) { deleteFile(files[i].getAbsolutePath()); } } file.delete(); } }", "protected static void deleteFile(String fileName){ if (fileName != null) { File file = new File(fileName); if (file.exists()) { if (file.isFile()) { file.delete(); } else { if (file.isDirectory()) { File[] files = file.listFiles(); for (int i = 0; i < files.length; i++) { deleteFile(files[i].getPath()); } } file.delete(); } } } }", "protected static void deleteFile(String fileName){ if (fileName != null) { try { File file = new File(fileName); if (file.exists()) { if (file.delete()) { System.out.println(\"File \" + fileName + \" deleted successfully.\"); } else { System.out.println(\"Failed to delete file.\"); } } else { System.out.println(\"File \" + fileName + \" does not exist.\"); } } catch (Exception e) { e.printStackTrace(); } } else { System.out.println(\"File name is null.\"); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (!file.exists()) return; if (file.isDirectory()) { for (File f : file.listFiles()) { deleteFile(f.getAbsolutePath()); } } file.delete(); }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }"], "code_level": "slib_runnable", "_id": "636767821a6d9265ec0183a0", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public String format(LoggingEvent event) {\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"[\");\n  sb.append(event.getLevel().toString());\n  sb.append(\"] \");\n  sb.append(event.getMessage());\n  sb.append(\"\\n\");\n  ThrowableInformation ti = event.getThrowableInformation();\n  if (ti != null) {\n    sb.append(\"Caused by: \");\n    sb.append(ti.getThrowable().getClass().getName());\n    sb.append(\": \");\n    sb.append(ti.getThrowable().getMessage());\n    sb.append(\"\\n\");\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  if (event == null) {\n    return null;\n  }\n  StringBuffer buffer = new StringBuffer();\n  buffer.append(event.getLevel().toString());\n  buffer.append(\": \");\n  buffer.append(event.getRenderedMessage());\n  return buffer.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  if (conversionPattern == null) {\n    return null;\n  }\n  StringBuilder sb = new StringBuilder();\n  sb.append(conversionPattern.format(event));\n  if (!ignoreCase) {\n    sb.append(' ');\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  StringBuilder sb = new StringBuilder(event.getMessage().length() + 64);\n  Formatter formatter = new Formatter(sb);\n  formatter.format(\n      \"%1$tF %1$tT %5$s %6$s%n\", event.getTimeStamp(), event.getLevel(), event.getLoggerName());\n  formatter.format(\n      \"%1$tF %1$tT %4$s %5$s%n\", event.getTimeStamp(), event.getLevel(), event.getMessage());\n  formatter.format(\"%n\");\n  if (event.getThrowableInformation() != null) {\n    ThrowableInformation throwableInformation = event.getThrowableInformation();\n    Throwable throwable = throwableInformation.getThrowable();\n    formatter.format(\"%1$s%n\", throwable.getMessage());\n    formatter.format(\"%n\");\n    for (Throwable t = throwable; t != null; t = t.getCause()) {\n      if (t.getClass().getName().contains(\"org.apache.log4j.Logger\")) {\n        continue;\n      }\n      formatter.format(\"%n\");\n      formatter.format(\"%1$s%n\", t.getMessage());\n    }\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  if (formatter != null) {\n    return formatter.format(event);\n  }\n  return \"\";\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  return MessageFormatter.arrayFormat(\n          conversionPattern,\n          new Object[] {event.getLevel(), event.getMessage(), event.getThrowableStrRep()})\n      .getMessage();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  StringBuilder sb = new StringBuilder();\n  if (!event.getFormattedMessage().isEmpty()) {\n    sb.append(event.getFormattedMessage());\n  }\n  if (event.getThrowableInformation() != null) {\n    sb.append(\"\\n\");\n    ThrowableInformation throwableInformation = event.getThrowableInformation();\n    for (Throwable throwable : throwableInformation.getThrowables()) {\n      sb.append(\"\\t\");\n      sb.append(throwable.getClass().getName());\n      sb.append(\": \");\n      sb.append(throwable.getMessage());\n      sb.append(\"\\n\");\n    }\n  }\n  if (event.getLevel().intValue() >= Level.WARN.intValue()) {\n    sb.append(\"\\n\");\n    sb.append(event.getLevel().getName());\n    sb.append(\": \");\n    sb.append(event.getLoggerName());\n    sb.append(\": \");\n    sb.append(event.getRenderedMessage());\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  return String.format(formatPattern, elapsed(event));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  return format(event.getFormattedMessage());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  StringBuffer sb = new StringBuffer();\n  sb.append(formatMessage(event));\n  if (event.getThrowableInformation() != null\n      && event.getThrowableInformation().getThrowable() != null) {\n    sb.append(\"\\n\");\n    sb.append(event.getThrowableInformation().getThrowable());\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Produces a formatted string as specified by the conversion pattern.\n */\n", "method_name": "format", "codes": ["public String format(LoggingEvent event){ StringBuilder sb = new StringBuilder(); sb.append(\"[\"); sb.append(event.getLevel().toString()); sb.append(\"] \"); sb.append(event.getMessage()); sb.append(\"\\n\"); ThrowableInformation ti = event.getThrowableInformation(); if (ti != null) { sb.append(\"Caused by: \"); sb.append(ti.getThrowable().getClass().getName()); sb.append(\": \"); sb.append(ti.getThrowable().getMessage()); sb.append(\"\\n\"); } return sb.toString(); }", "public String format(LoggingEvent event){ if (event == null) { return null; } StringBuffer buffer = new StringBuffer(); buffer.append(event.getLevel().toString()); buffer.append(\": \"); buffer.append(event.getRenderedMessage()); return buffer.toString(); }", "public String format(LoggingEvent event){ if (conversionPattern == null) { return null; } StringBuilder sb = new StringBuilder(); sb.append(conversionPattern.format(event)); if (!ignoreCase) { sb.append(' '); } return sb.toString(); }", "public String format(LoggingEvent event){ StringBuilder sb = new StringBuilder(event.getMessage().length() + 64); Formatter formatter = new Formatter(sb); formatter.format(\"%1$tF %1$tT %5$s %6$s%n\", event.getTimeStamp(), event.getLevel(), event.getLoggerName()); formatter.format(\"%1$tF %1$tT %4$s %5$s%n\", event.getTimeStamp(), event.getLevel(), event.getMessage()); formatter.format(\"%n\"); if (event.getThrowableInformation() != null) { ThrowableInformation throwableInformation = event.getThrowableInformation(); Throwable throwable = throwableInformation.getThrowable(); formatter.format(\"%1$s%n\", throwable.getMessage()); formatter.format(\"%n\"); for (Throwable t = throwable; t != null; t = t.getCause()) { if (t.getClass().getName().contains(\"org.apache.log4j.Logger\")) { continue; } formatter.format(\"%n\"); formatter.format(\"%1$s%n\", t.getMessage()); } } return sb.toString(); }", "public String format(LoggingEvent event){ if (formatter != null) { return formatter.format(event); } return \"\"; }", "public String format(LoggingEvent event){ return MessageFormatter.arrayFormat(conversionPattern, new Object[] { event.getLevel(), event.getMessage(), event.getThrowableStrRep() }).getMessage(); }", "public String format(LoggingEvent event){ StringBuilder sb = new StringBuilder(); if (!event.getFormattedMessage().isEmpty()) { sb.append(event.getFormattedMessage()); } if (event.getThrowableInformation() != null) { sb.append(\"\\n\"); ThrowableInformation throwableInformation = event.getThrowableInformation(); for (Throwable throwable : throwableInformation.getThrowables()) { sb.append(\"\\t\"); sb.append(throwable.getClass().getName()); sb.append(\": \"); sb.append(throwable.getMessage()); sb.append(\"\\n\"); } } if (event.getLevel().intValue() >= Level.WARN.intValue()) { sb.append(\"\\n\"); sb.append(event.getLevel().getName()); sb.append(\": \"); sb.append(event.getLoggerName()); sb.append(\": \"); sb.append(event.getRenderedMessage()); } return sb.toString(); }", "public String format(LoggingEvent event){ return String.format(formatPattern, elapsed(event)); }", "public String format(LoggingEvent event){ return format(event.getFormattedMessage()); }", "public String format(LoggingEvent event){ StringBuffer sb = new StringBuffer(); sb.append(formatMessage(event)); if (event.getThrowableInformation() != null && event.getThrowableInformation().getThrowable() != null) { sb.append(\"\\n\"); sb.append(event.getThrowableInformation().getThrowable()); } return sb.toString(); }"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec01830f", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (isLoggingEnabled(event)) {\n    this.outputStream.println(event.getRenderedMessage());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (isTraceEnabled()) {\n    super.subAppend(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){ if (event.getLevel().isGreaterOrEqual(Level.DEBUG)) { if (event.getMessage().contains(\"java.lang.UnsatisfiedLinkError\")) { if (!dumpEvent) { if (event.getRenderedMessage().contains(\"java.lang.InstantiationException\")) { } else { StringWriter writer = new StringWriter(); PrintWriter pw = new PrintWriter(writer); event.getThrowableInformation().getThrowable().printStackTrace(pw); pw.flush(); String stackTrace = writer.toString(); if (!stackTrace.contains(\"org.apache.log4j.spi.Logger\")) { stackTrace = \"\"; } stackTrace += event.getRenderedMessage(); pw.close(); pw = null; if (!stackTrace.contains(\"org.apache.log4j.spi.Logger\")) { stackTrace += \"\\n\"; } stackTrace += \"Logger: \" + event.getLoggerName(); stackTrace += \"\\n\"; stackTrace += \"Message: \" + event.getMessage(); stackTrace += \"\\n\"; stackTrace += \"Time: \" + event.getTimeStamp(); stackTrace += \"\\n\"; stackTrace += \"Source: \" + event.getThreadName(); stackTrace += \"\\n\"; stackTrace += \"Thread ID: \" + event.getThreadId(); stackTrace += \"\\n\"; stackTrace += \"Thread Group ID: \" + event.getThreadGroup().getName(); stackTrace += \"\\n\"; stackTrace += \"Thread Group ID: \" + event.getThreadGroup().getParent().getName(); stackTrace += \"\\n\"; stackTrace += \"Stack Trace:\"; stackTrace += \"\\n\"; stackTrace += event.getThrowableInformation().getThrowable().toString(); stackTrace += \"\\n\"; stackTrace += \"Cause: \" + event.getThrowableInformation().getThrowable().getCause().toString(); stackTrace += \"\\n\"; stackTrace += \"Throwable: \" + event.getThrowableInformation().getThrowable().getMessage(); stackTrace += \"\\n\"; stackTrace += \"Stack Trace:\"; stackTrace += \"\\n\"; stackTrace += event.getThrowableInformation().getThrowable().getStackTrace(); stackTrace += \"\\n\"; stackTrace += \"Stack Trace:\"; stackTrace += \"\\n\"; stackTrace += event.getThrowableInformation().getThrowable().getStackTrace(); stackTrace += \"\\n\"; stackTrace += \"Thread Name: \" + event.getThreadName(); stackTrace += \"\\n\"; stackTrace += \"Thread ID: \" + event.getThreadId(); stackTrace += \"\\n\"; stackTrace += \"Thread Group ID: \" + event.getThreadGroup().getName(); stackTrace += \"\\n\"; stackTrace += \"Thread Group ID: \" + event.getThreadGroup().getParent().getName(); stackTrace += \"\\n\"; stackTrace += \"Stack Trace:\"; stackTrace += \"\\n\"; stackTrace += event.getThrowableInformation().getThrowable().toString(); stackTrace += \"\\n\"; stackTrace += \"Cause: \" + event.getThrowableInformation().getThrowable().getC", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (event.getLevel().intValue() <= LOG_LEVEL) {\n    if (event.getLoggerName().equals(\"org.apache.log4j.Logger\")) {\n      Logger logger = Logger.getLogger(\"org.apache.log4j.Logger\");\n      logger.info(event.getMessage());\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (isRunnable()) {\n    synchronized (writer) {\n      try {\n        writer.write(event.getMessage().toString() + \"\\n\");\n        writer.flush();\n      } catch (IOException e) {\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (switchToStdOut) {\n    if (stdOutBuffer.size() > 0) {\n      stdOutBuffer.add(event);\n    }\n  }\n  if (switchToStdErr) {\n    if (stdErrBuffer.size() > 0) {\n      stdErrBuffer.add(event);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (!initialized) {\n    return;\n  }\n  if (enabled && !ignoreExceptions) {\n    if (lastEvent == null) {\n      lastEvent = event;\n    } else {\n      if (event.getLevel().intValue() > lastEvent.getLevel().intValue()) {\n        StringBuffer message =\n            new StringBuffer(event.getLevel() + \": \" + lastEvent.getRenderedMessage());\n        message.append(\"\\n\");\n        message.append(event.getThrowableInformation().getThrowable().getMessage());\n        message.append(\"\\n\");\n        lastEvent = event;\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (getEnabledLevel().intValue() >= event.getLevel().intValue()) {\n    super.subAppend(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (lastLog == null) {\n    return;\n  }\n  String msg = event.getFormattedMessage();\n  if (msg != null) {\n    String s = msg;\n    if (s.length() > maxLogLength) {\n      s = s.substring(0, maxLogLength) + \"...\";\n    }\n    if (s.length() > 0) {\n      s += NL;\n    }\n    s += lastLog;\n    msg = s;\n  }\n  try {\n    writer.write(msg);\n  } catch (IOException e) {\n    log.error(\"IOException when writing to log file\", e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){ if (event.getLevel().intValue() <= Level.WARN.intValue()) { return; } String msg = event.getFormattedMessage(); if (msg == null) { msg = event.getRenderedMessage(); } if (msg == null) { return; } msg = msg.replaceAll(\"\\r\", \"\"); msg = msg.replaceAll(\"\\n\", \"\"); msg = msg.replaceAll(\"\\t\", \"\"); if (msg.length() > 500) { msg = msg.substring(0, 500); } if (!msg.startsWith(\"[\")) { msg = \"[\" + msg; } if (!msg.endsWith(\"]\")) { msg += \"]\"; } msg = msg.replaceAll(\"\\\\{\\\\}\", \"\"); if (msg.contains(\"\\n\")) { msg = msg.replace(\"\\n\", \" \"); } if (msg.contains(\"\\r\")) { msg = msg.replace(\"\\r\", \" \"); } msg = msg.replaceAll(\"\\\\{\\\\s+\", \" \"); msg = msg.replaceAll(\"\\\\{\\\\s+\\\\}\", \" \"); msg = msg.replaceAll(\"\\\\{\\\\s+\\\\}\\\\s+\", \" \"); msg = msg.replaceAll(\"\\\\{\\\\s+\\\\}\\\\s+\\\\{\\\\s+\\\\}\", \" \"); } if (msg.contains(\"\\n\\r\")) { msg = msg.replace(\"\\n\\r\", \" \"); } if (msg.contains(\"\\n\\r\\r\")) { msg = msg.replace(\"\\n\\r\\r\", \" \"); } if (msg.contains(\"\\n\\r\\n\")) { msg = msg.replace(\"\\n\\r\\n\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\")) { msg = msg.replace(\"\\n\\r\\n\\r\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\\n\")) { msg = msg.replace(\"\\n\\r\\n\\r\\n\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\\n\\r\")) { msg = msg.replace(\"\\n\\r\\n\\r\\n\\r\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\\n\\r\\n\")) { msg = msg.replace(\"\\n\\r\\n\\r\\n\\r\\n\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\\n\\r\\n\\r\\n\")) { msg = msg.replace(\"\\n\\r\\n\\r\\n\\r\\n\\r\\n\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\")) { msg = msg.replace(\"\\n\\r\\n\\", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * This method does actual writing\n */\n", "method_name": "subAppend", "codes": ["protected void subAppend(LoggingEvent event){ if (isLoggingEnabled(event)) { this.outputStream.println(event.getRenderedMessage()); } }", "protected void subAppend(LoggingEvent event){ if (isTraceEnabled()) { super.subAppend(event); } }", "protected void subAppend(LoggingEvent event){ if (event.getLevel().isGreaterOrEqual(Level.DEBUG)) { if (event.getMessage().contains(\"java.lang.UnsatisfiedLinkError\")) { if (!dumpEvent) { if (event.getRenderedMessage().contains(\"java.lang.InstantiationException\")) { } else { StringWriter writer = new StringWriter(); PrintWriter pw = new PrintWriter(writer); event.getThrowableInformation().getThrowable().printStackTrace(pw); pw.flush(); String stackTrace = writer.toString(); if (!stackTrace.contains(\"org.apache.log4j.spi.Logger\")) { stackTrace = \"\"; } stackTrace += event.getRenderedMessage(); pw.close(); pw = null; if (!stackTrace.contains(\"org.apache.log4j.spi.Logger\")) { stackTrace += \"\\n\"; } stackTrace += \"Logger: \" + event.getLoggerName(); stackTrace += \"\\n\"; stackTrace += \"Message: \" + event.getMessage(); stackTrace += \"\\n\"; stackTrace += \"Time: \" + event.getTimeStamp(); stackTrace += \"\\n\"; stackTrace += \"Source: \" + event.getThreadName(); stackTrace += \"\\n\"; stackTrace += \"Thread ID: \" + event.getThreadId(); stackTrace += \"\\n\"; stackTrace += \"Thread Group ID: \" + event.getThreadGroup().getName(); stackTrace += \"\\n\"; stackTrace += \"Thread Group ID: \" + event.getThreadGroup().getParent().getName(); stackTrace += \"\\n\"; stackTrace += \"Stack Trace:\"; stackTrace += \"\\n\"; stackTrace += event.getThrowableInformation().getThrowable().toString(); stackTrace += \"\\n\"; stackTrace += \"Cause: \" + event.getThrowableInformation().getThrowable().getCause().toString(); stackTrace += \"\\n\"; stackTrace += \"Throwable: \" + event.getThrowableInformation().getThrowable().getMessage(); stackTrace += \"\\n\"; stackTrace += \"Stack Trace:\"; stackTrace += \"\\n\"; stackTrace += event.getThrowableInformation().getThrowable().getStackTrace(); stackTrace += \"\\n\"; stackTrace += \"Stack Trace:\"; stackTrace += \"\\n\"; stackTrace += event.getThrowableInformation().getThrowable().getStackTrace(); stackTrace += \"\\n\"; stackTrace += \"Thread Name: \" + event.getThreadName(); stackTrace += \"\\n\"; stackTrace += \"Thread ID: \" + event.getThreadId(); stackTrace += \"\\n\"; stackTrace += \"Thread Group ID: \" + event.getThreadGroup().getName(); stackTrace += \"\\n\"; stackTrace += \"Thread Group ID: \" + event.getThreadGroup().getParent().getName(); stackTrace += \"\\n\"; stackTrace += \"Stack Trace:\"; stackTrace += \"\\n\"; stackTrace += event.getThrowableInformation().getThrowable().toString(); stackTrace += \"\\n\"; stackTrace += \"Cause: \" + event.getThrowableInformation().getThrowable().getC", "protected void subAppend(LoggingEvent event){ if (event.getLevel().intValue() <= LOG_LEVEL) { if (event.getLoggerName().equals(\"org.apache.log4j.Logger\")) { Logger logger = Logger.getLogger(\"org.apache.log4j.Logger\"); logger.info(event.getMessage()); } } }", "protected void subAppend(LoggingEvent event){ if (isRunnable()) { synchronized (writer) { try { writer.write(event.getMessage().toString() + \"\\n\"); writer.flush(); } catch (IOException e) { } } } }", "protected void subAppend(LoggingEvent event){ if (switchToStdOut) { if (stdOutBuffer.size() > 0) { stdOutBuffer.add(event); } } if (switchToStdErr) { if (stdErrBuffer.size() > 0) { stdErrBuffer.add(event); } } }", "protected void subAppend(LoggingEvent event){ if (!initialized) { return; } if (enabled && !ignoreExceptions) { if (lastEvent == null) { lastEvent = event; } else { if (event.getLevel().intValue() > lastEvent.getLevel().intValue()) { StringBuffer message = new StringBuffer(event.getLevel() + \": \" + lastEvent.getRenderedMessage()); message.append(\"\\n\"); message.append(event.getThrowableInformation().getThrowable().getMessage()); message.append(\"\\n\"); lastEvent = event; } } } }", "protected void subAppend(LoggingEvent event){ if (getEnabledLevel().intValue() >= event.getLevel().intValue()) { super.subAppend(event); } }", "protected void subAppend(LoggingEvent event){ if (lastLog == null) { return; } String msg = event.getFormattedMessage(); if (msg != null) { String s = msg; if (s.length() > maxLogLength) { s = s.substring(0, maxLogLength) + \"...\"; } if (s.length() > 0) { s += NL; } s += lastLog; msg = s; } try { writer.write(msg); } catch (IOException e) { log.error(\"IOException when writing to log file\", e); } }", "protected void subAppend(LoggingEvent event){ if (event.getLevel().intValue() <= Level.WARN.intValue()) { return; } String msg = event.getFormattedMessage(); if (msg == null) { msg = event.getRenderedMessage(); } if (msg == null) { return; } msg = msg.replaceAll(\"\\r\", \"\"); msg = msg.replaceAll(\"\\n\", \"\"); msg = msg.replaceAll(\"\\t\", \"\"); if (msg.length() > 500) { msg = msg.substring(0, 500); } if (!msg.startsWith(\"[\")) { msg = \"[\" + msg; } if (!msg.endsWith(\"]\")) { msg += \"]\"; } msg = msg.replaceAll(\"\\\\{\\\\}\", \"\"); if (msg.contains(\"\\n\")) { msg = msg.replace(\"\\n\", \" \"); } if (msg.contains(\"\\r\")) { msg = msg.replace(\"\\r\", \" \"); } msg = msg.replaceAll(\"\\\\{\\\\s+\", \" \"); msg = msg.replaceAll(\"\\\\{\\\\s+\\\\}\", \" \"); msg = msg.replaceAll(\"\\\\{\\\\s+\\\\}\\\\s+\", \" \"); msg = msg.replaceAll(\"\\\\{\\\\s+\\\\}\\\\s+\\\\{\\\\s+\\\\}\", \" \"); } if (msg.contains(\"\\n\\r\")) { msg = msg.replace(\"\\n\\r\", \" \"); } if (msg.contains(\"\\n\\r\\r\")) { msg = msg.replace(\"\\n\\r\\r\", \" \"); } if (msg.contains(\"\\n\\r\\n\")) { msg = msg.replace(\"\\n\\r\\n\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\")) { msg = msg.replace(\"\\n\\r\\n\\r\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\\n\")) { msg = msg.replace(\"\\n\\r\\n\\r\\n\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\\n\\r\")) { msg = msg.replace(\"\\n\\r\\n\\r\\n\\r\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\\n\\r\\n\")) { msg = msg.replace(\"\\n\\r\\n\\r\\n\\r\\n\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\\n\\r\\n\\r\\n\")) { msg = msg.replace(\"\\n\\r\\n\\r\\n\\r\\n\\r\\n\", \" \"); } if (msg.contains(\"\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\")) { msg = msg.replace(\"\\n\\r\\n\\"], "code_level": "project_runnable", "_id": "636767781a6d9265ec01823d", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static String peek() {\n  String ctx = null;\n  String ctxStack = null;\n  Stack<String> stack = new Stack<String>();\n  stack.push(\"\");\n  while (!stack.isEmpty()) {\n    ctx = stack.pop();\n    ctxStack = stack.peek();\n    if (ctxStack.equals(ctx)) {\n      break;\n    }\n    stack.push(ctx);\n  }\n  return ctxStack;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String peek() {\n  StackTraceElement[] stack = new Throwable().getStackTrace();\n  if (stack.length == 0) return \"\";\n  StackTraceElement element = stack[stack.length - 1];\n  return element.getClassName() + \".\" + element.getMethodName();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String peek() {\n  return ((String) s_contextStack.peek()).trim();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  return _contextStack.peek();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  return dcStack.peek();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  return dc.peek();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  return ((String) ((Map) NDC.peek()).get(\"\"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  if (null == stack) {\n    return \"\";\n  } else {\n    return stack.peek();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  return Stack.peek();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  return _innermostDiagnosticContext.peek();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string \"\" is returned.\n * @return String The innermost diagnostic context.\n */\n", "method_name": "peek", "codes": ["public static String peek(){ String ctx = null; String ctxStack = null; Stack<String> stack = new Stack<String>(); stack.push(\"\"); while (!stack.isEmpty()) { ctx = stack.pop(); ctxStack = stack.peek(); if (ctxStack.equals(ctx)) { break; } stack.push(ctx); } return ctxStack; }", "public static String peek(){ StackTraceElement[] stack = new Throwable().getStackTrace(); if (stack.length == 0) return \"\"; StackTraceElement element = stack[stack.length - 1]; return element.getClassName() + \".\" + element.getMethodName(); }", "public static String peek(){ return ((String) s_contextStack.peek()).trim(); }", "public static String peek(){ return _contextStack.peek(); }", "public static String peek(){ return dcStack.peek(); }", "public static String peek(){ return dc.peek(); }", "public static String peek(){ return ((String) ((Map) NDC.peek()).get(\"\")); }", "public static String peek(){ if (null == stack) { return \"\"; } else { return stack.peek(); } }", "public static String peek(){ return Stack.peek(); }", "public static String peek(){ return _innermostDiagnosticContext.peek(); }"], "code_level": "class_runnable", "_id": "636767831a6d9265ec0183c9", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public Logger exists(String name) {\n  Logger logger = getLogger(name);\n  if (logger != null) return logger;\n  if (parent != null) {\n    logger = parent.exists(name);\n  }\n  return logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  if (name == null) {\n    return null;\n  }\n  for (int i = 0; i < loggers.length; i++) {\n    Logger l = loggers[i];\n    if (name.equals(l.getName())) {\n      return l;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  Logger logger = null;\n  for (Logger loggerRef : getLoggers()) {\n    if (loggerRef.getName().equals(name)) {\n      logger = loggerRef;\n      break;\n    }\n  }\n  return logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  return this.get(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  for (Logger logger : this.loggers) {\n    if (logger.getName().equals(name)) {\n      return logger;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  Logger logger = null;\n  for (Logger l : this.loggers) {\n    if (l.getName().equals(name)) {\n      logger = l;\n    }\n  }\n  return logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  for (Logger logger : loggers) {\n    if (logger.getName().equals(name)) return logger;\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  Logger logger = null;\n  synchronized (loggers) {\n    for (Logger logger2 : loggers.values()) {\n      if (logger2.getName().equals(name)) {\n        logger = logger2;\n        break;\n      }\n    }\n  }\n  return logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  synchronized (loggers) {\n    Logger logger = loggers.get(name);\n    if (logger != null) return logger;\n    logger = new Logger(name);\n    loggers.put(name, logger);\n  }\n  return logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  Logger found = null;\n  if (this.loggers != null) {\n    for (int i = 0; i < this.loggers.length; i++) {\n      found = this.loggers[i].exists(name);\n      if (found != null) {\n        break;\n      }\n    }\n  }\n  return found;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if the named logger exists in the hierarchy. If so return its reference, otherwise returns <code>null</code>.\n * @param name The name of the logger to search for.\n */\n", "method_name": "exists", "codes": ["public Logger exists(String name){ Logger logger = getLogger(name); if (logger != null) return logger; if (parent != null) { logger = parent.exists(name); } return logger; }", "public Logger exists(String name){ if (name == null) { return null; } for (int i = 0; i < loggers.length; i++) { Logger l = loggers[i]; if (name.equals(l.getName())) { return l; } } return null; }", "public Logger exists(String name){ Logger logger = null; for (Logger loggerRef : getLoggers()) { if (loggerRef.getName().equals(name)) { logger = loggerRef; break; } } return logger; }", "public Logger exists(String name){ return this.get(name); }", "public Logger exists(String name){ for (Logger logger : this.loggers) { if (logger.getName().equals(name)) { return logger; } } return null; }", "public Logger exists(String name){ Logger logger = null; for (Logger l : this.loggers) { if (l.getName().equals(name)) { logger = l; } } return logger; }", "public Logger exists(String name){ for (Logger logger : loggers) { if (logger.getName().equals(name)) return logger; } return null; }", "public Logger exists(String name){ Logger logger = null; synchronized (loggers) { for (Logger logger2 : loggers.values()) { if (logger2.getName().equals(name)) { logger = logger2; break; } } } return logger; }", "public Logger exists(String name){ synchronized (loggers) { Logger logger = loggers.get(name); if (logger != null) return logger; logger = new Logger(name); loggers.put(name, logger); } return logger; }", "public Logger exists(String name){ Logger found = null; if (this.loggers != null) { for (int i = 0; i < this.loggers.length; i++) { found = this.loggers[i].exists(name); if (found != null) { break; } } } return found; }"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec01832e", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public String format(final LoggingEvent event) {\n  return String.format(\"%s %s%n\", event.getLevel(), event.getMessage());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  String s = null;\n  if (event.getThrowableInformation() != null) {\n    s = event.getThrowableInformation().getThrowableStrRep();\n  }\n  if (s == null) {\n    s = event.getMessage();\n  }\n  if (s == null) {\n    s = \"\";\n  }\n  return s;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  StringBuilder sb = new StringBuilder();\n  sb.append(event.getLevel());\n  sb.append(\" [\");\n  sb.append(event.getLoggerName());\n  sb.append(\"] \");\n  sb.append(event.getMessage());\n  sb.append(\"\\n\");\n  sb.append(event.getThrowableStrRep());\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  StringBuffer buf = new StringBuffer();\n  buf.append(event.getLevel().toString()).append(\" \");\n  buf.append(event.getMessage()).append(\"\\n\");\n  buf.append(event.getRenderedMessage()).append(\"\\n\");\n  buf.append(event.getThrowableStrRep());\n  return buf.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  return this.format(event, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  if (event == null) {\n    throw new NullPointerException(\"event\");\n  }\n  final StringBuilder buf = new StringBuilder();\n  buf.append(event.getLevel().getLocalizedName());\n  buf.append(\" \");\n  buf.append(event.getLoggerName());\n  buf.append(\": \");\n  buf.append(event.getMessage());\n  buf.append(\"\\n\");\n  return buf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  StringBuilder sb = new StringBuilder();\n  sb.append(event.getLevel().toString());\n  sb.append(\": \");\n  sb.append(event.getRenderedMessage());\n  sb.append(\"\\n\");\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  return String.format(\"[%s] %s\", event.getLevel(), event.getMessage());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  String retVal = \"\";\n  retVal += \"[\" + event.getLevel().getName() + \"] \";\n  retVal += event.getMessage() + \"\\n\";\n  if (event.getThrowableInformation() != null) {\n    retVal += \"\\n\" + event.getThrowableInformation().getThrowable().getMessage();\n  }\n  return retVal;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  StringBuilder sb = new StringBuilder();\n  if (event.getLevel() == Level.WARN) {\n    sb.append(\"[WARN] \");\n  }\n  sb.append(event.getMessage());\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Formats a logging event to a writer.\n * @param event logging event to be formatted.\n */\n", "method_name": "format", "codes": ["public String format(final LoggingEvent event){ return String.format(\"%s %s%n\", event.getLevel(), event.getMessage()); }", "public String format(final LoggingEvent event){ String s = null; if (event.getThrowableInformation() != null) { s = event.getThrowableInformation().getThrowableStrRep(); } if (s == null) { s = event.getMessage(); } if (s == null) { s = \"\"; } return s; }", "public String format(final LoggingEvent event){ StringBuilder sb = new StringBuilder(); sb.append(event.getLevel()); sb.append(\" [\"); sb.append(event.getLoggerName()); sb.append(\"] \"); sb.append(event.getMessage()); sb.append(\"\\n\"); sb.append(event.getThrowableStrRep()); return sb.toString(); }", "public String format(final LoggingEvent event){ StringBuffer buf = new StringBuffer(); buf.append(event.getLevel().toString()).append(\" \"); buf.append(event.getMessage()).append(\"\\n\"); buf.append(event.getRenderedMessage()).append(\"\\n\"); buf.append(event.getThrowableStrRep()); return buf.toString(); }", "public String format(final LoggingEvent event){ return this.format(event, null); }", "public String format(final LoggingEvent event){ if (event == null) { throw new NullPointerException(\"event\"); } final StringBuilder buf = new StringBuilder(); buf.append(event.getLevel().getLocalizedName()); buf.append(\" \"); buf.append(event.getLoggerName()); buf.append(\": \"); buf.append(event.getMessage()); buf.append(\"\\n\"); return buf.toString(); }", "public String format(final LoggingEvent event){ StringBuilder sb = new StringBuilder(); sb.append(event.getLevel().toString()); sb.append(\": \"); sb.append(event.getRenderedMessage()); sb.append(\"\\n\"); return sb.toString(); }", "public String format(final LoggingEvent event){ return String.format(\"[%s] %s\", event.getLevel(), event.getMessage()); }", "public String format(final LoggingEvent event){ String retVal = \"\"; retVal += \"[\" + event.getLevel().getName() + \"] \"; retVal += event.getMessage() + \"\\n\"; if (event.getThrowableInformation() != null) { retVal += \"\\n\" + event.getThrowableInformation().getThrowable().getMessage(); } return retVal; }", "public String format(final LoggingEvent event){ StringBuilder sb = new StringBuilder(); if (event.getLevel() == Level.WARN) { sb.append(\"[WARN] \"); } sb.append(event.getMessage()); return sb.toString(); }"], "code_level": "project_runnable", "_id": "6367677b1a6d9265ec0182bd", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  if (className == null) {\n    throw new ClassNotFoundException(\"class name is null\");\n  }\n  Class clazz = null;\n  try {\n    clazz = getClassLoader().loadClass(className);\n  } catch (ClassNotFoundException e) {\n    if (className.startsWith(\"java.\") || className.startsWith(\"javax.\")) {\n      clazz = Class.forName(className);\n    } else {\n      throw e;\n    }\n  }\n  if (!isIncluded(clazz)) {\n    return clazz;\n  }\n  if (clazz.isInterface()) {\n    for (Class itf : clazz.getInterfaces()) {\n      if (!isIncluded(itf)) {\n        return itf;\n      }\n    }\n  }\n  return clazz;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  if (className == null) {\n    throw new NullPointerException(\"className\");\n  }\n  Class clazz = null;\n  if (className.indexOf('.') == -1) {\n    clazz = Class.forName(className);\n  } else {\n    final String packageName = className.substring(0, className.lastIndexOf('.'));\n    clazz = Class.forName(packageName + \".\" + className);\n  }\n  return clazz;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  if (className.startsWith(\"java.\") || className.startsWith(\"javax.\")) {\n    return findSystemClass(className);\n  }\n  return findClass(className, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  try {\n    return Class.forName(className);\n  } catch (final ClassNotFoundException e) {\n    try {\n      return Class.forName(className + \"$\");\n    } catch (final ClassNotFoundException e1) {\n      throw e;\n    }\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  if (className == null) {\n    throw new IllegalArgumentException(\"class name must not be null\");\n  }\n  final Class clazz = loader.loadClass(className);\n  if (!clazz.isInterface()) {\n    return clazz;\n  }\n  final Class[] interfaces = clazz.getInterfaces();\n  for (final Class iface : interfaces) {\n    if (!iface.isInterface()) {\n      return iface;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  if (className == null) {\n    throw new NullPointerException(\"className\");\n  }\n  if (classLoader == null) {\n    throw new ClassNotFoundException(\"ClassLoader was null.\");\n  }\n  if (className.indexOf('$') > -1) {\n    className = className.substring(0, className.lastIndexOf('$'));\n  }\n  final Class clazz = classLoader.loadClass(className);\n  if (!isCached(clazz)) {\n    cache(clazz);\n  }\n  return clazz;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  if (className == null) {\n    throw new IllegalArgumentException(\"className cannot be null\");\n  }\n  final Class clazz = Class.forName(className);\n  if (!clazz.isInterface()) {\n    throw new ClassNotFoundException(className);\n  }\n  return clazz;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  if (className == null) {\n    throw new NullPointerException();\n  }\n  try {\n    final ClassLoader loader = Thread.currentThread().getContextClassLoader();\n    if (loader == null) {\n      return Class.forName(className);\n    }\n    return loader.loadClass(className);\n  } catch (final ClassNotFoundException e) {\n    if (this.classLoader != null) {\n      return this.classLoader.loadClass(className);\n    }\n    throw e;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  try {\n    return Class.forName(className);\n  } catch (final ClassNotFoundException e) {\n    final String message = \"Unable to find class '\" + className + \"'\";\n    LOG.error(message, e);\n    throw e;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n  try {\n    return classLoader.loadClass(className);\n  } catch (final ClassNotFoundException e) {\n    final String msg = String.format(\"Can not load class %s\", className);\n    throw new ClassNotFoundException(msg, e);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n", "method_name": "findClass", "codes": ["private Class findClass(final String className) throws ClassNotFoundException { if (className == null) { throw new ClassNotFoundException(\"class name is null\"); } Class clazz = null; try { clazz = getClassLoader().loadClass(className); } catch (ClassNotFoundException e) { if (className.startsWith(\"java.\") || className.startsWith(\"javax.\")) { clazz = Class.forName(className); } else { throw e; } } if (!isIncluded(clazz)) { return clazz; } if (clazz.isInterface()) { for (Class itf : clazz.getInterfaces()) { if (!isIncluded(itf)) { return itf; } } } return clazz; }", "private Class findClass(final String className) throws ClassNotFoundException { if (className == null) { throw new NullPointerException(\"className\"); } Class clazz = null; if (className.indexOf('.') == -1) { clazz = Class.forName(className); } else { final String packageName = className.substring(0, className.lastIndexOf('.')); clazz = Class.forName(packageName + \".\" + className); } return clazz; }", "private Class findClass(final String className) throws ClassNotFoundException { if (className.startsWith(\"java.\") || className.startsWith(\"javax.\")) { return findSystemClass(className); } return findClass(className, null); }", "private Class findClass(final String className) throws ClassNotFoundException { try { return Class.forName(className); } catch (final ClassNotFoundException e) { try { return Class.forName(className + \"$\"); } catch (final ClassNotFoundException e1) { throw e; } } }", "private Class findClass(final String className) throws ClassNotFoundException { if (className == null) { throw new IllegalArgumentException(\"class name must not be null\"); } final Class clazz = loader.loadClass(className); if (!clazz.isInterface()) { return clazz; } final Class[] interfaces = clazz.getInterfaces(); for (final Class iface : interfaces) { if (!iface.isInterface()) { return iface; } } return null; }", "private Class findClass(final String className) throws ClassNotFoundException { if (className == null) { throw new NullPointerException(\"className\"); } if (classLoader == null) { throw new ClassNotFoundException(\"ClassLoader was null.\"); } if (className.indexOf('$') > -1) { className = className.substring(0, className.lastIndexOf('$')); } final Class clazz = classLoader.loadClass(className); if (!isCached(clazz)) { cache(clazz); } return clazz; }", "private Class findClass(final String className) throws ClassNotFoundException { if (className == null) { throw new IllegalArgumentException(\"className cannot be null\"); } final Class clazz = Class.forName(className); if (!clazz.isInterface()) { throw new ClassNotFoundException(className); } return clazz; }", "private Class findClass(final String className) throws ClassNotFoundException { if (className == null) { throw new NullPointerException(); } try { final ClassLoader loader = Thread.currentThread().getContextClassLoader(); if (loader == null) { return Class.forName(className); } return loader.loadClass(className); } catch (final ClassNotFoundException e) { if (this.classLoader != null) { return this.classLoader.loadClass(className); } throw e; } }", "private Class findClass(final String className) throws ClassNotFoundException { try { return Class.forName(className); } catch (final ClassNotFoundException e) { final String message = \"Unable to find class '\" + className + \"'\"; LOG.error(message, e); throw e; } }", "private Class findClass(final String className) throws ClassNotFoundException { final ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); try { return classLoader.loadClass(className); } catch (final ClassNotFoundException e) { final String msg = String.format(\"Can not load class %s\", className); throw new ClassNotFoundException(msg, e); } }"], "code_level": "slib_runnable", "_id": "636767791a6d9265ec018263", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void addMessage(final LogRecord lr) {\n  if (lr == null) {\n    throw new NullPointerException(\"Null log record\");\n  }\n  if (logTable == null) {\n    throw new IllegalStateException(\"LogTable has not been initialized\");\n  }\n  if (logTable.getModel() == null) {\n    logTable.setModel(new LogTableModel());\n  }\n  logTable.getModel().addLogRecord(lr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          synchronized (logTableModel) {\n            logTableModel.add(lr);\n          }\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  if (!isAlive()) {\n    return;\n  }\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          try {\n            LogTableModel ltm = (LogTableModel) getModel();\n            ltm.addRow(new Object[] {lr.getLevel().toString(), lr.getMessage(), lr.getThrown()});\n          } catch (Throwable e) {\n            logger.log(Level.SEVERE, \"Error in addMessage\", e);\n          }\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          synchronized (logTableModel) {\n            logTableModel.addLogRecord(lr);\n          }\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          if (!isVisible()) return;\n          if (lr.getLevel().intValue() >= Level.WARNING.intValue()) {\n            lblLog.append(lr.getMessage());\n          } else {\n            lblLog.append(lr.getMessage());\n          }\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          tableModel.addRecord(lr);\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          logTableModel.addMessage(lr);\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        @Override\n        public void run() {\n          synchronized (tableModel) {\n            tableModel.addLogRecord(lr);\n          }\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          String msg = lr.getMessage();\n          if (msg == null) msg = \"\";\n          logText.append(msg + \"\\n\");\n          logText.setCaretPosition(logText.getText().length() - 1);\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          synchronized (logTable) {\n            logTable.addMessage(lr);\n            logTable.fireTableDataChanged();\n          }\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a log record message to be displayed in the LogTable. This method is thread-safe as it posts requests to the SwingThread rather than processing directly.\n */\n", "method_name": "addMessage", "codes": ["public void addMessage(final LogRecord lr){ if (lr == null) { throw new NullPointerException(\"Null log record\"); } if (logTable == null) { throw new IllegalStateException(\"LogTable has not been initialized\"); } if (logTable.getModel() == null) { logTable.setModel(new LogTableModel()); } logTable.getModel().addLogRecord(lr); }", "public void addMessage(final LogRecord lr){ SwingUtilities.invokeLater(new Runnable() { public void run() { synchronized (logTableModel) { logTableModel.add(lr); } } }); }", "public void addMessage(final LogRecord lr){ if (!isAlive()) { return; } SwingUtilities.invokeLater(new Runnable() { public void run() { try { LogTableModel ltm = (LogTableModel) getModel(); ltm.addRow(new Object[] { lr.getLevel().toString(), lr.getMessage(), lr.getThrown() }); } catch (Throwable e) { logger.log(Level.SEVERE, \"Error in addMessage\", e); } } }); }", "public void addMessage(final LogRecord lr){ SwingUtilities.invokeLater(new Runnable() { public void run() { synchronized (logTableModel) { logTableModel.addLogRecord(lr); } } }); }", "public void addMessage(final LogRecord lr){ SwingUtilities.invokeLater(new Runnable() { public void run() { if (!isVisible()) return; if (lr.getLevel().intValue() >= Level.WARNING.intValue()) { lblLog.append(lr.getMessage()); } else { lblLog.append(lr.getMessage()); } } }); }", "public void addMessage(final LogRecord lr){ SwingUtilities.invokeLater(new Runnable() { public void run() { tableModel.addRecord(lr); } }); }", "public void addMessage(final LogRecord lr){ SwingUtilities.invokeLater(new Runnable() { public void run() { logTableModel.addMessage(lr); } }); }", "public void addMessage(final LogRecord lr){ SwingUtilities.invokeLater(new Runnable() { @Override public void run() { synchronized (tableModel) { tableModel.addLogRecord(lr); } } }); }", "public void addMessage(final LogRecord lr){ SwingUtilities.invokeLater(new Runnable() { public void run() { String msg = lr.getMessage(); if (msg == null) msg = \"\"; logText.append(msg + \"\\n\"); logText.setCaretPosition(logText.getText().length() - 1); } }); }", "public void addMessage(final LogRecord lr){ SwingUtilities.invokeLater(new Runnable() { public void run() { synchronized (logTable) { logTable.addMessage(lr); logTable.fireTableDataChanged(); } } }); }"], "code_level": "project_runnable", "_id": "636767791a6d9265ec018257", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  table.scrollRectToVisible(new Rectangle(row, 0, table.getRowHeight(), table.getRowHeight()));\n  pane.getViewport().setViewPosition(new Point(row, 0));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  selectRow(row, table.getRowCount(), pane);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  table.getSelectionModel().setSelectionInterval(row, row);\n  pane.setViewportView(table);\n  pane.repaint();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  if (table != null) {\n    int first = table.getSelectedRow();\n    int last = table.getRowCount() - 1;\n    if (row >= first && row <= last) {\n      table.setRowSelectionInterval(row, row);\n      pane.getViewport().scrollRectToVisible(new Rectangle(table.getCellRect(row, 0, true)));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  if (table == null || pane == null) return;\n  int viewRow = table.convertRowIndexToView(row);\n  int viewColumn = table.convertColumnIndexToView(table.getColumnCount() - 1);\n  if (viewRow < 0) return;\n  table.scrollRectToVisible(table.getCellRect(viewRow, viewColumn, true));\n  pane.getViewport().setViewPosition(new Point(0, 0));\n  pane.setViewportView(table);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  table.setRowSelectionInterval(row, row);\n  pane.setViewportView(table);\n  pane.scrollRectToVisible(table.getCellRect(row, 0, true));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  int numRows = table.getRowCount();\n  for (int i = 0; i < numRows; i++) {\n    if (i == row) {\n      if (table.getSelectedRow() != row) {\n        table.setRowSelectionInterval(row, row);\n        table.scrollRectToVisible(\n            new Rectangle(0, 0, table.getRowHeight(), table.getRowHeight()));\n      }\n    } else {\n      table.setRowSelectionInterval(i, i);\n      table.scrollRectToVisible(new Rectangle(0, 0, table.getRowHeight(), table.getRowHeight()));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  pane.getViewport().setViewPosition(new Point(row, 0));\n  table.scrollRectToVisible(new Rectangle(0, 0, pane.getWidth(), pane.getHeight()));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  selectRow(table.getRow(row), table, pane);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  if (row >= 0) {\n    int nrows = table.getRowCount();\n    if (nrows > row) {\n      if (table.getSelectedRow() == row) {\n        table.setRowSelectionInterval(row, row);\n      } else {\n        table.setRowSelectionInterval(row, nrows);\n      }\n    }\n  }\n  pane.getViewport().setViewPosition(new Point(0, 0));\n  pane.repaint();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Selects a the specified row in the specified JTable and scrolls the specified JScrollpane to the newly selected row. More importantly, the call to repaint() delayed long enough to have the table properly paint the newly selected row which may be offscre\n * @param table should belong to the specified JScrollPane\n */\n", "method_name": "selectRow", "codes": ["public static void selectRow(int row,JTable table,JScrollPane pane){ table.scrollRectToVisible(new Rectangle(row, 0, table.getRowHeight(), table.getRowHeight())); pane.getViewport().setViewPosition(new Point(row, 0)); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ selectRow(row, table.getRowCount(), pane); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ table.getSelectionModel().setSelectionInterval(row, row); pane.setViewportView(table); pane.repaint(); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ if (table != null) { int first = table.getSelectedRow(); int last = table.getRowCount() - 1; if (row >= first && row <= last) { table.setRowSelectionInterval(row, row); pane.getViewport().scrollRectToVisible(new Rectangle(table.getCellRect(row, 0, true))); } } }", "public static void selectRow(int row,JTable table,JScrollPane pane){ if (table == null || pane == null) return; int viewRow = table.convertRowIndexToView(row); int viewColumn = table.convertColumnIndexToView(table.getColumnCount() - 1); if (viewRow < 0) return; table.scrollRectToVisible(table.getCellRect(viewRow, viewColumn, true)); pane.getViewport().setViewPosition(new Point(0, 0)); pane.setViewportView(table); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ table.setRowSelectionInterval(row, row); pane.setViewportView(table); pane.scrollRectToVisible(table.getCellRect(row, 0, true)); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ int numRows = table.getRowCount(); for (int i = 0; i < numRows; i++) { if (i == row) { if (table.getSelectedRow() != row) { table.setRowSelectionInterval(row, row); table.scrollRectToVisible(new Rectangle(0, 0, table.getRowHeight(), table.getRowHeight())); } } else { table.setRowSelectionInterval(i, i); table.scrollRectToVisible(new Rectangle(0, 0, table.getRowHeight(), table.getRowHeight())); } } }", "public static void selectRow(int row,JTable table,JScrollPane pane){ pane.getViewport().setViewPosition(new Point(row, 0)); table.scrollRectToVisible(new Rectangle(0, 0, pane.getWidth(), pane.getHeight())); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ selectRow(table.getRow(row), table, pane); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ if (row >= 0) { int nrows = table.getRowCount(); if (nrows > row) { if (table.getSelectedRow() == row) { table.setRowSelectionInterval(row, row); } else { table.setRowSelectionInterval(row, nrows); } } } pane.getViewport().setViewPosition(new Point(0, 0)); pane.repaint(); }"], "code_level": "project_runnable", "_id": "636767841a6d9265ec0183ff", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static void createConfigurationDirectory() {\n  File lf5 = new File(\"lf5\");\n  if (!lf5.exists()) {\n    lf5.mkdir();\n  }\n  File confDir = new File(\"conf\");\n  if (!confDir.exists()) {\n    confDir.mkdir();\n  }\n  File lf5Conf = new File(\"conf/lf5.conf\");\n  if (!lf5Conf.exists()) {\n    try {\n      lf5Conf.createNewFile();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  File configFolder = new File(\"C:\\\\Users\\\\pavan\\\\Documents\\\\\");\n  if (!configFolder.exists()) {\n    configFolder.mkdir();\n  }\n  File lf5 = new File(\"C:\\\\Users\\\\pavan\\\\Documents\\\\\" + \"MRU File List\");\n  if (!lf5.exists()) {\n    try {\n      lf5.createNewFile();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  File lf5 = new File(\"lf5\");\n  if (!lf5.exists()) {\n    lf5.mkdir();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  File configDir =\n      new File(\"C:\\\\Program Files\\\\Microsoft\\\\Microsoft\\\\Windows\\\\Linux\\\\Linux\\\\Configuration\");\n  if (!configDir.exists()) {\n    configDir.mkdir();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  File lf5Dir = new File(\"/etc/lf5\");\n  if (!lf5Dir.exists()) {\n    lf5Dir.mkdir();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  File lf5 = new File(System.getProperty(\"user.home\") + \"/.mru\");\n  if (lf5.exists()) {\n    return;\n  }\n  lf5.mkdirs();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  File lf5Directory = new File(\"lf5\");\n  if (!lf5Directory.exists()) {\n    lf5Directory.mkdir();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  File lf5 = new File(\"lf5\");\n  if (lf5.exists()) {\n    lf5.delete();\n  }\n  lf5.mkdir();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  String configPath = \"config\";\n  File configDir = new File(configPath);\n  if (!configDir.exists()) {\n    configDir.mkdir();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  File lf5Directory = new File(\"lf5\");\n  if (!lf5Directory.exists()) {\n    lf5Directory.mkdir();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Creates the directory where the MRU file list will be written. The \"lf5\" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.\n */\n", "method_name": "createConfigurationDirectory", "codes": ["public static void createConfigurationDirectory(){ File lf5 = new File(\"lf5\"); if (!lf5.exists()) { lf5.mkdir(); } File confDir = new File(\"conf\"); if (!confDir.exists()) { confDir.mkdir(); } File lf5Conf = new File(\"conf/lf5.conf\"); if (!lf5Conf.exists()) { try { lf5Conf.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } }", "public static void createConfigurationDirectory(){ File configFolder = new File(\"C:\\\\Users\\\\pavan\\\\Documents\\\\\"); if (!configFolder.exists()) { configFolder.mkdir(); } File lf5 = new File(\"C:\\\\Users\\\\pavan\\\\Documents\\\\\" + \"MRU File List\"); if (!lf5.exists()) { try { lf5.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } }", "public static void createConfigurationDirectory(){ File lf5 = new File(\"lf5\"); if (!lf5.exists()) { lf5.mkdir(); } }", "public static void createConfigurationDirectory(){ File configDir = new File(\"C:\\\\Program Files\\\\Microsoft\\\\Microsoft\\\\Windows\\\\Linux\\\\Linux\\\\Configuration\"); if (!configDir.exists()) { configDir.mkdir(); } }", "public static void createConfigurationDirectory(){ File lf5Dir = new File(\"/etc/lf5\"); if (!lf5Dir.exists()) { lf5Dir.mkdir(); } }", "public static void createConfigurationDirectory(){ File lf5 = new File(System.getProperty(\"user.home\") + \"/.mru\"); if (lf5.exists()) { return; } lf5.mkdirs(); }", "public static void createConfigurationDirectory(){ File lf5Directory = new File(\"lf5\"); if (!lf5Directory.exists()) { lf5Directory.mkdir(); } }", "public static void createConfigurationDirectory(){ File lf5 = new File(\"lf5\"); if (lf5.exists()) { lf5.delete(); } lf5.mkdir(); }", "public static void createConfigurationDirectory(){ String configPath = \"config\"; File configDir = new File(configPath); if (!configDir.exists()) { configDir.mkdir(); } }", "public static void createConfigurationDirectory(){ File lf5Directory = new File(\"lf5\"); if (!lf5Directory.exists()) { lf5Directory.mkdir(); } }"], "code_level": "slib_runnable", "_id": "636767871a6d9265ec01846d", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public synchronized void send(final String message) {\n  if (message == null || message.equals(\"\")) {\n    return;\n  }\n  final StringBuilder builder = new StringBuilder(message.length() + 20);\n  builder.append(message);\n  for (final ChatClient client : clients) {\n    if (client.getSocket().isConnected()) {\n      try {\n        client.getWriter().write(builder.toString());\n        client.getWriter().flush();\n      } catch (final IOException e) {\n        clients.remove(client);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  if (message.length() > 0) {\n    this.output.println(message);\n    this.output.flush();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  if (message == null || message.length() == 0) {\n    return;\n  }\n  if (!isConnected()) {\n    return;\n  }\n  try {\n    if (outputStream == null) {\n      return;\n    }\n    outputStream.write(message.getBytes());\n    outputStream.flush();\n  } catch (IOException e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  for (final Socket client : clients) {\n    try {\n      PrintStream os = new PrintStream(client.getOutputStream());\n      os.println(message);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  for (TelnetClient telnetClient : telnetClients) {\n    try {\n      telnetClient.write(message);\n    } catch (IOException e) {\n      telnetClients.remove(telnetClient);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  for (final TelnetClient client : clients) {\n    try {\n      client.send(message);\n    } catch (IOException e) {\n      System.err.println(\"Error sending message: \" + message);\n      e.printStackTrace();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  if (message == null) {\n    return;\n  }\n  for (int i = 0; i < clients.length; i++) {\n    if (!clients[i].isConnected()) {\n      continue;\n    }\n    try {\n      clients[i].getOutputStream().write(message.getBytes());\n    } catch (IOException e) {\n      clients[i].disconnect();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  for (ClientHandler c : clients) {\n    if (c != null) {\n      c.send(message);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  for (final ClientHandler client : clients) {\n    client.send(message);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  for (int i = 0; i < clients.size(); i++) {\n    try {\n      final ChatClient client = clients.get(i);\n      client.output.write(message + \"\\n\");\n      client.output.flush();\n    } catch (final IOException e) {\n      e.printStackTrace();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * sends a message to each of the clients in telnet-friendly output. \n */\n", "method_name": "send", "codes": ["public synchronized void send(final String message){ if (message == null || message.equals(\"\")) { return; } final StringBuilder builder = new StringBuilder(message.length() + 20); builder.append(message); for (final ChatClient client : clients) { if (client.getSocket().isConnected()) { try { client.getWriter().write(builder.toString()); client.getWriter().flush(); } catch (final IOException e) { clients.remove(client); } } } }", "public synchronized void send(final String message){ if (message.length() > 0) { this.output.println(message); this.output.flush(); } }", "public synchronized void send(final String message){ if (message == null || message.length() == 0) { return; } if (!isConnected()) { return; } try { if (outputStream == null) { return; } outputStream.write(message.getBytes()); outputStream.flush(); } catch (IOException e) { e.printStackTrace(); } }", "public synchronized void send(final String message){ for (final Socket client : clients) { try { PrintStream os = new PrintStream(client.getOutputStream()); os.println(message); } catch (IOException e) { e.printStackTrace(); } } }", "public synchronized void send(final String message){ for (TelnetClient telnetClient : telnetClients) { try { telnetClient.write(message); } catch (IOException e) { telnetClients.remove(telnetClient); } } }", "public synchronized void send(final String message){ for (final TelnetClient client : clients) { try { client.send(message); } catch (IOException e) { System.err.println(\"Error sending message: \" + message); e.printStackTrace(); } } }", "public synchronized void send(final String message){ if (message == null) { return; } for (int i = 0; i < clients.length; i++) { if (!clients[i].isConnected()) { continue; } try { clients[i].getOutputStream().write(message.getBytes()); } catch (IOException e) { clients[i].disconnect(); } } }", "public synchronized void send(final String message){ for (ClientHandler c : clients) { if (c != null) { c.send(message); } } }", "public synchronized void send(final String message){ for (final ClientHandler client : clients) { client.send(message); } }", "public synchronized void send(final String message){ for (int i = 0; i < clients.size(); i++) { try { final ChatClient client = clients.get(i); client.output.write(message + \"\\n\"); client.output.flush(); } catch (final IOException e) { e.printStackTrace(); } } }"], "code_level": "class_runnable", "_id": "6367677f1a6d9265ec018347", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "protected void append(LoggingEvent event) {\n  if (event.getLevel().intValue() >= Level.WARNING.intValue()) {\n    String message = event.getMessage().toString();\n    if (message.length() > MAX_LOG_MESSAGE_LENGTH) {\n      message = message.substring(0, MAX_LOG_MESSAGE_LENGTH - 3) + \"...\";\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(message);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){ String message = event.getMessage(); if (message == null || message.length() == 0) { return; } if (message.startsWith(\"\\n\")) { message = message.substring(1); } if (message.endsWith(\"\\n\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\t\")) { message = message.substring(1); } if (message.endsWith(\"\\t\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\f\")) { message = message.substring(1); } if (message.endsWith(\"\\f\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\b\")) { message = message.substring(1); } if (message.endsWith(\"\\b\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\t\\t\")) { message = message.substring(1); } if (message.endsWith(\"\\t\\t\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\r\\n\")) { message = message.substring(1); } if (message.endsWith(\"\\r\\n\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\f\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\f\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\b\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\b\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\t\\b\\t\")) { message = message.substring(1); } if (message.endsWith(\"\\t\\b\\t\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\r\\n\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\r\\n\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\f\\r\\n\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\f\\r\\n\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\b\\r\\n\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\b\\r\\n\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\t\\b\\t\\t\")) { message = message.substring(1); } if (message.endsWith(\"\\t\\b\\t\\t\")) {", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (event.getLevel().isGreaterOrEqual(Level.WARN)) {\n    String message = event.getRenderedMessage();\n    if (message == null || message.isEmpty()) {\n      message = event.getThrowableInformation().getThrowable().getMessage();\n    }\n    if (message != null) {\n      try {\n        writer.write(message);\n        writer.write(\"\\n\");\n        writer.flush();\n      } catch (IOException ioe) {\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  for (Client client : clients) {\n    try {\n      client.send(event);\n    } catch (IOException e) {\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (!enabled) {\n    return;\n  }\n  synchronized (lock) {\n    if (enabled && !isWriting) {\n      if (event.getLevel().isGreaterOrEqual(Level.WARN)) {\n        isWriting = true;\n      }\n      for (Client client : clients) {\n        try {\n          client.write(event);\n        } catch (IOException e) {\n          logger.error(\"Error writing to client \" + client.getId(), e);\n        }\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){ try { if (event.getLevel().toInt() <= Level.WARN.toInt()) { String message = event.getRenderedMessage(); if (message != null) { if (message.contains(\"[\")) { message = message.substring(0, message.indexOf(\"[\")); } if (message.contains(\"]\")) { message = message.substring(message.indexOf(\"]\") + 1); } if (message.contains(\"\\\"\")) { message = message.substring(0, message.indexOf(\"\\\"\")); } if (message.contains(\"\\n\")) { message = message.substring(message.indexOf(\"\\n\") + 1); } if (message.contains(\"\\r\")) { message = message.substring(message.indexOf(\"\\r\") + 1); } if (message.contains(\"\\t\")) { message = message.substring(0, message.indexOf(\"\\t\")); } if (message.contains(\"\\b\")) { message = message.substring(message.indexOf(\"\\b\") + 1); } if (message.contains(\"\\f\")) { message = message.substring(message.indexOf(\"\\f\") + 1); } if (message.contains(\"\\r\\n\")) { message = message.substring(message.indexOf(\"\\r\\n\") + 1); } if (message.contains(\"\\r\")) { message = message.substring(message.indexOf(\"\\r\") + 1); } if (message.contains(\"\\n\")) { message = message.substring(message.indexOf(\"\\n\") + 1); } if (message.contains(\"\\t\")) { message = message.substring(0, message.indexOf(\"\\t\")); } if (message.contains(\"\\b\")) { message = message.substring(message.indexOf(\"\\b\") + 1); } if (message.contains(\"\\f\")) { message = message.substring(message.indexOf(\"\\f\") + 1); } if (message.contains(\"\\r\\n\")) { message = message.substring(message.indexOf(\"\\r\\n\") + 1); } if (message.contains(\"\\r\")) { message = message.substring(message.indexOf(\"\\r\") + 1); } if (message.contains(\"\\n\")) { message = message.substring(message.indexOf(\"\\n\") + 1); } if (message.contains(\"\\t\")) { message = message.substring(0, message.indexOf(\"\\t\")); } if (message.contains(\"\\b\")) { message = message.substring(message.indexOf(\"\\b\") + 1); } if (message.contains(\"\\f\")) { message = message.substring(message.indexOf(\"\\f\") + 1); } if (message.contains(\"\\r\\n\")) { message = message.substring(message.indexOf(\"\\r\\n\") + 1); } if (message.contains(\"\\r\")) { message = message.substring(message.indexOf(\"\\r\") + 1); } if", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (logLevel.compareTo(Level.DEBUG) < 0) {\n    return;\n  }\n  String message = event.getMessage().toString();\n  if (message.length() > MAX_MESSAGE_LENGTH) {\n    message = message.substring(0, MAX_MESSAGE_LENGTH);\n  }\n  if (message.length() > 0) {\n    if (!logToFile) {\n      writeToFile(message);\n    } else {\n      writeToLog(message);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (!isEnabled()) return;\n  if (event.getLevel().intValue() >= level.intValue()) {\n    if (!isAppend) {\n      synchronized (this) {\n        if (isAppend) {\n          return;\n        }\n        isAppend = true;\n      }\n    }\n    if (!isEmpty) {\n      if (!isConsoleEnabled) {\n        synchronized (this) {\n          if (isConsoleEnabled) {\n            return;\n          }\n          isConsoleEnabled = true;\n        }\n      }\n      if (!isSilent) {\n        synchronized (this) {\n          if (!isSilent) {\n            String message = event.getMessage().toString();\n            if (message.indexOf(\"\\n\") == -1) {\n              message = message + \"\\n\";\n            }\n            if (!isClosed) {\n              try {\n                if (message.length() > maxMessageLength) {\n                  message = message.substring(0, maxMessageLength);\n                }\n                if (message.length() > 0) {\n                  if (writer != null) {\n                    writer.write(message);\n                  }\n                }\n              } catch (IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (clients.size() <= 0) {\n    return;\n  }\n  for (ClientHandler client : clients) {\n    if (client.isConnected()) {\n      client.send(event);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  String message = formatMessage(event);\n  if (message != null) {\n    synchronized (lock) {\n      if (clients != null && !clients.isEmpty()) {\n        for (Socket client : clients) {\n          try {\n            PrintWriter out = new PrintWriter(client.getOutputStream(), true);\n            out.println(message);\n          } catch (IOException e) {\n            LOGGER.warn(\"Exception writing to client \" + client, e);\n          }\n        }\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n", "method_name": "append", "codes": ["protected void append(LoggingEvent event){ if (event.getLevel().intValue() >= Level.WARNING.intValue()) { String message = event.getMessage().toString(); if (message.length() > MAX_LOG_MESSAGE_LENGTH) { message = message.substring(0, MAX_LOG_MESSAGE_LENGTH - 3) + \"...\"; } if (log.isDebugEnabled()) { log.debug(message); } } }", "protected void append(LoggingEvent event){ String message = event.getMessage(); if (message == null || message.length() == 0) { return; } if (message.startsWith(\"\\n\")) { message = message.substring(1); } if (message.endsWith(\"\\n\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\t\")) { message = message.substring(1); } if (message.endsWith(\"\\t\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\f\")) { message = message.substring(1); } if (message.endsWith(\"\\f\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\b\")) { message = message.substring(1); } if (message.endsWith(\"\\b\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\t\\t\")) { message = message.substring(1); } if (message.endsWith(\"\\t\\t\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\r\\n\")) { message = message.substring(1); } if (message.endsWith(\"\\r\\n\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\f\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\f\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\b\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\b\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\t\\b\\t\")) { message = message.substring(1); } if (message.endsWith(\"\\t\\b\\t\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\r\\n\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\r\\n\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\f\\r\\n\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\f\\r\\n\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\b\\r\\n\\r\")) { message = message.substring(1); } if (message.endsWith(\"\\b\\r\\n\\r\")) { message = message.substring(0, message.length() - 1); } if (message.startsWith(\"\\t\\b\\t\\t\")) { message = message.substring(1); } if (message.endsWith(\"\\t\\b\\t\\t\")) {", "protected void append(LoggingEvent event){ if (event.getLevel().isGreaterOrEqual(Level.WARN)) { String message = event.getRenderedMessage(); if (message == null || message.isEmpty()) { message = event.getThrowableInformation().getThrowable().getMessage(); } if (message != null) { try { writer.write(message); writer.write(\"\\n\"); writer.flush(); } catch (IOException ioe) { } } } }", "protected void append(LoggingEvent event){ for (Client client : clients) { try { client.send(event); } catch (IOException e) { } } }", "protected void append(LoggingEvent event){ if (!enabled) { return; } synchronized (lock) { if (enabled && !isWriting) { if (event.getLevel().isGreaterOrEqual(Level.WARN)) { isWriting = true; } for (Client client : clients) { try { client.write(event); } catch (IOException e) { logger.error(\"Error writing to client \" + client.getId(), e); } } } } }", "protected void append(LoggingEvent event){ try { if (event.getLevel().toInt() <= Level.WARN.toInt()) { String message = event.getRenderedMessage(); if (message != null) { if (message.contains(\"[\")) { message = message.substring(0, message.indexOf(\"[\")); } if (message.contains(\"]\")) { message = message.substring(message.indexOf(\"]\") + 1); } if (message.contains(\"\\\"\")) { message = message.substring(0, message.indexOf(\"\\\"\")); } if (message.contains(\"\\n\")) { message = message.substring(message.indexOf(\"\\n\") + 1); } if (message.contains(\"\\r\")) { message = message.substring(message.indexOf(\"\\r\") + 1); } if (message.contains(\"\\t\")) { message = message.substring(0, message.indexOf(\"\\t\")); } if (message.contains(\"\\b\")) { message = message.substring(message.indexOf(\"\\b\") + 1); } if (message.contains(\"\\f\")) { message = message.substring(message.indexOf(\"\\f\") + 1); } if (message.contains(\"\\r\\n\")) { message = message.substring(message.indexOf(\"\\r\\n\") + 1); } if (message.contains(\"\\r\")) { message = message.substring(message.indexOf(\"\\r\") + 1); } if (message.contains(\"\\n\")) { message = message.substring(message.indexOf(\"\\n\") + 1); } if (message.contains(\"\\t\")) { message = message.substring(0, message.indexOf(\"\\t\")); } if (message.contains(\"\\b\")) { message = message.substring(message.indexOf(\"\\b\") + 1); } if (message.contains(\"\\f\")) { message = message.substring(message.indexOf(\"\\f\") + 1); } if (message.contains(\"\\r\\n\")) { message = message.substring(message.indexOf(\"\\r\\n\") + 1); } if (message.contains(\"\\r\")) { message = message.substring(message.indexOf(\"\\r\") + 1); } if (message.contains(\"\\n\")) { message = message.substring(message.indexOf(\"\\n\") + 1); } if (message.contains(\"\\t\")) { message = message.substring(0, message.indexOf(\"\\t\")); } if (message.contains(\"\\b\")) { message = message.substring(message.indexOf(\"\\b\") + 1); } if (message.contains(\"\\f\")) { message = message.substring(message.indexOf(\"\\f\") + 1); } if (message.contains(\"\\r\\n\")) { message = message.substring(message.indexOf(\"\\r\\n\") + 1); } if (message.contains(\"\\r\")) { message = message.substring(message.indexOf(\"\\r\") + 1); } if", "protected void append(LoggingEvent event){ if (logLevel.compareTo(Level.DEBUG) < 0) { return; } String message = event.getMessage().toString(); if (message.length() > MAX_MESSAGE_LENGTH) { message = message.substring(0, MAX_MESSAGE_LENGTH); } if (message.length() > 0) { if (!logToFile) { writeToFile(message); } else { writeToLog(message); } } }", "protected void append(LoggingEvent event){ if (!isEnabled()) return; if (event.getLevel().intValue() >= level.intValue()) { if (!isAppend) { synchronized (this) { if (isAppend) { return; } isAppend = true; } } if (!isEmpty) { if (!isConsoleEnabled) { synchronized (this) { if (isConsoleEnabled) { return; } isConsoleEnabled = true; } } if (!isSilent) { synchronized (this) { if (!isSilent) { String message = event.getMessage().toString(); if (message.indexOf(\"\\n\") == -1) { message = message + \"\\n\"; } if (!isClosed) { try { if (message.length() > maxMessageLength) { message = message.substring(0, maxMessageLength); } if (message.length() > 0) { if (writer != null) { writer.write(message); } } } catch (IOException e) { logger.error(e.getMessage()); } } } } } } } }", "protected void append(LoggingEvent event){ if (clients.size() <= 0) { return; } for (ClientHandler client : clients) { if (client.isConnected()) { client.send(event); } } }", "protected void append(LoggingEvent event){ String message = formatMessage(event); if (message != null) { synchronized (lock) { if (clients != null && !clients.isEmpty()) { for (Socket client : clients) { try { PrintWriter out = new PrintWriter(client.getOutputStream(), true); out.println(message); } catch (IOException e) { LOGGER.warn(\"Exception writing to client \" + client, e); } } } } } }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec01823e", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void put(LoggingEvent o) {\n  if (buffer.size() >= bufferSize) {\n    o.setLevel(Level.OFF);\n    o.setMessage(null);\n    o.setThrowable(null);\n    o.setLoggerName(null);\n    o.setLoggerFqcn(null);\n    o.setMDCPropertyMap(null);\n    o.setThreadName(null);\n    o.setThreadId(null);\n    o.setTimeStamp(0);\n  }\n  buffer.add(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (buffer.size() >= bufferCapacity) {\n    flush();\n  }\n  buffer.add(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (o.getLevel().intValue() >= level.intValue()) {\n    if (buffer.size() >= maxSize) {\n      flush();\n    }\n    buffer.add(o);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (o.getLevel().isGreaterOrEqual(level)) {\n    if (logBuffer.size() >= maxBufferSize) {\n      o.setLocationInformation(null);\n    }\n    logBuffer.add(o);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (isFull()) {\n    throw new BufferFullException(\"Cannot put a log event in the buffer, the buffer is full.\");\n  }\n  if (o == null) {\n    throw new NullPointerException(\"Cannot put a null log event.\");\n  }\n  logBuffer[size] = o;\n  size++;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (buffer.size() >= bufferSize) {\n    LoggingEvent e = buffer.remove();\n    e.setNativeLevel(o.getNativeLevel());\n    e.setLoggerName(o.getLoggerName());\n    e.setThrowableInformation(o.getThrowableInformation());\n  }\n  buffer.add(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (isFull()) {\n    drop();\n  }\n  if (o.getThrowableProxy() != null) {\n    throw new IllegalArgumentException(\"Can't put a LoggingEvent that is already logged\");\n  }\n  if (o.getLevel().intValue() >= level.intValue()) {\n    logger.log(o);\n  } else {\n    if (silent) {\n      logger.log(o);\n    } else {\n      throw new IllegalStateException(\"Can't drop a LoggingEvent that is not logged\");\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (buffer.size() >= MAX_BUFFER_SIZE) {\n    LOG.warn(\"Buffer full, can't put {}\", o);\n  }\n  buffer.add(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  synchronized (buffer) {\n    if (buffer.size() >= maxSize) {\n      try {\n        buffer.wait();\n      } catch (InterruptedException e) {\n      }\n    }\n    buffer.add(o);\n    buffer.notify();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (buffer.size() == maxSize) {\n    buffer.removeFirst();\n  }\n  buffer.addLast(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  \n */\n", "method_name": "put", "codes": ["public void put(LoggingEvent o){ if (buffer.size() >= bufferSize) { o.setLevel(Level.OFF); o.setMessage(null); o.setThrowable(null); o.setLoggerName(null); o.setLoggerFqcn(null); o.setMDCPropertyMap(null); o.setThreadName(null); o.setThreadId(null); o.setTimeStamp(0); } buffer.add(o); }", "public void put(LoggingEvent o){ if (buffer.size() >= bufferCapacity) { flush(); } buffer.add(o); }", "public void put(LoggingEvent o){ if (o.getLevel().intValue() >= level.intValue()) { if (buffer.size() >= maxSize) { flush(); } buffer.add(o); } }", "public void put(LoggingEvent o){ if (o.getLevel().isGreaterOrEqual(level)) { if (logBuffer.size() >= maxBufferSize) { o.setLocationInformation(null); } logBuffer.add(o); } }", "public void put(LoggingEvent o){ if (isFull()) { throw new BufferFullException(\"Cannot put a log event in the buffer, the buffer is full.\"); } if (o == null) { throw new NullPointerException(\"Cannot put a null log event.\"); } logBuffer[size] = o; size++; }", "public void put(LoggingEvent o){ if (buffer.size() >= bufferSize) { LoggingEvent e = buffer.remove(); e.setNativeLevel(o.getNativeLevel()); e.setLoggerName(o.getLoggerName()); e.setThrowableInformation(o.getThrowableInformation()); } buffer.add(o); }", "public void put(LoggingEvent o){ if (isFull()) { drop(); } if (o.getThrowableProxy() != null) { throw new IllegalArgumentException(\"Can't put a LoggingEvent that is already logged\"); } if (o.getLevel().intValue() >= level.intValue()) { logger.log(o); } else { if (silent) { logger.log(o); } else { throw new IllegalStateException(\"Can't drop a LoggingEvent that is not logged\"); } } }", "public void put(LoggingEvent o){ if (buffer.size() >= MAX_BUFFER_SIZE) { LOG.warn(\"Buffer full, can't put {}\", o); } buffer.add(o); }", "public void put(LoggingEvent o){ synchronized (buffer) { if (buffer.size() >= maxSize) { try { buffer.wait(); } catch (InterruptedException e) { } } buffer.add(o); buffer.notify(); } }", "public void put(LoggingEvent o){ if (buffer.size() == maxSize) { buffer.removeFirst(); } buffer.addLast(o); }"], "code_level": "class_runnable", "_id": "6367677f1a6d9265ec01834b", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static String findAndSubst(String key, Properties props) {\n  String value = findAndSubst(key, null, props);\n  if (value == null) {\n    value = props.getProperty(key);\n  }\n  return value;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  String value = null;\n  for (Object k : props.keySet()) {\n    if (key.equals(k)) {\n      value = props.getProperty(key);\n    }\n  }\n  if (value == null) {\n    return key;\n  }\n  return value.substring(0, value.indexOf('$'));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  if (key == null) {\n    return null;\n  }\n  if (props == null) {\n    props = new Properties();\n  }\n  String value = props.getProperty(key);\n  if (value == null) {\n    value = props.getProperty(key.toLowerCase());\n  }\n  if (value == null) {\n    value = props.getProperty(key.toUpperCase());\n  }\n  if (value == null) {\n    value = props.getProperty(key);\n  }\n  if (value == null) {\n    value = props.getProperty(key.trim());\n  }\n  return value;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  return findAndSubst(key, props, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  String value = props.getProperty(key);\n  if (value != null) {\n    return value;\n  }\n  value = props.getProperty(\"${\" + key + \"}\");\n  if (value != null) {\n    return value;\n  }\n  value = props.getProperty(key.toUpperCase());\n  if (value != null) {\n    return value;\n  }\n  value = props.getProperty(\"#{\" + key + \"}\");\n  if (value != null) {\n    return value;\n  }\n  value = props.getProperty(\"${\" + key.toUpperCase() + \"}\");\n  if (value != null) {\n    return value;\n  }\n  return props.getProperty(key.toLowerCase());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  return findAndSubst(key, props, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  String value = props.getProperty(key);\n  if (value == null) {\n    value = props.getProperty(key.toLowerCase());\n  }\n  if (value == null) {\n    value = props.getProperty(key.toUpperCase());\n  }\n  if (value == null) {\n    throw new RuntimeException(\"Could not find property '\" + key + \"' in \" + props);\n  }\n  return value;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  String value = props.getProperty(key);\n  if (value == null) {\n    return null;\n  }\n  StringBuilder sb = new StringBuilder(value);\n  int index = 0;\n  while ((index = sb.indexOf(\"${\", index)) != -1) {\n    String name = sb.substring(index + 2, sb.indexOf(\"}\", index));\n    String val = props.getProperty(name);\n    if (val != null) {\n      sb.replace(index, index + 2, val);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  String value = props.getProperty(key);\n  if (value != null) {\n    return value.substring(1, value.length() - 1);\n  } else {\n    return null;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  return findAndSubst(key, props, \"\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.\n */\n", "method_name": "findAndSubst", "codes": ["public static String findAndSubst(String key,Properties props){ String value = findAndSubst(key, null, props); if (value == null) { value = props.getProperty(key); } return value; }", "public static String findAndSubst(String key,Properties props){ String value = null; for (Object k : props.keySet()) { if (key.equals(k)) { value = props.getProperty(key); } } if (value == null) { return key; } return value.substring(0, value.indexOf('$')); }", "public static String findAndSubst(String key,Properties props){ if (key == null) { return null; } if (props == null) { props = new Properties(); } String value = props.getProperty(key); if (value == null) { value = props.getProperty(key.toLowerCase()); } if (value == null) { value = props.getProperty(key.toUpperCase()); } if (value == null) { value = props.getProperty(key); } if (value == null) { value = props.getProperty(key.trim()); } return value; }", "public static String findAndSubst(String key,Properties props){ return findAndSubst(key, props, null); }", "public static String findAndSubst(String key,Properties props){ String value = props.getProperty(key); if (value != null) { return value; } value = props.getProperty(\"${\" + key + \"}\"); if (value != null) { return value; } value = props.getProperty(key.toUpperCase()); if (value != null) { return value; } value = props.getProperty(\"#{\" + key + \"}\"); if (value != null) { return value; } value = props.getProperty(\"${\" + key.toUpperCase() + \"}\"); if (value != null) { return value; } return props.getProperty(key.toLowerCase()); }", "public static String findAndSubst(String key,Properties props){ return findAndSubst(key, props, null); }", "public static String findAndSubst(String key,Properties props){ String value = props.getProperty(key); if (value == null) { value = props.getProperty(key.toLowerCase()); } if (value == null) { value = props.getProperty(key.toUpperCase()); } if (value == null) { throw new RuntimeException(\"Could not find property '\" + key + \"' in \" + props); } return value; }", "public static String findAndSubst(String key,Properties props){ String value = props.getProperty(key); if (value == null) { return null; } StringBuilder sb = new StringBuilder(value); int index = 0; while ((index = sb.indexOf(\"${\", index)) != -1) { String name = sb.substring(index + 2, sb.indexOf(\"}\", index)); String val = props.getProperty(name); if (val != null) { sb.replace(index, index + 2, val); } } return sb.toString(); }", "public static String findAndSubst(String key,Properties props){ String value = props.getProperty(key); if (value != null) { return value.substring(1, value.length() - 1); } else { return null; } }", "public static String findAndSubst(String key,Properties props){ return findAndSubst(key, props, \"\"); }"], "code_level": "project_runnable", "_id": "636767791a6d9265ec01826d", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public boolean isAttached(Appender appender) {\n  return (appender != null) ? attachedAppenders.contains(appender) : false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isAttached(Appender appender) {\n  synchronized (this.appenders) {\n    return this.appenders.contains(appender);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return appenders.contains(appender);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return attachedAppenders.contains(appender);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return attachedAppenders.contains(appender);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return appenders.contains(appender);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return attachedAppenders.contains(appender);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return attachedAppenders.contains(appender);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return attachedAppenders.contains(appender);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return attachedAppenders.contains(appender);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns <code>true</code> if the specified appender is in the list of attached appenders, <code>false</code> otherwise.\n * @since 1.2 \n */\n", "method_name": "isAttached", "codes": ["public boolean isAttached(Appender appender){ return (appender != null) ? attachedAppenders.contains(appender) : false; }", "public boolean isAttached(Appender appender){ synchronized (this.appenders) { return this.appenders.contains(appender); } }", "public boolean isAttached(Appender appender){ return appenders.contains(appender); }", "public boolean isAttached(Appender appender){ return attachedAppenders.contains(appender); }", "public boolean isAttached(Appender appender){ return attachedAppenders.contains(appender); }", "public boolean isAttached(Appender appender){ return appenders.contains(appender); }", "public boolean isAttached(Appender appender){ return attachedAppenders.contains(appender); }", "public boolean isAttached(Appender appender){ return attachedAppenders.contains(appender); }", "public boolean isAttached(Appender appender){ return attachedAppenders.contains(appender); }", "public boolean isAttached(Appender appender){ return attachedAppenders.contains(appender); }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018238", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  return toBoolean(value, Boolean.toString(dEfault));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) return dEfault;\n  if (value.equalsIgnoreCase(\"true\")) return true;\n  if (value.equalsIgnoreCase(\"false\")) return false;\n  return dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) return dEfault;\n  value = value.trim();\n  if (\"true\".equalsIgnoreCase(value)) return true;\n  if (\"false\".equalsIgnoreCase(value)) return false;\n  return dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) {\n    return dEfault;\n  }\n  value = value.trim();\n  if (value.equals(\"true\")) {\n    return true;\n  }\n  if (value.equals(\"false\")) {\n    return false;\n  }\n  return dEfault;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  return toBoolean(value, String.valueOf(dEfault));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  return (dEfault ? Boolean.valueOf(value) : Boolean.parseBoolean(value));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) return dEfault;\n  if (\"true\".equalsIgnoreCase(value)) return true;\n  if (\"false\".equalsIgnoreCase(value)) return false;\n  return dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (StringUtils.isBlank(value)) {\n    return dEfault;\n  }\n  if (value.equalsIgnoreCase(\"true\")) {\n    return true;\n  }\n  if (value.equalsIgnoreCase(\"false\")) {\n    return false;\n  }\n  return dEfault;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) return dEfault;\n  if (value.equalsIgnoreCase(\"true\")) return true;\n  if (value.equalsIgnoreCase(\"false\")) return false;\n  return dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  return value != null && value.equalsIgnoreCase(\"true\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * If <code>value</code> is \"true\", then <code>true</code> is returned. If <code>value</code> is \"false\", then <code>true</code> is returned. Otherwise, <code>default</code> is returned. <p>Case of value is unimportant.  \n */\n", "method_name": "toBoolean", "codes": ["public static boolean toBoolean(String value,boolean dEfault){ return toBoolean(value, Boolean.toString(dEfault)); }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) return dEfault; if (value.equalsIgnoreCase(\"true\")) return true; if (value.equalsIgnoreCase(\"false\")) return false; return dEfault; }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) return dEfault; value = value.trim(); if (\"true\".equalsIgnoreCase(value)) return true; if (\"false\".equalsIgnoreCase(value)) return false; return dEfault; }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) { return dEfault; } value = value.trim(); if (value.equals(\"true\")) { return true; } if (value.equals(\"false\")) { return false; } return dEfault; }", "public static boolean toBoolean(String value,boolean dEfault){ return toBoolean(value, String.valueOf(dEfault)); }", "public static boolean toBoolean(String value,boolean dEfault){ return (dEfault ? Boolean.valueOf(value) : Boolean.parseBoolean(value)); }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) return dEfault; if (\"true\".equalsIgnoreCase(value)) return true; if (\"false\".equalsIgnoreCase(value)) return false; return dEfault; }", "public static boolean toBoolean(String value,boolean dEfault){ if (StringUtils.isBlank(value)) { return dEfault; } if (value.equalsIgnoreCase(\"true\")) { return true; } if (value.equalsIgnoreCase(\"false\")) { return false; } return dEfault; }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) return dEfault; if (value.equalsIgnoreCase(\"true\")) return true; if (value.equalsIgnoreCase(\"false\")) return false; return dEfault; }", "public static boolean toBoolean(String value,boolean dEfault){ return value != null && value.equalsIgnoreCase(\"true\"); }"], "code_level": "self_contained", "_id": "6367677d1a6d9265ec0182fd", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void add(LoggingEvent event) {\n  if (events.size() >= capacity) {\n    events.remove(0);\n  }\n  events.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  if (lastEvent == null) {\n    lastEvent = event;\n  } else {\n    if (lastEvent.getLevel().intValue() > event.getLevel().intValue()) {\n      lastEvent = event;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  synchronized (this) {\n    if (events.size() >= maxEvents) {\n      events.remove(0);\n    }\n    events.add(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  events.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  events.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  events.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  this.events.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  synchronized (events) {\n    events.add(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  if (events.size() == 0) {\n    logger.addAppender(appender);\n  }\n  events.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  buffer.addLast(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add an <code>event</code> as the last event in the buffer.\n */\n", "method_name": "add", "codes": ["public void add(LoggingEvent event){ if (events.size() >= capacity) { events.remove(0); } events.add(event); }", "public void add(LoggingEvent event){ if (lastEvent == null) { lastEvent = event; } else { if (lastEvent.getLevel().intValue() > event.getLevel().intValue()) { lastEvent = event; } } }", "public void add(LoggingEvent event){ synchronized (this) { if (events.size() >= maxEvents) { events.remove(0); } events.add(event); } }", "public void add(LoggingEvent event){ events.add(event); }", "public void add(LoggingEvent event){ events.add(event); }", "public void add(LoggingEvent event){ events.add(event); }", "public void add(LoggingEvent event){ this.events.add(event); }", "public void add(LoggingEvent event){ synchronized (events) { events.add(event); } }", "public void add(LoggingEvent event){ if (events.size() == 0) { logger.addAppender(appender); } events.add(event); }", "public void add(LoggingEvent event){ buffer.addLast(event); }"], "code_level": "class_runnable", "_id": "636767841a6d9265ec0183e8", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void removeAppender(String name) {\n  if (name != null) {\n    if (!appenders.contains(name)) {\n      return;\n    }\n    if (!context.getAppenders().contains(name)) {\n      return;\n    }\n    Appender appender = context.getAppenders().get(name);\n    if (appender instanceof LifeCycle) {\n      ((LifeCycle) appender).stop();\n    }\n    if (appender instanceof Lifecycle) {\n      ((Lifecycle) appender).destroy();\n    }\n    appenders.remove(name);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    appenders.remove(name);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    appenders.remove(name);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  this.appenders.remove(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  if (appenders.containsKey(name)) {\n    appenders.remove(name);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    appenders.remove(name);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    Iterator<Appender> it = appenders.iterator();\n    while (it.hasNext()) {\n      Appender appender = it.next();\n      if (appender.getName().equals(name)) {\n        it.remove();\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  appenders.remove(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  if (name != null) {\n    LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();\n    for (Logger logger : context.getLoggerList()) {\n      if (logger.getName().equals(name)) {\n        context.getLoggerList().remove(logger);\n        break;\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    for (int i = 0; i < appenders.size(); i++) {\n      Appender appender = appenders.get(i);\n      if (name.equals(appender.getName())) {\n        appenders.remove(i);\n        if (appender instanceof LifeCycle) {\n          ((LifeCycle) appender).stop();\n        }\n        return;\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Remove the appender with the name passed as parameter form the list of appenders.  \n */\n", "method_name": "removeAppender", "codes": ["public void removeAppender(String name){ if (name != null) { if (!appenders.contains(name)) { return; } if (!context.getAppenders().contains(name)) { return; } Appender appender = context.getAppenders().get(name); if (appender instanceof LifeCycle) { ((LifeCycle) appender).stop(); } if (appender instanceof Lifecycle) { ((Lifecycle) appender).destroy(); } appenders.remove(name); } }", "public void removeAppender(String name){ synchronized (appenders) { appenders.remove(name); } }", "public void removeAppender(String name){ synchronized (appenders) { appenders.remove(name); } }", "public void removeAppender(String name){ this.appenders.remove(name); }", "public void removeAppender(String name){ if (appenders.containsKey(name)) { appenders.remove(name); } }", "public void removeAppender(String name){ synchronized (appenders) { appenders.remove(name); } }", "public void removeAppender(String name){ synchronized (appenders) { Iterator<Appender> it = appenders.iterator(); while (it.hasNext()) { Appender appender = it.next(); if (appender.getName().equals(name)) { it.remove(); } } } }", "public void removeAppender(String name){ appenders.remove(name); }", "public void removeAppender(String name){ if (name != null) { LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory(); for (Logger logger : context.getLoggerList()) { if (logger.getName().equals(name)) { context.getLoggerList().remove(logger); break; } } } }", "public void removeAppender(String name){ synchronized (appenders) { for (int i = 0; i < appenders.size(); i++) { Appender appender = appenders.get(i); if (name.equals(appender.getName())) { appenders.remove(i); if (appender instanceof LifeCycle) { ((LifeCycle) appender).stop(); } return; } } } }"], "code_level": "project_runnable", "_id": "636767861a6d9265ec01844c", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int count = 0;\n  for (Iterator it = getAppenders().iterator(); it.hasNext(); ) {\n    ((Appender) it.next()).doAppend(event);\n    count++;\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int count = 0;\n  for (Appender appender : appenders) {\n    count += appender.doAppend(event);\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  if (event == null) {\n    throw new IllegalArgumentException(\"Event cannot be null\");\n  }\n  if (!event.getRenderedMessage().startsWith(this.prefix)) {\n    return -1;\n  }\n  int numAppenders = 0;\n  for (Iterator it = this.appenders.iterator(); it.hasNext(); ) {\n    Appender appender = (Appender) it.next();\n    if (appender.isStarted() && appender.isEnabled()) {\n      numAppenders++;\n      try {\n        appender.doAppend(event);\n      } catch (Throwable t) {\n        logger.error(\"Error logging event \" + event, t);\n      }\n    }\n  }\n  return numAppenders;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int result = 0;\n  for (Appender appender : appenders) {\n    if (appender.isEnabled()) {\n      result += appender.doAppend(event);\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int size = appenders.size();\n  for (int i = 0; i < size; i++) {\n    appenders.get(i).doAppend(event);\n  }\n  return size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int count = 0;\n  for (Iterator<Appender> it = this.appenders.iterator(); it.hasNext(); ) {\n    Appender appender = it.next();\n    try {\n      appender.doAppend(event);\n      count++;\n    } catch (Exception e) {\n      logger.error(\n          \"Appender [\" + appender.getName() + \"] failed to append event to the log file\", e);\n    }\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int count = 0;\n  for (Iterator iter = appenders.iterator(); iter.hasNext(); ) {\n    count++;\n    Appender appender = (Appender) iter.next();\n    try {\n      appender.doAppend(event);\n    } catch (Throwable t) {\n      if (!isIgnoreThrowable(t)) {\n        t.printStackTrace(System.err);\n      }\n    }\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int size = 0;\n  for (Appender appender : getAllAppenders()) {\n    size += appender.doAppend(event);\n  }\n  return size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  for (Appender appender : appenders) {\n    appender.doAppend(event);\n  }\n  return appenders.size();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int count = 0;\n  for (Iterator iter = getAppenders().iterator(); iter.hasNext(); ) {\n    Appender appender = (Appender) iter.next();\n    if (appender.isStarted()) {\n      count++;\n      appender.doAppend(event);\n    }\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Call the <code>doAppend</code> method on all attached appenders.  \n */\n", "method_name": "appendLoopOnAppenders", "codes": ["public int appendLoopOnAppenders(LoggingEvent event){ int count = 0; for (Iterator it = getAppenders().iterator(); it.hasNext(); ) { ((Appender) it.next()).doAppend(event); count++; } return count; }", "public int appendLoopOnAppenders(LoggingEvent event){ int count = 0; for (Appender appender : appenders) { count += appender.doAppend(event); } return count; }", "public int appendLoopOnAppenders(LoggingEvent event){ if (event == null) { throw new IllegalArgumentException(\"Event cannot be null\"); } if (!event.getRenderedMessage().startsWith(this.prefix)) { return -1; } int numAppenders = 0; for (Iterator it = this.appenders.iterator(); it.hasNext(); ) { Appender appender = (Appender) it.next(); if (appender.isStarted() && appender.isEnabled()) { numAppenders++; try { appender.doAppend(event); } catch (Throwable t) { logger.error(\"Error logging event \" + event, t); } } } return numAppenders; }", "public int appendLoopOnAppenders(LoggingEvent event){ int result = 0; for (Appender appender : appenders) { if (appender.isEnabled()) { result += appender.doAppend(event); } } return result; }", "public int appendLoopOnAppenders(LoggingEvent event){ int size = appenders.size(); for (int i = 0; i < size; i++) { appenders.get(i).doAppend(event); } return size; }", "public int appendLoopOnAppenders(LoggingEvent event){ int count = 0; for (Iterator<Appender> it = this.appenders.iterator(); it.hasNext(); ) { Appender appender = it.next(); try { appender.doAppend(event); count++; } catch (Exception e) { logger.error(\"Appender [\" + appender.getName() + \"] failed to append event to the log file\", e); } } return count; }", "public int appendLoopOnAppenders(LoggingEvent event){ int count = 0; for (Iterator iter = appenders.iterator(); iter.hasNext(); ) { count++; Appender appender = (Appender) iter.next(); try { appender.doAppend(event); } catch (Throwable t) { if (!isIgnoreThrowable(t)) { t.printStackTrace(System.err); } } } return count; }", "public int appendLoopOnAppenders(LoggingEvent event){ int size = 0; for (Appender appender : getAllAppenders()) { size += appender.doAppend(event); } return size; }", "public int appendLoopOnAppenders(LoggingEvent event){ for (Appender appender : appenders) { appender.doAppend(event); } return appenders.size(); }", "public int appendLoopOnAppenders(LoggingEvent event){ int count = 0; for (Iterator iter = getAppenders().iterator(); iter.hasNext(); ) { Appender appender = (Appender) iter.next(); if (appender.isStarted()) { count++; appender.doAppend(event); } } return count; }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018242", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public boolean hasThrown() {\n  return thrown != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown.size() > 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return getThrown() != null && !getThrown().toString().isEmpty();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasThrown() {\n  return (thrown != null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown != null && thrown.length() > 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown != null && !thrown.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return getThrown().toString().isEmpty();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown != null && thrown.length > 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return true if getThrown().toString() is a non-empty string.\n */\n", "method_name": "hasThrown", "codes": ["public boolean hasThrown(){ return thrown != null; }", "public boolean hasThrown(){ return thrown.size() > 0; }", "public boolean hasThrown(){ return thrown != null; }", "public boolean hasThrown(){ return getThrown() != null && !getThrown().toString().isEmpty(); }", "public boolean hasThrown(){ return (thrown != null); }", "public boolean hasThrown(){ return thrown != null; }", "public boolean hasThrown(){ return thrown != null && thrown.length() > 0; }", "public boolean hasThrown(){ return thrown != null && !thrown.isEmpty(); }", "public boolean hasThrown(){ return getThrown().toString().isEmpty(); }", "public boolean hasThrown(){ return thrown != null && thrown.length > 0; }"], "code_level": "class_runnable", "_id": "636767821a6d9265ec0183ab", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  if (getSelectedNodes().length > 0) {\n    if (getSelectedNodes().length > 1) {\n      if (!(getSelectedNodes()[0].getObject() instanceof CategoryNode)) {\n        if (!(getSelectedNodes()[1].getObject() instanceof CategoryNode)) {\n          if (!(getSelectedNodes()[2].getObject() instanceof CategoryNode)) {\n            if (!(getSelectedNodes()[3].getObject() instanceof CategoryNode)) {\n              removed++;\n            }\n          }\n        }\n      }\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removedNodes = 0;\n  if (root == null) return removedNodes;\n  for (int i = 0; i < root.children.size(); i++) {\n    if (root.children.get(i).isVisible()) {\n      if (root.children.get(i).children.size() == 0) {\n        root.children.remove(i);\n        removedNodes++;\n      }\n    }\n  }\n  return removedNodes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  for (Category cat : getCategories()) {\n    if (cat.getChildCount() == 0) {\n      remove(cat);\n      removed++;\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  for (CategoryNode node : categoryTree.getChildren()) {\n    if (!node.isInactive()) {\n      removed++;\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  TreeModel treeModel = (TreeModel) getModel();\n  int numChildren = treeModel.getChildCount(getRoot());\n  for (int i = 0; i < numChildren; i++) {\n    TreeNode node = (TreeNode) treeModel.getChild(getRoot(), i);\n    if (!node.isLeaf()) {\n      removeInactiveNode(node);\n    }\n  }\n  return numChildren;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  Iterator<Node> it = m_tree.iterator();\n  while (it.hasNext()) {\n    Node n = it.next();\n    if (!n.isInactive()) {\n      it.remove();\n      removed++;\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int n = 0;\n  for (Node node : nodes) {\n    if (!node.isVisible()) continue;\n    if (node.isInactive()) {\n      node.remove();\n      n++;\n    }\n  }\n  return n;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  if (!rootNode.getChildren().isEmpty()) {\n    for (CategoryNode node : rootNode.getChildren()) {\n      if (!node.getChildren().isEmpty()) {\n        removed++;\n      }\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int numNodes = 0;\n  for (Iterator iter = this.getRootNodes().iterator(); iter.hasNext(); ) {\n    CategoryNode node = (CategoryNode) iter.next();\n    if (node.getChildCount() == 0) {\n      this.removeNodeFromParent(node);\n      numNodes++;\n    }\n  }\n  return numNodes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  for (int i = 0; i < this.getRowCount(); i++) {\n    if (!this.isLeaf(i)) {\n      if (this.getChildCount(i) == 0) {\n        this.removeNodeFromParent(i);\n        removed++;\n      }\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes any inactive nodes from the Category tree.\n */\n", "method_name": "removeUnusedNodes", "codes": ["protected int removeUnusedNodes(){ int removed = 0; if (getSelectedNodes().length > 0) { if (getSelectedNodes().length > 1) { if (!(getSelectedNodes()[0].getObject() instanceof CategoryNode)) { if (!(getSelectedNodes()[1].getObject() instanceof CategoryNode)) { if (!(getSelectedNodes()[2].getObject() instanceof CategoryNode)) { if (!(getSelectedNodes()[3].getObject() instanceof CategoryNode)) { removed++; } } } } } } return removed; }", "protected int removeUnusedNodes(){ int removedNodes = 0; if (root == null) return removedNodes; for (int i = 0; i < root.children.size(); i++) { if (root.children.get(i).isVisible()) { if (root.children.get(i).children.size() == 0) { root.children.remove(i); removedNodes++; } } } return removedNodes; }", "protected int removeUnusedNodes(){ int removed = 0; for (Category cat : getCategories()) { if (cat.getChildCount() == 0) { remove(cat); removed++; } } return removed; }", "protected int removeUnusedNodes(){ int removed = 0; for (CategoryNode node : categoryTree.getChildren()) { if (!node.isInactive()) { removed++; } } return removed; }", "protected int removeUnusedNodes(){ TreeModel treeModel = (TreeModel) getModel(); int numChildren = treeModel.getChildCount(getRoot()); for (int i = 0; i < numChildren; i++) { TreeNode node = (TreeNode) treeModel.getChild(getRoot(), i); if (!node.isLeaf()) { removeInactiveNode(node); } } return numChildren; }", "protected int removeUnusedNodes(){ int removed = 0; Iterator<Node> it = m_tree.iterator(); while (it.hasNext()) { Node n = it.next(); if (!n.isInactive()) { it.remove(); removed++; } } return removed; }", "protected int removeUnusedNodes(){ int n = 0; for (Node node : nodes) { if (!node.isVisible()) continue; if (node.isInactive()) { node.remove(); n++; } } return n; }", "protected int removeUnusedNodes(){ int removed = 0; if (!rootNode.getChildren().isEmpty()) { for (CategoryNode node : rootNode.getChildren()) { if (!node.getChildren().isEmpty()) { removed++; } } } return removed; }", "protected int removeUnusedNodes(){ int numNodes = 0; for (Iterator iter = this.getRootNodes().iterator(); iter.hasNext(); ) { CategoryNode node = (CategoryNode) iter.next(); if (node.getChildCount() == 0) { this.removeNodeFromParent(node); numNodes++; } } return numNodes; }", "protected int removeUnusedNodes(){ int removed = 0; for (int i = 0; i < this.getRowCount(); i++) { if (!this.isLeaf(i)) { if (this.getChildCount(i) == 0) { this.removeNodeFromParent(i); removed++; } } } return removed; }"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec018314", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  return compare((Match) aObj1, (Match) aObj2);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  if (aObj1 == null || aObj2 == null) {\n    return 0;\n  } else {\n    if (aObj1 instanceof Object[]) {\n      if (aObj2 instanceof Object[]) {\n        return Arrays.compare((Object[]) aObj1, (Object[]) aObj2);\n      } else {\n        return -1;\n      }\n    } else if (aObj1 instanceof int[]) {\n      if (aObj2 instanceof int[]) {\n        return Arrays.compare((int[]) aObj1, (int[]) aObj2);\n      } else {\n        return -1;\n      }\n    } else if (aObj1 instanceof long[]) {\n      if (aObj2 instanceof long[]) {\n        return Arrays.compare((long[]) aObj1, (long[]) aObj2);\n      } else {\n        return -1;\n      }\n    } else if (aObj1 instanceof float[]) {\n      if (aObj2 instanceof float[]) {\n        return Arrays.compare((float[]) aObj1, (float[]) aObj2);\n      } else {\n        return -1;\n      }\n    } else if (aObj1 instanceof double[]) {\n      if (aObj2 instanceof double[]) {\n        return Arrays.compare((double[]) aObj1, (double[]) aObj2);\n      } else {\n        return -1;\n      }\n    } else if (aObj1 instanceof boolean[]) {\n      if (aObj2 instanceof boolean[]) {\n        return Arrays.compare((boolean[]) aObj1, (boolean[]) aObj2);\n      } else {\n        return -1;\n      }\n    } else if (aObj1 instanceof short[]) {\n      if (aObj2 instanceof short[]) {\n        return Arrays.compare((short[]) aObj1, (short[]) aObj2);\n      } else {\n        return -1;\n      }\n    } else {\n      return 0;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  if (aObj1 == null || aObj2 == null) {\n    return -1;\n  }\n  if (!(aObj1 instanceof Object[])) {\n    return -1;\n  }\n  if (!(aObj2 instanceof Object[])) {\n    return 1;\n  }\n  Object[] obj1 = (Object[]) aObj1;\n  Object[] obj2 = (Object[]) aObj2;\n  if (obj1.length < obj2.length) {\n    return -1;\n  }\n  if (obj1.length > obj2.length) {\n    return 1;\n  }\n  for (int i = 0; i < obj1.length; i++) {\n    if (!(obj1[i] instanceof Comparable)) {\n      return -1;\n    }\n    if (!(obj2[i] instanceof Comparable)) {\n      return 1;\n    }\n    if (((Comparable) obj1[i]).compareTo(obj2[i]) != 0) {\n      return ((Comparable) obj1[i]).compareTo(obj2[i]);\n    }\n  }\n  return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  if (aObj1 instanceof NamedNode) {\n    return ((NamedNode) aObj1).getName().compareToIgnoreCase(((NamedNode) aObj2).getName());\n  }\n  return -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  if (aObj1 == null || aObj2 == null) {\n    return 0;\n  }\n  if (aObj1 instanceof Item) {\n    Item item1 = (Item) aObj1;\n    if (item1.isSelected()) {\n      return -1;\n    }\n  }\n  if (aObj2 instanceof Item) {\n    Item item2 = (Item) aObj2;\n    if (item2.isSelected()) {\n      return 1;\n    }\n  }\n  if (aObj1 instanceof Category) {\n    Category category1 = (Category) aObj1;\n    if (category1.isSelected()) {\n      return -1;\n    }\n  }\n  if (aObj2 instanceof Category) {\n    Category category2 = (Category) aObj2;\n    if (category2.isSelected()) {\n      return 1;\n    }\n  }\n  return 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1,Object aObj2){ if (aObj1 instanceof Object[]) { Object[] objArr1 = (Object[]) aObj1; Object[] objArr2 = (Object[]) aObj2; int length1 = objArr1.length; int length2 = objArr2.length; if (length1 != length2) return length1 - length2; for (int i = 0; i < length1; i++) { Object obj1 = objArr1[i]; Object obj2 = objArr2[i]; if (obj1 == null) { if (obj2 != null) return -1; } else if (obj2 == null) return 1; else { int compare = ((Comparable) obj1).compareTo(obj2); if (compare != 0) return compare; } } return 0; } else if (aObj1 instanceof Object[][]) { Object[][] objArr1 = (Object[][]) aObj1; Object[][] objArr2 = (Object[][]) aObj2; int length1 = objArr1.length; int length2 = objArr2.length; if (length1 != length2) return length1 - length2; for (int i = 0; i < length1; i++) { Object[] obj1 = objArr1[i]; Object[] obj2 = objArr2[i]; int compare = ((Comparable) obj1).compareTo(obj2); if (compare != 0) return compare; } return 0; } else if (aObj1 instanceof int[]) { int[] objArr1 = (int[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof byte[]) { byte[] objArr1 = (byte[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof char[]) { char[] objArr1 = (char[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof short[]) { short[] objArr1 = (short[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof long[]) { long[] objArr1 = (long[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof float[]) { float[] objArr1 = (float[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof double[]) { double[] objArr1 = (double[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  if (aObj1 == null || aObj2 == null) return 0;\n  if (aObj1 instanceof String) {\n    String str1 = (String) aObj1;\n    String str2 = (String) aObj2;\n    return str1.compareTo(str2);\n  } else if (aObj1 instanceof Number) {\n    Number num1 = (Number) aObj1;\n    Number num2 = (Number) aObj2;\n    return num1.doubleValue() - num2.doubleValue();\n  } else if (aObj1 instanceof Date) {\n    Date d1 = (Date) aObj1;\n    Date d2 = (Date) aObj2;\n    return d1.compareTo(d2);\n  } else if (aObj1 instanceof Boolean) {\n    Boolean b1 = (Boolean) aObj1;\n    Boolean b2 = (Boolean) aObj2;\n    return b1.compareTo(b2);\n  } else if (aObj1 instanceof Object[]) {\n    Object[] obj1 = (Object[]) aObj1;\n    Object[] obj2 = (Object[]) aObj2;\n    return compareArrays(obj1, obj2);\n  } else if (aObj1 instanceof Map) {\n    Map map1 = (Map) aObj1;\n    Map map2 = (Map) aObj2;\n    return compareMaps(map1, map2);\n  }\n  return 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  if (aObj1 == null || aObj2 == null) {\n    return 0;\n  }\n  String s1 = aObj1.toString();\n  String s2 = aObj2.toString();\n  if (s1 == null || s2 == null) {\n    return 0;\n  }\n  if (s1.equals(s2)) {\n    return 0;\n  } else {\n    return s1.compareTo(s2);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  if (aObj1 == aObj2) {\n    return 0;\n  }\n  if (aObj1 == null) {\n    return -1;\n  }\n  if (aObj2 == null) {\n    return 1;\n  }\n  if (aObj1 instanceof Hashtable) {\n    Hashtable ht1 = (Hashtable) aObj1;\n    Hashtable ht2 = (Hashtable) aObj2;\n    Enumeration e1 = ht1.keys();\n    Enumeration e2 = ht2.keys();\n    while (e1.hasMoreElements()) {\n      String key = (String) e1.nextElement();\n      Object value1 = ht1.get(key);\n      Object value2 = ht2.get(key);\n      int result = value1.toString().compareTo(value2.toString());\n      if (result != 0) {\n        return result;\n      }\n    }\n    return 0;\n  }\n  return -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @see Comparator \n */\n", "method_name": "compare", "codes": ["public int compare(Object aObj1,Object aObj2){ return compare((Match) aObj1, (Match) aObj2); }", "public int compare(Object aObj1,Object aObj2){ if (aObj1 == null || aObj2 == null) { return 0; } else { if (aObj1 instanceof Object[]) { if (aObj2 instanceof Object[]) { return Arrays.compare((Object[]) aObj1, (Object[]) aObj2); } else { return -1; } } else if (aObj1 instanceof int[]) { if (aObj2 instanceof int[]) { return Arrays.compare((int[]) aObj1, (int[]) aObj2); } else { return -1; } } else if (aObj1 instanceof long[]) { if (aObj2 instanceof long[]) { return Arrays.compare((long[]) aObj1, (long[]) aObj2); } else { return -1; } } else if (aObj1 instanceof float[]) { if (aObj2 instanceof float[]) { return Arrays.compare((float[]) aObj1, (float[]) aObj2); } else { return -1; } } else if (aObj1 instanceof double[]) { if (aObj2 instanceof double[]) { return Arrays.compare((double[]) aObj1, (double[]) aObj2); } else { return -1; } } else if (aObj1 instanceof boolean[]) { if (aObj2 instanceof boolean[]) { return Arrays.compare((boolean[]) aObj1, (boolean[]) aObj2); } else { return -1; } } else if (aObj1 instanceof short[]) { if (aObj2 instanceof short[]) { return Arrays.compare((short[]) aObj1, (short[]) aObj2); } else { return -1; } } else { return 0; } } }", "public int compare(Object aObj1,Object aObj2){ if (aObj1 == null || aObj2 == null) { return -1; } if (!(aObj1 instanceof Object[])) { return -1; } if (!(aObj2 instanceof Object[])) { return 1; } Object[] obj1 = (Object[]) aObj1; Object[] obj2 = (Object[]) aObj2; if (obj1.length < obj2.length) { return -1; } if (obj1.length > obj2.length) { return 1; } for (int i = 0; i < obj1.length; i++) { if (!(obj1[i] instanceof Comparable)) { return -1; } if (!(obj2[i] instanceof Comparable)) { return 1; } if (((Comparable) obj1[i]).compareTo(obj2[i]) != 0) { return ((Comparable) obj1[i]).compareTo(obj2[i]); } } return 0; }", "public int compare(Object aObj1,Object aObj2){ if (aObj1 instanceof NamedNode) { return ((NamedNode) aObj1).getName().compareToIgnoreCase(((NamedNode) aObj2).getName()); } return -1; }", "public int compare(Object aObj1,Object aObj2){ if (aObj1 == null || aObj2 == null) { return 0; } if (aObj1 instanceof Item) { Item item1 = (Item) aObj1; if (item1.isSelected()) { return -1; } } if (aObj2 instanceof Item) { Item item2 = (Item) aObj2; if (item2.isSelected()) { return 1; } } if (aObj1 instanceof Category) { Category category1 = (Category) aObj1; if (category1.isSelected()) { return -1; } } if (aObj2 instanceof Category) { Category category2 = (Category) aObj2; if (category2.isSelected()) { return 1; } } return 0; }", "public int compare(Object aObj1,Object aObj2){ if (aObj1 instanceof Object[]) { Object[] objArr1 = (Object[]) aObj1; Object[] objArr2 = (Object[]) aObj2; int length1 = objArr1.length; int length2 = objArr2.length; if (length1 != length2) return length1 - length2; for (int i = 0; i < length1; i++) { Object obj1 = objArr1[i]; Object obj2 = objArr2[i]; if (obj1 == null) { if (obj2 != null) return -1; } else if (obj2 == null) return 1; else { int compare = ((Comparable) obj1).compareTo(obj2); if (compare != 0) return compare; } } return 0; } else if (aObj1 instanceof Object[][]) { Object[][] objArr1 = (Object[][]) aObj1; Object[][] objArr2 = (Object[][]) aObj2; int length1 = objArr1.length; int length2 = objArr2.length; if (length1 != length2) return length1 - length2; for (int i = 0; i < length1; i++) { Object[] obj1 = objArr1[i]; Object[] obj2 = objArr2[i]; int compare = ((Comparable) obj1).compareTo(obj2); if (compare != 0) return compare; } return 0; } else if (aObj1 instanceof int[]) { int[] objArr1 = (int[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof byte[]) { byte[] objArr1 = (byte[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof char[]) { char[] objArr1 = (char[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof short[]) { short[] objArr1 = (short[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof long[]) { long[] objArr1 = (long[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof float[]) { float[] objArr1 = (float[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr1[0]; } else if (aObj1 instanceof double[]) { double[] objArr1 = (double[]) aObj1; int length1 = objArr1.length; if (length1 != 1) return length1 - 1; return objArr", "public int compare(Object aObj1,Object aObj2){ if (aObj1 == null || aObj2 == null) return 0; if (aObj1 instanceof String) { String str1 = (String) aObj1; String str2 = (String) aObj2; return str1.compareTo(str2); } else if (aObj1 instanceof Number) { Number num1 = (Number) aObj1; Number num2 = (Number) aObj2; return num1.doubleValue() - num2.doubleValue(); } else if (aObj1 instanceof Date) { Date d1 = (Date) aObj1; Date d2 = (Date) aObj2; return d1.compareTo(d2); } else if (aObj1 instanceof Boolean) { Boolean b1 = (Boolean) aObj1; Boolean b2 = (Boolean) aObj2; return b1.compareTo(b2); } else if (aObj1 instanceof Object[]) { Object[] obj1 = (Object[]) aObj1; Object[] obj2 = (Object[]) aObj2; return compareArrays(obj1, obj2); } else if (aObj1 instanceof Map) { Map map1 = (Map) aObj1; Map map2 = (Map) aObj2; return compareMaps(map1, map2); } return 0; }", "public int compare(Object aObj1,Object aObj2){ if (aObj1 == null || aObj2 == null) { return 0; } String s1 = aObj1.toString(); String s2 = aObj2.toString(); if (s1 == null || s2 == null) { return 0; } if (s1.equals(s2)) { return 0; } else { return s1.compareTo(s2); } }", "public int compare(Object aObj1,Object aObj2){ return 0; }", "public int compare(Object aObj1,Object aObj2){ if (aObj1 == aObj2) { return 0; } if (aObj1 == null) { return -1; } if (aObj2 == null) { return 1; } if (aObj1 instanceof Hashtable) { Hashtable ht1 = (Hashtable) aObj1; Hashtable ht2 = (Hashtable) aObj2; Enumeration e1 = ht1.keys(); Enumeration e2 = ht2.keys(); while (e1.hasMoreElements()) { String key = (String) e1.nextElement(); Object value1 = ht1.get(key); Object value2 = ht2.get(key); int result = value1.toString().compareTo(value2.toString()); if (result != 0) { return result; } } return 0; } return -1; }"], "code_level": "project_runnable", "_id": "636767841a6d9265ec0183f2", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public int decide(LoggingEvent event) {\n  String msg = event.getMessage().toString();\n  return msg.indexOf(\"foo\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  if (null == mStringMatcher) {\n    return Filter.NEUTRAL;\n  }\n  return mStringMatcher.decide(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  if (this.matches(event.getMessage())) {\n    return Filter.NEUTRAL;\n  }\n  return Filter.ACCEPT;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  return Filter.NEUTRAL;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  return Filter.NEUTRAL;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  return Filter.NEUTRAL;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  return Filter.NEUTRAL;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  return Filter.NEUTRAL;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  return Filter.NEUTRAL;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  return Filter.NEUTRAL;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns  {@link Filter#NEUTRAL} is there is no string match.\n */\n", "method_name": "decide", "codes": ["public int decide(LoggingEvent event){ String msg = event.getMessage().toString(); return msg.indexOf(\"foo\"); }", "public int decide(LoggingEvent event){ if (null == mStringMatcher) { return Filter.NEUTRAL; } return mStringMatcher.decide(event); }", "public int decide(LoggingEvent event){ if (this.matches(event.getMessage())) { return Filter.NEUTRAL; } return Filter.ACCEPT; }", "public int decide(LoggingEvent event){ return Filter.NEUTRAL; }", "public int decide(LoggingEvent event){ return Filter.NEUTRAL; }", "public int decide(LoggingEvent event){ return Filter.NEUTRAL; }", "public int decide(LoggingEvent event){ return Filter.NEUTRAL; }", "public int decide(LoggingEvent event){ return Filter.NEUTRAL; }", "public int decide(LoggingEvent event){ return Filter.NEUTRAL; }", "public int decide(LoggingEvent event){ return Filter.NEUTRAL; }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018250", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  final int sz = name.length();\n  for (int i = nameStart; i < sz; i++) {\n    final char c = name.charAt(i);\n    if (c >= 'A' && c <= 'Z') {\n      buf.append('_');\n    }\n    buf.append(c);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  buf.append(name);\n  buf.append(' ');\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  buf.append(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  if (nameStart >= buf.length()) return;\n  if (this.isIdentifier()) {\n    final int n = nameStart;\n    buf.append(this.name);\n    if (n < buf.length()) {\n      buf.append('_');\n      buf.append(this.name.substring(n + 1));\n    }\n  } else {\n    if (this.isString()) {\n      final int n = nameStart;\n      buf.append(this.name);\n      if (n < buf.length()) {\n        buf.append('_');\n        buf.append(this.name.substring(n + 1));\n      }\n    } else if (this.isUnicodeCharacter()) {\n      final int n = nameStart;\n      buf.append(this.name);\n      if (n < buf.length()) {\n        buf.append('_');\n        buf.append(this.name.substring(n + 1));\n      }\n    } else if (this.isNumeric()) {\n      final int n = nameStart;\n      buf.append(this.name);\n      if (n < buf.length()) {\n        buf.append('_');\n        buf.append(this.name.substring(n + 1));\n      }\n    } else if (this.isKeyword()) {\n      final int n = nameStart;\n      buf.append(this.name);\n      if (n < buf.length()) {\n        buf.append('_');\n        buf.append(this.name.substring(n + 1));\n      }\n    } else {\n      throw new IllegalStateException(\"Unexpected nameStart: \" + nameStart);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  if (nameStart < 0) {\n    buf.append('-');\n  } else {\n    buf.append(name[nameStart]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  final int nameEnd = buf.length();\n  if (nameStart >= 0) {\n    final int nameEnd2 = nameEnd - 1;\n    if (nameEnd2 <= nameStart) {\n      buf.append(this.value);\n      return;\n    }\n    if (nameEnd2 < nameStart) {\n      buf.append(this.value);\n      return;\n    }\n    if (nameEnd < nameStart) {\n      buf.append(this.value);\n      return;\n    }\n    if (nameEnd > nameStart) {\n      buf.append(this.value);\n      return;\n    }\n  }\n  if (nameStart >= 0) {\n    final int nameEnd2 = nameEnd - 1;\n    if (nameEnd2 >= nameStart) {\n      buf.append(this.value);\n      return;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  buf.append(name, nameStart, nameEnd);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  buf.append(name, nameStart, nameLength);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  if (nameStart == 0) {\n    buf.append(\"<no name>\");\n    return;\n  }\n  final int nameEnd = buf.length();\n  final boolean first = (nameStart == 1);\n  buf.append(first ? \"\" : \" \");\n  if (nameEnd < nameStart) {\n    buf.append(\"<no name>\");\n  } else {\n    char firstChar = buf.charAt(nameStart - 1);\n    if (firstChar == '_') {\n      firstChar = ' ';\n    }\n    buf.setCharAt(nameStart - 1, Character.toUpperCase(firstChar));\n    buf.append(buf.substring(nameStart, nameEnd));\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  int i = nameStart;\n  while (i < buf.length()) {\n    char c = buf.charAt(i);\n    if (!Character.isLetterOrDigit(c)) {\n      break;\n    }\n    buf.setCharAt(i++, Character.toLowerCase(c));\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Abbreviate name.\n * @param buf buffer to append abbreviation.\n * @param nameStart start of name to abbreviate.\n */\n", "method_name": "abbreviate", "codes": ["public void abbreviate(final int nameStart,final StringBuffer buf){ final int sz = name.length(); for (int i = nameStart; i < sz; i++) { final char c = name.charAt(i); if (c >= 'A' && c <= 'Z') { buf.append('_'); } buf.append(c); } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ buf.append(name); buf.append(' '); }", "public void abbreviate(final int nameStart,final StringBuffer buf){ buf.append(name); }", "public void abbreviate(final int nameStart,final StringBuffer buf){ if (nameStart >= buf.length()) return; if (this.isIdentifier()) { final int n = nameStart; buf.append(this.name); if (n < buf.length()) { buf.append('_'); buf.append(this.name.substring(n + 1)); } } else { if (this.isString()) { final int n = nameStart; buf.append(this.name); if (n < buf.length()) { buf.append('_'); buf.append(this.name.substring(n + 1)); } } else if (this.isUnicodeCharacter()) { final int n = nameStart; buf.append(this.name); if (n < buf.length()) { buf.append('_'); buf.append(this.name.substring(n + 1)); } } else if (this.isNumeric()) { final int n = nameStart; buf.append(this.name); if (n < buf.length()) { buf.append('_'); buf.append(this.name.substring(n + 1)); } } else if (this.isKeyword()) { final int n = nameStart; buf.append(this.name); if (n < buf.length()) { buf.append('_'); buf.append(this.name.substring(n + 1)); } } else { throw new IllegalStateException(\"Unexpected nameStart: \" + nameStart); } } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ if (nameStart < 0) { buf.append('-'); } else { buf.append(name[nameStart]); } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ final int nameEnd = buf.length(); if (nameStart >= 0) { final int nameEnd2 = nameEnd - 1; if (nameEnd2 <= nameStart) { buf.append(this.value); return; } if (nameEnd2 < nameStart) { buf.append(this.value); return; } if (nameEnd < nameStart) { buf.append(this.value); return; } if (nameEnd > nameStart) { buf.append(this.value); return; } } if (nameStart >= 0) { final int nameEnd2 = nameEnd - 1; if (nameEnd2 >= nameStart) { buf.append(this.value); return; } } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ buf.append(name, nameStart, nameEnd); }", "public void abbreviate(final int nameStart,final StringBuffer buf){ buf.append(name, nameStart, nameLength); }", "public void abbreviate(final int nameStart,final StringBuffer buf){ if (nameStart == 0) { buf.append(\"<no name>\"); return; } final int nameEnd = buf.length(); final boolean first = (nameStart == 1); buf.append(first ? \"\" : \" \"); if (nameEnd < nameStart) { buf.append(\"<no name>\"); } else { char firstChar = buf.charAt(nameStart - 1); if (firstChar == '_') { firstChar = ' '; } buf.setCharAt(nameStart - 1, Character.toUpperCase(firstChar)); buf.append(buf.substring(nameStart, nameEnd)); } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ int i = nameStart; while (i < buf.length()) { char c = buf.charAt(i); if (!Character.isLetterOrDigit(c)) { break; } buf.setCharAt(i++, Character.toLowerCase(c)); } }"], "code_level": "class_runnable", "_id": "636767861a6d9265ec018440", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public String id(String entityId) {\n  return entityId == null ? null : entityId.replaceAll(\"\\\\.\\\\d+\", \"\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return entityId + \"-\" + id;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return entityId;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return entityId + \"_\" + id;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return id(entityId, \"\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return MessageFormat.format(\"{0}/{1}/{2}\", entityId, this.entityType, this.entityId);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return entityId;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return Objects.toString(entityId, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return entityId;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return entityId.substring(entityId.lastIndexOf(':') + 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * @return the row id\n */\n", "method_name": "id", "codes": ["public String id(String entityId){ return entityId == null ? null : entityId.replaceAll(\"\\\\.\\\\d+\", \"\"); }", "public String id(String entityId){ return entityId + \"-\" + id; }", "public String id(String entityId){ return entityId; }", "public String id(String entityId){ return entityId + \"_\" + id; }", "public String id(String entityId){ return id(entityId, \"\"); }", "public String id(String entityId){ return MessageFormat.format(\"{0}/{1}/{2}\", entityId, this.entityType, this.entityId); }", "public String id(String entityId){ return entityId; }", "public String id(String entityId){ return Objects.toString(entityId, null); }", "public String id(String entityId){ return entityId; }", "public String id(String entityId){ return entityId.substring(entityId.lastIndexOf(':') + 1); }"], "code_level": "project_runnable", "_id": "636767df1a6d9265ec01873c", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (!isInitialized) {\n    synchronized (this) {\n      if (!isInitialized) {\n        initialize();\n        isInitialized = true;\n      }\n    }\n  }\n  if (!isInitialized) {\n    synchronized (this) {\n      if (!isInitialized) {\n        initialize();\n        isInitialized = true;\n      }\n    }\n  }\n  cache.put(data.getMetricName(), data);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (data == null) {\n    return;\n  }\n  if (!cache.containsKey(data.getName())) {\n    cache.put(data.getName(), data);\n  } else {\n    final METRICS cachedData = cache.get(data.getName());\n    final int cachedValue = cachedData.getValue();\n    cachedData.setValue(data.getValue());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (isEmpty()) {\n    cache.put(data);\n  } else {\n    final METRICS cachedData = cache.getIfPresent(data);\n    if (cachedData == null) {\n      cache.put(data);\n    } else {\n      cachedData.merge(data);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  final long now = System.currentTimeMillis();\n  if (data.getTimestamp() <= now) {\n    if (data.getType() == METRICS.TYPE.HOURLY) {\n      if (!this.hourlyCache.containsKey(data.getId())) {\n        this.hourlyCache.put(data.getId(), data);\n        this.stats.add(data.getId());\n      } else {\n        final METRICS cachedData = this.hourlyCache.get(data.getId());\n        final METRICS mergedData = data.merge(cachedData);\n        this.hourlyCache.put(data.getId(), mergedData);\n        this.stats.add(data.getId());\n      }\n    } else if (data.getType() == METRICS.TYPE.DAILY) {\n      if (!this.dailyCache.containsKey(data.getId())) {\n        this.dailyCache.put(data.getId(), data);\n        this.stats.add(data.getId());\n      } else {\n        final METRICS cachedData = this.dailyCache.get(data.getId());\n        final METRICS mergedData = data.merge(cachedData);\n        this.dailyCache.put(data.getId(), mergedData);\n        this.stats.add(data.getId());\n      }\n    } else if (data.getType() == METRICS.TYPE.WEEKLY) {\n      if (!this.weeklyCache.containsKey(data.getId())) {\n        this.weeklyCache.put(data.getId(), data);\n        this.stats.add(data.getId());\n      } else {\n        final METRICS cachedData = this.weeklyCache.get(data.getId());\n        final METRICS mergedData = data.merge(cachedData);\n        this.weeklyCache.put(data.getId(), mergedData);\n        this.stats.add(data.getId());\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (!this.cache.containsKey(data)) {\n    this.cache.put(data, data);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (data == null) {\n    return;\n  }\n  final String key = getKey(data);\n  final CacheEntry cacheEntry = cache.get(key);\n  if (cacheEntry == null) {\n    cache.put(key, new CacheEntry(data));\n  } else {\n    if (!cacheEntry.equals(data)) {\n      if (cacheEntry.isExpired()) {\n        cache.remove(key);\n      } else {\n        cacheEntry.addData(data);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (data != null) {\n    cache.put(data.getKey(), data);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (data == null) {\n    return;\n  }\n  if (cache.putIfAbsent(data.getId(), data) != null) {\n    cache.put(data.getId(), data);\n  } else {\n    logger.debug(\"Cache already contains metric {}\", data.getId());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  this.cache.put(data.getKey(), data);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  final String key = getKey(data);\n  if (!cache.containsKey(key)) {\n    cache.put(key, data);\n  } else {\n    final METRICS existing = cache.get(key);\n    if (existing.getMetrics().getElapsedTime() > data.getMetrics().getElapsedTime()) {\n      cache.put(key, data);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.\n * @param data to be added potentially.\n */\n", "method_name": "accept", "codes": ["@Override public void accept(final METRICS data){ if (!isInitialized) { synchronized (this) { if (!isInitialized) { initialize(); isInitialized = true; } } } if (!isInitialized) { synchronized (this) { if (!isInitialized) { initialize(); isInitialized = true; } } } cache.put(data.getMetricName(), data); }", "@Override public void accept(final METRICS data){ if (data == null) { return; } if (!cache.containsKey(data.getName())) { cache.put(data.getName(), data); } else { final METRICS cachedData = cache.get(data.getName()); final int cachedValue = cachedData.getValue(); cachedData.setValue(data.getValue()); } }", "@Override public void accept(final METRICS data){ if (isEmpty()) { cache.put(data); } else { final METRICS cachedData = cache.getIfPresent(data); if (cachedData == null) { cache.put(data); } else { cachedData.merge(data); } } }", "@Override public void accept(final METRICS data){ final long now = System.currentTimeMillis(); if (data.getTimestamp() <= now) { if (data.getType() == METRICS.TYPE.HOURLY) { if (!this.hourlyCache.containsKey(data.getId())) { this.hourlyCache.put(data.getId(), data); this.stats.add(data.getId()); } else { final METRICS cachedData = this.hourlyCache.get(data.getId()); final METRICS mergedData = data.merge(cachedData); this.hourlyCache.put(data.getId(), mergedData); this.stats.add(data.getId()); } } else if (data.getType() == METRICS.TYPE.DAILY) { if (!this.dailyCache.containsKey(data.getId())) { this.dailyCache.put(data.getId(), data); this.stats.add(data.getId()); } else { final METRICS cachedData = this.dailyCache.get(data.getId()); final METRICS mergedData = data.merge(cachedData); this.dailyCache.put(data.getId(), mergedData); this.stats.add(data.getId()); } } else if (data.getType() == METRICS.TYPE.WEEKLY) { if (!this.weeklyCache.containsKey(data.getId())) { this.weeklyCache.put(data.getId(), data); this.stats.add(data.getId()); } else { final METRICS cachedData = this.weeklyCache.get(data.getId()); final METRICS mergedData = data.merge(cachedData); this.weeklyCache.put(data.getId(), mergedData); this.stats.add(data.getId()); } } } }", "@Override public void accept(final METRICS data){ if (!this.cache.containsKey(data)) { this.cache.put(data, data); } }", "@Override public void accept(final METRICS data){ if (data == null) { return; } final String key = getKey(data); final CacheEntry cacheEntry = cache.get(key); if (cacheEntry == null) { cache.put(key, new CacheEntry(data)); } else { if (!cacheEntry.equals(data)) { if (cacheEntry.isExpired()) { cache.remove(key); } else { cacheEntry.addData(data); } } } }", "@Override public void accept(final METRICS data){ if (data != null) { cache.put(data.getKey(), data); } }", "@Override public void accept(final METRICS data){ if (data == null) { return; } if (cache.putIfAbsent(data.getId(), data) != null) { cache.put(data.getId(), data); } else { logger.debug(\"Cache already contains metric {}\", data.getId()); } }", "@Override public void accept(final METRICS data){ this.cache.put(data.getKey(), data); }", "@Override public void accept(final METRICS data){ final String key = getKey(data); if (!cache.containsKey(key)) { cache.put(key, data); } else { final METRICS existing = cache.get(key); if (existing.getMetrics().getElapsedTime() > data.getMetrics().getElapsedTime()) { cache.put(key, data); } } }"], "code_level": "self_contained", "_id": "636767e11a6d9265ec018781", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> ranges = new ArrayList<TimeRange>();\n  if (start <= end) {\n    ranges.add(new TimeRange(start, end));\n  } else {\n    long half = (start + end) / 2;\n    ranges.add(new TimeRange(start, half));\n    ranges.add(new TimeRange(half, end));\n  }\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<>();\n  if (start > end) {\n    timeRanges.add(new TimeRange(start, end));\n  } else {\n    timeRanges.add(new TimeRange(start, end));\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<>();\n  timeRanges.add(new TimeRange(start, end));\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  if (start >= end) {\n    return Collections.emptyList();\n  }\n  List<TimeRange> timeRanges = new ArrayList<>();\n  timeRanges.add(new TimeRange(start, end));\n  if (end > start) {\n    timeRanges.add(new TimeRange(end, start));\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<>();\n  if (start < end) {\n    timeRanges.add(new TimeRange(start, end));\n  } else {\n    timeRanges.add(new TimeRange(start, 0));\n    timeRanges.add(new TimeRange(0, end));\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<TimeRange>();\n  long timeStart = start;\n  long timeEnd = end;\n  while (timeStart <= timeEnd) {\n    timeRanges.add(new TimeRange(timeStart, timeEnd));\n    timeStart += FETCH_DATA_DURATION;\n    timeEnd += FETCH_DATA_DURATION;\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  if (start == end) {\n    return Collections.singletonList(TimeRange.fromStartEnd(start, end, false));\n  } else if (start < end) {\n    return Collections.singletonList(TimeRange.fromStartEnd(start, end, true));\n  } else {\n    return Collections.emptyList();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  long startTime = start;\n  long endTime = end;\n  if (startTime > endTime) {\n    endTime = startTime;\n    startTime = endTime;\n  }\n  List<TimeRange> timeRanges = new ArrayList<TimeRange>();\n  while (startTime <= endTime) {\n    long currentTime = startTime;\n    timeRanges.add(new TimeRange(currentTime, currentTime + FETCH_DATA_DURATION));\n    startTime = currentTime + FETCH_DATA_DURATION;\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<TimeRange>();\n  if (start >= end) {\n    timeRanges.add(new TimeRange(start, end));\n  } else {\n    long timeDelta = end - start;\n    long startTime = start;\n    long endTime = start + timeDelta;\n    timeRanges.add(new TimeRange(startTime, endTime));\n    while (startTime <= endTime) {\n      startTime += timeDelta;\n      endTime += timeDelta;\n      timeRanges.add(new TimeRange(startTime, endTime));\n    }\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<TimeRange>();\n  timeRanges.add(new TimeRange(start, end));\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}\n */\n", "method_name": "buildTimeRanges", "codes": ["protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> ranges = new ArrayList<TimeRange>(); if (start <= end) { ranges.add(new TimeRange(start, end)); } else { long half = (start + end) / 2; ranges.add(new TimeRange(start, half)); ranges.add(new TimeRange(half, end)); } return ranges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<>(); if (start > end) { timeRanges.add(new TimeRange(start, end)); } else { timeRanges.add(new TimeRange(start, end)); } return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<>(); timeRanges.add(new TimeRange(start, end)); return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ if (start >= end) { return Collections.emptyList(); } List<TimeRange> timeRanges = new ArrayList<>(); timeRanges.add(new TimeRange(start, end)); if (end > start) { timeRanges.add(new TimeRange(end, start)); } return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<>(); if (start < end) { timeRanges.add(new TimeRange(start, end)); } else { timeRanges.add(new TimeRange(start, 0)); timeRanges.add(new TimeRange(0, end)); } return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<TimeRange>(); long timeStart = start; long timeEnd = end; while (timeStart <= timeEnd) { timeRanges.add(new TimeRange(timeStart, timeEnd)); timeStart += FETCH_DATA_DURATION; timeEnd += FETCH_DATA_DURATION; } return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ if (start == end) { return Collections.singletonList(TimeRange.fromStartEnd(start, end, false)); } else if (start < end) { return Collections.singletonList(TimeRange.fromStartEnd(start, end, true)); } else { return Collections.emptyList(); } }", "protected List<TimeRange> buildTimeRanges(long start,long end){ long startTime = start; long endTime = end; if (startTime > endTime) { endTime = startTime; startTime = endTime; } List<TimeRange> timeRanges = new ArrayList<TimeRange>(); while (startTime <= endTime) { long currentTime = startTime; timeRanges.add(new TimeRange(currentTime, currentTime + FETCH_DATA_DURATION)); startTime = currentTime + FETCH_DATA_DURATION; } return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<TimeRange>(); if (start >= end) { timeRanges.add(new TimeRange(start, end)); } else { long timeDelta = end - start; long startTime = start; long endTime = start + timeDelta; timeRanges.add(new TimeRange(startTime, endTime)); while (startTime <= endTime) { startTime += timeDelta; endTime += timeDelta; timeRanges.add(new TimeRange(startTime, endTime)); } } return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<TimeRange>(); timeRanges.add(new TimeRange(start, end)); return timeRanges; }"], "code_level": "self_contained", "_id": "636767df1a6d9265ec018744", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value != null) {\n    if (!existingValues.containsKey(key)) {\n      existingValues.put(key, value);\n    } else {\n      Long existingValue = existingValues.get(key);\n      existingValues.put(key, existingValue + value);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value == null) {\n    remove(key);\n  } else {\n    put(key, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  map.put(key, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value != null) {\n    if (this.values == null) {\n      this.values = new LinkedHashMap<>();\n    }\n    this.values.put(key, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (values.containsKey(key)) {\n    values.put(key, values.get(key) + value);\n  } else {\n    values.put(key, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  valueAccumulation(key, Long.toString(value));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  valueAccumulation(key, value, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  this.valueAccumulation.put(key, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value == null) return;\n  if (!map.containsKey(key)) {\n    map.put(key, value);\n  } else {\n    Long oldValue = map.get(key);\n    map.put(key, oldValue + value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (!containsKey(key)) {\n    put(key, value);\n  } else {\n    put(key, get(key) + value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Accumulate the value with existing value in the same given key.\n */\n", "method_name": "valueAccumulation", "codes": ["public void valueAccumulation(String key,Long value){ if (value != null) { if (!existingValues.containsKey(key)) { existingValues.put(key, value); } else { Long existingValue = existingValues.get(key); existingValues.put(key, existingValue + value); } } }", "public void valueAccumulation(String key,Long value){ if (value == null) { remove(key); } else { put(key, value); } }", "public void valueAccumulation(String key,Long value){ map.put(key, value); }", "public void valueAccumulation(String key,Long value){ if (value != null) { if (this.values == null) { this.values = new LinkedHashMap<>(); } this.values.put(key, value); } }", "public void valueAccumulation(String key,Long value){ if (values.containsKey(key)) { values.put(key, values.get(key) + value); } else { values.put(key, value); } }", "public void valueAccumulation(String key,Long value){ valueAccumulation(key, Long.toString(value)); }", "public void valueAccumulation(String key,Long value){ valueAccumulation(key, value, null); }", "public void valueAccumulation(String key,Long value){ this.valueAccumulation.put(key, value); }", "public void valueAccumulation(String key,Long value){ if (value == null) return; if (!map.containsKey(key)) { map.put(key, value); } else { Long oldValue = map.get(key); map.put(key, oldValue + value); } }", "public void valueAccumulation(String key,Long value){ if (!containsKey(key)) { put(key, value); } else { put(key, get(key) + value); } }"], "code_level": "class_runnable", "_id": "636767de1a6d9265ec01871c", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  if (expiredThreshold <= 0) {\n    return false;\n  }\n  long now = System.currentTimeMillis();\n  if (now - lastUpdateTime < expiredThreshold) {\n    return false;\n  }\n  lastUpdateTime = now;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  if (timestamp < lastUpdateTime) {\n    return true;\n  }\n  long delta = timestamp - lastUpdateTime;\n  if (delta < expiredThreshold) {\n    return true;\n  }\n  lastUpdateTime = timestamp;\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  long currentTime = System.currentTimeMillis();\n  if (currentTime >= timestamp) {\n    return false;\n  }\n  long diff = currentTime - timestamp;\n  if (diff > expiredThreshold) {\n    return true;\n  }\n  return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  if (System.currentTimeMillis() < timestamp + expiredThreshold) {\n    return true;\n  }\n  return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  long now = System.currentTimeMillis();\n  return now - timestamp < expiredThreshold;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  if (this.lastUpdateTime < timestamp) {\n    return false;\n  }\n  if (this.lastUpdateTime > timestamp + expiredThreshold) {\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  return (System.currentTimeMillis() - timestamp) < expiredThreshold;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  return timestamp - this.lastUpdated > expiredThreshold;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  return (System.currentTimeMillis() - timestamp) < expiredThreshold;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  return timestamp - this.lastUpdateTime > expiredThreshold;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @param timestamp        of current time\n * @param expiredThreshold represents the duration between last update time and the time point removing from cache.\n * @return true means this metrics should be removed from cache.\n */\n", "method_name": "isExpired", "codes": ["public boolean isExpired(long timestamp,long expiredThreshold){ if (expiredThreshold <= 0) { return false; } long now = System.currentTimeMillis(); if (now - lastUpdateTime < expiredThreshold) { return false; } lastUpdateTime = now; return true; }", "public boolean isExpired(long timestamp,long expiredThreshold){ if (timestamp < lastUpdateTime) { return true; } long delta = timestamp - lastUpdateTime; if (delta < expiredThreshold) { return true; } lastUpdateTime = timestamp; return false; }", "public boolean isExpired(long timestamp,long expiredThreshold){ long currentTime = System.currentTimeMillis(); if (currentTime >= timestamp) { return false; } long diff = currentTime - timestamp; if (diff > expiredThreshold) { return true; } return false; }", "public boolean isExpired(long timestamp,long expiredThreshold){ if (System.currentTimeMillis() < timestamp + expiredThreshold) { return true; } return false; }", "public boolean isExpired(long timestamp,long expiredThreshold){ long now = System.currentTimeMillis(); return now - timestamp < expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ if (this.lastUpdateTime < timestamp) { return false; } if (this.lastUpdateTime > timestamp + expiredThreshold) { return true; } return false; }", "public boolean isExpired(long timestamp,long expiredThreshold){ return (System.currentTimeMillis() - timestamp) < expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ return timestamp - this.lastUpdated > expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ return (System.currentTimeMillis() - timestamp) < expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ return timestamp - this.lastUpdateTime > expiredThreshold; }"], "code_level": "class_runnable", "_id": "636767dd1a6d9265ec0186de", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  if (jsonObject.containsKey(\"ats\")) {\n    JsonObject ats = jsonObject.get(\"ats\").getAsJsonObject();\n    content.put(\"ats\", buildContent(ats));\n  }\n  if (jsonObject.containsKey(\"reply\")) {\n    JsonObject reply = jsonObject.get(\"reply\").getAsJsonObject();\n    content.put(\"reply\", buildContent(reply));\n  }\n  return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> result = new HashMap<>();\n  if (jsonObject.has(\"ats\")) {\n    result.put(\"ats\", jsonObject.get(\"ats\").getAsString());\n  }\n  if (jsonObject.has(\"ats_content\")) {\n    result.put(\"ats_content\", jsonObject.get(\"ats_content\").getAsString());\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  JsonArray jsonArray = jsonObject.getAsJsonArray(\"ats\");\n  for (JsonElement jsonElement : jsonArray) {\n    JsonObject atsJsonObject = jsonElement.getAsJsonObject();\n    String ats = atsJsonObject.get(\"ats\").getAsString();\n    if (!StringUtils.isEmpty(ats)) {\n      content.put(ats, atsJsonObject.get(\"value\").getAsString());\n    }\n  }\n  return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> map = new HashMap<>();\n  JsonArray ats = jsonObject.get(\"ats\").getAsJsonArray();\n  for (JsonElement e : ats) {\n    JsonObject obj = e.getAsJsonObject();\n    String k = obj.get(\"k\").getAsString();\n    String v = obj.get(\"v\").getAsString();\n    map.put(k, v);\n  }\n  return map;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> map = new HashMap<String, Object>();\n  if (jsonObject.has(\"ats\")) {\n    JsonArray ats = jsonObject.get(\"ats\").getAsJsonArray();\n    if (ats.size() > 0) {\n      JsonObject atsObj = ats.get(0).getAsJsonObject();\n      String atsId = atsObj.get(\"id\").getAsString();\n      String atsName = atsObj.get(\"name\").getAsString();\n      String atsKey = atsObj.get(\"key\").getAsString();\n      String atsSecret = atsObj.get(\"secret\").getAsString();\n      String atsToken = atsObj.get(\"token\").getAsString();\n      String atsCreateTime = atsObj.get(\"createTime\").getAsString();\n      String atsUpdateTime = atsObj.get(\"updateTime\").getAsString();\n      String atsLastLoginTime = atsObj.get(\"lastLoginTime\").getAsString();\n      String atsType = atsObj.get(\"type\").getAsString();\n      String atsSecretKey = atsObj.get(\"secretKey\").getAsString();\n      map.put(\"atsId\", atsId);\n      map.put(\"atsName\", atsName);\n      map.put(\"atsKey\", atsKey);\n      map.put(\"atsSecret\", atsSecret);\n      map.put(\"atsToken\", atsToken);\n      map.put(\"atsCreateTime\", atsCreateTime);\n      map.put(\"atsUpdateTime\", atsUpdateTime);\n      map.put(\"atsLastLoginTime\", atsLastLoginTime);\n      map.put(\"atsType\", atsType);\n      map.put(\"atsSecretKey\", atsSecretKey);\n    }\n  }\n  return map;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  JsonArray jsonArray = jsonObject.get(\"ats\").getAsJsonArray();\n  for (JsonElement jsonElement : jsonArray) {\n    JsonObject atsJsonObject = jsonElement.getAsJsonObject();\n    String ats = atsJsonObject.get(\"ats\").getAsString();\n    content.put(ats, atsJsonObject.get(\"content\").getAsString());\n  }\n  return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<String, Object>();\n  if (jsonObject.has(\"ats\")) {\n    JsonElement jsonElement = jsonObject.get(\"ats\");\n    if (jsonElement.isJsonArray()) {\n      JsonArray jsonArray = jsonElement.getAsJsonArray();\n      for (JsonElement element : jsonArray) {\n        JsonObject atsObj = element.getAsJsonObject();\n        JsonElement urlElement = atsObj.get(\"url\");\n        if (urlElement.isJsonPrimitive()) {\n          String url = urlElement.getAsString();\n          atsObj.addProperty(\"url\", \"\");\n          content.put(url, atsObj);\n        }\n      }\n    } else {\n      JsonObject atsObj = jsonElement.getAsJsonObject();\n      JsonElement urlElement = atsObj.get(\"url\");\n      if (urlElement.isJsonPrimitive()) {\n        String url = urlElement.getAsString();\n        atsObj.addProperty(\"url\", \"\");\n        content.put(url, atsObj);\n      }\n    }\n  }\n  return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  content.put(\"ats\", jsonObject.get(\"ats\").getAsString());\n  return content;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> map = new HashMap<>();\n  if (jsonObject.has(\"ats\")) {\n    JsonObject ats = jsonObject.get(\"ats\").getAsJsonObject();\n    JsonArray jsonArray = ats.getAsJsonArray(\"users\");\n    for (JsonElement jsonElement : jsonArray) {\n      JsonObject user = jsonElement.getAsJsonObject();\n      map.put(user.get(\"user_id\").getAsString(), user.get(\"username\").getAsString());\n    }\n  }\n  return map;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  if (jsonObject.has(\"ats\")) {\n    JsonObject ats = jsonObject.getAsJsonObject(\"ats\");\n    String atsId = ats.get(\"id\").getAsString();\n    String atsUserId = ats.get(\"userId\").getAsString();\n    String atsName = ats.get(\"name\").getAsString();\n    String atsContent = ats.get(\"content\").getAsString();\n    String atsLocation = ats.get(\"location\").getAsString();\n    String atsStartTime = ats.get(\"startTime\").getAsString();\n    String atsEndTime = ats.get(\"endTime\").getAsString();\n    content.put(\"atsId\", atsId);\n    content.put(\"atsUserId\", atsUserId);\n    content.put(\"atsName\", atsName);\n    content.put(\"atsContent\", atsContent);\n    content.put(\"atsLocation\", atsLocation);\n    content.put(\"atsStartTime\", atsStartTime);\n    content.put(\"atsEndTime\", atsEndTime);\n  }\n  return content;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * build content,if it has ats someone set the ats\n */\n", "method_name": "buildContent", "codes": ["private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); if (jsonObject.containsKey(\"ats\")) { JsonObject ats = jsonObject.get(\"ats\").getAsJsonObject(); content.put(\"ats\", buildContent(ats)); } if (jsonObject.containsKey(\"reply\")) { JsonObject reply = jsonObject.get(\"reply\").getAsJsonObject(); content.put(\"reply\", buildContent(reply)); } return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> result = new HashMap<>(); if (jsonObject.has(\"ats\")) { result.put(\"ats\", jsonObject.get(\"ats\").getAsString()); } if (jsonObject.has(\"ats_content\")) { result.put(\"ats_content\", jsonObject.get(\"ats_content\").getAsString()); } return result; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); JsonArray jsonArray = jsonObject.getAsJsonArray(\"ats\"); for (JsonElement jsonElement : jsonArray) { JsonObject atsJsonObject = jsonElement.getAsJsonObject(); String ats = atsJsonObject.get(\"ats\").getAsString(); if (!StringUtils.isEmpty(ats)) { content.put(ats, atsJsonObject.get(\"value\").getAsString()); } } return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> map = new HashMap<>(); JsonArray ats = jsonObject.get(\"ats\").getAsJsonArray(); for (JsonElement e : ats) { JsonObject obj = e.getAsJsonObject(); String k = obj.get(\"k\").getAsString(); String v = obj.get(\"v\").getAsString(); map.put(k, v); } return map; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> map = new HashMap<String, Object>(); if (jsonObject.has(\"ats\")) { JsonArray ats = jsonObject.get(\"ats\").getAsJsonArray(); if (ats.size() > 0) { JsonObject atsObj = ats.get(0).getAsJsonObject(); String atsId = atsObj.get(\"id\").getAsString(); String atsName = atsObj.get(\"name\").getAsString(); String atsKey = atsObj.get(\"key\").getAsString(); String atsSecret = atsObj.get(\"secret\").getAsString(); String atsToken = atsObj.get(\"token\").getAsString(); String atsCreateTime = atsObj.get(\"createTime\").getAsString(); String atsUpdateTime = atsObj.get(\"updateTime\").getAsString(); String atsLastLoginTime = atsObj.get(\"lastLoginTime\").getAsString(); String atsType = atsObj.get(\"type\").getAsString(); String atsSecretKey = atsObj.get(\"secretKey\").getAsString(); map.put(\"atsId\", atsId); map.put(\"atsName\", atsName); map.put(\"atsKey\", atsKey); map.put(\"atsSecret\", atsSecret); map.put(\"atsToken\", atsToken); map.put(\"atsCreateTime\", atsCreateTime); map.put(\"atsUpdateTime\", atsUpdateTime); map.put(\"atsLastLoginTime\", atsLastLoginTime); map.put(\"atsType\", atsType); map.put(\"atsSecretKey\", atsSecretKey); } } return map; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); JsonArray jsonArray = jsonObject.get(\"ats\").getAsJsonArray(); for (JsonElement jsonElement : jsonArray) { JsonObject atsJsonObject = jsonElement.getAsJsonObject(); String ats = atsJsonObject.get(\"ats\").getAsString(); content.put(ats, atsJsonObject.get(\"content\").getAsString()); } return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<String, Object>(); if (jsonObject.has(\"ats\")) { JsonElement jsonElement = jsonObject.get(\"ats\"); if (jsonElement.isJsonArray()) { JsonArray jsonArray = jsonElement.getAsJsonArray(); for (JsonElement element : jsonArray) { JsonObject atsObj = element.getAsJsonObject(); JsonElement urlElement = atsObj.get(\"url\"); if (urlElement.isJsonPrimitive()) { String url = urlElement.getAsString(); atsObj.addProperty(\"url\", \"\"); content.put(url, atsObj); } } } else { JsonObject atsObj = jsonElement.getAsJsonObject(); JsonElement urlElement = atsObj.get(\"url\"); if (urlElement.isJsonPrimitive()) { String url = urlElement.getAsString(); atsObj.addProperty(\"url\", \"\"); content.put(url, atsObj); } } } return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); content.put(\"ats\", jsonObject.get(\"ats\").getAsString()); return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> map = new HashMap<>(); if (jsonObject.has(\"ats\")) { JsonObject ats = jsonObject.get(\"ats\").getAsJsonObject(); JsonArray jsonArray = ats.getAsJsonArray(\"users\"); for (JsonElement jsonElement : jsonArray) { JsonObject user = jsonElement.getAsJsonObject(); map.put(user.get(\"user_id\").getAsString(), user.get(\"username\").getAsString()); } } return map; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); if (jsonObject.has(\"ats\")) { JsonObject ats = jsonObject.getAsJsonObject(\"ats\"); String atsId = ats.get(\"id\").getAsString(); String atsUserId = ats.get(\"userId\").getAsString(); String atsName = ats.get(\"name\").getAsString(); String atsContent = ats.get(\"content\").getAsString(); String atsLocation = ats.get(\"location\").getAsString(); String atsStartTime = ats.get(\"startTime\").getAsString(); String atsEndTime = ats.get(\"endTime\").getAsString(); content.put(\"atsId\", atsId); content.put(\"atsUserId\", atsUserId); content.put(\"atsName\", atsName); content.put(\"atsContent\", atsContent); content.put(\"atsLocation\", atsLocation); content.put(\"atsStartTime\", atsStartTime); content.put(\"atsEndTime\", atsEndTime); } return content; }"], "code_level": "project_runnable", "_id": "636767e01a6d9265ec018755", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (shardingKeyIndices.isEmpty()) {\n    throw new IllegalStateException(\"No sharding key indices are continuous\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (shardingKeyIndices == null) {\n    throw new IllegalStateException(\"sharding key indices must be specified\");\n  }\n  if (shardingKeyIndices.size() > 1) {\n    throw new IllegalStateException(\"sharding key indices must be unique\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (shardingKeyIndices.size() > 0 && !shardingKeyIndices.contains(modelName)) {\n    throw new IllegalStateException(\n        \"The sharding key indices \" + shardingKeyIndices + \" are not continuous: \" + modelName);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (!shardingKeyIndices.isEmpty()) {\n    throw new IllegalStateException(\"sharding key indices can not be continuous\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (shardingKeyIndices.size() == 0) {\n    throw new IllegalStateException(\"No sharding key indices are continuous\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (shardingKeyIndices.isEmpty()) {\n    throw new IllegalStateException(\"sharding key indices are not continuous\");\n  }\n  if (shardingKeyIndices.size() > 1) {\n    throw new IllegalStateException(\n        \"sharding key indices are not continuous, only one is supported.\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (!this.shardingKeyIndices.contains(modelName)) {\n    throw new IllegalStateException(\"Invalid sharding key index: \" + modelName);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (!isContinuous(modelName)) {\n    throw new IllegalStateException(\"sharding key indices are not continuous: \" + modelName);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (shardingKeyIndices.isEmpty()) {\n    throw new IllegalStateException(\"Sharding key indices are not continuous\");\n  }\n  if (shardingKeyIndices.size() > 1) {\n    throw new IllegalStateException(\"Sharding key indices are not continuous\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (!shardingKeyIndices.contains(modelName)) {\n    throw new IllegalStateException(\"Sharding key indices are not continuous: \" + modelName);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n", "method_name": "check", "codes": ["private void check(String modelName) throws IllegalStateException { if (shardingKeyIndices.isEmpty()) { throw new IllegalStateException(\"No sharding key indices are continuous\"); } }", "private void check(String modelName) throws IllegalStateException { if (shardingKeyIndices == null) { throw new IllegalStateException(\"sharding key indices must be specified\"); } if (shardingKeyIndices.size() > 1) { throw new IllegalStateException(\"sharding key indices must be unique\"); } }", "private void check(String modelName) throws IllegalStateException { if (shardingKeyIndices.size() > 0 && !shardingKeyIndices.contains(modelName)) { throw new IllegalStateException(\"The sharding key indices \" + shardingKeyIndices + \" are not continuous: \" + modelName); } }", "private void check(String modelName) throws IllegalStateException { if (!shardingKeyIndices.isEmpty()) { throw new IllegalStateException(\"sharding key indices can not be continuous\"); } }", "private void check(String modelName) throws IllegalStateException { if (shardingKeyIndices.size() == 0) { throw new IllegalStateException(\"No sharding key indices are continuous\"); } }", "private void check(String modelName) throws IllegalStateException { if (shardingKeyIndices.isEmpty()) { throw new IllegalStateException(\"sharding key indices are not continuous\"); } if (shardingKeyIndices.size() > 1) { throw new IllegalStateException(\"sharding key indices are not continuous, only one is supported.\"); } }", "private void check(String modelName) throws IllegalStateException { if (!this.shardingKeyIndices.contains(modelName)) { throw new IllegalStateException(\"Invalid sharding key index: \" + modelName); } }", "private void check(String modelName) throws IllegalStateException { if (!isContinuous(modelName)) { throw new IllegalStateException(\"sharding key indices are not continuous: \" + modelName); } }", "private void check(String modelName) throws IllegalStateException { if (shardingKeyIndices.isEmpty()) { throw new IllegalStateException(\"Sharding key indices are not continuous\"); } if (shardingKeyIndices.size() > 1) { throw new IllegalStateException(\"Sharding key indices are not continuous\"); } }", "private void check(String modelName) throws IllegalStateException { if (!shardingKeyIndices.contains(modelName)) { throw new IllegalStateException(\"Sharding key indices are not continuous: \" + modelName); } }"], "code_level": "self_contained", "_id": "636767de1a6d9265ec01871e", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void overrideName(String oldName, String newName) {\n  this.overrideName(oldName, newName);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  this.name = this.name.overrideName(oldName, newName);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  if (!this.name.equals(oldName)) {\n    this.name = newName;\n    this.replacedName = this.name;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  if (!oldName.equals(newName)) {\n    String oldNameWithoutPrefix = oldName.replace('.', '_');\n    String newNameWithoutPrefix = newName.replace('.', '_');\n    String renamedName = oldNameWithoutPrefix + \"_\" + newNameWithoutPrefix;\n    setName(renamedName);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  this.name = new Name(oldName, newName);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  this.overrideName = newName;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  if (this.name.equals(oldName)) {\n    this.name = newName;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  overrideName(oldName, newName, this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  this.overrideName(oldName, newName, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  this.name = newName;\n  this.oldName = oldName;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Keep the same name replacement as  {@link ColumnName#overrideName(String,String)}\n * @param oldName to be replaced.\n * @param newName to use in the storage level.\n */\n", "method_name": "overrideName", "codes": ["public void overrideName(String oldName,String newName){ this.overrideName(oldName, newName); }", "public void overrideName(String oldName,String newName){ this.name = this.name.overrideName(oldName, newName); }", "public void overrideName(String oldName,String newName){ if (!this.name.equals(oldName)) { this.name = newName; this.replacedName = this.name; } }", "public void overrideName(String oldName,String newName){ if (!oldName.equals(newName)) { String oldNameWithoutPrefix = oldName.replace('.', '_'); String newNameWithoutPrefix = newName.replace('.', '_'); String renamedName = oldNameWithoutPrefix + \"_\" + newNameWithoutPrefix; setName(renamedName); } }", "public void overrideName(String oldName,String newName){ this.name = new Name(oldName, newName); }", "public void overrideName(String oldName,String newName){ this.overrideName = newName; }", "public void overrideName(String oldName,String newName){ if (this.name.equals(oldName)) { this.name = newName; } }", "public void overrideName(String oldName,String newName){ overrideName(oldName, newName, this); }", "public void overrideName(String oldName,String newName){ this.overrideName(oldName, newName, null); }", "public void overrideName(String oldName,String newName){ this.name = newName; this.oldName = oldName; }"], "code_level": "self_contained", "_id": "636767dd1a6d9265ec0186f3", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (dataset == null) {\n    return false;\n  }\n  if (this.getCount() != dataset.getCount()) {\n    return false;\n  }\n  for (int i = 0; i < this.getCount(); i++) {\n    if (!this.getData(i).isCompatible(dataset.getData(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  return this.getBucketName().equals(dataset.getBucketName());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  return (dataset.size() == this.size());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (dataset == null) {\n    throw new IllegalArgumentException(\"DataTable cannot be null\");\n  }\n  if (dataset.size() != this.size()) {\n    return false;\n  }\n  for (int i = 0; i < this.size(); i++) {\n    if (!this.get(i).isCompatible(dataset.get(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (dataset.getRowCount() != getRowCount()) {\n    return false;\n  }\n  for (int i = 0; i < dataset.getRowCount(); i++) {\n    if (!dataset.get(i, 0).equals(get(i, 0))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  return this.dataset.getTitle().equals(dataset.getTitle())\n      && this.dataset.getLanguage().equals(dataset.getLanguage());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (dataset.getColumns().size() != columns.size()) {\n    return false;\n  }\n  for (int i = 0; i < columns.size(); i++) {\n    if (!columns.get(i).isCompatible(dataset.getColumns().get(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (dataset.getRowCount() != rowCount()) {\n    return false;\n  }\n  for (int i = 0; i < rowCount(); i++) {\n    if (!dataset.getValue(i, columnIndex(i)).equals(getValue(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (dataset.getRowCount() != getRowCount()) return false;\n  for (int i = 0; i < getRowCount(); i++) {\n    DataRow row = dataset.getRow(i);\n    for (int j = 0; j < getColumnCount(); j++) {\n      if (!getData(i, j).equals(row.getData(j))) return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (dataset == null) {\n    return false;\n  }\n  if (dataset.size() != size()) {\n    return false;\n  }\n  for (int i = 0; i < size(); i++) {\n    if (!get(i).isCompatible(dataset.get(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return true if the bucket is same.\n */\n", "method_name": "isCompatible", "codes": ["public boolean isCompatible(DataTable dataset){ if (dataset == null) { return false; } if (this.getCount() != dataset.getCount()) { return false; } for (int i = 0; i < this.getCount(); i++) { if (!this.getData(i).isCompatible(dataset.getData(i))) { return false; } } return true; }", "public boolean isCompatible(DataTable dataset){ return this.getBucketName().equals(dataset.getBucketName()); }", "public boolean isCompatible(DataTable dataset){ return (dataset.size() == this.size()); }", "public boolean isCompatible(DataTable dataset){ if (dataset == null) { throw new IllegalArgumentException(\"DataTable cannot be null\"); } if (dataset.size() != this.size()) { return false; } for (int i = 0; i < this.size(); i++) { if (!this.get(i).isCompatible(dataset.get(i))) { return false; } } return true; }", "public boolean isCompatible(DataTable dataset){ if (dataset.getRowCount() != getRowCount()) { return false; } for (int i = 0; i < dataset.getRowCount(); i++) { if (!dataset.get(i, 0).equals(get(i, 0))) { return false; } } return true; }", "public boolean isCompatible(DataTable dataset){ return this.dataset.getTitle().equals(dataset.getTitle()) && this.dataset.getLanguage().equals(dataset.getLanguage()); }", "public boolean isCompatible(DataTable dataset){ if (dataset.getColumns().size() != columns.size()) { return false; } for (int i = 0; i < columns.size(); i++) { if (!columns.get(i).isCompatible(dataset.getColumns().get(i))) { return false; } } return true; }", "public boolean isCompatible(DataTable dataset){ if (dataset.getRowCount() != rowCount()) { return false; } for (int i = 0; i < rowCount(); i++) { if (!dataset.getValue(i, columnIndex(i)).equals(getValue(i))) { return false; } } return true; }", "public boolean isCompatible(DataTable dataset){ if (dataset.getRowCount() != getRowCount()) return false; for (int i = 0; i < getRowCount(); i++) { DataRow row = dataset.getRow(i); for (int j = 0; j < getColumnCount(); j++) { if (!getData(i, j).equals(row.getData(j))) return false; } } return true; }", "public boolean isCompatible(DataTable dataset){ if (dataset == null) { return false; } if (dataset.size() != size()) { return false; } for (int i = 0; i < size(); i++) { if (!get(i).isCompatible(dataset.get(i))) { return false; } } return true; }"], "code_level": "plib_runnable", "_id": "636767e11a6d9265ec018795", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  if (mappings.size() == 0) {\n    return this;\n  }\n  List<Mapping> dbMappings = new ArrayList<Mapping>();\n  for (Mapping mapping : mappings.values()) {\n    if (mapping.isHistory()) {\n      dbMappings.add(mapping);\n    }\n  }\n  if (dbMappings.size() == 0) {\n    return this;\n  }\n  Map<String, Mapping> dbMappingsMap = new HashMap<String, Mapping>();\n  for (Mapping mapping : dbMappings) {\n    dbMappingsMap.put(mapping.getSource(), mapping);\n  }\n  Map<String, Mapping> sourceMap = new HashMap<String, Mapping>();\n  for (Mapping mapping : mappings.values()) {\n    if (mapping.isSource()) {\n      sourceMap.put(mapping.getSource(), mapping);\n    }\n  }\n  Map<String, Mapping> result = new HashMap<String, Mapping>();\n  for (Map.Entry<String, Mapping> entry : dbMappingsMap.entrySet()) {\n    String source = entry.getKey();\n    if (!sourceMap.containsKey(source)) {\n      result.put(source, entry.getValue());\n    }\n  }\n  for (Map.Entry<String, Mapping> entry : sourceMap.entrySet()) {\n    String source = entry.getKey();\n    if (!dbMappingsMap.containsKey(source)) {\n      result.put(source, entry.getValue());\n    }\n  }\n  return new Mappings(result);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  return diffStructure(tableName, mappings, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  Mappings diff = new Mappings();\n  for (String field : mappings.getFields()) {\n    if (!mappings.getSourceField(tableName, field).exists()) {\n      diff.add(field, mappings.getSourceField(tableName, field));\n    }\n  }\n  return diff;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){ Map<String, Mapping> sourceMappings = mappings.getSourceMappings(); Map<String, Mapping> targetMappings = mappings.getTargetMappings(); Map<String, String> sourceFields = sourceMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> sourceMappings.get(field).getField())); Map<String, String> targetFields = targetMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> targetMappings.get(field).getField())); Map<String, String> sourceFieldTypes = sourceMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> sourceMappings.get(field).getFieldType())); Map<String, String> targetFieldTypes = targetMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> targetMappings.get(field).getFieldType())); Map<String, String> sourceFieldsTypes = sourceMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> sourceMappings.get(field).getFieldType())); Map<String, String> targetFieldsTypes = targetMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> targetMappings.get(field).getFieldType())); Map<String, String> sourceFieldTypesHistory = sourceMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> sourceMappings.get(field).getFieldTypeHistory())); Map<String, String> targetFieldTypesHistory = targetMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> targetMappings.get(field).getFieldTypeHistory())); Map<String, String> sourceFieldTypesHistoryHistory = sourceMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> sourceMappings.get(field).getFieldTypeHistoryHistory())); Map<String, String> targetFieldTypesHistoryHistory = targetMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> targetMappings.get(field).getFieldTypeHistoryHistory())); if (!sourceFields.equals(targetFields)) { if (!sourceFieldTypes.equals(targetFieldTypes)) { throw new IllegalArgumentException(\"Source fields and target fields should have the same type\"); } if (!sourceFieldsTypes.equals(sourceFieldTypesHistory)) { throw new IllegalArgumentException(\"Source fields and target fields should have the same type history\"); } if (!sourceFieldsTypes.equals(sourceFieldTypesHistoryHistory)) { throw new IllegalArgumentException(\"Source fields and target fields should have the same type history history\"); } } if (!sourceFieldsTypes.equals(targetFieldTypesHistory)) { throw new IllegalArgumentException(\"Source fields and target fields should have the same type history history\"); } if (!sourceFieldTypesHistory.equals(targetFieldTypesHistoryHistory)) { throw new IllegalArgumentException(\"Source fields and target fields should have the same type history history history\"); } if (!sourceFieldTypesHistory", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  Map<String, Map<String, String>> newMappings = new HashMap<>();\n  for (Mapping mapping : mappings.getMappings()) {\n    if (!isHistoryMapping(mapping)) {\n      newMappings.put(mapping.getTableName(), mapping.getSourceMapping());\n    }\n  }\n  return new Mappings(newMappings);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){ if (!mappings.isHistory()) { throw new IllegalArgumentException(\"mappings is not history\"); } if (tableName == null || tableName.length() == 0) { throw new IllegalArgumentException(\"tableName is null or empty\"); } if (mappings.getInputFields().isEmpty()) { throw new IllegalArgumentException(\"input mappings is empty\"); } if (mappings.getOutputFields().isEmpty()) { throw new IllegalArgumentException(\"output mappings is empty\"); } if (mappings.getInputFields().size() != mappings.getOutputFields().size()) { throw new IllegalArgumentException(\"input mappings and output mappings have different number of fields\"); } if (mappings.getInputFields().containsKey(Fields.ID)) { throw new IllegalArgumentException(\"input mappings contains field with ID\"); } if (mappings.getInputFields().containsKey(Fields.TYPE)) { throw new IllegalArgumentException(\"input mappings contains field with type\"); } if (mappings.getInputFields().containsKey(Fields.TYPE_NAME)) { throw new IllegalArgumentException(\"input mappings contains field with type_name\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_TYPE)) { throw new IllegalArgumentException(\"input mappings contains field with field_type\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_TYPE_NAME)) { throw new IllegalArgumentException(\"input mappings contains field with field_type_name\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_NAME)) { throw new IllegalArgumentException(\"input mappings contains field with field_name\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_NAME_FULL)) { throw new IllegalArgumentException(\"input mappings contains field with field_name_full\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_NAME_LOWER)) { throw new IllegalArgumentException(\"input mappings contains field with field_name_lower\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_NAME_UPPER)) { throw new IllegalArgumentException(\"input mappings contains field with field_name_upper\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_REQUIRED)) { throw new IllegalArgumentException(\"input mappings contains field with field_required\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_REQUIRED_FULL)) { throw new IllegalArgumentException(\"input mappings contains field with field_required_full\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_REQUIRED_LOWER)) { throw new IllegalArgumentException(\"input mapping", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  return diffStructure(tableName, mappings, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  return diffStructure(tableName, mappings, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  return diffStructure(tableName, mappings, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  return diffStructure(tableName, mappings, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns mappings with fields that not exist in the input mappings. The input mappings should be history mapping from current index. Do not return _source config to avoid current index update conflict.\n */\n", "method_name": "diffStructure", "codes": ["public Mappings diffStructure(String tableName,Mappings mappings){ if (mappings.size() == 0) { return this; } List<Mapping> dbMappings = new ArrayList<Mapping>(); for (Mapping mapping : mappings.values()) { if (mapping.isHistory()) { dbMappings.add(mapping); } } if (dbMappings.size() == 0) { return this; } Map<String, Mapping> dbMappingsMap = new HashMap<String, Mapping>(); for (Mapping mapping : dbMappings) { dbMappingsMap.put(mapping.getSource(), mapping); } Map<String, Mapping> sourceMap = new HashMap<String, Mapping>(); for (Mapping mapping : mappings.values()) { if (mapping.isSource()) { sourceMap.put(mapping.getSource(), mapping); } } Map<String, Mapping> result = new HashMap<String, Mapping>(); for (Map.Entry<String, Mapping> entry : dbMappingsMap.entrySet()) { String source = entry.getKey(); if (!sourceMap.containsKey(source)) { result.put(source, entry.getValue()); } } for (Map.Entry<String, Mapping> entry : sourceMap.entrySet()) { String source = entry.getKey(); if (!dbMappingsMap.containsKey(source)) { result.put(source, entry.getValue()); } } return new Mappings(result); }", "public Mappings diffStructure(String tableName,Mappings mappings){ return diffStructure(tableName, mappings, null); }", "public Mappings diffStructure(String tableName,Mappings mappings){ Mappings diff = new Mappings(); for (String field : mappings.getFields()) { if (!mappings.getSourceField(tableName, field).exists()) { diff.add(field, mappings.getSourceField(tableName, field)); } } return diff; }", "public Mappings diffStructure(String tableName,Mappings mappings){ Map<String, Mapping> sourceMappings = mappings.getSourceMappings(); Map<String, Mapping> targetMappings = mappings.getTargetMappings(); Map<String, String> sourceFields = sourceMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> sourceMappings.get(field).getField())); Map<String, String> targetFields = targetMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> targetMappings.get(field).getField())); Map<String, String> sourceFieldTypes = sourceMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> sourceMappings.get(field).getFieldType())); Map<String, String> targetFieldTypes = targetMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> targetMappings.get(field).getFieldType())); Map<String, String> sourceFieldsTypes = sourceMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> sourceMappings.get(field).getFieldType())); Map<String, String> targetFieldsTypes = targetMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> targetMappings.get(field).getFieldType())); Map<String, String> sourceFieldTypesHistory = sourceMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> sourceMappings.get(field).getFieldTypeHistory())); Map<String, String> targetFieldTypesHistory = targetMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> targetMappings.get(field).getFieldTypeHistory())); Map<String, String> sourceFieldTypesHistoryHistory = sourceMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> sourceMappings.get(field).getFieldTypeHistoryHistory())); Map<String, String> targetFieldTypesHistoryHistory = targetMappings.keySet().stream().collect(Collectors.toMap(field -> field, field -> targetMappings.get(field).getFieldTypeHistoryHistory())); if (!sourceFields.equals(targetFields)) { if (!sourceFieldTypes.equals(targetFieldTypes)) { throw new IllegalArgumentException(\"Source fields and target fields should have the same type\"); } if (!sourceFieldsTypes.equals(sourceFieldTypesHistory)) { throw new IllegalArgumentException(\"Source fields and target fields should have the same type history\"); } if (!sourceFieldsTypes.equals(sourceFieldTypesHistoryHistory)) { throw new IllegalArgumentException(\"Source fields and target fields should have the same type history history\"); } } if (!sourceFieldsTypes.equals(targetFieldTypesHistory)) { throw new IllegalArgumentException(\"Source fields and target fields should have the same type history history\"); } if (!sourceFieldTypesHistory.equals(targetFieldTypesHistoryHistory)) { throw new IllegalArgumentException(\"Source fields and target fields should have the same type history history history\"); } if (!sourceFieldTypesHistory", "public Mappings diffStructure(String tableName,Mappings mappings){ Map<String, Map<String, String>> newMappings = new HashMap<>(); for (Mapping mapping : mappings.getMappings()) { if (!isHistoryMapping(mapping)) { newMappings.put(mapping.getTableName(), mapping.getSourceMapping()); } } return new Mappings(newMappings); }", "public Mappings diffStructure(String tableName,Mappings mappings){ if (!mappings.isHistory()) { throw new IllegalArgumentException(\"mappings is not history\"); } if (tableName == null || tableName.length() == 0) { throw new IllegalArgumentException(\"tableName is null or empty\"); } if (mappings.getInputFields().isEmpty()) { throw new IllegalArgumentException(\"input mappings is empty\"); } if (mappings.getOutputFields().isEmpty()) { throw new IllegalArgumentException(\"output mappings is empty\"); } if (mappings.getInputFields().size() != mappings.getOutputFields().size()) { throw new IllegalArgumentException(\"input mappings and output mappings have different number of fields\"); } if (mappings.getInputFields().containsKey(Fields.ID)) { throw new IllegalArgumentException(\"input mappings contains field with ID\"); } if (mappings.getInputFields().containsKey(Fields.TYPE)) { throw new IllegalArgumentException(\"input mappings contains field with type\"); } if (mappings.getInputFields().containsKey(Fields.TYPE_NAME)) { throw new IllegalArgumentException(\"input mappings contains field with type_name\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_TYPE)) { throw new IllegalArgumentException(\"input mappings contains field with field_type\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_TYPE_NAME)) { throw new IllegalArgumentException(\"input mappings contains field with field_type_name\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_NAME)) { throw new IllegalArgumentException(\"input mappings contains field with field_name\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_NAME_FULL)) { throw new IllegalArgumentException(\"input mappings contains field with field_name_full\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_NAME_LOWER)) { throw new IllegalArgumentException(\"input mappings contains field with field_name_lower\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_NAME_UPPER)) { throw new IllegalArgumentException(\"input mappings contains field with field_name_upper\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_REQUIRED)) { throw new IllegalArgumentException(\"input mappings contains field with field_required\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_REQUIRED_FULL)) { throw new IllegalArgumentException(\"input mappings contains field with field_required_full\"); } if (mappings.getInputFields().containsKey(Fields.FIELD_REQUIRED_LOWER)) { throw new IllegalArgumentException(\"input mapping", "public Mappings diffStructure(String tableName,Mappings mappings){ return diffStructure(tableName, mappings, false); }", "public Mappings diffStructure(String tableName,Mappings mappings){ return diffStructure(tableName, mappings, null); }", "public Mappings diffStructure(String tableName,Mappings mappings){ return diffStructure(tableName, mappings, null); }", "public Mappings diffStructure(String tableName,Mappings mappings){ return diffStructure(tableName, mappings, true); }"], "code_level": "plib_runnable", "_id": "636767de1a6d9265ec018706", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return (timeBucket + dayStep - 1) / dayStep;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return timeBucket * dayStep;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  long tmp = timeBucket;\n  int i = 0;\n  while (tmp >= 0) {\n    tmp -= dayStep;\n    i++;\n  }\n  return i;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return (timeBucket << dayStep) | (timeBucket >>> (32 - dayStep));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  long timeBucketLong = timeBucket;\n  int dayStepLong = dayStep;\n  int i = 0;\n  while (i < dayStepLong) {\n    timeBucketLong = timeBucketLong * 10 + 1;\n    i++;\n  }\n  return timeBucketLong;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  long timeBucketLong = timeBucket;\n  int i = 1;\n  while ((timeBucketLong % dayStep) != 0) {\n    timeBucketLong = timeBucketLong * 10;\n    i++;\n  }\n  return timeBucketLong;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return timeBucket << dayStep;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return timeBucket << (dayStep * 8);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  long timeBucketLong = timeBucket;\n  if (timeBucketLong < 0) {\n    timeBucketLong = -timeBucketLong;\n  }\n  if (timeBucketLong < 0) {\n    timeBucketLong += 24 * 60 * 60 * 1000;\n  }\n  long timeBucketLong2 = timeBucketLong;\n  if (timeBucketLong2 < 0) {\n    timeBucketLong2 = -timeBucketLong2;\n  }\n  long timeBucketLong3 = timeBucketLong2;\n  if (timeBucketLong3 < 0) {\n    timeBucketLong3 = -timeBucketLong3;\n  }\n  if (timeBucketLong3 < 0) {\n    timeBucketLong3 += 24 * 60 * 60 * 1000;\n  }\n  if (timeBucketLong3 < 0) {\n    timeBucketLong3 += 24 * 60 * 60 * 1000;\n  }\n  timeBucketLong3 *= dayStep;\n  timeBucketLong3 += timeBucketLong3 / 24 * 24 * 60 * 60 * 1000;\n  timeBucketLong3 += timeBucketLong3 / 60 * 60 * 1000;\n  timeBucketLong3 += timeBucketLong3 / 1000 * 60 * 1000;\n  timeBucketLong3 += timeBucketLong3 / 1000 * 1000;\n  timeBucketLong3 = timeBucketLong3 % 1000;\n  return timeBucketLong3;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return timeBucket << dayStep;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n", "method_name": "compressTimeBucket", "codes": ["static long compressTimeBucket(long timeBucket,int dayStep){ return (timeBucket + dayStep - 1) / dayStep; }", "static long compressTimeBucket(long timeBucket,int dayStep){ return timeBucket * dayStep; }", "static long compressTimeBucket(long timeBucket,int dayStep){ long tmp = timeBucket; int i = 0; while (tmp >= 0) { tmp -= dayStep; i++; } return i; }", "static long compressTimeBucket(long timeBucket,int dayStep){ return (timeBucket << dayStep) | (timeBucket >>> (32 - dayStep)); }", "static long compressTimeBucket(long timeBucket,int dayStep){ long timeBucketLong = timeBucket; int dayStepLong = dayStep; int i = 0; while (i < dayStepLong) { timeBucketLong = timeBucketLong * 10 + 1; i++; } return timeBucketLong; }", "static long compressTimeBucket(long timeBucket,int dayStep){ long timeBucketLong = timeBucket; int i = 1; while ((timeBucketLong % dayStep) != 0) { timeBucketLong = timeBucketLong * 10; i++; } return timeBucketLong; }", "static long compressTimeBucket(long timeBucket,int dayStep){ return timeBucket << dayStep; }", "static long compressTimeBucket(long timeBucket,int dayStep){ return timeBucket << (dayStep * 8); }", "static long compressTimeBucket(long timeBucket,int dayStep){ long timeBucketLong = timeBucket; if (timeBucketLong < 0) { timeBucketLong = -timeBucketLong; } if (timeBucketLong < 0) { timeBucketLong += 24 * 60 * 60 * 1000; } long timeBucketLong2 = timeBucketLong; if (timeBucketLong2 < 0) { timeBucketLong2 = -timeBucketLong2; } long timeBucketLong3 = timeBucketLong2; if (timeBucketLong3 < 0) { timeBucketLong3 = -timeBucketLong3; } if (timeBucketLong3 < 0) { timeBucketLong3 += 24 * 60 * 60 * 1000; } if (timeBucketLong3 < 0) { timeBucketLong3 += 24 * 60 * 60 * 1000; } timeBucketLong3 *= dayStep; timeBucketLong3 += timeBucketLong3 / 24 * 24 * 60 * 60 * 1000; timeBucketLong3 += timeBucketLong3 / 60 * 60 * 1000; timeBucketLong3 += timeBucketLong3 / 1000 * 60 * 1000; timeBucketLong3 += timeBucketLong3 / 1000 * 1000; timeBucketLong3 = timeBucketLong3 % 1000; return timeBucketLong3; }", "static long compressTimeBucket(long timeBucket,int dayStep){ return timeBucket << dayStep; }"], "code_level": "project_runnable", "_id": "636767dc1a6d9265ec0186be", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private boolean containsAllFields(Fields fields) {\n  if (fields == null) return false;\n  for (Field field : fields) {\n    if (!field.isStored()) return false;\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  boolean result = true;\n  for (Field field : fields) {\n    result &= containsField(field);\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (String fieldName : fields.keySet()) {\n    if (!fields.get(fieldName).equals(getProperties().get(fieldName))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  if (fields == null) {\n    return false;\n  } else {\n    for (String field : fields.getAllFields()) {\n      if (!this.properties.containsKey(field)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (Field field : fields.getAllFields()) {\n    if (!field.getType().equals(FieldType.STRING) && !field.getType().equals(FieldType.DATE)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (Field field : fields.values()) {\n    if (!containsField(field)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (Field field : fields) {\n    if (field.getValue() == null || field.getValue().isEmpty()) return false;\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (String field : fields) {\n    if (!this.containsField(field)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (Field field : fields.values()) {\n    if (!containsField(field)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (Field field : fields) {\n    if (!field.isEmpty()) return false;\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n", "method_name": "containsAllFields", "codes": ["private boolean containsAllFields(Fields fields){ if (fields == null) return false; for (Field field : fields) { if (!field.isStored()) return false; } return true; }", "private boolean containsAllFields(Fields fields){ boolean result = true; for (Field field : fields) { result &= containsField(field); } return result; }", "private boolean containsAllFields(Fields fields){ for (String fieldName : fields.keySet()) { if (!fields.get(fieldName).equals(getProperties().get(fieldName))) { return false; } } return true; }", "private boolean containsAllFields(Fields fields){ if (fields == null) { return false; } else { for (String field : fields.getAllFields()) { if (!this.properties.containsKey(field)) { return false; } } return true; } }", "private boolean containsAllFields(Fields fields){ for (Field field : fields.getAllFields()) { if (!field.getType().equals(FieldType.STRING) && !field.getType().equals(FieldType.DATE)) { return false; } } return true; }", "private boolean containsAllFields(Fields fields){ for (Field field : fields.values()) { if (!containsField(field)) { return false; } } return true; }", "private boolean containsAllFields(Fields fields){ for (Field field : fields) { if (field.getValue() == null || field.getValue().isEmpty()) return false; } return true; }", "private boolean containsAllFields(Fields fields){ for (String field : fields) { if (!this.containsField(field)) { return false; } } return true; }", "private boolean containsAllFields(Fields fields){ for (Field field : fields.values()) { if (!containsField(field)) { return false; } } return true; }", "private boolean containsAllFields(Fields fields){ for (Field field : fields) { if (!field.isEmpty()) return false; } return true; }"], "code_level": "slib_runnable", "_id": "636767dc1a6d9265ec0186c6", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  if (channels == null) {\n    throw new IllegalArgumentException(\"Channels cannot be null\");\n  }\n  if (consumer == null) {\n    throw new IllegalArgumentException(\"Consumer cannot be null\");\n  }\n  if (channels.getTargets() == null) {\n    throw new IllegalArgumentException(\"Channels has no targets\");\n  }\n  if (channels.getTargets().size() < 1) {\n    throw new IllegalArgumentException(\"Channels has no targets\");\n  }\n  this.targets.add(new Target(channels, consumer));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  if (consumer == null) throw new NullPointerException(\"Consumer cannot be null\");\n  if (channels == null) throw new NullPointerException(\"Channels cannot be null\");\n  if (channels.getTargets().size() == 0) {\n    System.out.println(\"No target channels to add\");\n    return;\n  }\n  for (Target target : channels.getTargets()) {\n    if (target == null) throw new NullPointerException(\"Target cannot be null\");\n  }\n  if (!this.targets.contains(channels.getTargets().get(0))) {\n    this.targets.add(channels.getTargets().get(0));\n  }\n  this.targets.add(channels);\n  consumer.accept(channels);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  this.targets.put(channels, consumer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  targetChannels.add(channels);\n  targets.add(consumer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  if (channels.size() == 0) {\n    return;\n  }\n  for (int i = 0; i < channels.size(); i++) {\n    addTarget(channels.get(i), consumer);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  String channelName = \"target\" + getNextTargetIndex();\n  IChannel targetChannel = new Channel(channelName, consumer);\n  targetChannel.setChannelProperty(IChannel.CHANNEL_PROPERTY_TARGET_REGION, channels.getRegion());\n  targetChannel.setChannelProperty(IChannel.CHANNEL_PROPERTY_TARGET_NUMBER, channels.getNumber());\n  channels.addChannel(targetChannel);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  targetChannels.put(channels, consumer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  synchronized (this.targetChannels) {\n    this.targetChannels.put(channels, consumer);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  if (channels != null) {\n    if (targets.containsKey(channels)) {\n      targets.get(channels).add(consumer);\n    } else {\n      Set<IConsumer> set = new HashSet<IConsumer>();\n      set.add(consumer);\n      targets.put(channels, set);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  if (!targets.contains(channels)) {\n    targets.add(channels);\n    consumer.consume(channels);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a new target channels.\n */\n", "method_name": "addNewTarget", "codes": ["public void addNewTarget(Channels channels,IConsumer consumer){ if (channels == null) { throw new IllegalArgumentException(\"Channels cannot be null\"); } if (consumer == null) { throw new IllegalArgumentException(\"Consumer cannot be null\"); } if (channels.getTargets() == null) { throw new IllegalArgumentException(\"Channels has no targets\"); } if (channels.getTargets().size() < 1) { throw new IllegalArgumentException(\"Channels has no targets\"); } this.targets.add(new Target(channels, consumer)); }", "public void addNewTarget(Channels channels,IConsumer consumer){ if (consumer == null) throw new NullPointerException(\"Consumer cannot be null\"); if (channels == null) throw new NullPointerException(\"Channels cannot be null\"); if (channels.getTargets().size() == 0) { System.out.println(\"No target channels to add\"); return; } for (Target target : channels.getTargets()) { if (target == null) throw new NullPointerException(\"Target cannot be null\"); } if (!this.targets.contains(channels.getTargets().get(0))) { this.targets.add(channels.getTargets().get(0)); } this.targets.add(channels); consumer.accept(channels); }", "public void addNewTarget(Channels channels,IConsumer consumer){ this.targets.put(channels, consumer); }", "public void addNewTarget(Channels channels,IConsumer consumer){ targetChannels.add(channels); targets.add(consumer); }", "public void addNewTarget(Channels channels,IConsumer consumer){ if (channels.size() == 0) { return; } for (int i = 0; i < channels.size(); i++) { addTarget(channels.get(i), consumer); } }", "public void addNewTarget(Channels channels,IConsumer consumer){ String channelName = \"target\" + getNextTargetIndex(); IChannel targetChannel = new Channel(channelName, consumer); targetChannel.setChannelProperty(IChannel.CHANNEL_PROPERTY_TARGET_REGION, channels.getRegion()); targetChannel.setChannelProperty(IChannel.CHANNEL_PROPERTY_TARGET_NUMBER, channels.getNumber()); channels.addChannel(targetChannel); }", "public void addNewTarget(Channels channels,IConsumer consumer){ targetChannels.put(channels, consumer); }", "public void addNewTarget(Channels channels,IConsumer consumer){ synchronized (this.targetChannels) { this.targetChannels.put(channels, consumer); } }", "public void addNewTarget(Channels channels,IConsumer consumer){ if (channels != null) { if (targets.containsKey(channels)) { targets.get(channels).add(consumer); } else { Set<IConsumer> set = new HashSet<IConsumer>(); set.add(consumer); targets.put(channels, set); } } }", "public void addNewTarget(Channels channels,IConsumer consumer){ if (!targets.contains(channels)) { targets.add(channels); consumer.consume(channels); } }"], "code_level": "plib_runnable", "_id": "636767dd1a6d9265ec0186e5", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void init() {\n  if (!initialized) {\n    config = new Properties();\n    try {\n      config.load(new FileInputStream(new File(\"config.properties\")));\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    initialized = true;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  config = new Config();\n  config.load();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  this.mConfig = new Config();\n  this.mConfig.setHost(this.mHost);\n  this.mConfig.setPort(this.mPort);\n  this.mConfig.setDistPath(this.mDistPath);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  config = new Config(new File(\"config/\"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init(){ try { File file = new File(configPath); if (!file.exists()) { file.createNewFile(); } FileWriter fw = new FileWriter(file.getAbsoluteFile()); BufferedWriter bw = new BufferedWriter(fw); bw.write(\"-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  try {\n    File configFile = new File(FILE_PATH);\n    if (configFile.exists()) {\n      config = new Properties();\n      config.load(new FileInputStream(configFile));\n    } else {\n      config = new Properties();\n    }\n  } catch (Exception e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  if (config == null) {\n    config = new Configuration(new File(Constants.CONFIG_FILE));\n    config.load();\n  }\n  if (checkDistPath == null) {\n    checkDistPath = config.get(\"Dist\", \"checkDistPath\", true).getBoolean(true);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  if (!inited) {\n    inited = true;\n    checkDistPath = new HashMap<String, String>();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  if (configFile == null) {\n    configFile =\n        new File(\n            baseDir\n                + File.separator\n                + \"config\"\n                + File.separator\n                + \"dist\"\n                + File.separator\n                + \"config.txt\");\n  }\n  if (!configFile.exists()) {\n    try {\n      configFile.createNewFile();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  if (config == null) {\n    config = new Config();\n    config.init();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * initialize config, such as check dist path\n */\n", "method_name": "init", "codes": ["public void init(){ if (!initialized) { config = new Properties(); try { config.load(new FileInputStream(new File(\"config.properties\"))); } catch (IOException e) { e.printStackTrace(); } initialized = true; } }", "public void init(){ config = new Config(); config.load(); }", "public void init(){ this.mConfig = new Config(); this.mConfig.setHost(this.mHost); this.mConfig.setPort(this.mPort); this.mConfig.setDistPath(this.mDistPath); }", "public void init(){ config = new Config(new File(\"config/\")); }", "public void init(){ try { File file = new File(configPath); if (!file.exists()) { file.createNewFile(); } FileWriter fw = new FileWriter(file.getAbsoluteFile()); BufferedWriter bw = new BufferedWriter(fw); bw.write(\"-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "public void init(){ try { File configFile = new File(FILE_PATH); if (configFile.exists()) { config = new Properties(); config.load(new FileInputStream(configFile)); } else { config = new Properties(); } } catch (Exception e) { e.printStackTrace(); } }", "public void init(){ if (config == null) { config = new Configuration(new File(Constants.CONFIG_FILE)); config.load(); } if (checkDistPath == null) { checkDistPath = config.get(\"Dist\", \"checkDistPath\", true).getBoolean(true); } }", "public void init(){ if (!inited) { inited = true; checkDistPath = new HashMap<String, String>(); } }", "public void init(){ if (configFile == null) { configFile = new File(baseDir + File.separator + \"config\" + File.separator + \"dist\" + File.separator + \"config.txt\"); } if (!configFile.exists()) { try { configFile.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } }", "public void init(){ if (config == null) { config = new Config(); config.init(); } }"], "code_level": "slib_runnable", "_id": "636767dc1a6d9265ec0186cb", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  if (segmentProfiles.isEmpty()) {\n    return Collections.emptyList();\n  }\n  List<SequenceRange> seqRanges = new ArrayList<>(segmentProfiles.size());\n  for (SegmentProfile profile : segmentProfiles) {\n    seqRanges.add(profile.buildSequenceRange());\n  }\n  return seqRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> ranges = new ArrayList<>();\n  if (_isSegmentAtFirstSegment) {\n    ranges.add(new SequenceRange(_startSegment, _endSegment));\n  } else {\n    ranges.add(new SequenceRange(_startSegment, _startSegment + 1));\n  }\n  if (_isSegmentAtLastSegment) {\n    ranges.add(new SequenceRange(_endSegment, _endSegment + 1));\n  } else {\n    ranges.add(new SequenceRange(_endSegment, _endSegment + 1));\n  }\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> seqRanges = new ArrayList<>();\n  for (int i = 0; i < currentProfiles.size(); i++) {\n    Profile currentProfile = currentProfiles.get(i);\n    seqRanges.add(new SequenceRange(currentProfile.getStartTime(), currentProfile.getEndTime()));\n  }\n  return seqRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> sequenceRanges = new ArrayList<>();\n  List<ProfileSegmentSnapshot> profileSegmentSnapshots = this.profileSegmentSnapshots;\n  for (ProfileSegmentSnapshot profileSegmentSnapshot : profileSegmentSnapshots) {\n    if (profileSegmentSnapshot.getSequenceRanges() != null) {\n      sequenceRanges.addAll(profileSegmentSnapshot.getSequenceRanges());\n    }\n  }\n  return sequenceRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> ranges = new ArrayList<>();\n  for (Segment segment : this.getSegments()) {\n    ranges.add(segment.buildSequenceRange());\n  }\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> ranges = new ArrayList<>();\n  for (String key : keySet()) {\n    SequenceRange range = keyToSequenceRange.get(key);\n    if (range == null) {\n      range = new SequenceRange(0, 0);\n    }\n    ranges.add(range);\n  }\n  Collections.sort(\n      ranges,\n      new Comparator<SequenceRange>() {\n        @Override\n        public int compare(SequenceRange o1, SequenceRange o2) {\n          return Integer.compare(o1.end, o2.end);\n        }\n      });\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  if (profiles == null || profiles.isEmpty()) {\n    return Collections.emptyList();\n  }\n  List<SequenceRange> ranges = new ArrayList<>();\n  Map<String, Long> profileSeqs = new HashMap<>();\n  for (String profile : profiles) {\n    profileSeqs.put(profile, 0L);\n  }\n  for (String profile : profiles) {\n    profileSeqs.put(profile, profileSeqs.get(profile) + 1);\n  }\n  for (String profile : profiles) {\n    long profileSeq = profileSeqs.get(profile);\n    if (profileSeq > 0) {\n      long start = Math.max(0L, profileSeq - 1);\n      long end = Math.min(profileSeq + 1, profileSeqs.size());\n      ranges.add(new SequenceRange(start, end));\n    }\n  }\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> ranges = new ArrayList<SequenceRange>();\n  int i = 0;\n  while (i < this.profiles.size() - 1) {\n    if (this.profiles.get(i).getStartTime() >= this.profiles.get(i + 1).getEndTime()) {\n      ranges.add(new SequenceRange(this.profiles.get(i), this.profiles.get(i + 1)));\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> seqRanges = new ArrayList<SequenceRange>();\n  int start = 0;\n  int end = 0;\n  for (int i = 0; i < mProfiles.size(); i++) {\n    Profile profile = mProfiles.get(i);\n    if (profile.getStart() >= start) {\n      start = profile.getStart();\n      end = profile.getEnd();\n    }\n    if (profile.getEnd() <= end) {\n      seqRanges.add(new SequenceRange(start, end));\n      start = end + 1;\n      end = end + 1;\n    }\n  }\n  seqRanges.add(new SequenceRange(start, end));\n  return seqRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> ranges = new ArrayList<SequenceRange>();\n  if (currentProfile.getName().equals(\"\")) {\n    ranges.add(SequenceRange.create(currentProfile.getStart(), currentProfile.getStart()));\n  } else {\n    ranges.add(\n        SequenceRange.create(\n            currentProfile.getStart(), getNextSegmentStart(currentProfile.getName())));\n  }\n  if (currentProfile.getName().equals(\"\")) {\n    ranges.add(SequenceRange.create(currentProfile.getEnd(), currentProfile.getEnd()));\n  } else {\n    ranges.add(\n        SequenceRange.create(\n            getNextSegmentStart(currentProfile.getName()), currentProfile.getEnd()));\n  }\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * build current profiles segment snapshot search sequence ranges\n */\n", "method_name": "buildSequenceRanges", "codes": ["public List<SequenceRange> buildSequenceRanges(){ if (segmentProfiles.isEmpty()) { return Collections.emptyList(); } List<SequenceRange> seqRanges = new ArrayList<>(segmentProfiles.size()); for (SegmentProfile profile : segmentProfiles) { seqRanges.add(profile.buildSequenceRange()); } return seqRanges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> ranges = new ArrayList<>(); if (_isSegmentAtFirstSegment) { ranges.add(new SequenceRange(_startSegment, _endSegment)); } else { ranges.add(new SequenceRange(_startSegment, _startSegment + 1)); } if (_isSegmentAtLastSegment) { ranges.add(new SequenceRange(_endSegment, _endSegment + 1)); } else { ranges.add(new SequenceRange(_endSegment, _endSegment + 1)); } return ranges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> seqRanges = new ArrayList<>(); for (int i = 0; i < currentProfiles.size(); i++) { Profile currentProfile = currentProfiles.get(i); seqRanges.add(new SequenceRange(currentProfile.getStartTime(), currentProfile.getEndTime())); } return seqRanges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> sequenceRanges = new ArrayList<>(); List<ProfileSegmentSnapshot> profileSegmentSnapshots = this.profileSegmentSnapshots; for (ProfileSegmentSnapshot profileSegmentSnapshot : profileSegmentSnapshots) { if (profileSegmentSnapshot.getSequenceRanges() != null) { sequenceRanges.addAll(profileSegmentSnapshot.getSequenceRanges()); } } return sequenceRanges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> ranges = new ArrayList<>(); for (Segment segment : this.getSegments()) { ranges.add(segment.buildSequenceRange()); } return ranges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> ranges = new ArrayList<>(); for (String key : keySet()) { SequenceRange range = keyToSequenceRange.get(key); if (range == null) { range = new SequenceRange(0, 0); } ranges.add(range); } Collections.sort(ranges, new Comparator<SequenceRange>() { @Override public int compare(SequenceRange o1, SequenceRange o2) { return Integer.compare(o1.end, o2.end); } }); return ranges; }", "public List<SequenceRange> buildSequenceRanges(){ if (profiles == null || profiles.isEmpty()) { return Collections.emptyList(); } List<SequenceRange> ranges = new ArrayList<>(); Map<String, Long> profileSeqs = new HashMap<>(); for (String profile : profiles) { profileSeqs.put(profile, 0L); } for (String profile : profiles) { profileSeqs.put(profile, profileSeqs.get(profile) + 1); } for (String profile : profiles) { long profileSeq = profileSeqs.get(profile); if (profileSeq > 0) { long start = Math.max(0L, profileSeq - 1); long end = Math.min(profileSeq + 1, profileSeqs.size()); ranges.add(new SequenceRange(start, end)); } } return ranges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> ranges = new ArrayList<SequenceRange>(); int i = 0; while (i < this.profiles.size() - 1) { if (this.profiles.get(i).getStartTime() >= this.profiles.get(i + 1).getEndTime()) { ranges.add(new SequenceRange(this.profiles.get(i), this.profiles.get(i + 1))); i++; } else { i++; } } return ranges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> seqRanges = new ArrayList<SequenceRange>(); int start = 0; int end = 0; for (int i = 0; i < mProfiles.size(); i++) { Profile profile = mProfiles.get(i); if (profile.getStart() >= start) { start = profile.getStart(); end = profile.getEnd(); } if (profile.getEnd() <= end) { seqRanges.add(new SequenceRange(start, end)); start = end + 1; end = end + 1; } } seqRanges.add(new SequenceRange(start, end)); return seqRanges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> ranges = new ArrayList<SequenceRange>(); if (currentProfile.getName().equals(\"\")) { ranges.add(SequenceRange.create(currentProfile.getStart(), currentProfile.getStart())); } else { ranges.add(SequenceRange.create(currentProfile.getStart(), getNextSegmentStart(currentProfile.getName()))); } if (currentProfile.getName().equals(\"\")) { ranges.add(SequenceRange.create(currentProfile.getEnd(), currentProfile.getEnd())); } else { ranges.add(SequenceRange.create(getNextSegmentStart(currentProfile.getName()), currentProfile.getEnd())); } return ranges; }"], "code_level": "class_runnable", "_id": "636767de1a6d9265ec018726", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  String fileContents = FileUtils.readFileToString(file);\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n  String[] threadSnapshotsAsStrings = fileContents.split(\"\\n\");\n  for (String threadSnapshotsAsString : threadSnapshotsAsStrings) {\n    String[] threadSnapshotStrings = threadSnapshotsAsString.split(\",\");\n    ProfileAnalyzeTimeRange timeRange = timeRanges.get(0);\n    if (threadSnapshotStrings.length != timeRange.getMinimum().length\n        || threadSnapshotStrings.length != timeRange.getMaximum().length) {\n      throw new IllegalArgumentException(\n          \"Wrong number of thread snapshots, expected \"\n              + threadSnapshotsAsStrings.length\n              + \", got \"\n              + threadSnapshotStrings.length\n              + \" \"\n              + timeRange.toString());\n    }\n    for (int i = 0; i < threadSnapshotStrings.length; i++) {\n      String threadSnapshotString = threadSnapshotStrings[i];\n      String[] threadSnapshotSplit = threadSnapshotString.split(\":\");\n      if (threadSnapshotSplit.length != 2) {\n        throw new IllegalArgumentException(\n            \"Wrong number of thread snapshots, expected \"\n                + threadSnapshotStrings.length\n                + \", got \"\n                + threadSnapshotStrings.length\n                + \" \"\n                + timeRange.toString());\n      }\n      int threadSnapshotId = Integer.parseInt(threadSnapshotSplit[0]);\n      int startTime = Integer.parseInt(threadSnapshotSplit[1]);\n      if (startTime <= 0 || startTime >= timeRange.getMaximum()[i]) {\n        throw new IllegalArgumentException(\n            \"Thread snapshot \"\n                + threadSnapshotId\n                + \" has invalid start time \"\n                + startTime\n                + \". It must be between \"\n                + timeRange.getMinimum()[i]\n                + \" and \"\n                + timeRange.getMaximum()[i]\n                + \" \"\n                + timeRange.toString());\n      }\n      int endTime = Integer.parseInt(threadSnapshotSplit[0]);\n      if (endTime <= 0 || endTime >= timeRange.getMinimum()[i]) {\n        throw new IllegalArgumentException(\n            \"Thread snapshot \"\n                + threadSnapshotId\n                + \" has invalid end time \"\n                + endTime\n                + \". It must be between \"\n                + timeRange.getMinimum()[i]\n                + \" and \"\n                + timeRange.getMaximum()[i]\n                + \" \"\n                + timeRange.toString());\n      }\n    }\n    threadSnapshots.add(\n        new ThreadSnapshot(\n            timeRange.getMinimum()[0],\n            timeRange.getMinimum()[1],\n            timeRange.getMaximum()[0],\n            timeRange.getMaximum()[1],\n            threadSnapshotId));\n  }\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  return parseFromFile(file, timeRanges, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<>();\n  BufferedReader reader = new BufferedReader(new FileReader(file));\n  String line;\n  String[] split;\n  ProfileAnalyzeTimeRange timeRange;\n  while ((line = reader.readLine()) != null) {\n    split = line.split(\"\\t\");\n    if (split.length < 4) {\n      continue;\n    }\n    timeRange = new ProfileAnalyzeTimeRange(split[0], split[1], split[2], split[3]);\n    if (timeRanges.contains(timeRange)) {\n      threadSnapshots.add(new ThreadSnapshot(timeRange));\n    }\n  }\n  reader.close();\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  BufferedReader reader = new BufferedReader(new FileReader(file));\n  String line = reader.readLine();\n  if (line == null) {\n    throw new IOException(\"Invalid file format\");\n  }\n  String[] split = line.split(\"\\\\s+\");\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>(timeRanges.size());\n  for (ProfileAnalyzeTimeRange timeRange : timeRanges) {\n    threadSnapshots.add(parseFromFileWithTimeRange(file, split, timeRange));\n  }\n  reader.close();\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n    String line = null;\n    String[] fields = null;\n    List<ThreadSnapshot> threads = new ArrayList<>();\n    while ((line = reader.readLine()) != null) {\n      if (line.isEmpty()) {\n        continue;\n      }\n      fields = line.split(\"\\\\s+\");\n      if (fields.length != 4) {\n        throw new IllegalArgumentException(\n            \"line \"\n                + line\n                + \" is not of the expected format: \"\n                + \"threads: thread name, thread id, thread start time, thread end time, \"\n                + \"thread snapshots\");\n      }\n      ProfileAnalyzeTimeRange timeRange = timeRanges.get(Integer.parseInt(fields[0]));\n      if (timeRange == null) {\n        throw new IllegalArgumentException(\"unknown time range: \" + fields[0]);\n      }\n      threads.add(new ThreadSnapshot(fields[1], fields[2], Long.parseLong(fields[3]), timeRange));\n    }\n    return threads;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  List<ThreadSnapshot> snapshots = new ArrayList<ThreadSnapshot>();\n  BufferedReader br = new BufferedReader(new FileReader(file));\n  String line;\n  while ((line = br.readLine()) != null) {\n    String[] arr = line.split(\"\\t\");\n    if (arr.length != 3) {\n      System.err.println(\"error: bad line: \" + line);\n      continue;\n    }\n    String timeRange = arr[0];\n    ProfileAnalyzeTimeRange timeRangeInfo = new ProfileAnalyzeTimeRange(timeRange);\n    timeRanges.add(timeRangeInfo);\n    if (arr[2].equals(\"true\")) {\n      snapshots.add(new ThreadSnapshot(timeRangeInfo, arr[1]));\n    }\n  }\n  br.close();\n  return snapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  StringBuilder sb = new StringBuilder();\n  BufferedReader br = new BufferedReader(new FileReader(file));\n  String line;\n  while ((line = br.readLine()) != null) {\n    sb.append(line);\n  }\n  br.close();\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<>();\n  String[] threads = sb.toString().split(\"\\\\|\");\n  for (String thread : threads) {\n    String[] threadSnapshot = thread.split(\",\");\n    ProfileAnalyzeTimeRange timeRange = timeRanges.get(Integer.parseInt(threadSnapshot[0]));\n    if (timeRange != null) {\n      threadSnapshots.add(new ThreadSnapshot(timeRange, Long.parseLong(threadSnapshot[1])));\n    }\n  }\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<>();\n  try (BufferedReader bufferedReader = new BufferedReader(new FileReader(file))) {\n    String line;\n    while ((line = bufferedReader.readLine()) != null) {\n      String[] values = line.split(\",\");\n      long time = Long.parseLong(values[0]);\n      ProfileAnalyzeTimeRange profileAnalyzeTimeRange = timeRanges.get(Long.parseLong(values[1]));\n      if (profileAnalyzeTimeRange == null) {\n        profileAnalyzeTimeRange = new ProfileAnalyzeTimeRange();\n        profileAnalyzeTimeRange.setTime(time);\n        profileAnalyzeTimeRange.setAnalyzed(false);\n      }\n      profileAnalyzeTimeRange.addValue(time);\n      threadSnapshots.add(new ThreadSnapshot(time, profileAnalyzeTimeRange.getAnalyzed()));\n    }\n  }\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  BufferedReader br = new BufferedReader(new FileReader(file));\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<>();\n  String line = br.readLine();\n  while (line != null) {\n    String[] split = line.split(\"\\t\");\n    ProfileAnalyzeTimeRange timeRange = ProfileAnalyzeTimeRange.parseFromString(split[0]);\n    if (timeRange != null) {\n      timeRanges.add(timeRange);\n    } else {\n      System.err.println(\"line: \" + line);\n      System.err.println(\"split: \" + split);\n      System.err.println(\"timeRange: \" + timeRange);\n      System.err.println(\"split length: \" + split.length);\n      System.err.println(\"timeRange length: \" + timeRange.getSplit().length);\n      System.err.println(\"split[0]: \" + split[0]);\n      System.err.println(\"split[1]: \" + split[1]);\n    }\n    line = br.readLine();\n  }\n  br.close();\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<>();\n  if (file == null || !file.exists()) {\n    return threadSnapshots;\n  }\n  BufferedReader reader = new BufferedReader(new FileReader(file));\n  String line = null;\n  while ((line = reader.readLine()) != null) {\n    String[] str = line.split(\",\");\n    if (str.length != 5) {\n      throw new IllegalArgumentException(\"file format error:\" + file.getPath() + \" line:\" + line);\n    }\n    ProfileAnalyzeTimeRange timeRange =\n        new ProfileAnalyzeTimeRange(str[0], str[1], str[2], str[3], str[4]);\n    if (timeRanges.contains(timeRange)) {\n      continue;\n    }\n    threadSnapshots.add(new ThreadSnapshot(timeRange));\n    timeRanges.add(timeRange);\n  }\n  reader.close();\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * load thread snapshots in appointing time range\n */\n", "method_name": "parseFromFileWithTimeRange", "codes": ["public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { String fileContents = FileUtils.readFileToString(file); List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>(); String[] threadSnapshotsAsStrings = fileContents.split(\"\\n\"); for (String threadSnapshotsAsString : threadSnapshotsAsStrings) { String[] threadSnapshotStrings = threadSnapshotsAsString.split(\",\"); ProfileAnalyzeTimeRange timeRange = timeRanges.get(0); if (threadSnapshotStrings.length != timeRange.getMinimum().length || threadSnapshotStrings.length != timeRange.getMaximum().length) { throw new IllegalArgumentException(\"Wrong number of thread snapshots, expected \" + threadSnapshotsAsStrings.length + \", got \" + threadSnapshotStrings.length + \" \" + timeRange.toString()); } for (int i = 0; i < threadSnapshotStrings.length; i++) { String threadSnapshotString = threadSnapshotStrings[i]; String[] threadSnapshotSplit = threadSnapshotString.split(\":\"); if (threadSnapshotSplit.length != 2) { throw new IllegalArgumentException(\"Wrong number of thread snapshots, expected \" + threadSnapshotStrings.length + \", got \" + threadSnapshotStrings.length + \" \" + timeRange.toString()); } int threadSnapshotId = Integer.parseInt(threadSnapshotSplit[0]); int startTime = Integer.parseInt(threadSnapshotSplit[1]); if (startTime <= 0 || startTime >= timeRange.getMaximum()[i]) { throw new IllegalArgumentException(\"Thread snapshot \" + threadSnapshotId + \" has invalid start time \" + startTime + \". It must be between \" + timeRange.getMinimum()[i] + \" and \" + timeRange.getMaximum()[i] + \" \" + timeRange.toString()); } int endTime = Integer.parseInt(threadSnapshotSplit[0]); if (endTime <= 0 || endTime >= timeRange.getMinimum()[i]) { throw new IllegalArgumentException(\"Thread snapshot \" + threadSnapshotId + \" has invalid end time \" + endTime + \". It must be between \" + timeRange.getMinimum()[i] + \" and \" + timeRange.getMaximum()[i] + \" \" + timeRange.toString()); } } threadSnapshots.add(new ThreadSnapshot(timeRange.getMinimum()[0], timeRange.getMinimum()[1], timeRange.getMaximum()[0], timeRange.getMaximum()[1], threadSnapshotId)); } return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { return parseFromFile(file, timeRanges, true); }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { List<ThreadSnapshot> threadSnapshots = new ArrayList<>(); BufferedReader reader = new BufferedReader(new FileReader(file)); String line; String[] split; ProfileAnalyzeTimeRange timeRange; while ((line = reader.readLine()) != null) { split = line.split(\"\\t\"); if (split.length < 4) { continue; } timeRange = new ProfileAnalyzeTimeRange(split[0], split[1], split[2], split[3]); if (timeRanges.contains(timeRange)) { threadSnapshots.add(new ThreadSnapshot(timeRange)); } } reader.close(); return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(file)); String line = reader.readLine(); if (line == null) { throw new IOException(\"Invalid file format\"); } String[] split = line.split(\"\\\\s+\"); List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>(timeRanges.size()); for (ProfileAnalyzeTimeRange timeRange : timeRanges) { threadSnapshots.add(parseFromFileWithTimeRange(file, split, timeRange)); } reader.close(); return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { try (BufferedReader reader = new BufferedReader(new FileReader(file))) { String line = null; String[] fields = null; List<ThreadSnapshot> threads = new ArrayList<>(); while ((line = reader.readLine()) != null) { if (line.isEmpty()) { continue; } fields = line.split(\"\\\\s+\"); if (fields.length != 4) { throw new IllegalArgumentException(\"line \" + line + \" is not of the expected format: \" + \"threads: thread name, thread id, thread start time, thread end time, \" + \"thread snapshots\"); } ProfileAnalyzeTimeRange timeRange = timeRanges.get(Integer.parseInt(fields[0])); if (timeRange == null) { throw new IllegalArgumentException(\"unknown time range: \" + fields[0]); } threads.add(new ThreadSnapshot(fields[1], fields[2], Long.parseLong(fields[3]), timeRange)); } return threads; } }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { List<ThreadSnapshot> snapshots = new ArrayList<ThreadSnapshot>(); BufferedReader br = new BufferedReader(new FileReader(file)); String line; while ((line = br.readLine()) != null) { String[] arr = line.split(\"\\t\"); if (arr.length != 3) { System.err.println(\"error: bad line: \" + line); continue; } String timeRange = arr[0]; ProfileAnalyzeTimeRange timeRangeInfo = new ProfileAnalyzeTimeRange(timeRange); timeRanges.add(timeRangeInfo); if (arr[2].equals(\"true\")) { snapshots.add(new ThreadSnapshot(timeRangeInfo, arr[1])); } } br.close(); return snapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { StringBuilder sb = new StringBuilder(); BufferedReader br = new BufferedReader(new FileReader(file)); String line; while ((line = br.readLine()) != null) { sb.append(line); } br.close(); List<ThreadSnapshot> threadSnapshots = new ArrayList<>(); String[] threads = sb.toString().split(\"\\\\|\"); for (String thread : threads) { String[] threadSnapshot = thread.split(\",\"); ProfileAnalyzeTimeRange timeRange = timeRanges.get(Integer.parseInt(threadSnapshot[0])); if (timeRange != null) { threadSnapshots.add(new ThreadSnapshot(timeRange, Long.parseLong(threadSnapshot[1]))); } } return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { List<ThreadSnapshot> threadSnapshots = new ArrayList<>(); try (BufferedReader bufferedReader = new BufferedReader(new FileReader(file))) { String line; while ((line = bufferedReader.readLine()) != null) { String[] values = line.split(\",\"); long time = Long.parseLong(values[0]); ProfileAnalyzeTimeRange profileAnalyzeTimeRange = timeRanges.get(Long.parseLong(values[1])); if (profileAnalyzeTimeRange == null) { profileAnalyzeTimeRange = new ProfileAnalyzeTimeRange(); profileAnalyzeTimeRange.setTime(time); profileAnalyzeTimeRange.setAnalyzed(false); } profileAnalyzeTimeRange.addValue(time); threadSnapshots.add(new ThreadSnapshot(time, profileAnalyzeTimeRange.getAnalyzed())); } } return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { BufferedReader br = new BufferedReader(new FileReader(file)); List<ThreadSnapshot> threadSnapshots = new ArrayList<>(); String line = br.readLine(); while (line != null) { String[] split = line.split(\"\\t\"); ProfileAnalyzeTimeRange timeRange = ProfileAnalyzeTimeRange.parseFromString(split[0]); if (timeRange != null) { timeRanges.add(timeRange); } else { System.err.println(\"line: \" + line); System.err.println(\"split: \" + split); System.err.println(\"timeRange: \" + timeRange); System.err.println(\"split length: \" + split.length); System.err.println(\"timeRange length: \" + timeRange.getSplit().length); System.err.println(\"split[0]: \" + split[0]); System.err.println(\"split[1]: \" + split[1]); } line = br.readLine(); } br.close(); return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { List<ThreadSnapshot> threadSnapshots = new ArrayList<>(); if (file == null || !file.exists()) { return threadSnapshots; } BufferedReader reader = new BufferedReader(new FileReader(file)); String line = null; while ((line = reader.readLine()) != null) { String[] str = line.split(\",\"); if (str.length != 5) { throw new IllegalArgumentException(\"file format error:\" + file.getPath() + \" line:\" + line); } ProfileAnalyzeTimeRange timeRange = new ProfileAnalyzeTimeRange(str[0], str[1], str[2], str[3], str[4]); if (timeRanges.contains(timeRange)) { continue; } threadSnapshots.add(new ThreadSnapshot(timeRange)); timeRanges.add(timeRange); } reader.close(); return threadSnapshots; }"], "code_level": "project_runnable", "_id": "636767e11a6d9265ec018790", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair keyStringValuePair : properties) { if (keyStringValuePair.getKey().equals(\"name\")) { jsonObject.addProperty(\"name\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"description\")) { jsonObject.addProperty(\"description\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"type\")) { jsonObject.addProperty(\"type\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"version\")) { jsonObject.addProperty(\"version\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"status\")) { jsonObject.addProperty(\"status\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"required\")) { jsonObject.addProperty(\"required\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValue\")) { jsonObject.addProperty(\"defaultValue\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormat\")) { jsonObject.addProperty(\"defaultValueFormat\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatMessage\")) { jsonObject.addProperty(\"defaultValueFormatMessage\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatParams\")) { jsonObject.addProperty(\"defaultValueFormatParams\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatParamsMessage\")) { jsonObject.addProperty(\"defaultValueFormatParamsMessage\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatSequence\")) { jsonObject.addProperty(\"defaultValueFormatSequence\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatSequenceMessage\")) { jsonObject.addProperty(\"defaultValueFormatSequenceMessage\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatSequenceParams\")) { jsonObject.addProperty(\"defaultValueFormatSequenceParams\", keyStringValuePair.getValue()); } else if (keyStr", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject result = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    JsonObject propertyValue = new JsonObject();\n    propertyValue.addProperty(\"key\", property.getKey());\n    propertyValue.addProperty(\"value\", property.getValue());\n    result.add(property.getKey(), propertyValue);\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonObject = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    jsonObject.addProperty(property.getKey(), property.getValue());\n  }\n  return jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject json = new JsonObject();\n  for (KeyStringValuePair pair : properties) {\n    json.addProperty(pair.getKey(), pair.getValue());\n  }\n  return json;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject json = new JsonObject();\n  for (KeyStringValuePair pair : properties) {\n    json.add(pair.getKey(), pair.getValue());\n  }\n  return json;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject json = new JsonObject(); json.addProperty(\"id\", id); json.addProperty(\"name\", name); json.addProperty(\"description\", description); json.addProperty(\"is_default\", isDefault); json.addProperty(\"process_type_id\", processTypeId); json.addProperty(\"process_type_name\", processTypeName); json.addProperty(\"process_type_description\", processTypeDescription); json.addProperty(\"process_type_details\", processTypeDetails); json.addProperty(\"process_type_version\", processTypeVersion); json.addProperty(\"process_type_snapshot_id\", processTypeSnapshotId); json.addProperty(\"process_type_snapshot_name\", processTypeSnapshotName); json.addProperty(\"process_type_snapshot_description\", processTypeSnapshotDescription); json.addProperty(\"process_type_snapshot_details\", processTypeSnapshotDetails); json.addProperty(\"process_type_snapshot_version\", processTypeSnapshotVersion); json.addProperty(\"process_type_snapshot_snapshot_id\", processTypeSnapshotSnapshotId); json.addProperty(\"process_type_snapshot_snapshot_name\", processTypeSnapshotSnapshotName); json.addProperty(\"process_type_snapshot_snapshot_description\", processTypeSnapshotSnapshotDescription); json.addProperty(\"process_type_snapshot_snapshot_details\", processTypeSnapshotSnapshotDetails); json.addProperty(\"process_type_snapshot_snapshot_version\", processTypeSnapshotSnapshotVersion); json.addProperty(\"process_type_snapshot_snapshot_snapshot_id\", processTypeSnapshotSnapshotSnapshotId); json.addProperty(\"process_type_snapshot_snapshot_snapshot_name\", processTypeSnapshotSnapshotSnapshotName); json.addProperty(\"process_type_snapshot_snapshot_snapshot_description\", processTypeSnapshotSnapshotSnapshotDescription); json.addProperty(\"process_type_snapshot_snapshot_snapshot_details\", processTypeSnapshotSnapshotSnapshotDetails); json.addProperty(\"process_type_snapshot_snapshot_version\", processTypeSnapshotSnapshotVersion); json.addProperty(\"process_type_snapshot_snapshot_snapshot_snapshot_id\", processTypeSnapshotSnapshotSnapshotSnapshotId); json.addProperty(\"process_type_snapshot_snapshot_snapshot_snapshot_name\", processTypeSnapshotSnapshotSnapshotSnapshotName); json.addProperty(\"process_type_snapshot_snapshot_snapshot_snapshot_description\", processTypeSnapshotSnapshotSnapshotSnapshotDescription); json.addProperty(\"process_type_snapshot_snapshot_snapshot_snapshot_details\", processTypeSnapshotSnapshotSnapshotSnapshotDetails); json.addProperty(\"process_type_snapshot_snapshot_snapshot_version\", processTypeSnapshotSnapshotSnapshotVersion); j", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject json = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    json.addProperty(property.getKey(), property.getValue());\n  }\n  return json;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonObject = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    if (property.getKey().equals(\"Process\")) {\n      jsonObject.addProperty(\"processId\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessDefinitionKey\")) {\n      jsonObject.addProperty(\"processDefinitionKey\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessDefinitionId\")) {\n      jsonObject.addProperty(\"processDefinitionId\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessDefinitionName\")) {\n      jsonObject.addProperty(\"processDefinitionName\", property.getValue());\n    } else if (property.getKey().equals(\"DeploymentId\")) {\n      jsonObject.addProperty(\"deploymentId\", property.getValue());\n    } else if (property.getKey().equals(\"DeploymentName\")) {\n      jsonObject.addProperty(\"deploymentName\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessInstanceId\")) {\n      jsonObject.addProperty(\"processInstanceId\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessInstanceName\")) {\n      jsonObject.addProperty(\"processInstanceName\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessDefinitionVersion\")) {\n      jsonObject.addProperty(\"processDefinitionVersion\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessDefinitionVersionInteger\")) {\n      jsonObject.addProperty(\"processDefinitionVersionInteger\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessDefinitionVersionDate\")) {\n      jsonObject.addProperty(\"processDefinitionVersionDate\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessDefinitionVersionByte\")) {\n      jsonObject.addProperty(\"processDefinitionVersionByte\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessDefinitionVersionString\")) {\n      jsonObject.addProperty(\"processDefinitionVersionString\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessDefinitionVersionTimestamp\")) {\n      jsonObject.addProperty(\"processDefinitionVersionTimestamp\", property.getValue());\n    } else if (property.getKey().equals(\"ProcessDefinitionVersionDateTime\")) {\n      jsonObject.addProperty(\"processDefinitionVersionDateTime\", property.getValue());\n    } else if (property.getKey().equals(\"TenantId\")) {\n      jsonObject.addProperty(\"tenantId\", property.getValue());\n    }\n  }\n  return jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonProperties = new JsonObject();\n  for (KeyStringValuePair keyValuePair : properties) {\n    JsonObject property = new JsonObject();\n    property.put(\"key\", keyValuePair.getKey());\n    property.put(\"value\", keyValuePair.getValue());\n    jsonProperties.add(keyValuePair.getKey(), property);\n  }\n  return jsonProperties;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonObject = new JsonObject();\n  for (KeyStringValuePair keyStringValuePair : properties) {\n    jsonObject.addProperty(keyStringValuePair.getKey(), keyStringValuePair.getValue());\n  }\n  return jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Convert process properties to source data\n */\n", "method_name": "convertProperties", "codes": ["private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair keyStringValuePair : properties) { if (keyStringValuePair.getKey().equals(\"name\")) { jsonObject.addProperty(\"name\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"description\")) { jsonObject.addProperty(\"description\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"type\")) { jsonObject.addProperty(\"type\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"version\")) { jsonObject.addProperty(\"version\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"status\")) { jsonObject.addProperty(\"status\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"required\")) { jsonObject.addProperty(\"required\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValue\")) { jsonObject.addProperty(\"defaultValue\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormat\")) { jsonObject.addProperty(\"defaultValueFormat\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatMessage\")) { jsonObject.addProperty(\"defaultValueFormatMessage\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatParams\")) { jsonObject.addProperty(\"defaultValueFormatParams\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatParamsMessage\")) { jsonObject.addProperty(\"defaultValueFormatParamsMessage\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatSequence\")) { jsonObject.addProperty(\"defaultValueFormatSequence\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatSequenceMessage\")) { jsonObject.addProperty(\"defaultValueFormatSequenceMessage\", keyStringValuePair.getValue()); } else if (keyStringValuePair.getKey().equals(\"defaultValueFormatSequenceParams\")) { jsonObject.addProperty(\"defaultValueFormatSequenceParams\", keyStringValuePair.getValue()); } else if (keyStr", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject result = new JsonObject(); for (KeyStringValuePair property : properties) { JsonObject propertyValue = new JsonObject(); propertyValue.addProperty(\"key\", property.getKey()); propertyValue.addProperty(\"value\", property.getValue()); result.add(property.getKey(), propertyValue); } return result; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair property : properties) { jsonObject.addProperty(property.getKey(), property.getValue()); } return jsonObject; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject json = new JsonObject(); for (KeyStringValuePair pair : properties) { json.addProperty(pair.getKey(), pair.getValue()); } return json; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject json = new JsonObject(); for (KeyStringValuePair pair : properties) { json.add(pair.getKey(), pair.getValue()); } return json; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject json = new JsonObject(); json.addProperty(\"id\", id); json.addProperty(\"name\", name); json.addProperty(\"description\", description); json.addProperty(\"is_default\", isDefault); json.addProperty(\"process_type_id\", processTypeId); json.addProperty(\"process_type_name\", processTypeName); json.addProperty(\"process_type_description\", processTypeDescription); json.addProperty(\"process_type_details\", processTypeDetails); json.addProperty(\"process_type_version\", processTypeVersion); json.addProperty(\"process_type_snapshot_id\", processTypeSnapshotId); json.addProperty(\"process_type_snapshot_name\", processTypeSnapshotName); json.addProperty(\"process_type_snapshot_description\", processTypeSnapshotDescription); json.addProperty(\"process_type_snapshot_details\", processTypeSnapshotDetails); json.addProperty(\"process_type_snapshot_version\", processTypeSnapshotVersion); json.addProperty(\"process_type_snapshot_snapshot_id\", processTypeSnapshotSnapshotId); json.addProperty(\"process_type_snapshot_snapshot_name\", processTypeSnapshotSnapshotName); json.addProperty(\"process_type_snapshot_snapshot_description\", processTypeSnapshotSnapshotDescription); json.addProperty(\"process_type_snapshot_snapshot_details\", processTypeSnapshotSnapshotDetails); json.addProperty(\"process_type_snapshot_snapshot_version\", processTypeSnapshotSnapshotVersion); json.addProperty(\"process_type_snapshot_snapshot_snapshot_id\", processTypeSnapshotSnapshotSnapshotId); json.addProperty(\"process_type_snapshot_snapshot_snapshot_name\", processTypeSnapshotSnapshotSnapshotName); json.addProperty(\"process_type_snapshot_snapshot_snapshot_description\", processTypeSnapshotSnapshotSnapshotDescription); json.addProperty(\"process_type_snapshot_snapshot_snapshot_details\", processTypeSnapshotSnapshotSnapshotDetails); json.addProperty(\"process_type_snapshot_snapshot_version\", processTypeSnapshotSnapshotVersion); json.addProperty(\"process_type_snapshot_snapshot_snapshot_snapshot_id\", processTypeSnapshotSnapshotSnapshotSnapshotId); json.addProperty(\"process_type_snapshot_snapshot_snapshot_snapshot_name\", processTypeSnapshotSnapshotSnapshotSnapshotName); json.addProperty(\"process_type_snapshot_snapshot_snapshot_snapshot_description\", processTypeSnapshotSnapshotSnapshotSnapshotDescription); json.addProperty(\"process_type_snapshot_snapshot_snapshot_snapshot_details\", processTypeSnapshotSnapshotSnapshotSnapshotDetails); json.addProperty(\"process_type_snapshot_snapshot_snapshot_version\", processTypeSnapshotSnapshotSnapshotVersion); j", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject json = new JsonObject(); for (KeyStringValuePair property : properties) { json.addProperty(property.getKey(), property.getValue()); } return json; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair property : properties) { if (property.getKey().equals(\"Process\")) { jsonObject.addProperty(\"processId\", property.getValue()); } else if (property.getKey().equals(\"ProcessDefinitionKey\")) { jsonObject.addProperty(\"processDefinitionKey\", property.getValue()); } else if (property.getKey().equals(\"ProcessDefinitionId\")) { jsonObject.addProperty(\"processDefinitionId\", property.getValue()); } else if (property.getKey().equals(\"ProcessDefinitionName\")) { jsonObject.addProperty(\"processDefinitionName\", property.getValue()); } else if (property.getKey().equals(\"DeploymentId\")) { jsonObject.addProperty(\"deploymentId\", property.getValue()); } else if (property.getKey().equals(\"DeploymentName\")) { jsonObject.addProperty(\"deploymentName\", property.getValue()); } else if (property.getKey().equals(\"ProcessInstanceId\")) { jsonObject.addProperty(\"processInstanceId\", property.getValue()); } else if (property.getKey().equals(\"ProcessInstanceName\")) { jsonObject.addProperty(\"processInstanceName\", property.getValue()); } else if (property.getKey().equals(\"ProcessDefinitionVersion\")) { jsonObject.addProperty(\"processDefinitionVersion\", property.getValue()); } else if (property.getKey().equals(\"ProcessDefinitionVersionInteger\")) { jsonObject.addProperty(\"processDefinitionVersionInteger\", property.getValue()); } else if (property.getKey().equals(\"ProcessDefinitionVersionDate\")) { jsonObject.addProperty(\"processDefinitionVersionDate\", property.getValue()); } else if (property.getKey().equals(\"ProcessDefinitionVersionByte\")) { jsonObject.addProperty(\"processDefinitionVersionByte\", property.getValue()); } else if (property.getKey().equals(\"ProcessDefinitionVersionString\")) { jsonObject.addProperty(\"processDefinitionVersionString\", property.getValue()); } else if (property.getKey().equals(\"ProcessDefinitionVersionTimestamp\")) { jsonObject.addProperty(\"processDefinitionVersionTimestamp\", property.getValue()); } else if (property.getKey().equals(\"ProcessDefinitionVersionDateTime\")) { jsonObject.addProperty(\"processDefinitionVersionDateTime\", property.getValue()); } else if (property.getKey().equals(\"TenantId\")) { jsonObject.addProperty(\"tenantId\", property.getValue()); } } return jsonObject; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonProperties = new JsonObject(); for (KeyStringValuePair keyValuePair : properties) { JsonObject property = new JsonObject(); property.put(\"key\", keyValuePair.getKey()); property.put(\"value\", keyValuePair.getValue()); jsonProperties.add(keyValuePair.getKey(), property); } return jsonProperties; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair keyStringValuePair : properties) { jsonObject.addProperty(keyStringValuePair.getKey(), keyStringValuePair.getValue()); } return jsonObject; }"], "code_level": "project_runnable", "_id": "636767e01a6d9265ec018764", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private int pop() {\n  int ret = this.outputFrame.pop();\n  this.outputFrame.push(ret);\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  if (outputStack.isEmpty()) {\n    throw new RuntimeException(\"Stack is empty.\");\n  }\n  return outputStack.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  int result = outputStack[outputStackTop];\n  outputStackTop--;\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int pop() {\n  int ret;\n  if (inputStack.size() > 0) {\n    ret = inputStack.pop();\n    if (ret < 0) {\n      throw new RuntimeException(\"Cannot pop an int from the input stack\");\n    }\n  } else {\n    ret = 0;\n  }\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  return output.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  int type = (int) popStack();\n  if (type <= 0) {\n    throw new RuntimeException(\"popping a non-abstract type\");\n  }\n  return type;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  if (outputFrame.size() > 0) {\n    return outputFrame.pop();\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  return outputStack.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  return (int) outputFrame.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  if (outputFrame == null) {\n    throw new RuntimeException(\"Cannot pop a non-existent abstract type.\");\n  }\n  return outputFrame[outputFrameCount - 1];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n", "method_name": "pop", "codes": ["private int pop(){ int ret = this.outputFrame.pop(); this.outputFrame.push(ret); return ret; }", "private int pop(){ if (outputStack.isEmpty()) { throw new RuntimeException(\"Stack is empty.\"); } return outputStack.pop(); }", "private int pop(){ int result = outputStack[outputStackTop]; outputStackTop--; return result; }", "private int pop(){ int ret; if (inputStack.size() > 0) { ret = inputStack.pop(); if (ret < 0) { throw new RuntimeException(\"Cannot pop an int from the input stack\"); } } else { ret = 0; } return ret; }", "private int pop(){ return output.pop(); }", "private int pop(){ int type = (int) popStack(); if (type <= 0) { throw new RuntimeException(\"popping a non-abstract type\"); } return type; }", "private int pop(){ if (outputFrame.size() > 0) { return outputFrame.pop(); } else { return null; } }", "private int pop(){ return outputStack.pop(); }", "private int pop(){ return (int) outputFrame.pop(); }", "private int pop(){ if (outputFrame == null) { throw new RuntimeException(\"Cannot pop a non-existent abstract type.\"); } return outputFrame[outputFrameCount - 1]; }"], "code_level": "self_contained", "_id": "636766a91a6d9265ec0175c2", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  final int frameIndex = currentFrame.init(offset, numLocal, numStack);\n  if (frameIndex == -1) {\n    return -1;\n  }\n  currentFrame.frame[frameIndex] = Frame.OBJECT | Frame.FULL;\n  currentFrame.stackMap = stackMap;\n  stackMap = new int[maxStack];\n  stackMapIndex = currentFrame.init(stackMapIndex);\n  return frameIndex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  this.currentFrame = new Frame(offset, numLocal, numStack);\n  return offset;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  currentFrame = new Frame();\n  currentFrame.offset = offset;\n  currentFrame.numLocal = numLocal;\n  currentFrame.numStack = numStack;\n  return numStack;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  currentFrame.frame = new Frame();\n  currentFrame.frame.offset = offset;\n  currentFrame.frame.numLocals = numLocal;\n  currentFrame.frame.numStack = numStack;\n  return currentFrame.index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  int i = currentFrame;\n  currentFrame = i + 1;\n  int numStackDepth = 0;\n  if (numLocal > 0) {\n    numStackDepth = numLocal + 2;\n  }\n  visitFrameTypes(types);\n  visitFrameLengths(lengths);\n  if (numStack > 0) {\n    if (numStackDepth > 3) {\n      throw new IllegalArgumentException(\"StackMap table too big\");\n    }\n    if (numStackDepth > 1) {\n      numStackDepth = 2;\n    }\n    visitFrameAttrs(new int[] {offset, numLocal, numStack});\n  }\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  currentFrame = new Frame(currentFrame);\n  currentFrame.offset = offset;\n  currentFrame.numLocals = numLocal;\n  currentFrame.numStack = numStack;\n  return currentFrame.index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if ((offset & 3) == 0) {\n    currentFrame.previous = new Frame();\n    currentFrame.previous.offset = offset;\n    currentFrame.previous.numLocals = numLocal;\n    currentFrame.previous.numStack = numStack;\n  } else {\n    currentFrame.stack = new Frame();\n    currentFrame.stack.offset = offset;\n    currentFrame.stack.numLocals = numLocal;\n    currentFrame.stack.numStack = numStack;\n  }\n  return offset;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if (currentFrame == null) {\n    currentFrame = new Frame();\n  }\n  currentFrame.frame = new Object[numStack];\n  currentFrame.offset = offset;\n  currentFrame.count = numLocal + numStack;\n  return numLocal + numStack;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  int i;\n  if ((offset & 3) == 0) {\n    if (numLocal <= 3) {\n      i = nextFrameOffset - offset;\n    } else {\n      i = nextFrameOffset - offset + 4;\n    }\n  } else {\n    if (numLocal <= 3) {\n      i = nextFrameOffset - offset + 1;\n    } else {\n      i = nextFrameOffset - offset + 5;\n    }\n  }\n  currentFrame = new Frame();\n  currentFrame.offset = offset;\n  currentFrame.stack = new Object[numStack];\n  currentFrame.locals = new int[numLocal];\n  currentFrame.stackOffset = 0;\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if (this.currentFrame == null) {\n    this.currentFrame = new Frame(offset, numLocal, numStack);\n  } else {\n    this.currentFrame.visitFrameStart(offset, numLocal, numStack);\n  }\n  return -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.\n * @param offset   the bytecode offset of the instruction to which the frame corresponds.\n * @param numLocal the number of local variables in the frame.\n * @param numStack the number of stack elements in the frame.\n * @return the index of the next element to be written in this frame.\n */\n", "method_name": "visitFrameStart", "codes": ["int visitFrameStart(final int offset,final int numLocal,final int numStack){ final int frameIndex = currentFrame.init(offset, numLocal, numStack); if (frameIndex == -1) { return -1; } currentFrame.frame[frameIndex] = Frame.OBJECT | Frame.FULL; currentFrame.stackMap = stackMap; stackMap = new int[maxStack]; stackMapIndex = currentFrame.init(stackMapIndex); return frameIndex; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ this.currentFrame = new Frame(offset, numLocal, numStack); return offset; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ currentFrame = new Frame(); currentFrame.offset = offset; currentFrame.numLocal = numLocal; currentFrame.numStack = numStack; return numStack; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ currentFrame.frame = new Frame(); currentFrame.frame.offset = offset; currentFrame.frame.numLocals = numLocal; currentFrame.frame.numStack = numStack; return currentFrame.index; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ int i = currentFrame; currentFrame = i + 1; int numStackDepth = 0; if (numLocal > 0) { numStackDepth = numLocal + 2; } visitFrameTypes(types); visitFrameLengths(lengths); if (numStack > 0) { if (numStackDepth > 3) { throw new IllegalArgumentException(\"StackMap table too big\"); } if (numStackDepth > 1) { numStackDepth = 2; } visitFrameAttrs(new int[] { offset, numLocal, numStack }); } return i; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ currentFrame = new Frame(currentFrame); currentFrame.offset = offset; currentFrame.numLocals = numLocal; currentFrame.numStack = numStack; return currentFrame.index; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if ((offset & 3) == 0) { currentFrame.previous = new Frame(); currentFrame.previous.offset = offset; currentFrame.previous.numLocals = numLocal; currentFrame.previous.numStack = numStack; } else { currentFrame.stack = new Frame(); currentFrame.stack.offset = offset; currentFrame.stack.numLocals = numLocal; currentFrame.stack.numStack = numStack; } return offset; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if (currentFrame == null) { currentFrame = new Frame(); } currentFrame.frame = new Object[numStack]; currentFrame.offset = offset; currentFrame.count = numLocal + numStack; return numLocal + numStack; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ int i; if ((offset & 3) == 0) { if (numLocal <= 3) { i = nextFrameOffset - offset; } else { i = nextFrameOffset - offset + 4; } } else { if (numLocal <= 3) { i = nextFrameOffset - offset + 1; } else { i = nextFrameOffset - offset + 5; } } currentFrame = new Frame(); currentFrame.offset = offset; currentFrame.stack = new Object[numStack]; currentFrame.locals = new int[numLocal]; currentFrame.stackOffset = 0; return i; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if (this.currentFrame == null) { this.currentFrame = new Frame(offset, numLocal, numStack); } else { this.currentFrame.visitFrameStart(offset, numLocal, numStack); } return -1; }"], "code_level": "self_contained", "_id": "636766aa1a6d9265ec0175ce", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private void enlarge(final int size) {\n  if (size > bytes.length) {\n    final byte[] tmp = new byte[size];\n    System.arraycopy(bytes, 0, tmp, 0, bytes.length);\n    bytes = tmp;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int newCapacity = capacity + (capacity >> 1);\n  final byte[] newData = new byte[newCapacity];\n  System.arraycopy(data, 0, newData, 0, capacity);\n  data = newData;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] buf = new byte[size];\n  System.arraycopy(data, 0, buf, 0, data.length);\n  data = buf;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] temp = new byte[size];\n  System.arraycopy(buf, 0, temp, 0, size);\n  buf = temp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  if (size > maxByteSize) {\n    throw new IllegalArgumentException(\"size > \" + maxByteSize);\n  }\n  if (size > buf.length) {\n    final byte[] newbuf = new byte[Math.max(buf.length << 1, size)];\n    System.arraycopy(buf, 0, newbuf, 0, buf.length);\n    buf = newbuf;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){ final byte[] buf = new byte[size]; System.arraycopy(buf, 0, buf, 0, buf.length); buf = buf.clone(); buf[size] = 0; buf = buf.clone(); buf[size] |= 0x80; buf = buf.clone(); buf[size] |= 0x40; buf = buf.clone(); buf[size] |= 0x20; buf = buf.clone(); buf[size] |= 0x10; buf = buf.clone(); buf[size] |= 0x08; buf = buf.clone(); buf[size] |= 0x04; buf = buf.clone(); buf[size] |= 0x02; buf = buf.clone(); buf[size] |= 0x01; buf = buf.clone(); buf[size] |= 0x0c; buf = buf.clone(); buf[size] |= 0x0e; buf = buf.clone(); buf[size] |= 0x0f; buf = buf.clone(); buf[size] |= 0x10; buf = buf.clone(); buf[size] |= 0x08; buf = buf.clone(); buf[size] |= 0x04; buf = buf.clone(); buf[size] |= 0x02; buf = buf.clone(); buf[size] |= 0x01; buf = buf.clone(); buf[size] |= 0x0c; buf = buf.clone(); buf[size] |= 0x0e; buf = buf.clone(); buf[size] |= 0x0f; buf = buf.clone(); buf[size] |= 0x10; buf = buf.clone(); buf[size] |= 0x08; buf = buf.clone(); buf[size] |= 0x04; buf = buf.clone(); buf[size] |= 0x02; buf = buf.clone(); buf[size] |= 0x01; buf = buf.clone(); buf[size] |= 0x0c; buf = buf.clone(); buf[size] |= 0x0e; buf = buf.clone(); buf[size] |= 0x0f; buf = buf.clone(); buf[size] |= 0x10; buf = buf.clone(); buf[size] |= 0x08; buf = buf.clone(); buf[size] |= 0x04; buf = buf.clone(); buf[size] |= 0x02; buf = buf.clone(); buf[size] |= 0x01; buf = buf.clone(); buf[size] |= 0x0c; buf = buf.clone(); buf[size] |= 0x0e; buf = buf.clone(); buf[size] |= 0x0f; buf = buf.clone(); buf[size] |= 0x10; buf = buf.clone(); buf[size] |= 0x08; buf = buf.clone(); buf[size] |= 0x04; buf = buf.clone(); buf[size] |= 0x02; buf = buf.clone(); buf[size] |= 0x01; buf = buf.clone(); buf[size]", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int newCapacity = this.capacity + (this.capacity >> 1) + (size >> 1);\n  this.capacity = newCapacity;\n  final byte[] newData = new byte[newCapacity];\n  System.arraycopy(this.data, 0, newData, 0, this.data.length);\n  this.data = newData;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  if (size >= 8) {\n    final int newCapacity = (int) (capacity() * 1.5);\n    final byte[] newData = new byte[newCapacity];\n    System.arraycopy(data, 0, newData, 0, data.length);\n    data = newData;\n  } else if (size >= 4) {\n    final int newCapacity = (int) (capacity() * 1.5);\n    final byte[] newData = new byte[newCapacity];\n    System.arraycopy(data, 0, newData, 0, data.length);\n    data = newData;\n  } else {\n    data = new byte[size];\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] old = m_data;\n  m_data = Arrays.copyOf(old, old.length + size);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  int newCapacity = _buffer.length << 1;\n  if (newCapacity >= size) {\n    return;\n  }\n  byte[] newBuffer = new byte[newCapacity];\n  System.arraycopy(_buffer, 0, newBuffer, 0, _buffer.length);\n  _buffer = newBuffer;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n", "method_name": "enlarge", "codes": ["private void enlarge(final int size){ if (size > bytes.length) { final byte[] tmp = new byte[size]; System.arraycopy(bytes, 0, tmp, 0, bytes.length); bytes = tmp; } }", "private void enlarge(final int size){ final int newCapacity = capacity + (capacity >> 1); final byte[] newData = new byte[newCapacity]; System.arraycopy(data, 0, newData, 0, capacity); data = newData; }", "private void enlarge(final int size){ final byte[] buf = new byte[size]; System.arraycopy(data, 0, buf, 0, data.length); data = buf; }", "private void enlarge(final int size){ final byte[] temp = new byte[size]; System.arraycopy(buf, 0, temp, 0, size); buf = temp; }", "private void enlarge(final int size){ if (size > maxByteSize) { throw new IllegalArgumentException(\"size > \" + maxByteSize); } if (size > buf.length) { final byte[] newbuf = new byte[Math.max(buf.length << 1, size)]; System.arraycopy(buf, 0, newbuf, 0, buf.length); buf = newbuf; } }", "private void enlarge(final int size){ final byte[] buf = new byte[size]; System.arraycopy(buf, 0, buf, 0, buf.length); buf = buf.clone(); buf[size] = 0; buf = buf.clone(); buf[size] |= 0x80; buf = buf.clone(); buf[size] |= 0x40; buf = buf.clone(); buf[size] |= 0x20; buf = buf.clone(); buf[size] |= 0x10; buf = buf.clone(); buf[size] |= 0x08; buf = buf.clone(); buf[size] |= 0x04; buf = buf.clone(); buf[size] |= 0x02; buf = buf.clone(); buf[size] |= 0x01; buf = buf.clone(); buf[size] |= 0x0c; buf = buf.clone(); buf[size] |= 0x0e; buf = buf.clone(); buf[size] |= 0x0f; buf = buf.clone(); buf[size] |= 0x10; buf = buf.clone(); buf[size] |= 0x08; buf = buf.clone(); buf[size] |= 0x04; buf = buf.clone(); buf[size] |= 0x02; buf = buf.clone(); buf[size] |= 0x01; buf = buf.clone(); buf[size] |= 0x0c; buf = buf.clone(); buf[size] |= 0x0e; buf = buf.clone(); buf[size] |= 0x0f; buf = buf.clone(); buf[size] |= 0x10; buf = buf.clone(); buf[size] |= 0x08; buf = buf.clone(); buf[size] |= 0x04; buf = buf.clone(); buf[size] |= 0x02; buf = buf.clone(); buf[size] |= 0x01; buf = buf.clone(); buf[size] |= 0x0c; buf = buf.clone(); buf[size] |= 0x0e; buf = buf.clone(); buf[size] |= 0x0f; buf = buf.clone(); buf[size] |= 0x10; buf = buf.clone(); buf[size] |= 0x08; buf = buf.clone(); buf[size] |= 0x04; buf = buf.clone(); buf[size] |= 0x02; buf = buf.clone(); buf[size] |= 0x01; buf = buf.clone(); buf[size] |= 0x0c; buf = buf.clone(); buf[size] |= 0x0e; buf = buf.clone(); buf[size] |= 0x0f; buf = buf.clone(); buf[size] |= 0x10; buf = buf.clone(); buf[size] |= 0x08; buf = buf.clone(); buf[size] |= 0x04; buf = buf.clone(); buf[size] |= 0x02; buf = buf.clone(); buf[size] |= 0x01; buf = buf.clone(); buf[size]", "private void enlarge(final int size){ final int newCapacity = this.capacity + (this.capacity >> 1) + (size >> 1); this.capacity = newCapacity; final byte[] newData = new byte[newCapacity]; System.arraycopy(this.data, 0, newData, 0, this.data.length); this.data = newData; }", "private void enlarge(final int size){ if (size >= 8) { final int newCapacity = (int) (capacity() * 1.5); final byte[] newData = new byte[newCapacity]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } else if (size >= 4) { final int newCapacity = (int) (capacity() * 1.5); final byte[] newData = new byte[newCapacity]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } else { data = new byte[size]; } }", "private void enlarge(final int size){ final byte[] old = m_data; m_data = Arrays.copyOf(old, old.length + size); }", "private void enlarge(final int size){ int newCapacity = _buffer.length << 1; if (newCapacity >= size) { return; } byte[] newBuffer = new byte[newCapacity]; System.arraycopy(_buffer, 0, newBuffer, 0, _buffer.length); _buffer = newBuffer; }"], "code_level": "self_contained", "_id": "636766a91a6d9265ec0175c1", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength == 0) {\n    return this;\n  }\n  final int byteCount = byteLength;\n  if (byteCount > this.length) {\n    throw new IllegalArgumentException(\"byteCount > length: \" + byteCount + \" > \" + this.length);\n  }\n  if (byteOffset < 0) {\n    throw new IllegalArgumentException(\"byteOffset < 0: \" + byteOffset + \" < 0\");\n  }\n  if (byteOffset + byteCount > this.length) {\n    byteOffset += byteCount - this.length;\n  }\n  if (byteLength == 1) {\n    final byte[] tmp = new byte[1];\n    tmp[0] = byteArrayValue[byteOffset];\n    putByte(tmp);\n  } else {\n    final int tmpLength = byteCount;\n    final byte[] tmpArray = new byte[tmpLength];\n    System.arraycopy(byteArrayValue, byteOffset, tmpArray, 0, tmpLength);\n    putByteArray(tmpArray);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > byteArrayValue.length) {\n    throw new IllegalArgumentException(\n        \"byteLength (\"\n            + byteLength\n            + \") > byteArrayValue.length (\"\n            + byteArrayValue.length\n            + \")\");\n  }\n  if (byteLength == 0) {\n    return this;\n  }\n  if (byteOffset > byteArrayValue.length) {\n    throw new IllegalArgumentException(\n        \"byteOffset (\"\n            + byteOffset\n            + \") > byteArrayValue.length (\"\n            + byteArrayValue.length\n            + \")\");\n  }\n  if (byteOffset < 0) {\n    throw new IllegalArgumentException(\"byteOffset (\" + byteOffset + \") < 0\");\n  }\n  if (byteLength == byteArrayValue.length) {\n    return this;\n  }\n  if (this.byteLength + byteLength > this.byteArray.length) {\n    grow(this.byteArray.length);\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteLength, byteLength);\n  this.byteLength += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  checkPositionIndexes(byteOffset, byteOffset + byteLength, getLength());\n  if (byteLength == 0) {\n    return this;\n  }\n  final int newLength = byteLength + getPosition();\n  final int newCapacity = newLength + (newLength >>> 3);\n  ensureCapacity(newCapacity);\n  System.arraycopy(byteArrayValue, byteOffset, buffer, getPosition(), byteLength);\n  setPosition(newLength);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteArrayValue == null) {\n    if (this.length == 0) {\n      return this;\n    } else {\n      throw new IllegalArgumentException(\"byteArrayValue must not be null\");\n    }\n  }\n  if (byteLength < 0) {\n    throw new IllegalArgumentException(\"byteLength must not be negative\");\n  }\n  if (byteOffset < 0) {\n    throw new IllegalArgumentException(\"byteOffset must not be negative\");\n  }\n  if (byteOffset + byteLength > this.length) {\n    if (this.length <= 0) {\n      return this;\n    }\n    byteLength = this.length - byteOffset;\n  }\n  if (byteLength == 0) {\n    return this;\n  }\n  if (byteLength > this.byteArray.length - this.byteOffset) {\n    final int newLength = this.byteArray.length - this.byteOffset;\n    final byte[] newArray = new byte[newLength];\n    System.arraycopy(this.byteArray, this.byteOffset, newArray, 0, newLength);\n    this.byteArray = newArray;\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLength);\n  this.byteOffset += byteLength;\n  this.length += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteArrayValue == null) {\n    putNull();\n    return this;\n  }\n  if (byteOffset < 0\n      || byteOffset > byteArrayValue.length\n      || byteLength < 0\n      || byteLength > byteArrayValue.length - byteOffset) {\n    throw new IndexOutOfBoundsException(\n        \"byteOffset: \" + byteOffset + \", byteLength: \" + byteLength);\n  }\n  int length = this.length;\n  if (byteLength > length) {\n    byte[] tmp = new byte[length];\n    System.arraycopy(this.byteArray, this.byteOffset, tmp, 0, byteLength);\n    this.byteArray = tmp;\n  }\n  System.arraycopy(\n      byteArrayValue, byteOffset, this.byteArray, this.byteOffset + byteLength, byteLength);\n  this.byteOffset += byteLength;\n  this.length = this.byteOffset + byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > this.length) {\n    ensureCapacity(this.length + byteLength);\n    System.arraycopy(byteArrayValue, byteOffset, this.value, this.length, byteLength);\n    this.length = this.length + byteLength;\n  } else {\n    System.arraycopy(byteArrayValue, byteOffset, this.value, this.length, byteLength);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteArrayValue == null) {\n    if (this.byteLength == 0) {\n      return this;\n    }\n  } else if (byteLength == 0) {\n    return putNull();\n  }\n  if (this.byteLength + byteLength > this.maxCapacity) {\n    throw new IndexOutOfBoundsException(\n        \"byteLength > maxCapacity: \" + byteLength + \" > \" + this.maxCapacity);\n  }\n  this.byteLength += byteLength;\n  if (byteOffset > this.byteLength) {\n    this.byteOffset = 0;\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLength);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength == 0) {\n    return this;\n  }\n  ensureCapacity(count + byteLength);\n  System.arraycopy(byteArrayValue, byteOffset, data, count, byteLength);\n  count += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > byteArrayValue.length - byteOffset) {\n    throw new IllegalArgumentException(\n        \"byteArrayValue.length must be less than byteOffset + byteLength\");\n  }\n  ensureCapacity(count + byteLength);\n  System.arraycopy(byteArrayValue, byteOffset, buffer, count, byteLength);\n  count += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > 0) {\n    if (byteLength >= length) {\n      expand(byteLength);\n    }\n    System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLength);\n    this.byteOffset += byteLength;\n    this.length += byteLength;\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n * @param byteLength     number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n", "method_name": "putByteArray", "codes": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength == 0) { return this; } final int byteCount = byteLength; if (byteCount > this.length) { throw new IllegalArgumentException(\"byteCount > length: \" + byteCount + \" > \" + this.length); } if (byteOffset < 0) { throw new IllegalArgumentException(\"byteOffset < 0: \" + byteOffset + \" < 0\"); } if (byteOffset + byteCount > this.length) { byteOffset += byteCount - this.length; } if (byteLength == 1) { final byte[] tmp = new byte[1]; tmp[0] = byteArrayValue[byteOffset]; putByte(tmp); } else { final int tmpLength = byteCount; final byte[] tmpArray = new byte[tmpLength]; System.arraycopy(byteArrayValue, byteOffset, tmpArray, 0, tmpLength); putByteArray(tmpArray); } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > byteArrayValue.length) { throw new IllegalArgumentException(\"byteLength (\" + byteLength + \") > byteArrayValue.length (\" + byteArrayValue.length + \")\"); } if (byteLength == 0) { return this; } if (byteOffset > byteArrayValue.length) { throw new IllegalArgumentException(\"byteOffset (\" + byteOffset + \") > byteArrayValue.length (\" + byteArrayValue.length + \")\"); } if (byteOffset < 0) { throw new IllegalArgumentException(\"byteOffset (\" + byteOffset + \") < 0\"); } if (byteLength == byteArrayValue.length) { return this; } if (this.byteLength + byteLength > this.byteArray.length) { grow(this.byteArray.length); } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteLength, byteLength); this.byteLength += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ checkPositionIndexes(byteOffset, byteOffset + byteLength, getLength()); if (byteLength == 0) { return this; } final int newLength = byteLength + getPosition(); final int newCapacity = newLength + (newLength >>> 3); ensureCapacity(newCapacity); System.arraycopy(byteArrayValue, byteOffset, buffer, getPosition(), byteLength); setPosition(newLength); return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteArrayValue == null) { if (this.length == 0) { return this; } else { throw new IllegalArgumentException(\"byteArrayValue must not be null\"); } } if (byteLength < 0) { throw new IllegalArgumentException(\"byteLength must not be negative\"); } if (byteOffset < 0) { throw new IllegalArgumentException(\"byteOffset must not be negative\"); } if (byteOffset + byteLength > this.length) { if (this.length <= 0) { return this; } byteLength = this.length - byteOffset; } if (byteLength == 0) { return this; } if (byteLength > this.byteArray.length - this.byteOffset) { final int newLength = this.byteArray.length - this.byteOffset; final byte[] newArray = new byte[newLength]; System.arraycopy(this.byteArray, this.byteOffset, newArray, 0, newLength); this.byteArray = newArray; } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLength); this.byteOffset += byteLength; this.length += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteArrayValue == null) { putNull(); return this; } if (byteOffset < 0 || byteOffset > byteArrayValue.length || byteLength < 0 || byteLength > byteArrayValue.length - byteOffset) { throw new IndexOutOfBoundsException(\"byteOffset: \" + byteOffset + \", byteLength: \" + byteLength); } int length = this.length; if (byteLength > length) { byte[] tmp = new byte[length]; System.arraycopy(this.byteArray, this.byteOffset, tmp, 0, byteLength); this.byteArray = tmp; } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset + byteLength, byteLength); this.byteOffset += byteLength; this.length = this.byteOffset + byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > this.length) { ensureCapacity(this.length + byteLength); System.arraycopy(byteArrayValue, byteOffset, this.value, this.length, byteLength); this.length = this.length + byteLength; } else { System.arraycopy(byteArrayValue, byteOffset, this.value, this.length, byteLength); } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteArrayValue == null) { if (this.byteLength == 0) { return this; } } else if (byteLength == 0) { return putNull(); } if (this.byteLength + byteLength > this.maxCapacity) { throw new IndexOutOfBoundsException(\"byteLength > maxCapacity: \" + byteLength + \" > \" + this.maxCapacity); } this.byteLength += byteLength; if (byteOffset > this.byteLength) { this.byteOffset = 0; } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLength); return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength == 0) { return this; } ensureCapacity(count + byteLength); System.arraycopy(byteArrayValue, byteOffset, data, count, byteLength); count += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > byteArrayValue.length - byteOffset) { throw new IllegalArgumentException(\"byteArrayValue.length must be less than byteOffset + byteLength\"); } ensureCapacity(count + byteLength); System.arraycopy(byteArrayValue, byteOffset, buffer, count, byteLength); count += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > 0) { if (byteLength >= length) { expand(byteLength); } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLength); this.byteOffset += byteLength; this.length += byteLength; } return this; }"], "code_level": "class_runnable", "_id": "636766a91a6d9265ec0175ae", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private void pop(final int elements) {\n  if (elements > 0) {\n    for (int i = 0; i < elements; i++) {\n      outputStack.pop();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  final int top = stack.size() - elements;\n  stack.setSize(top);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  if (elements > stack.length) {\n    throw new RuntimeException(\n        \"Unable to pop \" + elements + \" abstract types from the frame stack.\");\n  }\n  for (int i = 0; i < elements; i++) {\n    stack[i] = null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  if (elements > 0) {\n    int numStackElements = stackElements.size();\n    for (int i = 0; i < numStackElements - elements; i++) {\n      stackElements.pop();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  frame.pop(elements);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  for (int i = 0; i < elements; i++) {\n    frame.popType();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  final int[] arr = new int[elements];\n  System.arraycopy(this.outputStack, this.outputStackTop, arr, 0, elements);\n  this.outputStackTop = 0;\n  this.outputStack = arr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  if (outputFrame.length < elements) {\n    outputFrame = new int[elements];\n  }\n  System.arraycopy(outputFrame, 0, outputFrame, 0, outputFrame.length - elements);\n  outputFrame[outputFrame.length - elements] = 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  for (int i = 0; i < elements; i++) {\n    if (stack[top] == TYPE) {\n      stack[top] = 0;\n      top--;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  if (elements > 0) {\n    for (int i = 0; i < elements; ++i) {\n      outputFrame.pop();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n", "method_name": "pop", "codes": ["private void pop(final int elements){ if (elements > 0) { for (int i = 0; i < elements; i++) { outputStack.pop(); } } }", "private void pop(final int elements){ final int top = stack.size() - elements; stack.setSize(top); }", "private void pop(final int elements){ if (elements > stack.length) { throw new RuntimeException(\"Unable to pop \" + elements + \" abstract types from the frame stack.\"); } for (int i = 0; i < elements; i++) { stack[i] = null; } }", "private void pop(final int elements){ if (elements > 0) { int numStackElements = stackElements.size(); for (int i = 0; i < numStackElements - elements; i++) { stackElements.pop(); } } }", "private void pop(final int elements){ frame.pop(elements); }", "private void pop(final int elements){ for (int i = 0; i < elements; i++) { frame.popType(); } }", "private void pop(final int elements){ final int[] arr = new int[elements]; System.arraycopy(this.outputStack, this.outputStackTop, arr, 0, elements); this.outputStackTop = 0; this.outputStack = arr; }", "private void pop(final int elements){ if (outputFrame.length < elements) { outputFrame = new int[elements]; } System.arraycopy(outputFrame, 0, outputFrame, 0, outputFrame.length - elements); outputFrame[outputFrame.length - elements] = 0; }", "private void pop(final int elements){ for (int i = 0; i < elements; i++) { if (stack[top] == TYPE) { stack[top] = 0; top--; } } }", "private void pop(final int elements){ if (elements > 0) { for (int i = 0; i < elements; ++i) { outputFrame.pop(); } } }"], "code_level": "self_contained", "_id": "636766a81a6d9265ec017586", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "public ByteVector putInt(final int intValue) {\n  if (isConstant) {\n    throw new IllegalStateException(\"Cannot put int into constant value\");\n  }\n  if (intValue > Byte.MAX_VALUE || intValue < Byte.MIN_VALUE) {\n    throw new IllegalArgumentException(\"Value out of range for byte\");\n  }\n  putShort((short) intValue);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  if (intValue >= 0) {\n    if (this.size == this.data.length) {\n      resize(this.size * 2);\n    }\n    this.data[this.size++] = (byte) (intValue >>> 24);\n    this.data[this.size++] = (byte) (intValue >>> 16);\n    this.data[this.size++] = (byte) (intValue >>> 8);\n    this.data[this.size++] = (byte) intValue;\n  } else {\n    putByte((byte) (-intValue));\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  if (this.isConstant) {\n    return this;\n  }\n  if (this.length == this.data.length) {\n    final byte[] newData = new byte[this.length * 2];\n    System.arraycopy(this.data, 0, newData, 0, this.length);\n    this.data = newData;\n  }\n  this.data[this.length++] = (byte) ((intValue >>> 24) & 0xFF);\n  this.data[this.length++] = (byte) ((intValue >>> 16) & 0xFF);\n  this.data[this.length++] = (byte) ((intValue >>> 8) & 0xFF);\n  this.data[this.length++] = (byte) (intValue & 0xFF);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  if (this.length == this.data.length) {\n    enlarge(8);\n  }\n  this.data[this.length++] = (byte) (intValue >>> 24);\n  this.data[this.length++] = (byte) (intValue >>> 16);\n  this.data[this.length++] = (byte) (intValue >>> 8);\n  this.data[this.length++] = (byte) intValue;\n  return this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  if (intValue > 32767) {\n    throw new IllegalArgumentException(\"Value too large for int\");\n  }\n  if (intValue < -32768) {\n    throw new IllegalArgumentException(\"Value too small for int\");\n  }\n  intBitsToByteArray(intValue, byteArray, pos);\n  pos += INT_SIZE;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  if (intValue >= 0) {\n    if (this.size + 4 > this.data.length) {\n      final int newCapacity = ((this.data.length << 1) + 1);\n      if (newCapacity - this.size > 0) {\n        System.arraycopy(this.data, this.size, this.data, 0, newCapacity);\n      }\n      this.data = new byte[newCapacity];\n    }\n    this.data[this.size++] = (byte) (intValue >>> 24);\n    this.data[this.size++] = (byte) (intValue >>> 16);\n    this.data[this.size++] = (byte) (intValue >>> 8);\n    this.data[this.size++] = (byte) intValue;\n  } else {\n    putLong((long) intValue);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  intLength = INT_SIZE;\n  if (intValue >= 0) {\n    intLength += intValue;\n  } else {\n    intLength += (-intValue);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  intLength += 4;\n  byte[] tmp = new byte[intLength];\n  System.arraycopy(buf, pos, tmp, 0, intLength);\n  putBytes(tmp, 0, intValue);\n  pos += intLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  intValue(intValue);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  if (this.remaining() < 4) {\n    this.resize(4 + intValue);\n  }\n  this.buffer[this.pos++] = (byte) ((intValue >>> 24) & 0xFF);\n  this.buffer[this.pos++] = (byte) ((intValue >>> 16) & 0xFF);\n  this.buffer[this.pos++] = (byte) ((intValue >>> 8) & 0xFF);\n  this.buffer[this.pos++] = (byte) (intValue & 0xFF);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param intValue an int.\n * @return this byte vector.\n */\n", "method_name": "putInt", "codes": ["public ByteVector putInt(final int intValue){ if (isConstant) { throw new IllegalStateException(\"Cannot put int into constant value\"); } if (intValue > Byte.MAX_VALUE || intValue < Byte.MIN_VALUE) { throw new IllegalArgumentException(\"Value out of range for byte\"); } putShort((short) intValue); return this; }", "public ByteVector putInt(final int intValue){ if (intValue >= 0) { if (this.size == this.data.length) { resize(this.size * 2); } this.data[this.size++] = (byte) (intValue >>> 24); this.data[this.size++] = (byte) (intValue >>> 16); this.data[this.size++] = (byte) (intValue >>> 8); this.data[this.size++] = (byte) intValue; } else { putByte((byte) (-intValue)); } return this; }", "public ByteVector putInt(final int intValue){ if (this.isConstant) { return this; } if (this.length == this.data.length) { final byte[] newData = new byte[this.length * 2]; System.arraycopy(this.data, 0, newData, 0, this.length); this.data = newData; } this.data[this.length++] = (byte) ((intValue >>> 24) & 0xFF); this.data[this.length++] = (byte) ((intValue >>> 16) & 0xFF); this.data[this.length++] = (byte) ((intValue >>> 8) & 0xFF); this.data[this.length++] = (byte) (intValue & 0xFF); return this; }", "public ByteVector putInt(final int intValue){ if (this.length == this.data.length) { enlarge(8); } this.data[this.length++] = (byte) (intValue >>> 24); this.data[this.length++] = (byte) (intValue >>> 16); this.data[this.length++] = (byte) (intValue >>> 8); this.data[this.length++] = (byte) intValue; return this; }", "public ByteVector putInt(final int intValue){ if (intValue > 32767) { throw new IllegalArgumentException(\"Value too large for int\"); } if (intValue < -32768) { throw new IllegalArgumentException(\"Value too small for int\"); } intBitsToByteArray(intValue, byteArray, pos); pos += INT_SIZE; return this; }", "public ByteVector putInt(final int intValue){ if (intValue >= 0) { if (this.size + 4 > this.data.length) { final int newCapacity = ((this.data.length << 1) + 1); if (newCapacity - this.size > 0) { System.arraycopy(this.data, this.size, this.data, 0, newCapacity); } this.data = new byte[newCapacity]; } this.data[this.size++] = (byte) (intValue >>> 24); this.data[this.size++] = (byte) (intValue >>> 16); this.data[this.size++] = (byte) (intValue >>> 8); this.data[this.size++] = (byte) intValue; } else { putLong((long) intValue); } return this; }", "public ByteVector putInt(final int intValue){ intLength = INT_SIZE; if (intValue >= 0) { intLength += intValue; } else { intLength += (-intValue); } return this; }", "public ByteVector putInt(final int intValue){ intLength += 4; byte[] tmp = new byte[intLength]; System.arraycopy(buf, pos, tmp, 0, intLength); putBytes(tmp, 0, intValue); pos += intLength; return this; }", "public ByteVector putInt(final int intValue){ intValue(intValue); return this; }", "public ByteVector putInt(final int intValue){ if (this.remaining() < 4) { this.resize(4 + intValue); } this.buffer[this.pos++] = (byte) ((intValue >>> 24) & 0xFF); this.buffer[this.pos++] = (byte) ((intValue >>> 16) & 0xFF); this.buffer[this.pos++] = (byte) ((intValue >>> 8) & 0xFF); this.buffer[this.pos++] = (byte) (intValue & 0xFF); return this; }"], "code_level": "class_runnable", "_id": "636766a81a6d9265ec017596", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private void pop(final String descriptor) {\n  if (mv != null) {\n    mv.visitTypeInsn(CHECKCAST, descriptor);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.charAt(0) == ')') {\n    throw new IllegalStateException(\n        \"Cannot pop a type from an abstract type stack: \" + descriptor);\n  }\n  int i = 0;\n  for (; i < stackSize; ++i) {\n    if (stack[i].getDescriptor().equals(descriptor)) {\n      break;\n    }\n  }\n  if (i == stackSize) {\n    throw new IllegalStateException(\n        \"Cannot pop a type from an abstract type stack: \" + descriptor);\n  }\n  for (; i < stackSize; ++i) {\n    stack[i - 1] = stack[i];\n  }\n  stackSize -= 1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (stackSize == 0) {\n    throw new IllegalStateException(\"Cannot pop from empty frame stack\");\n  }\n  Object t;\n  if ((t = stack[--stackSize]) == Opcodes.UNINITIALIZED_THIS) {\n    throw new IllegalStateException(\"Cannot pop from uninitialized stack\");\n  }\n  if ((t = stack[--stackSize]) == Opcodes.NEW) {\n    throw new IllegalStateException(\"Cannot pop from new stack\");\n  }\n  if ((t = stack[--stackSize]) == Opcodes.ANEWARRAY) {\n    throw new IllegalStateException(\"Cannot pop from array type\");\n  }\n  if (t instanceof Type) {\n    Type ty = (Type) t;\n    if (descriptor.charAt(0) != '[') {\n      throw new IllegalStateException(\"Wrong type descriptor\");\n    }\n    int dims = 0;\n    while (dims < descriptor.length() && descriptor.charAt(dims) == '[') {\n      dims++;\n    }\n    if (dims == descriptor.length()) {\n      throw new IllegalStateException(\"Wrong type descriptor\");\n    }\n    for (int i = dims; i < descriptor.length(); i++) {\n      char c = descriptor.charAt(i);\n      if (c == 'L' || c == '[') {\n        throw new IllegalStateException(\"Wrong type descriptor\");\n      }\n      if (c == ';') {\n        break;\n      }\n    }\n  }\n  stack[stackSize - 1] = t;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  int size = this.outputFrame.size();\n  if (size == 0) {\n    return;\n  }\n  Type[] types = new Type[size];\n  for (int i = 0; i < size; ++i) {\n    types[i] = this.outputFrame.get(i).type;\n  }\n  Type type = Type.getObjectType(descriptor);\n  this.outputFrame.set(size - 1, new Frame.TypedValue(type, types));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (this.stackSize == 0) {\n    throw new IllegalStateException(\"Stack is empty!\");\n  }\n  final Type type = this.stack[--this.stackSize];\n  final Type[] argTypes = Type.getArgumentTypes(descriptor);\n  if (argTypes.length == 0) {\n    this.stack[this.stackSize] = type;\n  } else {\n    this.stack[this.stackSize] = Type.getObjectType(this.owner, type, argTypes);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  int n = stack[stackSize - 1];\n  if ((n & 0xFF) == descriptor.charAt(0)) {\n    stack[stackSize - 1] = n >> 8;\n  } else {\n    stack[stackSize - 1] = n | 0xFFFFFF00;\n  }\n  stackSize -= 2;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  int opcode = mv.visitTypeInsn(NEW, descriptor);\n  if (opcode == 0) {\n    mv.visitInsn(DUP);\n    mv.visitInsn(ICONST_1);\n    mv.visitInsn(SWAP);\n    mv.visitMethodInsn(INVOKESPECIAL, descriptor, \"<init>\", \"()V\", false);\n  } else {\n    mv.visitLdcInsn(opcode);\n    mv.visitMethodInsn(INVOKEVIRTUAL, descriptor, \"getOpcode\", \"(I)I\", false);\n  }\n  mv.visitInsn(ARETURN);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  final Type type = Type.getObjectType(descriptor);\n  if (type.getSize() == 2) {\n    pop2();\n  } else if (type.getSize() == 1) {\n    pop1();\n  } else {\n    throw new IllegalArgumentException(\"Invalid abstract type descriptor '\" + descriptor + \"'\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  Type type = Type.getType(descriptor);\n  if (type.getSize() == 0) {\n    pop();\n  } else {\n    pop(type);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  final int type = cp.getType(descriptor);\n  if (type == Opcodes.LONG\n      || type == Opcodes.DOUBLE\n      || type == Opcodes.FLOAT\n      || type == Opcodes.INTEGER) {\n    pop(type);\n  } else if (type == Opcodes.ARRAY) {\n    pop(Opcodes.OBJECT);\n  } else if (type == Opcodes.METHOD) {\n    pop(Opcodes.METHOD_HANDLE);\n  } else {\n    throw new IllegalArgumentException(\"Invalid abstract type: \" + descriptor);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n", "method_name": "pop", "codes": ["private void pop(final String descriptor){ if (mv != null) { mv.visitTypeInsn(CHECKCAST, descriptor); } }", "private void pop(final String descriptor){ if (descriptor.charAt(0) == ')') { throw new IllegalStateException(\"Cannot pop a type from an abstract type stack: \" + descriptor); } int i = 0; for (; i < stackSize; ++i) { if (stack[i].getDescriptor().equals(descriptor)) { break; } } if (i == stackSize) { throw new IllegalStateException(\"Cannot pop a type from an abstract type stack: \" + descriptor); } for (; i < stackSize; ++i) { stack[i - 1] = stack[i]; } stackSize -= 1; }", "private void pop(final String descriptor){ if (stackSize == 0) { throw new IllegalStateException(\"Cannot pop from empty frame stack\"); } Object t; if ((t = stack[--stackSize]) == Opcodes.UNINITIALIZED_THIS) { throw new IllegalStateException(\"Cannot pop from uninitialized stack\"); } if ((t = stack[--stackSize]) == Opcodes.NEW) { throw new IllegalStateException(\"Cannot pop from new stack\"); } if ((t = stack[--stackSize]) == Opcodes.ANEWARRAY) { throw new IllegalStateException(\"Cannot pop from array type\"); } if (t instanceof Type) { Type ty = (Type) t; if (descriptor.charAt(0) != '[') { throw new IllegalStateException(\"Wrong type descriptor\"); } int dims = 0; while (dims < descriptor.length() && descriptor.charAt(dims) == '[') { dims++; } if (dims == descriptor.length()) { throw new IllegalStateException(\"Wrong type descriptor\"); } for (int i = dims; i < descriptor.length(); i++) { char c = descriptor.charAt(i); if (c == 'L' || c == '[') { throw new IllegalStateException(\"Wrong type descriptor\"); } if (c == ';') { break; } } } stack[stackSize - 1] = t; }", "private void pop(final String descriptor){ int size = this.outputFrame.size(); if (size == 0) { return; } Type[] types = new Type[size]; for (int i = 0; i < size; ++i) { types[i] = this.outputFrame.get(i).type; } Type type = Type.getObjectType(descriptor); this.outputFrame.set(size - 1, new Frame.TypedValue(type, types)); }", "private void pop(final String descriptor){ if (this.stackSize == 0) { throw new IllegalStateException(\"Stack is empty!\"); } final Type type = this.stack[--this.stackSize]; final Type[] argTypes = Type.getArgumentTypes(descriptor); if (argTypes.length == 0) { this.stack[this.stackSize] = type; } else { this.stack[this.stackSize] = Type.getObjectType(this.owner, type, argTypes); } }", "private void pop(final String descriptor){ int n = stack[stackSize - 1]; if ((n & 0xFF) == descriptor.charAt(0)) { stack[stackSize - 1] = n >> 8; } else { stack[stackSize - 1] = n | 0xFFFFFF00; } stackSize -= 2; }", "private void pop(final String descriptor){ int opcode = mv.visitTypeInsn(NEW, descriptor); if (opcode == 0) { mv.visitInsn(DUP); mv.visitInsn(ICONST_1); mv.visitInsn(SWAP); mv.visitMethodInsn(INVOKESPECIAL, descriptor, \"<init>\", \"()V\", false); } else { mv.visitLdcInsn(opcode); mv.visitMethodInsn(INVOKEVIRTUAL, descriptor, \"getOpcode\", \"(I)I\", false); } mv.visitInsn(ARETURN); }", "private void pop(final String descriptor){ final Type type = Type.getObjectType(descriptor); if (type.getSize() == 2) { pop2(); } else if (type.getSize() == 1) { pop1(); } else { throw new IllegalArgumentException(\"Invalid abstract type descriptor '\" + descriptor + \"'\"); } }", "private void pop(final String descriptor){ Type type = Type.getType(descriptor); if (type.getSize() == 0) { pop(); } else { pop(type); } }", "private void pop(final String descriptor){ final int type = cp.getType(descriptor); if (type == Opcodes.LONG || type == Opcodes.DOUBLE || type == Opcodes.FLOAT || type == Opcodes.INTEGER) { pop(type); } else if (type == Opcodes.ARRAY) { pop(Opcodes.OBJECT); } else if (type == Opcodes.METHOD) { pop(Opcodes.METHOD_HANDLE); } else { throw new IllegalArgumentException(\"Invalid abstract type: \" + descriptor); } }"], "code_level": "class_runnable", "_id": "636766a91a6d9265ec0175c4", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  int a = byteValue1 & 0xFF;\n  int b = byteValue2 & 0xFF;\n  int v = a << 8 | b;\n  put11(v);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  if (remaining() < 4) {\n    ensureCapacity(4);\n  }\n  array[pos++] = (byte) (byteValue1 & 0xFF);\n  array[pos++] = (byte) (byteValue1 >>> 8);\n  array[pos++] = (byte) (byteValue1 >>> 16);\n  array[pos++] = (byte) (byteValue1 >>> 24);\n  array[pos++] = (byte) (byteValue2 & 0xFF);\n  array[pos++] = (byte) (byteValue2 >>> 8);\n  array[pos++] = (byte) (byteValue2 >>> 16);\n  array[pos++] = (byte) (byteValue2 >>> 24);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  if (length == data.length) {\n    enlarge(2);\n  }\n  data[length++] = (byte) (byteValue1 << 4 | byteValue2);\n  return this;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  if (length == data.length) {\n    ensureCapacity(length + 2);\n    System.arraycopy(data, index, data, index + 2, length - index);\n    data[index] = (byte) (byteValue1 << 8 | byteValue2);\n    index = index + 2;\n    length = length - index;\n  } else {\n    ensureCapacity(length + 1);\n    System.arraycopy(data, index, data, index + 1, length - index);\n    data[index] = (byte) (byteValue1 << 8 | byteValue2);\n    index = index + 1;\n    length = length - index;\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  int i = this.pos;\n  if (i + 3 >= this.limit) {\n    int n = this.ensureCapacity(i + 3);\n    System.arraycopy(this.buffer, this.offset, n, 0, i);\n    this.offset = 0;\n    this.limit = n;\n  }\n  this.buffer[i++] = (byte) ((byteValue1 >>> 8) & 0xFF);\n  this.buffer[i++] = (byte) (byteValue1 & 0xFF);\n  this.buffer[i++] = (byte) ((byteValue2 >>> 8) & 0xFF);\n  this.buffer[i++] = (byte) (byteValue2 & 0xFF);\n  this.pos = i;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  int i = this.size;\n  if (i + 3 >= this.data.length) {\n    enlarge(3);\n  }\n  this.data[i++] = (byte) (byteValue1 >>> 8);\n  this.data[i++] = (byte) (byteValue1 & 0xFF);\n  this.data[i++] = (byte) (byteValue2 >>> 8);\n  this.data[i++] = (byte) (byteValue2 & 0xFF);\n  this.size = i;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  int pos = this.pos;\n  if (pos + 3 > this.limit) {\n    this.grow(pos + 3);\n  }\n  this.buffer[pos++] = (byte) (byteValue1 >>> 24);\n  this.buffer[pos++] = (byte) (byteValue1 >>> 16);\n  this.buffer[pos++] = (byte) (byteValue1 >>> 8);\n  this.buffer[pos++] = (byte) byteValue1;\n  this.buffer[pos++] = (byte) (byteValue2 >>> 24);\n  this.buffer[pos++] = (byte) (byteValue2 >>> 16);\n  this.buffer[pos++] = (byte) (byteValue2 >>> 8);\n  this.buffer[pos++] = (byte) byteValue2;\n  this.buffer[pos++] = (byte) (byteValue1 << 24);\n  this.buffer[pos++] = (byte) (byteValue2 << 16);\n  this.buffer[pos++] = (byte) (byteValue2 << 8);\n  this.limit = pos;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){ int pos = this.pos; if (pos + 3 > this.data.length) { enlarge(3); } this.data[pos] = (byte) (byteValue1 >>> 24); this.data[pos + 1] = (byte) (byteValue1 >>> 16); this.data[pos + 2] = (byte) (byteValue1 >>> 8); this.data[pos + 3] = (byte) byteValue1; pos += 4; this.data[pos] = (byte) (byteValue2 >>> 24); this.data[pos + 1] = (byte) (byteValue2 >>> 16); this.data[pos + 2] = (byte) (byteValue2 >>> 8); this.data[pos + 3] = (byte) byteValue2; pos += 4; this.data[pos] = (byte) (byteValue1 >>> 0); this.data[pos + 1] = (byte) (byteValue1 >>> 8); this.data[pos + 2] = (byte) byteValue1; pos += 3; this.data[pos] = (byte) (byteValue2 >>> 0); this.data[pos + 1] = (byte) (byteValue2 >>> 8); this.data[pos + 2] = (byte) byteValue2; pos += 3; this.data[pos] = (byte) (byteValue1 >>> 16); this.data[pos + 1] = (byte) (byteValue1 >>> 8); this.data[pos + 2] = (byte) byteValue1; pos += 3; this.data[pos] = (byte) (byteValue2 >>> 16); this.data[pos + 1] = (byte) (byteValue2 >>> 8); this.data[pos + 2] = (byte) byteValue2; pos += 3; this.data[pos] = (byte) (byteValue1 >>> 24); this.data[pos + 1] = (byte) (byteValue1 >>> 16); this.data[pos + 2] = (byte) (byteValue1 >>> 8); this.data[pos + 3] = (byte) byteValue1; pos += 4; this.data[pos] = (byte) (byteValue2 >>> 24); this.data[pos + 1] = (byte) (byteValue2 >>> 16); this.data[pos + 2] = (byte) (byteValue2 >>> 8); this.data[pos + 3] = (byte) byteValue2; pos += 4; this.data[pos] = (byte) (byteValue1 >>> 32); this.data[pos + 1] = (byte) (byteValue1 >>> 24); this.data[pos + 2] = (byte) (byteValue1 >>> 16); this.data[pos + 3] = (byte) (byteValue1 >>> 8); this.data[pos + 4] = (byte) byteValue1; pos += 5; this.data[pos] = (byte) (byteValue2 >>> 32); this.data[pos + 1] = (byte) (byteValue2 >>> 24); this.data[pos + 2] = (byte) (byteValue2 >>> 16); this.data[pos + 3] = (byte) (byteValue2 >>> 8); this.data[pos + 4] = (byte) byteValue2; pos += 5; this.data[pos] = (byte) (byteValue1 >>> 48); this.data[pos + 1] = (byte) (byteValue1 >>> 40); this.data[pos + 2", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  int length = this.length;\n  if (length + 3 > this.data.length) {\n    enlarge(8);\n  }\n  if (byteValue1 >= 0 && byteValue1 <= 127 && byteValue2 >= 0 && byteValue2 <= 127) {\n    this.data[length++] = (byte) byteValue1;\n    this.data[length++] = (byte) byteValue2;\n  } else if (byteValue1 >= 0 && byteValue1 <= 255 && byteValue2 >= 0 && byteValue2 <= 255) {\n    this.data[length++] = (byte) byteValue1;\n    this.data[length++] = (byte) byteValue2;\n    this.data[length++] = (byte) byteValue1;\n    this.data[length++] = (byte) byteValue2;\n  } else {\n    throw new IllegalArgumentException(\"Illegal byte value: \" + byteValue1 + \", \" + byteValue2);\n  }\n  this.length = length;\n  return this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  if (this.length == this.data.length) {\n    enlarge(8);\n  }\n  if (this.length - this.data.length >= 4) {\n    System.arraycopy(this.data, this.length - 4, this.data, 0, 4);\n  }\n  this.data[this.length++] = (byte) byteValue1;\n  this.data[this.length++] = (byte) byteValue2;\n  return this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n", "method_name": "put11", "codes": ["final ByteVector put11(final int byteValue1,final int byteValue2){ int a = byteValue1 & 0xFF; int b = byteValue2 & 0xFF; int v = a << 8 | b; put11(v); return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ if (remaining() < 4) { ensureCapacity(4); } array[pos++] = (byte) (byteValue1 & 0xFF); array[pos++] = (byte) (byteValue1 >>> 8); array[pos++] = (byte) (byteValue1 >>> 16); array[pos++] = (byte) (byteValue1 >>> 24); array[pos++] = (byte) (byteValue2 & 0xFF); array[pos++] = (byte) (byteValue2 >>> 8); array[pos++] = (byte) (byteValue2 >>> 16); array[pos++] = (byte) (byteValue2 >>> 24); return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ if (length == data.length) { enlarge(2); } data[length++] = (byte) (byteValue1 << 4 | byteValue2); return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ if (length == data.length) { ensureCapacity(length + 2); System.arraycopy(data, index, data, index + 2, length - index); data[index] = (byte) (byteValue1 << 8 | byteValue2); index = index + 2; length = length - index; } else { ensureCapacity(length + 1); System.arraycopy(data, index, data, index + 1, length - index); data[index] = (byte) (byteValue1 << 8 | byteValue2); index = index + 1; length = length - index; } return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ int i = this.pos; if (i + 3 >= this.limit) { int n = this.ensureCapacity(i + 3); System.arraycopy(this.buffer, this.offset, n, 0, i); this.offset = 0; this.limit = n; } this.buffer[i++] = (byte) ((byteValue1 >>> 8) & 0xFF); this.buffer[i++] = (byte) (byteValue1 & 0xFF); this.buffer[i++] = (byte) ((byteValue2 >>> 8) & 0xFF); this.buffer[i++] = (byte) (byteValue2 & 0xFF); this.pos = i; return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ int i = this.size; if (i + 3 >= this.data.length) { enlarge(3); } this.data[i++] = (byte) (byteValue1 >>> 8); this.data[i++] = (byte) (byteValue1 & 0xFF); this.data[i++] = (byte) (byteValue2 >>> 8); this.data[i++] = (byte) (byteValue2 & 0xFF); this.size = i; return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ int pos = this.pos; if (pos + 3 > this.limit) { this.grow(pos + 3); } this.buffer[pos++] = (byte) (byteValue1 >>> 24); this.buffer[pos++] = (byte) (byteValue1 >>> 16); this.buffer[pos++] = (byte) (byteValue1 >>> 8); this.buffer[pos++] = (byte) byteValue1; this.buffer[pos++] = (byte) (byteValue2 >>> 24); this.buffer[pos++] = (byte) (byteValue2 >>> 16); this.buffer[pos++] = (byte) (byteValue2 >>> 8); this.buffer[pos++] = (byte) byteValue2; this.buffer[pos++] = (byte) (byteValue1 << 24); this.buffer[pos++] = (byte) (byteValue2 << 16); this.buffer[pos++] = (byte) (byteValue2 << 8); this.limit = pos; return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ int pos = this.pos; if (pos + 3 > this.data.length) { enlarge(3); } this.data[pos] = (byte) (byteValue1 >>> 24); this.data[pos + 1] = (byte) (byteValue1 >>> 16); this.data[pos + 2] = (byte) (byteValue1 >>> 8); this.data[pos + 3] = (byte) byteValue1; pos += 4; this.data[pos] = (byte) (byteValue2 >>> 24); this.data[pos + 1] = (byte) (byteValue2 >>> 16); this.data[pos + 2] = (byte) (byteValue2 >>> 8); this.data[pos + 3] = (byte) byteValue2; pos += 4; this.data[pos] = (byte) (byteValue1 >>> 0); this.data[pos + 1] = (byte) (byteValue1 >>> 8); this.data[pos + 2] = (byte) byteValue1; pos += 3; this.data[pos] = (byte) (byteValue2 >>> 0); this.data[pos + 1] = (byte) (byteValue2 >>> 8); this.data[pos + 2] = (byte) byteValue2; pos += 3; this.data[pos] = (byte) (byteValue1 >>> 16); this.data[pos + 1] = (byte) (byteValue1 >>> 8); this.data[pos + 2] = (byte) byteValue1; pos += 3; this.data[pos] = (byte) (byteValue2 >>> 16); this.data[pos + 1] = (byte) (byteValue2 >>> 8); this.data[pos + 2] = (byte) byteValue2; pos += 3; this.data[pos] = (byte) (byteValue1 >>> 24); this.data[pos + 1] = (byte) (byteValue1 >>> 16); this.data[pos + 2] = (byte) (byteValue1 >>> 8); this.data[pos + 3] = (byte) byteValue1; pos += 4; this.data[pos] = (byte) (byteValue2 >>> 24); this.data[pos + 1] = (byte) (byteValue2 >>> 16); this.data[pos + 2] = (byte) (byteValue2 >>> 8); this.data[pos + 3] = (byte) byteValue2; pos += 4; this.data[pos] = (byte) (byteValue1 >>> 32); this.data[pos + 1] = (byte) (byteValue1 >>> 24); this.data[pos + 2] = (byte) (byteValue1 >>> 16); this.data[pos + 3] = (byte) (byteValue1 >>> 8); this.data[pos + 4] = (byte) byteValue1; pos += 5; this.data[pos] = (byte) (byteValue2 >>> 32); this.data[pos + 1] = (byte) (byteValue2 >>> 24); this.data[pos + 2] = (byte) (byteValue2 >>> 16); this.data[pos + 3] = (byte) (byteValue2 >>> 8); this.data[pos + 4] = (byte) byteValue2; pos += 5; this.data[pos] = (byte) (byteValue1 >>> 48); this.data[pos + 1] = (byte) (byteValue1 >>> 40); this.data[pos + 2", "final ByteVector put11(final int byteValue1,final int byteValue2){ int length = this.length; if (length + 3 > this.data.length) { enlarge(8); } if (byteValue1 >= 0 && byteValue1 <= 127 && byteValue2 >= 0 && byteValue2 <= 127) { this.data[length++] = (byte) byteValue1; this.data[length++] = (byte) byteValue2; } else if (byteValue1 >= 0 && byteValue1 <= 255 && byteValue2 >= 0 && byteValue2 <= 255) { this.data[length++] = (byte) byteValue1; this.data[length++] = (byte) byteValue2; this.data[length++] = (byte) byteValue1; this.data[length++] = (byte) byteValue2; } else { throw new IllegalArgumentException(\"Illegal byte value: \" + byteValue1 + \", \" + byteValue2); } this.length = length; return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ if (this.length == this.data.length) { enlarge(8); } if (this.length - this.data.length >= 4) { System.arraycopy(this.data, this.length - 4, this.data, 0, 4); } this.data[this.length++] = (byte) byteValue1; this.data[this.length++] = (byte) byteValue2; return this; }"], "code_level": "class_runnable", "_id": "636766a81a6d9265ec017595", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return toString(true, features);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ if (features.length > 0) { if (this.features == null) { this.features = new HashMap<>(); } for (JSONWriter.Feature f : features) { this.features.put(f, Boolean.TRUE); } } if (this.features != null) { if (this.features.containsKey(JSONWriter.Feature.QuoteFieldNames)) { this.features.put(JSONWriter.Feature.QuoteFieldNames, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.QuoteElements)) { this.features.put(JSONWriter.Feature.QuoteElements, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.SkipTransientField)) { this.features.put(JSONWriter.Feature.SkipTransientField, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.SortField)) { this.features.put(JSONWriter.Feature.SortField, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.SortDescending)) { this.features.put(JSONWriter.Feature.SortDescending, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseBigDecimal)) { this.features.put(JSONWriter.Feature.UseBigDecimal, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseBigInteger)) { this.features.put(JSONWriter.Feature.UseBigInteger, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseIntegral)) { this.features.put(JSONWriter.Feature.UseIntegral, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseLong)) { this.features.put(JSONWriter.Feature.UseLong, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseNumber)) { this.features.put(JSONWriter.Feature.UseNumber, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseSingleQuotes)) { this.features.put(JSONWriter.Feature.UseSingleQuotes, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseSingleQuotesNoSlash)) { this.features.put(JSONWriter.Feature.UseSingleQuotesNoSlash, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.AllowSingleQuotes)) { this.features.put(JSONWriter.Feature.AllowSingleQuotes, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.AllowUnQuotedFieldNames)) { this.features.put(JSONWriter.Feature.AllowUnQuotedField", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return json.toString(features);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  if (_jsonFactory.isEnabled(Feature.QuoteFieldNames)) {\n    return toString(features, true);\n  }\n  return toString(features, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  if (isEmpty()) {\n    return \"{}\";\n  }\n  final List<String> keys = new ArrayList<String>(size());\n  for (final Object key : keySet()) {\n    keys.add(key.toString());\n  }\n  final StringBuilder sb = new StringBuilder(\"{\");\n  for (final Object key : keys) {\n    sb.append(key).append(':').append(get(key)).append(',');\n  }\n  sb.setCharAt(sb.length() - 1, '}');\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return toString((Collection<JSONWriter.Feature>) Arrays.asList(features));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return toString(this, features);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return toString(features, null, null, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return toString(true, features);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  try {\n    return jsonWriter.write(object, features);\n  } catch (IOException e) {\n    throw new JSONException(e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Serialize to JSON  {@link String}\n * @param features features to be enabled in serialization\n * @return JSON {@link String}\n */\n", "method_name": "toString", "codes": ["@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return toString(true, features); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ if (features.length > 0) { if (this.features == null) { this.features = new HashMap<>(); } for (JSONWriter.Feature f : features) { this.features.put(f, Boolean.TRUE); } } if (this.features != null) { if (this.features.containsKey(JSONWriter.Feature.QuoteFieldNames)) { this.features.put(JSONWriter.Feature.QuoteFieldNames, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.QuoteElements)) { this.features.put(JSONWriter.Feature.QuoteElements, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.SkipTransientField)) { this.features.put(JSONWriter.Feature.SkipTransientField, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.SortField)) { this.features.put(JSONWriter.Feature.SortField, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.SortDescending)) { this.features.put(JSONWriter.Feature.SortDescending, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseBigDecimal)) { this.features.put(JSONWriter.Feature.UseBigDecimal, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseBigInteger)) { this.features.put(JSONWriter.Feature.UseBigInteger, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseIntegral)) { this.features.put(JSONWriter.Feature.UseIntegral, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseLong)) { this.features.put(JSONWriter.Feature.UseLong, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseNumber)) { this.features.put(JSONWriter.Feature.UseNumber, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseSingleQuotes)) { this.features.put(JSONWriter.Feature.UseSingleQuotes, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.UseSingleQuotesNoSlash)) { this.features.put(JSONWriter.Feature.UseSingleQuotesNoSlash, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.AllowSingleQuotes)) { this.features.put(JSONWriter.Feature.AllowSingleQuotes, Boolean.TRUE); } if (this.features.containsKey(JSONWriter.Feature.AllowUnQuotedFieldNames)) { this.features.put(JSONWriter.Feature.AllowUnQuotedField", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return json.toString(features); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ if (_jsonFactory.isEnabled(Feature.QuoteFieldNames)) { return toString(features, true); } return toString(features, false); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ if (isEmpty()) { return \"{}\"; } final List<String> keys = new ArrayList<String>(size()); for (final Object key : keySet()) { keys.add(key.toString()); } final StringBuilder sb = new StringBuilder(\"{\"); for (final Object key : keys) { sb.append(key).append(':').append(get(key)).append(','); } sb.setCharAt(sb.length() - 1, '}'); return sb.toString(); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return toString((Collection<JSONWriter.Feature>) Arrays.asList(features)); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return toString(this, features); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return toString(features, null, null, null); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return toString(true, features); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ try { return jsonWriter.write(object, features); } catch (IOException e) { throw new JSONException(e); } }"], "code_level": "self_contained", "_id": "636766a81a6d9265ec01757b", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int prime = 2;\n  while (prime <= desiredCapacity / 2) {\n    if (desiredCapacity % prime == 0) {\n      return prime;\n    }\n    prime++;\n  }\n  return prime;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int result = 1;\n  while (result < desiredCapacity) {\n    if (!isPrime(result)) {\n      result++;\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int n = 1;\n  while (true) {\n    if (isPrime(n)) {\n      return n;\n    }\n    n++;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int i = 0;\n  int j = 1;\n  int k = 1;\n  int l = 1;\n  int m = 1;\n  int n = 1;\n  int o = 1;\n  int p = 1;\n  int q = 1;\n  int r = 1;\n  int s = 1;\n  int t = 1;\n  int u = 1;\n  int v = 1;\n  int w = 1;\n  int x = 1;\n  int y = 1;\n  int z = 1;\n  do {\n    i = j;\n    j = k;\n    k = l;\n    l = m;\n    m = n;\n    n = o;\n    o = p;\n    p = q;\n    q = r;\n    r = s;\n    s = t;\n    t = u;\n    u = v;\n    v = w;\n    w = x;\n    x = y;\n    y = z;\n    z = z;\n  } while (j <= n && k <= n);\n  if (j <= n && k <= n) {\n    if (j <= n && k <= n) {\n      if (j == n) {\n        i = k;\n      } else {\n        i = k + n;\n      }\n    } else {\n      i = k;\n    }\n  } else {\n    i = k;\n  }\n  if (j <= n && k <= n) {\n    if (j == n) {\n      i = n;\n    } else {\n      i = n + k;\n    }\n  } else {\n    i = n;\n  }\n  if (j <= n && k <= n) {\n    if (j == n) {\n      i = n + k;\n    } else {\n      i = n + k + n;\n    }\n  } else {\n    i = n + k;\n  }\n  if (j <= n && k <= n) {\n    if (j == n) {\n      i = n;\n    } else {\n      i = n + k + n;\n    }\n  } else {\n    i = n + k;\n  }\n  if (j <= n && k <= n) {\n    if (j == n) {\n      i = n + k;\n    } else {\n      i = n + k + n + n;\n    }\n  } else {\n    i = n + k;\n  }\n  return i;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int h = 1;\n  int k = 0;\n  while (h != desiredCapacity) {\n    if (isPrime(h)) {\n      k++;\n    }\n    h++;\n  }\n  return k;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  if (desiredCapacity <= 1) {\n    return 2;\n  }\n  if (desiredCapacity <= 3) {\n    return 3;\n  }\n  if (desiredCapacity <= 5) {\n    return 5;\n  }\n  if (desiredCapacity <= 7) {\n    return 7;\n  }\n  if (desiredCapacity <= 11) {\n    return 11;\n  }\n  return (int) (Math.ceil(Math.log(desiredCapacity) / Math.log(2)));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int prime = 1;\n  while (true) {\n    if (isPrime(prime)) {\n      return prime;\n    }\n    prime++;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int i = 0;\n  int j = 1;\n  int k = j;\n  do {\n    i = j + 1;\n    k = j + 1;\n    j = i;\n  } while ((k <= desiredCapacity) && (i <= j));\n  if (k <= desiredCapacity) {\n    return k;\n  } else {\n    return i;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int n = 1;\n  while (true) {\n    if (isPrime(n)) {\n      return n;\n    }\n    n++;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  if (desiredCapacity <= 0) return 0;\n  int i = 2;\n  while (true) {\n    if (isPrime(i)) {\n      return i;\n    }\n    i++;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).\n * @param desiredCapacity the capacity desired by the user.\n * @return the capacity which should be used for a hashtable.\n */\n", "method_name": "nextPrime", "codes": ["public static int nextPrime(int desiredCapacity){ int prime = 2; while (prime <= desiredCapacity / 2) { if (desiredCapacity % prime == 0) { return prime; } prime++; } return prime; }", "public static int nextPrime(int desiredCapacity){ int result = 1; while (result < desiredCapacity) { if (!isPrime(result)) { result++; } } return result; }", "public static int nextPrime(int desiredCapacity){ int n = 1; while (true) { if (isPrime(n)) { return n; } n++; } }", "public static int nextPrime(int desiredCapacity){ int i = 0; int j = 1; int k = 1; int l = 1; int m = 1; int n = 1; int o = 1; int p = 1; int q = 1; int r = 1; int s = 1; int t = 1; int u = 1; int v = 1; int w = 1; int x = 1; int y = 1; int z = 1; do { i = j; j = k; k = l; l = m; m = n; n = o; o = p; p = q; q = r; r = s; s = t; t = u; u = v; v = w; w = x; x = y; y = z; z = z; } while (j <= n && k <= n); if (j <= n && k <= n) { if (j <= n && k <= n) { if (j == n) { i = k; } else { i = k + n; } } else { i = k; } } else { i = k; } if (j <= n && k <= n) { if (j == n) { i = n; } else { i = n + k; } } else { i = n; } if (j <= n && k <= n) { if (j == n) { i = n + k; } else { i = n + k + n; } } else { i = n + k; } if (j <= n && k <= n) { if (j == n) { i = n; } else { i = n + k + n; } } else { i = n + k; } if (j <= n && k <= n) { if (j == n) { i = n + k; } else { i = n + k + n + n; } } else { i = n + k; } return i; }", "public static int nextPrime(int desiredCapacity){ int h = 1; int k = 0; while (h != desiredCapacity) { if (isPrime(h)) { k++; } h++; } return k; }", "public static int nextPrime(int desiredCapacity){ if (desiredCapacity <= 1) { return 2; } if (desiredCapacity <= 3) { return 3; } if (desiredCapacity <= 5) { return 5; } if (desiredCapacity <= 7) { return 7; } if (desiredCapacity <= 11) { return 11; } return (int) (Math.ceil(Math.log(desiredCapacity) / Math.log(2))); }", "public static int nextPrime(int desiredCapacity){ int prime = 1; while (true) { if (isPrime(prime)) { return prime; } prime++; } }", "public static int nextPrime(int desiredCapacity){ int i = 0; int j = 1; int k = j; do { i = j + 1; k = j + 1; j = i; } while ((k <= desiredCapacity) && (i <= j)); if (k <= desiredCapacity) { return k; } else { return i; } }", "public static int nextPrime(int desiredCapacity){ int n = 1; while (true) { if (isPrime(n)) { return n; } n++; } }", "public static int nextPrime(int desiredCapacity){ if (desiredCapacity <= 0) return 0; int i = 2; while (true) { if (isPrime(i)) { return i; } i++; } }"], "code_level": "slib_runnable", "_id": "636766a81a6d9265ec01758e", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else {\n    return c - 'a' + 10;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  }\n  return c - 'a' + 10;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else if (c >= 'a' && c <= 'f') {\n    return c - 'a' + 10;\n  } else if (c >= 'A' && c <= 'F') {\n    return c - 'A' + 10;\n  } else {\n    throw new IllegalArgumentException(\"Invalid digit: \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else if (c >= 'A' && c <= 'F') {\n    return c - 'A' + 10;\n  } else if (c >= 'a' && c <= 'f') {\n    return c - 'a' + 10;\n  } else {\n    throw new IllegalArgumentException(\"Character \" + c + \" is not a valid digit\");\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  }\n  return -1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  }\n  return c - 'A' + 10;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else {\n    throw new IllegalArgumentException(String.format(\"Invalid digit '%s'\", c));\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  }\n  if (c >= 'a' && c <= 'f') {\n    return c - 'a' + 10;\n  }\n  if (c >= 'A' && c <= 'F') {\n    return c - 'A' + 10;\n  }\n  throw new IllegalArgumentException(\"Illegal character in a digit: \" + c);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else {\n    throw new IllegalArgumentException(\"Invalid digit '\" + c + \"'\");\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if ('0' <= c && c <= '9') {\n    return c - '0';\n  } else if ('a' <= c && c <= 'z') {\n    return c - 'a' + 10;\n  } else if ('A' <= c && c <= 'Z') {\n    return c - 'A' + 10;\n  } else {\n    throw new IllegalArgumentException(\"Invalid character \" + c + \" in numeric value\");\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()} but we don't accept non-ASCII digits.\n */\n", "method_name": "digitValue", "codes": ["private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } else { return c - 'a' + 10; } }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } return c - 'a' + 10; }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } else if (c >= 'a' && c <= 'f') { return c - 'a' + 10; } else if (c >= 'A' && c <= 'F') { return c - 'A' + 10; } else { throw new IllegalArgumentException(\"Invalid digit: \" + c); } }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } else if (c >= 'A' && c <= 'F') { return c - 'A' + 10; } else if (c >= 'a' && c <= 'f') { return c - 'a' + 10; } else { throw new IllegalArgumentException(\"Character \" + c + \" is not a valid digit\"); } }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } return -1; }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } return c - 'A' + 10; }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } else { throw new IllegalArgumentException(String.format(\"Invalid digit '%s'\", c)); } }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } if (c >= 'a' && c <= 'f') { return c - 'a' + 10; } if (c >= 'A' && c <= 'F') { return c - 'A' + 10; } throw new IllegalArgumentException(\"Illegal character in a digit: \" + c); }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } else { throw new IllegalArgumentException(\"Invalid digit '\" + c + \"'\"); } }", "private static int digitValue(final char c){ if ('0' <= c && c <= '9') { return c - '0'; } else if ('a' <= c && c <= 'z') { return c - 'a' + 10; } else if ('A' <= c && c <= 'Z') { return c - 'A' + 10; } else { throw new IllegalArgumentException(\"Invalid character \" + c + \" in numeric value\"); } }"], "code_level": "self_contained", "_id": "636767a61a6d9265ec0185b7", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "private static boolean isHex(final char c) {\n  return '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Is this a hex digit?\n */\n", "method_name": "isHex", "codes": ["private static boolean isHex(final char c){ return '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F'; }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F'; }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F'; }", "private static boolean isHex(final char c){ return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); }", "private static boolean isHex(final char c){ return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F'; }", "private static boolean isHex(final char c){ return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'); }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f'; }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F'; }", "private static boolean isHex(final char c){ return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); }"], "code_level": "self_contained", "_id": "636767ab1a6d9265ec018676", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  if (buffer.writableBytes() < message.getSerializedSize()) {\n    throw new IllegalArgumentException(\"message must have a fixed length\");\n  }\n  int writtenBytes = writeDelimitedTo(out, message, schema, buffer.next(), buffer);\n  buffer.reset();\n  return writtenBytes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  if (message instanceof MessageLite) {\n    return writeDelimitedTo(out, (MessageLite) message, schema, buffer);\n  }\n  if (message instanceof GeneratedMessageLite) {\n    return writeDelimitedTo(out, (GeneratedMessageLite) message, schema, buffer);\n  }\n  if (message instanceof GeneratedExtensionLite) {\n    return writeDelimitedTo(out, (GeneratedExtensionLite) message, schema, buffer);\n  }\n  if (message instanceof ExtendableMessageLite) {\n    return writeDelimitedTo(out, (ExtendableMessageLite) message, schema, buffer);\n  }\n  if (message instanceof Deprecated) {\n    writeDeprecatedTo(out, (Deprecated) message, schema, buffer);\n  }\n  if (message instanceof UnknownFieldSet) {\n    return writeUnknownFieldsTo(out, (UnknownFieldSet) message, schema, buffer);\n  }\n  if (message instanceof Internal.EnumLite) {\n    return writeEnumTo(out, (Internal.EnumLite) message, schema, buffer);\n  }\n  if (message instanceof UnknownFieldSetLite) {\n    return writeUnknownFieldsTo(out, (UnknownFieldSetLite) message, schema, buffer);\n  }\n  if (message instanceof MessageLite.Builder) {\n    return writeMessageTo(out, (MessageLite.Builder) message, schema, buffer);\n  }\n  if (message instanceof MessageLite.BuilderLite) {\n    return writeMessageTo(out, (MessageLite.BuilderLite) message, schema, buffer);\n  }\n  if (message instanceof MessageLite) {\n    return writeMessageTo(out, (MessageLite) message, schema, buffer);\n  }\n  if (message instanceof MessageLite.Builder) {\n    return writeMessageTo(out, (MessageLite.Builder) message, schema, buffer);\n  }\n  if (message instanceof MessageLite.BuilderLite) {\n    return writeMessageTo(out, (MessageLite.BuilderLite) message, schema, buffer);\n  }\n  if (message instanceof Message) {\n    return writeMessageTo(out, (Message) message, schema, buffer);\n  }\n  throw new IllegalArgumentException(\"Unknown message type.\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer == null) { throw new NullPointerException(\"buffer\"); } if (schema == null) { throw new NullPointerException(\"schema\"); } int size = 0; if (message instanceof GenericRecord) { GenericRecord genericRecord = (GenericRecord) message; Schema.Type type = schema.getType(); if (type == Schema.Type.BYTES) { GenericData.Record data = (GenericData.Record) genericRecord; if (data.getSchema().getType() == Schema.Type.STRING) { writeBytesTo(out, (byte[]) data.get(\"data\"), buffer); } else { writeBytesTo(out, (byte[]) data.get(\"data\"), (byte[]) data.get(\"data\"), buffer); } } else if (type == Schema.Type.INT) { writeIntTo(out, (Integer) genericRecord.get(\"id\"), buffer); } else if (type == Schema.Type.FLOAT) { writeFloatTo(out, (Float) genericRecord.get(\"x\"), buffer); } else if (type == Schema.Type.LONG) { writeLongTo(out, (Long) genericRecord.get(\"x\"), buffer); } else if (type == Schema.Type.DOUBLE) { writeDoubleTo(out, (Double) genericRecord.get(\"x\"), buffer); } else if (type == Schema.Type.BOOLEAN) { writeBooleanTo(out, (Boolean) genericRecord.get(\"x\"), buffer); } else if (type == Schema.Type.STRING) { writeStringTo(out, (String) genericRecord.get(\"data\"), buffer); } else { throw new UnsupportedOperationException(\"Unsupported type: \" + type); } } else if (message instanceof GenericArray) { GenericData.Array genericArray = (GenericData.Array) message; Schema.Type type = schema.getType(); if (type == Schema.Type.BYTES) { byte[] data = (byte[]) genericArray.get(\"data\"); if (data.length > 0) { writeBytesTo(out, data, buffer); } } else if (type == Schema.Type.INT) { writeIntTo(out, (Integer) genericArray.get(\"id\"), buffer); } else if (type == Schema.Type.FLOAT) { writeFloatTo(out, (Float) genericArray.get(\"x\"), buffer); } else if (type == Schema.Type.LONG) { writeLongTo(out, (Long) genericArray.get(\"x\"), buffer); } else if (type == Schema.Type.DOUBLE) { writeDoubleTo(out, (Double) genericArray.get(\"x\"), buffer); } else if (type == Schema.Type.BOOLEAN) { writeBooleanTo(out, (Boolean) genericArray.get(\"x\"), buffer); } else if (type == Schema.Type.STRING) { writeStringTo(out, (String) genericArray.get(\"data\"), buffer); } else { throw new UnsupportedOperationException(\"Unsupported type: \" + type); } } else { throw", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  return writeDelimitedTo(out, message, schema, buffer, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  int written = 0;\n  try {\n    final int n = schema.getFieldCount();\n    final int maxLength = buffer.length();\n    for (int i = 0; i < n; i++) {\n      final T field = schema.getField(i).getDefaultValue();\n      if (field == null) {\n        out.write(NULL);\n      } else {\n        if (buffer.isReadable()) {\n          final byte[] bytes = field.serialize(message);\n          written += bytes.length;\n          out.write(bytes);\n        } else {\n          out.write(buffer.buffer(), 0, buffer.length());\n        }\n      }\n    }\n  } catch (SerializationException e) {\n    throw new IOException(e);\n  }\n  return written;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  try (TOutput output = TOutput.create(out, schema, buffer)) {\n    output.writeDelimitedTo(message);\n    return output.size();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  if (buffer == null) {\n    throw new NullPointerException(\"buffer\");\n  }\n  if (message == null) {\n    throw new NullPointerException(\"message\");\n  }\n  int size = 0;\n  while (true) {\n    int r = writeDelimitedTo(out, message, schema, buffer, size);\n    if (r == 0) {\n      break;\n    }\n    size += r;\n  }\n  return size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  if (buffer == null) {\n    throw new NullPointerException(\"buffer must not be null\");\n  }\n  if (message == null) {\n    throw new NullPointerException(\"message must not be null\");\n  }\n  if (schema == null) {\n    throw new NullPointerException(\"schema must not be null\");\n  }\n  int size;\n  try {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream(buffer.capacity());\n    writeDelimitedTo(message, schema, baos, buffer);\n    size = baos.size();\n    out.write(baos.toByteArray());\n  } catch (IOException e) {\n    throw e;\n  } catch (Exception e) {\n    throw new RuntimeException(e);\n  }\n  return size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  if (message instanceof GeneratedMessage) {\n    GeneratedMessage.Builder<?> builder = ((GeneratedMessage) message).newBuilderForType();\n    builder.mergeFrom((byte[]) message);\n    return writeDelimitedTo(out, builder.build(), schema, buffer);\n  } else {\n    return writeDelimitedTo(out, message, schema, buffer);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  try (TOutput output = new TOutput(out, buffer.alloc())) {\n    schema.writeTo(output, message);\n    return output.size();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.\n * @return the size of the message\n */\n", "method_name": "writeDelimitedTo", "codes": ["public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer.writableBytes() < message.getSerializedSize()) { throw new IllegalArgumentException(\"message must have a fixed length\"); } int writtenBytes = writeDelimitedTo(out, message, schema, buffer.next(), buffer); buffer.reset(); return writtenBytes; }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (message instanceof MessageLite) { return writeDelimitedTo(out, (MessageLite) message, schema, buffer); } if (message instanceof GeneratedMessageLite) { return writeDelimitedTo(out, (GeneratedMessageLite) message, schema, buffer); } if (message instanceof GeneratedExtensionLite) { return writeDelimitedTo(out, (GeneratedExtensionLite) message, schema, buffer); } if (message instanceof ExtendableMessageLite) { return writeDelimitedTo(out, (ExtendableMessageLite) message, schema, buffer); } if (message instanceof Deprecated) { writeDeprecatedTo(out, (Deprecated) message, schema, buffer); } if (message instanceof UnknownFieldSet) { return writeUnknownFieldsTo(out, (UnknownFieldSet) message, schema, buffer); } if (message instanceof Internal.EnumLite) { return writeEnumTo(out, (Internal.EnumLite) message, schema, buffer); } if (message instanceof UnknownFieldSetLite) { return writeUnknownFieldsTo(out, (UnknownFieldSetLite) message, schema, buffer); } if (message instanceof MessageLite.Builder) { return writeMessageTo(out, (MessageLite.Builder) message, schema, buffer); } if (message instanceof MessageLite.BuilderLite) { return writeMessageTo(out, (MessageLite.BuilderLite) message, schema, buffer); } if (message instanceof MessageLite) { return writeMessageTo(out, (MessageLite) message, schema, buffer); } if (message instanceof MessageLite.Builder) { return writeMessageTo(out, (MessageLite.Builder) message, schema, buffer); } if (message instanceof MessageLite.BuilderLite) { return writeMessageTo(out, (MessageLite.BuilderLite) message, schema, buffer); } if (message instanceof Message) { return writeMessageTo(out, (Message) message, schema, buffer); } throw new IllegalArgumentException(\"Unknown message type.\"); }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer == null) { throw new NullPointerException(\"buffer\"); } if (schema == null) { throw new NullPointerException(\"schema\"); } int size = 0; if (message instanceof GenericRecord) { GenericRecord genericRecord = (GenericRecord) message; Schema.Type type = schema.getType(); if (type == Schema.Type.BYTES) { GenericData.Record data = (GenericData.Record) genericRecord; if (data.getSchema().getType() == Schema.Type.STRING) { writeBytesTo(out, (byte[]) data.get(\"data\"), buffer); } else { writeBytesTo(out, (byte[]) data.get(\"data\"), (byte[]) data.get(\"data\"), buffer); } } else if (type == Schema.Type.INT) { writeIntTo(out, (Integer) genericRecord.get(\"id\"), buffer); } else if (type == Schema.Type.FLOAT) { writeFloatTo(out, (Float) genericRecord.get(\"x\"), buffer); } else if (type == Schema.Type.LONG) { writeLongTo(out, (Long) genericRecord.get(\"x\"), buffer); } else if (type == Schema.Type.DOUBLE) { writeDoubleTo(out, (Double) genericRecord.get(\"x\"), buffer); } else if (type == Schema.Type.BOOLEAN) { writeBooleanTo(out, (Boolean) genericRecord.get(\"x\"), buffer); } else if (type == Schema.Type.STRING) { writeStringTo(out, (String) genericRecord.get(\"data\"), buffer); } else { throw new UnsupportedOperationException(\"Unsupported type: \" + type); } } else if (message instanceof GenericArray) { GenericData.Array genericArray = (GenericData.Array) message; Schema.Type type = schema.getType(); if (type == Schema.Type.BYTES) { byte[] data = (byte[]) genericArray.get(\"data\"); if (data.length > 0) { writeBytesTo(out, data, buffer); } } else if (type == Schema.Type.INT) { writeIntTo(out, (Integer) genericArray.get(\"id\"), buffer); } else if (type == Schema.Type.FLOAT) { writeFloatTo(out, (Float) genericArray.get(\"x\"), buffer); } else if (type == Schema.Type.LONG) { writeLongTo(out, (Long) genericArray.get(\"x\"), buffer); } else if (type == Schema.Type.DOUBLE) { writeDoubleTo(out, (Double) genericArray.get(\"x\"), buffer); } else if (type == Schema.Type.BOOLEAN) { writeBooleanTo(out, (Boolean) genericArray.get(\"x\"), buffer); } else if (type == Schema.Type.STRING) { writeStringTo(out, (String) genericArray.get(\"data\"), buffer); } else { throw new UnsupportedOperationException(\"Unsupported type: \" + type); } } else { throw", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { return writeDelimitedTo(out, message, schema, buffer, false); }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { int written = 0; try { final int n = schema.getFieldCount(); final int maxLength = buffer.length(); for (int i = 0; i < n; i++) { final T field = schema.getField(i).getDefaultValue(); if (field == null) { out.write(NULL); } else { if (buffer.isReadable()) { final byte[] bytes = field.serialize(message); written += bytes.length; out.write(bytes); } else { out.write(buffer.buffer(), 0, buffer.length()); } } } } catch (SerializationException e) { throw new IOException(e); } return written; }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { try (TOutput output = TOutput.create(out, schema, buffer)) { output.writeDelimitedTo(message); return output.size(); } }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer == null) { throw new NullPointerException(\"buffer\"); } if (message == null) { throw new NullPointerException(\"message\"); } int size = 0; while (true) { int r = writeDelimitedTo(out, message, schema, buffer, size); if (r == 0) { break; } size += r; } return size; }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer == null) { throw new NullPointerException(\"buffer must not be null\"); } if (message == null) { throw new NullPointerException(\"message must not be null\"); } if (schema == null) { throw new NullPointerException(\"schema must not be null\"); } int size; try { ByteArrayOutputStream baos = new ByteArrayOutputStream(buffer.capacity()); writeDelimitedTo(message, schema, baos, buffer); size = baos.size(); out.write(baos.toByteArray()); } catch (IOException e) { throw e; } catch (Exception e) { throw new RuntimeException(e); } return size; }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (message instanceof GeneratedMessage) { GeneratedMessage.Builder<?> builder = ((GeneratedMessage) message).newBuilderForType(); builder.mergeFrom((byte[]) message); return writeDelimitedTo(out, builder.build(), schema, buffer); } else { return writeDelimitedTo(out, message, schema, buffer); } }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { try (TOutput output = new TOutput(out, buffer.alloc())) { schema.writeTo(output, message); return output.size(); } }"], "code_level": "project_runnable", "_id": "636767a41a6d9265ec018582", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == null) {\n    return false;\n  }\n  if (len <= 0) {\n    return false;\n  }\n  for (int i = 0; i < len; i++) {\n    if (data[offset + i] != m_a[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == null) {\n    throw new NullPointerException(\"data\");\n  }\n  if (offset < 0 || offset > data.length || len < 0 || len > data.length - offset) {\n    return false;\n  }\n  for (int i = 0; i < len; i++) {\n    if (data[i + offset] != array[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == null) {\n    return false;\n  }\n  if (offset + len > data.length) {\n    return false;\n  }\n  for (int i = 0; i < len; ++i) {\n    if (data[offset + i] != this.data[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (len == 0) {\n    return true;\n  }\n  int i = offset;\n  if (len > data.length) {\n    len = data.length;\n  }\n  int j = 0;\n  while (j < len) {\n    if (data[i++] != data[j++]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (len == 0) {\n    return true;\n  }\n  for (int i = 0; i < len; i++) {\n    if (data[offset + i] != this.data[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == null) {\n    throw new NullPointerException();\n  }\n  if (offset < 0 || len < 0 || offset + len > data.length) {\n    throw new IndexOutOfBoundsException();\n  }\n  for (int i = 0; i < len; i++) {\n    if (data[offset + i] != get(i)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == null) {\n    return false;\n  }\n  if (len == 0) {\n    return true;\n  }\n  if (data.length - offset < len) {\n    return false;\n  }\n  for (int i = 0; i < len; i++) {\n    if (data[i + offset] != data[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (offset < 0 || offset + len > data.length) {\n    return false;\n  }\n  for (int i = 0; i < len; i++) {\n    if (this.data[i + offset] != data[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == null || data.length == 0) {\n    return false;\n  }\n  if (offset < 0 || len < 0 || offset + len > data.length) {\n    return false;\n  }\n  if (len == 0) {\n    return true;\n  }\n  if (offset + len > data.length) {\n    len = data.length - offset;\n  }\n  for (int i = 0; i < len; i++) {\n    if (data[offset + i] != array[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == null) {\n    return false;\n  }\n  if (offset + len > data.length) {\n    return false;\n  }\n  for (int i = 0; i < len; i++) {\n    if (data[offset + i] != this.data[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Returns true if the contents of the internal array and the provided array match.\n */\n", "method_name": "equals", "codes": ["public boolean equals(final byte[] data,int offset,final int len){ if (data == null) { return false; } if (len <= 0) { return false; } for (int i = 0; i < len; i++) { if (data[offset + i] != m_a[i]) { return false; } } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (data == null) { throw new NullPointerException(\"data\"); } if (offset < 0 || offset > data.length || len < 0 || len > data.length - offset) { return false; } for (int i = 0; i < len; i++) { if (data[i + offset] != array[i]) { return false; } } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (data == null) { return false; } if (offset + len > data.length) { return false; } for (int i = 0; i < len; ++i) { if (data[offset + i] != this.data[i]) { return false; } } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (len == 0) { return true; } int i = offset; if (len > data.length) { len = data.length; } int j = 0; while (j < len) { if (data[i++] != data[j++]) { return false; } } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (len == 0) { return true; } for (int i = 0; i < len; i++) { if (data[offset + i] != this.data[i]) { return false; } } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (data == null) { throw new NullPointerException(); } if (offset < 0 || len < 0 || offset + len > data.length) { throw new IndexOutOfBoundsException(); } for (int i = 0; i < len; i++) { if (data[offset + i] != get(i)) { return false; } } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (data == null) { return false; } if (len == 0) { return true; } if (data.length - offset < len) { return false; } for (int i = 0; i < len; i++) { if (data[i + offset] != data[i]) { return false; } } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (offset < 0 || offset + len > data.length) { return false; } for (int i = 0; i < len; i++) { if (this.data[i + offset] != data[i]) { return false; } } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (data == null || data.length == 0) { return false; } if (offset < 0 || len < 0 || offset + len > data.length) { return false; } if (len == 0) { return true; } if (offset + len > data.length) { len = data.length - offset; } for (int i = 0; i < len; i++) { if (data[offset + i] != array[i]) { return false; } } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (data == null) { return false; } if (offset + len > data.length) { return false; } for (int i = 0; i < len; i++) { if (data[offset + i] != this.data[i]) { return false; } } return true; }"], "code_level": "class_runnable", "_id": "636767a51a6d9265ec01859d", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  final int utf8Len = computeUTF8Length(str, index, len);\n  return utf8Len;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  if (len == 0) {\n    return 0;\n  }\n  int size = 0;\n  for (int i = index; i < index + len; i++) {\n    size += computeUTF8Size(str.charAt(i));\n  }\n  return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  if (str == null) {\n    return 0;\n  } else if (index + len > str.length()) {\n    return str.length() - index;\n  } else {\n    return computeUTF8Size(str, index, len, false);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  if (str == null) {\n    return 0;\n  }\n  if (index + len > str.length()) {\n    return str.length() - index;\n  }\n  return computeUTF8Size0(str, index, len);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  if (str == null) {\n    return 0;\n  }\n  final int utfLen = str.length();\n  if (index < 0 || index >= utfLen) {\n    throw new IndexOutOfBoundsException(\"index: \" + index);\n  }\n  if (len < 0 || (index + len) > utfLen) {\n    throw new IndexOutOfBoundsException(\"len: \" + len);\n  }\n  final int totalLength = 1 + 2 + 2 + 2 + len;\n  if (totalLength > utfLen) {\n    throw new UTFDataFormatException(\"String too long: \" + str);\n  }\n  final int numBytes = (utfLen - 1) / BYTE_SIZE;\n  final byte[] bytes = new byte[numBytes];\n  final int n = 0;\n  for (int i = 0; i < utfLen; i++) {\n    final int charPos = i * BYTE_SIZE;\n    final int charCount = (len > 0 ? (charPos + 1) : 0);\n    final byte b = (byte) (str.charAt(index + i) & 0xFF);\n    bytes[n] = b;\n    if (charCount > 0) {\n      bytes[n + 1] = (byte) ((b >> 8) & 0xFF);\n      bytes[n + 2] = (byte) (b & 0xFF);\n    }\n    n += 3;\n  }\n  return totalLength + numBytes * BYTE_SIZE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  final int end = index + len;\n  for (int i = index; i < end; i++) {\n    final char c = str.charAt(i);\n    if (c >= 0x0001) {\n      if (c < 0x007F) {\n        len += 2;\n      } else if (c < 0x07FF) {\n        len += 3;\n      } else {\n        len += 4;\n      }\n    } else {\n      len += 1;\n    }\n  }\n  return len;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  return computeUTF8Size(str, index, len, false);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  if (str == null) {\n    return 0;\n  }\n  return computeUTF8Size(str, index, len, false);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  int size = 0;\n  if (str == null) {\n    return size;\n  }\n  final int len2 = len;\n  for (int i = index; i < len2; i++) {\n    size += computeUTF8SizeNoTag(str.charAt(i));\n  }\n  return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  final int utf16Size = computeUTF16Size(str, index, len);\n  return utf16Size + computeUTF8Size(str, index + len, len);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.\n */\n", "method_name": "computeUTF8Size", "codes": ["public static int computeUTF8Size(final CharSequence str,final int index,final int len){ final int utf8Len = computeUTF8Length(str, index, len); return utf8Len; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ if (len == 0) { return 0; } int size = 0; for (int i = index; i < index + len; i++) { size += computeUTF8Size(str.charAt(i)); } return size; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ if (str == null) { return 0; } else if (index + len > str.length()) { return str.length() - index; } else { return computeUTF8Size(str, index, len, false); } }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ if (str == null) { return 0; } if (index + len > str.length()) { return str.length() - index; } return computeUTF8Size0(str, index, len); }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ if (str == null) { return 0; } final int utfLen = str.length(); if (index < 0 || index >= utfLen) { throw new IndexOutOfBoundsException(\"index: \" + index); } if (len < 0 || (index + len) > utfLen) { throw new IndexOutOfBoundsException(\"len: \" + len); } final int totalLength = 1 + 2 + 2 + 2 + len; if (totalLength > utfLen) { throw new UTFDataFormatException(\"String too long: \" + str); } final int numBytes = (utfLen - 1) / BYTE_SIZE; final byte[] bytes = new byte[numBytes]; final int n = 0; for (int i = 0; i < utfLen; i++) { final int charPos = i * BYTE_SIZE; final int charCount = (len > 0 ? (charPos + 1) : 0); final byte b = (byte) (str.charAt(index + i) & 0xFF); bytes[n] = b; if (charCount > 0) { bytes[n + 1] = (byte) ((b >> 8) & 0xFF); bytes[n + 2] = (byte) (b & 0xFF); } n += 3; } return totalLength + numBytes * BYTE_SIZE; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ final int end = index + len; for (int i = index; i < end; i++) { final char c = str.charAt(i); if (c >= 0x0001) { if (c < 0x007F) { len += 2; } else if (c < 0x07FF) { len += 3; } else { len += 4; } } else { len += 1; } } return len; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ return computeUTF8Size(str, index, len, false); }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ if (str == null) { return 0; } return computeUTF8Size(str, index, len, false); }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ int size = 0; if (str == null) { return size; } final int len2 = len; for (int i = index; i < len2; i++) { size += computeUTF8SizeNoTag(str.charAt(i)); } return size; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ final int utf16Size = computeUTF16Size(str, index, len); return utf16Size + computeUTF8Size(str, index + len, len); }"], "code_level": "self_contained", "_id": "636767a41a6d9265ec01856c", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  if (str == null) {\n    return lb;\n  }\n  try {\n    final byte[] bytes = str.toString().getBytes(\"UTF-8\");\n    session.write(bytes, 0, bytes.length);\n    return lb;\n  } catch (final Exception e) {\n    throw new IllegalStateException(e);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  if (str == null) {\n    return lb;\n  }\n  lb.append(str);\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  final int len = str.length();\n  lb.writeUtf8(str, 0, len);\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  try {\n    final ByteBuffer bb = session.getBuffer().duplicate();\n    bb.position(0);\n    final int len = str.length();\n    bb.limit(len);\n    final CharBuffer cb = CharBuffer.wrap(str);\n    cb.rewind();\n    lb.add(cb);\n    lb.add(bb);\n  } catch (final Exception e) {\n    throw new RuntimeException(e);\n  }\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  final int len = str.length();\n  if (len == 0) {\n    return lb;\n  }\n  final int sz = session.getBufferSize();\n  final int sz2 = lb.size();\n  final int n = sz2 - sz;\n  final int n2 = lb.offset + lb.length;\n  final byte[] bytes = session.getBuffer();\n  final byte[] buf = lb.buffer;\n  final int n3 = lb.offset + lb.length;\n  final int n4 = n3 + n;\n  final int n5 = n2 + n;\n  final int n6 = n4 + n2;\n  final int n7 = n5 + n;\n  final int n8 = n6 + n3;\n  for (int i = n7; i < n8; ++i) {\n    buf[i] = (byte) str.charAt(i - n7);\n  }\n  for (int i2 = n; i2 < n2; ++i2) {\n    buf[i2] = (byte) 0;\n  }\n  for (int i3 = n3; i3 < n4; ++i3) {\n    buf[i3] = (byte) 0;\n  }\n  for (int i4 = n3; i4 < n5; ++i4) {\n    buf[i4] = (byte) 0;\n  }\n  for (int i5 = n3; i5 < n6; ++i5) {\n    buf[i5] = (byte) 0;\n  }\n  for (int i6 = n3; i6 < n7; ++i6) {\n    buf[i6] = (byte) 0;\n  }\n  for (int i7 = n; i7 < n8; ++i7) {\n    buf[i7] = (byte) 0;\n  }\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  try {\n    lb.writeUTF8(str);\n    return lb;\n  } catch (final IOException ioe) {\n    throw new RuntimeException(ioe);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  if (str == null) {\n    lb.appendNull();\n    return lb;\n  }\n  final int len = str.length();\n  if (len == 0) {\n    lb.appendNull();\n    return lb;\n  }\n  lb.append(str);\n  lb.append('\\0');\n  lb.append(str.codePointAt(0));\n  lb.append('\\0');\n  lb.append(str.codePointAt(len - 1));\n  lb.append('\\0');\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  final int strLen = str.length();\n  int pos = lb.pos();\n  lb.putUtf8(str);\n  lb.putUtf8(str, 0, strLen);\n  lb.putUtf8(str, pos, strLen);\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  if (str == null) {\n    lb.writeByte((byte) 0);\n    return lb;\n  }\n  final int len = str.length();\n  lb.writeByte((byte) (len >>> 8));\n  lb.writeByte((byte) len);\n  final int i = 0;\n  final char[] chars = str.toString().toCharArray();\n  for (int j = 0; j < chars.length; j++) {\n    final char c = chars[j];\n    lb.writeChar(c);\n    if (c < 0x800) {\n      lb.writeByte((byte) ((c >> 6) | 0xc0));\n      lb.writeByte((byte) (c & 0x3f));\n    } else {\n      lb.writeByte((byte) (0xe0 | ((c >> 12) & 0xf)));\n      lb.writeByte((byte) (0x80 | ((c >> 6) & 0x3f)));\n      lb.writeByte((byte) (0x80 | ((c & 0x3f))));\n    }\n  }\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  if (str == null) {\n    return lb;\n  }\n  final int len = str.length();\n  final byte[] bytes = new byte[len];\n  int pos = 0;\n  int i;\n  for (i = 0; i < len; i++) {\n    char c = str.charAt(i);\n    if (c <= 0x7F) {\n      bytes[pos++] = (byte) c;\n    } else if (c <= 0x7FF) {\n      bytes[pos++] = (byte) (0xC0 | ((c >> 6) & 0x1F));\n      bytes[pos++] = (byte) (0x80 | ((c & 0x3F)));\n    } else if (c <= 0xFFFF) {\n      bytes[pos++] = (byte) (0xE0 | ((c >> 12) & 0x0F));\n      bytes[pos++] = (byte) (0x80 | ((c >> 6) & 0x3F));\n      bytes[pos++] = (byte) (0x80 | ((c & 0x3F)));\n    } else {\n      bytes[pos++] = (byte) (0xF0 | ((c >> 18) & 0x0F));\n      bytes[pos++] = (byte) (0x80 | ((c >> 12) & 0x3F));\n      bytes[pos++] = (byte) (0x80 | ((c >> 6) & 0x3F));\n      bytes[pos++] = (byte) (0x80 | ((c & 0x3F)));\n    }\n  }\n  lb.addBytes(bytes, 0, pos);\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Writes the utf8-encoded bytes from the string into the  {@link LinkedBuffer}.\n */\n", "method_name": "writeUTF8", "codes": ["public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ if (str == null) { return lb; } try { final byte[] bytes = str.toString().getBytes(\"UTF-8\"); session.write(bytes, 0, bytes.length); return lb; } catch (final Exception e) { throw new IllegalStateException(e); } }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ if (str == null) { return lb; } lb.append(str); return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ final int len = str.length(); lb.writeUtf8(str, 0, len); return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ try { final ByteBuffer bb = session.getBuffer().duplicate(); bb.position(0); final int len = str.length(); bb.limit(len); final CharBuffer cb = CharBuffer.wrap(str); cb.rewind(); lb.add(cb); lb.add(bb); } catch (final Exception e) { throw new RuntimeException(e); } return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ final int len = str.length(); if (len == 0) { return lb; } final int sz = session.getBufferSize(); final int sz2 = lb.size(); final int n = sz2 - sz; final int n2 = lb.offset + lb.length; final byte[] bytes = session.getBuffer(); final byte[] buf = lb.buffer; final int n3 = lb.offset + lb.length; final int n4 = n3 + n; final int n5 = n2 + n; final int n6 = n4 + n2; final int n7 = n5 + n; final int n8 = n6 + n3; for (int i = n7; i < n8; ++i) { buf[i] = (byte) str.charAt(i - n7); } for (int i2 = n; i2 < n2; ++i2) { buf[i2] = (byte) 0; } for (int i3 = n3; i3 < n4; ++i3) { buf[i3] = (byte) 0; } for (int i4 = n3; i4 < n5; ++i4) { buf[i4] = (byte) 0; } for (int i5 = n3; i5 < n6; ++i5) { buf[i5] = (byte) 0; } for (int i6 = n3; i6 < n7; ++i6) { buf[i6] = (byte) 0; } for (int i7 = n; i7 < n8; ++i7) { buf[i7] = (byte) 0; } return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ try { lb.writeUTF8(str); return lb; } catch (final IOException ioe) { throw new RuntimeException(ioe); } }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ if (str == null) { lb.appendNull(); return lb; } final int len = str.length(); if (len == 0) { lb.appendNull(); return lb; } lb.append(str); lb.append('\\0'); lb.append(str.codePointAt(0)); lb.append('\\0'); lb.append(str.codePointAt(len - 1)); lb.append('\\0'); return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ final int strLen = str.length(); int pos = lb.pos(); lb.putUtf8(str); lb.putUtf8(str, 0, strLen); lb.putUtf8(str, pos, strLen); return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ if (str == null) { lb.writeByte((byte) 0); return lb; } final int len = str.length(); lb.writeByte((byte) (len >>> 8)); lb.writeByte((byte) len); final int i = 0; final char[] chars = str.toString().toCharArray(); for (int j = 0; j < chars.length; j++) { final char c = chars[j]; lb.writeChar(c); if (c < 0x800) { lb.writeByte((byte) ((c >> 6) | 0xc0)); lb.writeByte((byte) (c & 0x3f)); } else { lb.writeByte((byte) (0xe0 | ((c >> 12) & 0xf))); lb.writeByte((byte) (0x80 | ((c >> 6) & 0x3f))); lb.writeByte((byte) (0x80 | ((c & 0x3f)))); } } return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ if (str == null) { return lb; } final int len = str.length(); final byte[] bytes = new byte[len]; int pos = 0; int i; for (i = 0; i < len; i++) { char c = str.charAt(i); if (c <= 0x7F) { bytes[pos++] = (byte) c; } else if (c <= 0x7FF) { bytes[pos++] = (byte) (0xC0 | ((c >> 6) & 0x1F)); bytes[pos++] = (byte) (0x80 | ((c & 0x3F))); } else if (c <= 0xFFFF) { bytes[pos++] = (byte) (0xE0 | ((c >> 12) & 0x0F)); bytes[pos++] = (byte) (0x80 | ((c >> 6) & 0x3F)); bytes[pos++] = (byte) (0x80 | ((c & 0x3F))); } else { bytes[pos++] = (byte) (0xF0 | ((c >> 18) & 0x0F)); bytes[pos++] = (byte) (0x80 | ((c >> 12) & 0x3F)); bytes[pos++] = (byte) (0x80 | ((c >> 6) & 0x3F)); bytes[pos++] = (byte) (0x80 | ((c & 0x3F))); } } lb.addBytes(bytes, 0, pos); return lb; }"], "code_level": "project_runnable", "_id": "636767ab1a6d9265ec01867b", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public long readRawVarint64() throws IOException {\n  long result = 0;\n  for (int shift = 0; shift < 64; shift += 7) {\n    final byte b = readRawByte();\n    result |= (long) (b & 0x7F) << shift;\n    if ((b & 0x80) == 0) {\n      return result;\n    }\n  }\n  throw InvalidProtocolBufferException.malformedVarint();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  long ret = 0;\n  byte tmp = 0;\n  int b;\n  while ((b = read()) != -1) {\n    tmp = (byte) (tmp << 8 | b);\n    if ((b & 0x80) == 0) {\n      return ret;\n    }\n    ret |= (long) (b & 0x7F);\n    if ((b & 0x80) == 0) {\n      return ret;\n    }\n  }\n  throw InvalidProtocolBufferException.malformedVarint();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  return VarInts.readRawVarint64(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  byte[] buf = new byte[64];\n  int read = readRawBytes(buf);\n  if (read == buf.length) {\n    return readRawVarint32();\n  } else {\n    return readRawVarint64SlowPath(buf, 0, read);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  byte b = readRawByte();\n  if (b >= 0) {\n    return b;\n  } else if (b < -128) {\n    return b + ((b & 0x7f) << 7);\n  } else {\n    b = readRawByte();\n    if (b >= 0) {\n      return b + ((b & 0x7f) << 14);\n    } else if (b < -32768) {\n      return b + ((b & 0x7f) << 21);\n    } else {\n      b = readRawByte();\n      if (b >= 0) {\n        return b + ((b & 0x7f) << 28);\n      } else if (b < -2147483648) {\n        return b + ((b & 0x7f) << 35);\n      } else {\n        b = readRawByte();\n        if (b >= 0) {\n          return b + ((b & 0x7f) << 42);\n        } else if (b < -9223372036854775808L) {\n          return b + ((b & 0x7f) << 49);\n        } else {\n          throw InvalidProtocolBufferException.truncatedMessage();\n        }\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  return ((long) readRawVarint32()) & 0xFFFFFFFFL;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public long readRawVarint64() throws IOException {\n  byte tmp = readRawByte();\n  long result = 0;\n  while (tmp >= 0) {\n    result |= (tmp & 0x7F) << (31 - 7);\n    tmp = readRawByte();\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  if (buffer.size == bufferPointer) {\n    fillBuffer();\n  }\n  long result = buffer.get(bufferPointer++);\n  if (bufferPointer == buffer.size) {\n    bufferPointer = 0;\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  byte[] bytes = new byte[8];\n  int i = readRawByte(bytes, 0, 8);\n  long result = 0;\n  for (int shift = 0; shift < 8; shift += 7) {\n    result |= ((long) bytes[i] & 0xff) << shift;\n    i++;\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  long result = 0;\n  int shift = 0;\n  int byteCount = 0;\n  while (shift < 64) {\n    final byte currentByte = readByte();\n    result |= (currentByte & 0x7F) << shift;\n    if ((currentByte & 0x80) == 0) {\n      break;\n    }\n    shift += 7;\n    byteCount++;\n  }\n  if (byteCount == 0) {\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n  return result >>> (64 - byteCount);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Read a raw Varint from the stream.\n */\n", "method_name": "readRawVarint64", "codes": ["public long readRawVarint64() throws IOException { long result = 0; for (int shift = 0; shift < 64; shift += 7) { final byte b = readRawByte(); result |= (long) (b & 0x7F) << shift; if ((b & 0x80) == 0) { return result; } } throw InvalidProtocolBufferException.malformedVarint(); }", "public long readRawVarint64() throws IOException { long ret = 0; byte tmp = 0; int b; while ((b = read()) != -1) { tmp = (byte) (tmp << 8 | b); if ((b & 0x80) == 0) { return ret; } ret |= (long) (b & 0x7F); if ((b & 0x80) == 0) { return ret; } } throw InvalidProtocolBufferException.malformedVarint(); }", "public long readRawVarint64() throws IOException { return VarInts.readRawVarint64(this); }", "public long readRawVarint64() throws IOException { byte[] buf = new byte[64]; int read = readRawBytes(buf); if (read == buf.length) { return readRawVarint32(); } else { return readRawVarint64SlowPath(buf, 0, read); } }", "public long readRawVarint64() throws IOException { byte b = readRawByte(); if (b >= 0) { return b; } else if (b < -128) { return b + ((b & 0x7f) << 7); } else { b = readRawByte(); if (b >= 0) { return b + ((b & 0x7f) << 14); } else if (b < -32768) { return b + ((b & 0x7f) << 21); } else { b = readRawByte(); if (b >= 0) { return b + ((b & 0x7f) << 28); } else if (b < -2147483648) { return b + ((b & 0x7f) << 35); } else { b = readRawByte(); if (b >= 0) { return b + ((b & 0x7f) << 42); } else if (b < -9223372036854775808L) { return b + ((b & 0x7f) << 49); } else { throw InvalidProtocolBufferException.truncatedMessage(); } } } } }", "public long readRawVarint64() throws IOException { return ((long) readRawVarint32()) & 0xFFFFFFFFL; }", "public long readRawVarint64() throws IOException { byte tmp = readRawByte(); long result = 0; while (tmp >= 0) { result |= (tmp & 0x7F) << (31 - 7); tmp = readRawByte(); } return result; }", "public long readRawVarint64() throws IOException { if (buffer.size == bufferPointer) { fillBuffer(); } long result = buffer.get(bufferPointer++); if (bufferPointer == buffer.size) { bufferPointer = 0; } return result; }", "public long readRawVarint64() throws IOException { byte[] bytes = new byte[8]; int i = readRawByte(bytes, 0, 8); long result = 0; for (int shift = 0; shift < 8; shift += 7) { result |= ((long) bytes[i] & 0xff) << shift; i++; } return result; }", "public long readRawVarint64() throws IOException { long result = 0; int shift = 0; int byteCount = 0; while (shift < 64) { final byte currentByte = readByte(); result |= (currentByte & 0x7F) << shift; if ((currentByte & 0x80) == 0) { break; } shift += 7; byteCount++; } if (byteCount == 0) { throw InvalidProtocolBufferNanoException.truncatedMessage(); } return result >>> (64 - byteCount); }"], "code_level": "class_runnable", "_id": "636767a41a6d9265ec018572", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  int size = 0;\n  if (node != null) {\n    size += writeTo(out, node.head);\n    size += writeTo(out, node.tail);\n  }\n  return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  out.writeInt(node.size);\n  out.writeInt(node.buffer.remaining());\n  out.write(node.buffer.array(), node.buffer.arrayOffset() + node.buffer.position(), node.size);\n  return node.size + node.buffer.remaining();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  int size = 0;\n  while (node != null) {\n    out.writeByte(node.bufferSize());\n    size += node.bufferSize();\n    node = node.next;\n  }\n  return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  if (node == null) {\n    out.writeInt(0);\n    return 0;\n  }\n  final int nodeSize = node.size();\n  final int minSize = nodeSize < MIN_SIZE ? MIN_SIZE : nodeSize;\n  final int maxSize = nodeSize > MAX_SIZE ? MAX_SIZE : nodeSize;\n  out.writeInt(minSize);\n  out.writeInt(maxSize);\n  final int pos = 0;\n  out.writeInt(node.buffer.length);\n  for (final int i : node) {\n    out.writeInt(i);\n  }\n  return minSize + maxSize;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  int totalSize = 0;\n  if (node == null) {\n    totalSize += 1;\n  } else {\n    totalSize += node.getSize();\n    totalSize += writeTo(out, node.getNext());\n    totalSize += writeTo(out, node.getPrev());\n  }\n  return totalSize;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  out.writeInt(node.size());\n  for (int i = 0; i < node.size(); ++i) {\n    out.writeInt(node.get(i).key());\n    out.writeInt(node.get(i).value());\n  }\n  return node.size();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  out.writeInt(node.size());\n  out.writeInt(node.capacity());\n  out.writeInt(node.buffer().capacity());\n  if (node.buffer().isDirect()) {\n    if (node.buffer().isReadOnly()) {\n      out.writeBoolean(false);\n    } else {\n      out.writeBoolean(true);\n      out.writeLong(node.buffer().position());\n      out.writeLong(node.buffer().limit());\n    }\n  } else {\n    if (node.buffer().isReadOnly()) {\n      out.writeBoolean(true);\n    } else {\n      out.writeBoolean(false);\n      out.writeInt(node.buffer().position());\n      out.writeInt(node.buffer().limit());\n    }\n  }\n  return node.size();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  out.writeInt(node.buffer.length);\n  out.write(node.buffer);\n  return node.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  if (node == null) {\n    out.writeBoolean(false);\n    return 0;\n  }\n  out.writeBoolean(true);\n  out.writeInt(node.length());\n  return node.writeTo(out);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  int size = 0;\n  size += writeTo(out, node.header);\n  size += writeTo(out, node.body);\n  return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Writes the contents of the  {@link LinkedBuffer} into the {@link DataOutput}.\n * @return the total content size of the buffer.\n */\n", "method_name": "writeTo", "codes": ["public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { int size = 0; if (node != null) { size += writeTo(out, node.head); size += writeTo(out, node.tail); } return size; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { out.writeInt(node.size); out.writeInt(node.buffer.remaining()); out.write(node.buffer.array(), node.buffer.arrayOffset() + node.buffer.position(), node.size); return node.size + node.buffer.remaining(); }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { int size = 0; while (node != null) { out.writeByte(node.bufferSize()); size += node.bufferSize(); node = node.next; } return size; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { if (node == null) { out.writeInt(0); return 0; } final int nodeSize = node.size(); final int minSize = nodeSize < MIN_SIZE ? MIN_SIZE : nodeSize; final int maxSize = nodeSize > MAX_SIZE ? MAX_SIZE : nodeSize; out.writeInt(minSize); out.writeInt(maxSize); final int pos = 0; out.writeInt(node.buffer.length); for (final int i : node) { out.writeInt(i); } return minSize + maxSize; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { int totalSize = 0; if (node == null) { totalSize += 1; } else { totalSize += node.getSize(); totalSize += writeTo(out, node.getNext()); totalSize += writeTo(out, node.getPrev()); } return totalSize; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { out.writeInt(node.size()); for (int i = 0; i < node.size(); ++i) { out.writeInt(node.get(i).key()); out.writeInt(node.get(i).value()); } return node.size(); }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { out.writeInt(node.size()); out.writeInt(node.capacity()); out.writeInt(node.buffer().capacity()); if (node.buffer().isDirect()) { if (node.buffer().isReadOnly()) { out.writeBoolean(false); } else { out.writeBoolean(true); out.writeLong(node.buffer().position()); out.writeLong(node.buffer().limit()); } } else { if (node.buffer().isReadOnly()) { out.writeBoolean(true); } else { out.writeBoolean(false); out.writeInt(node.buffer().position()); out.writeInt(node.buffer().limit()); } } return node.size(); }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { out.writeInt(node.buffer.length); out.write(node.buffer); return node.length; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { if (node == null) { out.writeBoolean(false); return 0; } out.writeBoolean(true); out.writeInt(node.length()); return node.writeTo(out); }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { int size = 0; size += writeTo(out, node.header); size += writeTo(out, node.body); return size; }"], "code_level": "class_runnable", "_id": "636767aa1a6d9265ec01865a", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "@Override\npublic String readString() throws IOException {\n  return this.readString(this.reader.readInt());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  int i = this.readRawVarint32();\n  if ((i & -128) != 0) {\n    return readString(i, true);\n  }\n  return readString(i, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  return StreamUtils.readString(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  final int size = readUnsignedShort();\n  if (size == 0) {\n    return null;\n  } else if (size == 1) {\n    return \"\";\n  } else {\n    final StringBuilder buf = new StringBuilder(size);\n    for (int i = 0; i < size; i++) {\n      buf.append(readChar());\n    }\n    return buf.toString();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  return readString(length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  return readString(getStream());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  return readString(\"\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  return readString(stream.readInt());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  int len = readVInt();\n  if (len == 0) {\n    return null;\n  }\n  byte[] bytes = new byte[len];\n  readBytes(bytes, 0, len);\n  return new String(bytes, StandardCharsets.UTF_8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  return readString(null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Read a  {@code string} field value from the stream.\n */\n", "method_name": "readString", "codes": ["@Override public String readString() throws IOException { return this.readString(this.reader.readInt()); }", "@Override public String readString() throws IOException { int i = this.readRawVarint32(); if ((i & -128) != 0) { return readString(i, true); } return readString(i, false); }", "@Override public String readString() throws IOException { return StreamUtils.readString(this); }", "@Override public String readString() throws IOException { final int size = readUnsignedShort(); if (size == 0) { return null; } else if (size == 1) { return \"\"; } else { final StringBuilder buf = new StringBuilder(size); for (int i = 0; i < size; i++) { buf.append(readChar()); } return buf.toString(); } }", "@Override public String readString() throws IOException { return readString(length()); }", "@Override public String readString() throws IOException { return readString(getStream()); }", "@Override public String readString() throws IOException { return readString(\"\"); }", "@Override public String readString() throws IOException { return readString(stream.readInt()); }", "@Override public String readString() throws IOException { int len = readVInt(); if (len == 0) { return null; } byte[] bytes = new byte[len]; readBytes(bytes, 0, len); return new String(bytes, StandardCharsets.UTF_8); }", "@Override public String readString() throws IOException { return readString(null); }"], "code_level": "project_runnable", "_id": "636767a31a6d9265ec018552", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public final byte[] toByteArray() {\n  byte[] result = new byte[buffer.remaining()];\n  buffer.get(result);\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  return Arrays.copyOf(buf, buf.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  byte[] result = new byte[this.buffer.remaining()];\n  this.buffer.get(result);\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  return buf.toByteArray();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  byte[] arr = new byte[buf.remaining()];\n  buf.get(arr);\n  return arr;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  return _buffer;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  return buf.array();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  byte[] arr = new byte[length()];\n  int i = 0;\n  for (byte b : this.buffer) {\n    arr[i++] = b;\n  }\n  return arr;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  byte[] result = new byte[size()];\n  int i = 0;\n  for (byte[] s : arrays) {\n    System.arraycopy(s, 0, result, i, s.length);\n    i += s.length;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  byte[] data = new byte[buf.length];\n  for (int i = 0; i < data.length; i++) {\n    data[i] = buf[i];\n  }\n  return data;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Returns a single byte array containg all the contents written to the buffer(s).\n */\n", "method_name": "toByteArray", "codes": ["public final byte[] toByteArray(){ byte[] result = new byte[buffer.remaining()]; buffer.get(result); return result; }", "public final byte[] toByteArray(){ return Arrays.copyOf(buf, buf.length); }", "public final byte[] toByteArray(){ byte[] result = new byte[this.buffer.remaining()]; this.buffer.get(result); return result; }", "public final byte[] toByteArray(){ return buf.toByteArray(); }", "public final byte[] toByteArray(){ byte[] arr = new byte[buf.remaining()]; buf.get(arr); return arr; }", "public final byte[] toByteArray(){ return _buffer; }", "public final byte[] toByteArray(){ return buf.array(); }", "public final byte[] toByteArray(){ byte[] arr = new byte[length()]; int i = 0; for (byte b : this.buffer) { arr[i++] = b; } return arr; }", "public final byte[] toByteArray(){ byte[] result = new byte[size()]; int i = 0; for (byte[] s : arrays) { System.arraycopy(s, 0, result, i, s.length); i += s.length; } return result; }", "public final byte[] toByteArray(){ byte[] data = new byte[buf.length]; for (int i = 0; i < data.length; i++) { data[i] = buf[i]; } return data; }"], "code_level": "project_runnable", "_id": "636767a21a6d9265ec018517", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "private static int compareSigned(long a, long b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  return a < b ? -1 : (a == b ? 0 : 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  return (a < b) ? -1 : ((a > b) ? 1 : 0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  return Long.signum(a - b);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  if (a > b) {\n    return 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  if (a < b) {\n    return -1;\n  } else if (a == b) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  return (a < b) ? -1 : ((a == b) ? 0 : 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  return a < b ? -1 : (a == b ? 0 : 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  return (a < b) ? -1 : ((a > b) ? 1 : 0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  return (int) (a - b);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares the two specified  {@code long} values. The sign of the value returned is the same as that of{@code ((Long) a).compareTo(b)}. <p> <b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the equivalent {@link Long#compare} method instead.\n * @param a the first  {@code long} to compare\n * @param b the second  {@code long} to compare\n * @return a negative value if {@code a} is less than {@code b}; a positive value if  {@code a} is greater than{@code b}; or zero if they are equal\n */\n", "method_name": "compareSigned", "codes": ["private static int compareSigned(long a,long b){ if (a < b) { return -1; } if (a > b) { return 1; } return 0; }", "private static int compareSigned(long a,long b){ return a < b ? -1 : (a == b ? 0 : 1); }", "private static int compareSigned(long a,long b){ return (a < b) ? -1 : ((a > b) ? 1 : 0); }", "private static int compareSigned(long a,long b){ return Long.signum(a - b); }", "private static int compareSigned(long a,long b){ if (a > b) { return 1; } if (a < b) { return -1; } return 0; }", "private static int compareSigned(long a,long b){ if (a < b) { return -1; } else if (a == b) { return 0; } else { return 1; } }", "private static int compareSigned(long a,long b){ return (a < b) ? -1 : ((a == b) ? 0 : 1); }", "private static int compareSigned(long a,long b){ return a < b ? -1 : (a == b ? 0 : 1); }", "private static int compareSigned(long a,long b){ return (a < b) ? -1 : ((a > b) ? 1 : 0); }", "private static int compareSigned(long a,long b){ return (int) (a - b); }"], "code_level": "self_contained", "_id": "636767a41a6d9265ec01857e", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public byte[] toByteArray() {\n  return getBytes(0, length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  return new byte[] {\n    (byte) ((value >> 24) & 0xFF),\n    (byte) ((value >> 16) & 0xFF),\n    (byte) ((value >> 8) & 0xFF),\n    (byte) (value & 0xFF)\n  };\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  byte[] array = new byte[length()];\n  for (int i = 0; i < length(); i++) {\n    array[i] = get(i);\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  return byteArray.get();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  return _buffer.array();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  return (byte[]) toByteArray(null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  return toByteArray(0, size());\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  byte[] res = new byte[data.length];\n  System.arraycopy(data, 0, res, 0, data.length);\n  return res;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  byte[] bytes = new byte[size];\n  for (int i = 0; i < size; i++) {\n    bytes[i] = byteArray[i];\n  }\n  return bytes;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  return this.buf.toByteArray();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Copies bytes to a  {@code byte[]}.\n */\n", "method_name": "toByteArray", "codes": ["public byte[] toByteArray(){ return getBytes(0, length()); }", "public byte[] toByteArray(){ return new byte[] { (byte) ((value >> 24) & 0xFF), (byte) ((value >> 16) & 0xFF), (byte) ((value >> 8) & 0xFF), (byte) (value & 0xFF) }; }", "public byte[] toByteArray(){ byte[] array = new byte[length()]; for (int i = 0; i < length(); i++) { array[i] = get(i); } return array; }", "public byte[] toByteArray(){ return byteArray.get(); }", "public byte[] toByteArray(){ return _buffer.array(); }", "public byte[] toByteArray(){ return (byte[]) toByteArray(null); }", "public byte[] toByteArray(){ return toByteArray(0, size()); }", "public byte[] toByteArray(){ byte[] res = new byte[data.length]; System.arraycopy(data, 0, res, 0, data.length); return res; }", "public byte[] toByteArray(){ byte[] bytes = new byte[size]; for (int i = 0; i < size; i++) { bytes[i] = byteArray[i]; } return bytes; }", "public byte[] toByteArray(){ return this.buf.toByteArray(); }"], "code_level": "self_contained", "_id": "636767aa1a6d9265ec01864a", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "private void checkIfPackedField() throws IOException {\n  if (this.packedFieldsRead != this.fieldsRead) {\n    throw new IOException(\n        \"Fields read and written from a Lucene index was not the same as the index\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (!packed) {\n    int packedLength = packedLength();\n    if (packedLength > 0 && (packedLength <= byteLength || byteLength < 0)) {\n      byteLength = packedLength;\n    }\n    if (byteLength > 0) {\n      byteBuffer.position(byteBuffer.position() + byteLength);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (fieldNumber >= fields.length) {\n    int newLength = fields.length + (fieldNumber * 4) + 4;\n    if (newLength > maxFieldLength) {\n      throw new IllegalStateException(\n          \"Cannot push field to a field that is too large: \"\n              + fieldNumber\n              + \" - \"\n              + maxFieldLength);\n    }\n    byte[] newBytes = new byte[newLength];\n    System.arraycopy(fields, 0, newBytes, 0, fields.length);\n    fields = newBytes;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (this.packedFields.size() > 0) {\n    this.bytesTotal += this.packedFields.size();\n    this.bytesRead += this.packedFields.size() * this.bytesPerField;\n    this.bytesRead += this.packedFields.size() * this.bytesPerField;\n    this.bytesRead += this.packedFields.size() * this.bytesPerField;\n    this.bytesRead += this.packedFields.size() * this.bytesPerField;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException { if (!isPackedField()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { ", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (packed) {\n    return;\n  }\n  int numBytes = readInt();\n  if (numBytes == 0) {\n    return;\n  }\n  int numFields = readInt();\n  if (numFields < 0) {\n    throw new IllegalArgumentException(\"Number of fields must be >= 0\");\n  }\n  fields = new Object[numFields];\n  for (int i = 0; i < numFields; i++) {\n    fields[i] = readObject();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (!packed) {\n    if (packedIntsVersion >= VERSION_CURRENT) {\n      if (!field.isStored()) {\n        field.setLength(in.readVInt());\n      } else {\n        field.setLength(in.readVLong());\n      }\n    } else {\n      field.setLength(in.readVLong());\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (packedFields.isEmpty()) {\n    return;\n  }\n  if (packedFields.size() == 1) {\n    return;\n  }\n  int numFields = packedFields.size();\n  int numFieldsToUpdate = numFields - 1;\n  if (numFieldsToUpdate == 0) {\n    return;\n  }\n  int fieldCount = 0;\n  for (int i = 0; i < numFields; i++) {\n    FieldInfo fi = packedFields.get(i);\n    if (fi.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)\n        < 0) {\n      fieldCount++;\n    }\n  }\n  if (fieldCount == numFields) {\n    return;\n  }\n  if (fieldCount == 1 && numFields == 1) {\n    if (packedFields\n            .get(0)\n            .getIndexOptions()\n            .compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)\n        == 0) {\n      return;\n    }\n  }\n  if (fieldCount > 1 && numFields == 1) {\n    if (packedFields\n            .get(0)\n            .getIndexOptions()\n            .compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)\n        == 0) {\n      return;\n    }\n  }\n  int lastFieldIdx = numFields - 1;\n  FieldInfo lastFieldInfo = packedFields.get(lastFieldIdx);\n  if (lastFieldInfo\n          .getIndexOptions()\n          .compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)\n      < 0) {\n    lastFieldInfo.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n  } else {\n    lastFieldInfo.setIndexOptions(\n        lastFieldInfo\n                    .getIndexOptions()\n                    .compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)\n                > 0\n            ? lastFieldInfo.getIndexOptions()\n            : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n  }\n  if (numFieldsToUpdate > 0) {\n    int fieldCountToUpdate = numFieldsToUpdate;\n    for (int i = lastFieldIdx; i < fieldCount; i++) {\n      FieldInfo fi = packedFields.get(i);\n      if (fi.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)\n          < 0) {\n        fieldCountToUpdate--;\n      } else {\n        fi.setIndexOptions(\n            fi.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)\n                    > 0\n                ? fi.getIndexOptions()\n                : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n      }\n    }\n    if (fieldCountToUpdate > 0) {\n      throw new IllegalStateException(\n          \"Fields have been updated but they are not added to the same index: \" + packedFields);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (packedIntsVersion.onOrAfter(Version.V_5_0_0_alpha1)) {\n    checkLengthDelimitedField();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (fields.size() > 1) {\n    throw new IOException(\"Multiple fields are not supported: \" + fields.toString());\n  }\n  if (fields.isEmpty()) {\n    throw new IOException(\"No field is present in incoming field stream.\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n", "method_name": "checkIfPackedField", "codes": ["private void checkIfPackedField() throws IOException { if (this.packedFieldsRead != this.fieldsRead) { throw new IOException(\"Fields read and written from a Lucene index was not the same as the index\"); } }", "private void checkIfPackedField() throws IOException { if (!packed) { int packedLength = packedLength(); if (packedLength > 0 && (packedLength <= byteLength || byteLength < 0)) { byteLength = packedLength; } if (byteLength > 0) { byteBuffer.position(byteBuffer.position() + byteLength); } } }", "private void checkIfPackedField() throws IOException { if (fieldNumber >= fields.length) { int newLength = fields.length + (fieldNumber * 4) + 4; if (newLength > maxFieldLength) { throw new IllegalStateException(\"Cannot push field to a field that is too large: \" + fieldNumber + \" - \" + maxFieldLength); } byte[] newBytes = new byte[newLength]; System.arraycopy(fields, 0, newBytes, 0, fields.length); fields = newBytes; } }", "private void checkIfPackedField() throws IOException { if (this.packedFields.size() > 0) { this.bytesTotal += this.packedFields.size(); this.bytesRead += this.packedFields.size() * this.bytesPerField; this.bytesRead += this.packedFields.size() * this.bytesPerField; this.bytesRead += this.packedFields.size() * this.bytesPerField; this.bytesRead += this.packedFields.size() * this.bytesPerField; } }", "private void checkIfPackedField() throws IOException { if (!isPackedField()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { if (input.readBoolean()) { ", "private void checkIfPackedField() throws IOException { if (packed) { return; } int numBytes = readInt(); if (numBytes == 0) { return; } int numFields = readInt(); if (numFields < 0) { throw new IllegalArgumentException(\"Number of fields must be >= 0\"); } fields = new Object[numFields]; for (int i = 0; i < numFields; i++) { fields[i] = readObject(); } }", "private void checkIfPackedField() throws IOException { if (!packed) { if (packedIntsVersion >= VERSION_CURRENT) { if (!field.isStored()) { field.setLength(in.readVInt()); } else { field.setLength(in.readVLong()); } } else { field.setLength(in.readVLong()); } } }", "private void checkIfPackedField() throws IOException { if (packedFields.isEmpty()) { return; } if (packedFields.size() == 1) { return; } int numFields = packedFields.size(); int numFieldsToUpdate = numFields - 1; if (numFieldsToUpdate == 0) { return; } int fieldCount = 0; for (int i = 0; i < numFields; i++) { FieldInfo fi = packedFields.get(i); if (fi.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) { fieldCount++; } } if (fieldCount == numFields) { return; } if (fieldCount == 1 && numFields == 1) { if (packedFields.get(0).getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) == 0) { return; } } if (fieldCount > 1 && numFields == 1) { if (packedFields.get(0).getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) == 0) { return; } } int lastFieldIdx = numFields - 1; FieldInfo lastFieldInfo = packedFields.get(lastFieldIdx); if (lastFieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) { lastFieldInfo.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS); } else { lastFieldInfo.setIndexOptions(lastFieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) > 0 ? lastFieldInfo.getIndexOptions() : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS); } if (numFieldsToUpdate > 0) { int fieldCountToUpdate = numFieldsToUpdate; for (int i = lastFieldIdx; i < fieldCount; i++) { FieldInfo fi = packedFields.get(i); if (fi.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) { fieldCountToUpdate--; } else { fi.setIndexOptions(fi.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) > 0 ? fi.getIndexOptions() : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS); } } if (fieldCountToUpdate > 0) { throw new IllegalStateException(\"Fields have been updated but they are not added to the same index: \" + packedFields); } } }", "private void checkIfPackedField() throws IOException { if (packedIntsVersion.onOrAfter(Version.V_5_0_0_alpha1)) { checkLengthDelimitedField(); } }", "private void checkIfPackedField() throws IOException { if (fields.size() > 1) { throw new IOException(\"Multiple fields are not supported: \" + fields.toString()); } if (fields.isEmpty()) { throw new IOException(\"No field is present in incoming field stream.\"); } }"], "code_level": "class_runnable", "_id": "636767a31a6d9265ec01854f", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public int readTag() throws IOException {\n  int tag = readRawVarint32();\n  if (tag == 0) {\n    return 0;\n  }\n  checkLastTagWas(WireFormat.makeTag(tag, WireFormat.WIRETYPE_END_GROUP));\n  return tag;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int readTag() throws IOException { int tag = readRawVarint32(); if (tag != 0) { if ((tag & 0x00000010) != 0) { return tag; } if ((tag & 0x00000002) != 0) { return tag; } if ((tag & 0x00000004) != 0) { return tag; } if ((tag & 0x00000020) != 0) { return tag; } if ((tag & 0x00000040) != 0) { return tag; } if ((tag & 0x00000080) != 0) { return tag; } if ((tag & 0x00000100) != 0) { return tag; } if ((tag & 0x00000200) != 0) { return tag; } if ((tag & 0x00000400) != 0) { return tag; } if ((tag & 0x00000800) != 0) { return tag; } if ((tag & 0x00001000) != 0) { return tag; } if ((tag & 0x00002000) != 0) { return tag; } if ((tag & 0x00004000) != 0) { return tag; } if ((tag & 0x00008000) != 0) { return tag; } if ((tag & 0x00010000) != 0) { return tag; } if ((tag & 0x00020000) != 0) { return tag; } if ((tag & 0x00040000) != 0) { return tag; } if ((tag & 0x00080000) != 0) { return tag; } if ((tag & 0x00100000) != 0) { return tag; } if ((tag & 0x00200000) != 0) { return tag; } if ((tag & 0x00400000) != 0) { return tag; } if ((tag & 0x00800000) != 0) { return tag; } if ((tag & 0x01000000) != 0) { return tag; } if ((tag & 0x02000000) != 0) { return tag; } if ((tag & 0x04000000) != 0) { return tag; } if ((tag & 0x08000000) != 0) { return tag; } if ((tag & 0x10000000) != 0) { return tag; } if ((tag & 0x20000000) != 0) { return tag; } if ((tag & 0x40000000) != 0) { return tag; } if ((tag & 0x80000000) != 0) { return tag; } if ((tag & 0x100000000) != 0) { return tag; } if ((tag & 0x200000000) != 0) { return tag; } if ((tag & 0x400000000) != 0) { return tag; } if ((tag & 0x800000000) != 0) { return tag; } if ((tag & 0x10000000) != 0) { return tag; } if ((tag & 0x20000000) != 0) { return tag; } if ((tag & 0x400000000) != 0) { return tag; } if ((tag & 0x80000000) != 0) { return tag; } } throw InvalidProtocolBufferException.truncatedMessage(); }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = readRawVarint32();\n  if ((tag >= 0) && (tag <= 31)) {\n    return tag;\n  }\n  if (tag >= 0) {\n    throw ProtobufException.invalidTag();\n  }\n  int result = WireFormat.getTagFieldNumber(tag);\n  if (result == -1) {\n    throw ProtobufException.invalidTag();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int readTag() throws IOException {\n  int tag = in.readTag();\n  if (tag == 0) {\n    throw new EOFException();\n  }\n  return tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = input.readTag();\n  if (tag == 0) {\n    return 0;\n  }\n  if (tag < 0) {\n    throw InvalidProtocolBufferMicroException.invalidTag();\n  }\n  return tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = readRawVarint32();\n  if (tag != 0) {\n    return tag;\n  }\n  tag = readRawVarint32();\n  if (tag >= 0 && tag <= 7) {\n    return tag;\n  }\n  tag = (tag << 7) | readRawVarint32();\n  if (tag >= 0 && tag <= 7) {\n    return tag;\n  }\n  throw InvalidProtocolBufferException.invalidTag();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException { if (this._currToken == JsonToken.FIELD_NAME) { this._nameCopied = false; String name = this._parser.getCurrentName(); this._currToken = this._parser.nextToken(); if (name.equals(\"int32\")) { return this.readInt32(); } else if (name.equals(\"int64\")) { return this.readInt64(); } else if (name.equals(\"uint32\")) { return this.readUInt32(); } else if (name.equals(\"uint64\")) { return this.readUInt64(); } else if (name.equals(\"sint32\")) { return this.readSInt32(); } else if (name.equals(\"sint64\")) { return this.readSInt64(); } else if (name.equals(\"fixed32\")) { return this.readFixed32(); } else if (name.equals(\"fixed64\")) { return this.readFixed64(); } else if (name.equals(\"sfixed32\")) { return this.readSFixed32(); } else if (name.equals(\"sfixed64\")) { return this.readSFixed64(); } else if (name.equals(\"bool\")) { return this.readBool(); } else if (name.equals(\"string\")) { return this.readString(); } else if (name.equals(\"bytes\")) { return this.readBytes(); } else if (name.equals(\"group\")) { return this.readGroup(); } else if (name.equals(\"mutable_message\")) { return this.readMutableMessage(); } else if (name.equals(\"nested_message\")) { return this.readNestedMessage(); } else if (name.equals(\"nested_enum\")) { return this.readNestedEnum(); } else if (name.equals(\"enum\")) { return this.readEnum(); } else if (name.equals(\"complex\")) { return this.readComplex(); } else if (name.equals(\"nested_complex\")) { return this.readNestedComplex(); } else if (name.equals(\"nested_enum_with_default\")) { return this.readNestedEnumWithDefault(); } else if (name.equals(\"nested_enum_with_default_nested\")) { return this.readNestedEnumWithDefaultNested(); } else if (name.equals(\"nested_enum_with_default_nested_nested\")) { return this.readNestedEnumWithDefaultNestedNested(); } else if (name.equals(\"nested_enum_with_default_nested_nested_nested\")) { return this.readNestedEnumWithDefaultNestedNestedNested(); } else { throw new IllegalStateException(\"Unknown field name: \" + name); } } else { if (this._currToken == JsonToken.START_OBJECT) { this._parsingContext = this._parsingContext.createChildArrayContext(this._tokenInput", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = readRawVarint32();\n  if (tag >= 0 && tag < 0x80) return tag;\n  if (tag >= 0xc0 && tag <= 0xdf) {\n    return tag - 0xc0;\n  }\n  if (tag == 0xe0) {\n    int length = readRawVarint32();\n    if (length > 0 && length <= MAX_VARINT) {\n      return length;\n    }\n    return -1;\n  }\n  if (tag == 0xf0) {\n    int length = readRawVarint32();\n    if (length > 0 && length <= MAX_VARINT) {\n      return length;\n    }\n    return -1;\n  }\n  if (tag == 0x07) {\n    int length = readRawVarint32();\n    if (length > 0 && length <= MAX_VARINT) {\n      return length;\n    }\n    return -1;\n  }\n  if (tag == 0x0e) {\n    if (!lenient) {\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n    return -1;\n  }\n  if (tag >= 0x0f) {\n    throw InvalidProtocolBufferException.invalidTag();\n  }\n  throw InvalidProtocolBufferException.invalidRawVarint32();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = readRawVarint32();\n  if (tag != 0) {\n    return tag;\n  }\n  tag = readRawVarint32();\n  if (tag >= 0) {\n    return tag;\n  }\n  tag = tag << 1;\n  if ((tag & 1) == 0) {\n    tag |= 1;\n  }\n  return tag;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int readTag() throws IOException {\n  if (this.tag == null) {\n    readTagBody();\n  }\n  return this.tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.\n */\n", "method_name": "readTag", "codes": ["public int readTag() throws IOException { int tag = readRawVarint32(); if (tag == 0) { return 0; } checkLastTagWas(WireFormat.makeTag(tag, WireFormat.WIRETYPE_END_GROUP)); return tag; }", "public int readTag() throws IOException { int tag = readRawVarint32(); if (tag != 0) { if ((tag & 0x00000010) != 0) { return tag; } if ((tag & 0x00000002) != 0) { return tag; } if ((tag & 0x00000004) != 0) { return tag; } if ((tag & 0x00000020) != 0) { return tag; } if ((tag & 0x00000040) != 0) { return tag; } if ((tag & 0x00000080) != 0) { return tag; } if ((tag & 0x00000100) != 0) { return tag; } if ((tag & 0x00000200) != 0) { return tag; } if ((tag & 0x00000400) != 0) { return tag; } if ((tag & 0x00000800) != 0) { return tag; } if ((tag & 0x00001000) != 0) { return tag; } if ((tag & 0x00002000) != 0) { return tag; } if ((tag & 0x00004000) != 0) { return tag; } if ((tag & 0x00008000) != 0) { return tag; } if ((tag & 0x00010000) != 0) { return tag; } if ((tag & 0x00020000) != 0) { return tag; } if ((tag & 0x00040000) != 0) { return tag; } if ((tag & 0x00080000) != 0) { return tag; } if ((tag & 0x00100000) != 0) { return tag; } if ((tag & 0x00200000) != 0) { return tag; } if ((tag & 0x00400000) != 0) { return tag; } if ((tag & 0x00800000) != 0) { return tag; } if ((tag & 0x01000000) != 0) { return tag; } if ((tag & 0x02000000) != 0) { return tag; } if ((tag & 0x04000000) != 0) { return tag; } if ((tag & 0x08000000) != 0) { return tag; } if ((tag & 0x10000000) != 0) { return tag; } if ((tag & 0x20000000) != 0) { return tag; } if ((tag & 0x40000000) != 0) { return tag; } if ((tag & 0x80000000) != 0) { return tag; } if ((tag & 0x100000000) != 0) { return tag; } if ((tag & 0x200000000) != 0) { return tag; } if ((tag & 0x400000000) != 0) { return tag; } if ((tag & 0x800000000) != 0) { return tag; } if ((tag & 0x10000000) != 0) { return tag; } if ((tag & 0x20000000) != 0) { return tag; } if ((tag & 0x400000000) != 0) { return tag; } if ((tag & 0x80000000) != 0) { return tag; } } throw InvalidProtocolBufferException.truncatedMessage(); }", "public int readTag() throws IOException { int tag = readRawVarint32(); if ((tag >= 0) && (tag <= 31)) { return tag; } if (tag >= 0) { throw ProtobufException.invalidTag(); } int result = WireFormat.getTagFieldNumber(tag); if (result == -1) { throw ProtobufException.invalidTag(); } return result; }", "public int readTag() throws IOException { int tag = in.readTag(); if (tag == 0) { throw new EOFException(); } return tag; }", "public int readTag() throws IOException { int tag = input.readTag(); if (tag == 0) { return 0; } if (tag < 0) { throw InvalidProtocolBufferMicroException.invalidTag(); } return tag; }", "public int readTag() throws IOException { int tag = readRawVarint32(); if (tag != 0) { return tag; } tag = readRawVarint32(); if (tag >= 0 && tag <= 7) { return tag; } tag = (tag << 7) | readRawVarint32(); if (tag >= 0 && tag <= 7) { return tag; } throw InvalidProtocolBufferException.invalidTag(); }", "public int readTag() throws IOException { if (this._currToken == JsonToken.FIELD_NAME) { this._nameCopied = false; String name = this._parser.getCurrentName(); this._currToken = this._parser.nextToken(); if (name.equals(\"int32\")) { return this.readInt32(); } else if (name.equals(\"int64\")) { return this.readInt64(); } else if (name.equals(\"uint32\")) { return this.readUInt32(); } else if (name.equals(\"uint64\")) { return this.readUInt64(); } else if (name.equals(\"sint32\")) { return this.readSInt32(); } else if (name.equals(\"sint64\")) { return this.readSInt64(); } else if (name.equals(\"fixed32\")) { return this.readFixed32(); } else if (name.equals(\"fixed64\")) { return this.readFixed64(); } else if (name.equals(\"sfixed32\")) { return this.readSFixed32(); } else if (name.equals(\"sfixed64\")) { return this.readSFixed64(); } else if (name.equals(\"bool\")) { return this.readBool(); } else if (name.equals(\"string\")) { return this.readString(); } else if (name.equals(\"bytes\")) { return this.readBytes(); } else if (name.equals(\"group\")) { return this.readGroup(); } else if (name.equals(\"mutable_message\")) { return this.readMutableMessage(); } else if (name.equals(\"nested_message\")) { return this.readNestedMessage(); } else if (name.equals(\"nested_enum\")) { return this.readNestedEnum(); } else if (name.equals(\"enum\")) { return this.readEnum(); } else if (name.equals(\"complex\")) { return this.readComplex(); } else if (name.equals(\"nested_complex\")) { return this.readNestedComplex(); } else if (name.equals(\"nested_enum_with_default\")) { return this.readNestedEnumWithDefault(); } else if (name.equals(\"nested_enum_with_default_nested\")) { return this.readNestedEnumWithDefaultNested(); } else if (name.equals(\"nested_enum_with_default_nested_nested\")) { return this.readNestedEnumWithDefaultNestedNested(); } else if (name.equals(\"nested_enum_with_default_nested_nested_nested\")) { return this.readNestedEnumWithDefaultNestedNestedNested(); } else { throw new IllegalStateException(\"Unknown field name: \" + name); } } else { if (this._currToken == JsonToken.START_OBJECT) { this._parsingContext = this._parsingContext.createChildArrayContext(this._tokenInput", "public int readTag() throws IOException { int tag = readRawVarint32(); if (tag >= 0 && tag < 0x80) return tag; if (tag >= 0xc0 && tag <= 0xdf) { return tag - 0xc0; } if (tag == 0xe0) { int length = readRawVarint32(); if (length > 0 && length <= MAX_VARINT) { return length; } return -1; } if (tag == 0xf0) { int length = readRawVarint32(); if (length > 0 && length <= MAX_VARINT) { return length; } return -1; } if (tag == 0x07) { int length = readRawVarint32(); if (length > 0 && length <= MAX_VARINT) { return length; } return -1; } if (tag == 0x0e) { if (!lenient) { throw InvalidProtocolBufferException.truncatedMessage(); } return -1; } if (tag >= 0x0f) { throw InvalidProtocolBufferException.invalidTag(); } throw InvalidProtocolBufferException.invalidRawVarint32(); }", "public int readTag() throws IOException { int tag = readRawVarint32(); if (tag != 0) { return tag; } tag = readRawVarint32(); if (tag >= 0) { return tag; } tag = tag << 1; if ((tag & 1) == 0) { tag |= 1; } return tag; }", "public int readTag() throws IOException { if (this.tag == null) { readTagBody(); } return this.tag; }"], "code_level": "class_runnable", "_id": "636767a81a6d9265ec0185fc", "project_name": "protostuff-master"}]