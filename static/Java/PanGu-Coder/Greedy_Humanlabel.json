[{"generate_results": [{"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!dict.containsKey(message)) {\n    dict.put(message, timestamp);\n    return true;\n  }\n  if (dict.get(message) < timestamp - 10) {\n    dict.put(message, timestamp);\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. \n */\n", "method_name": "shouldPrintMessage", "codes": ["public boolean shouldPrintMessage(int timestamp,String message){ if (!dict.containsKey(message)) { dict.put(message, timestamp); return true; } if (dict.get(message) < timestamp - 10) { dict.put(message, timestamp); return true; } return false; }"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c73", "project_name": "interviews-master"}, {"generate_results": [{"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) return false;\n  int index = map.get(val);\n  if (index < list.size() - 1) {\n    int lastVal = list.get(list.size() - 1);\n    list.set(index, lastVal);\n    map.put(lastVal, index);\n  }\n  list.remove(list.size() - 1);\n  map.remove(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes a value from the set. Returns true if the set contained the specified element. \n */\n", "method_name": "remove", "codes": ["public boolean remove(int val){ if (!map.containsKey(val)) return false; int index = map.get(val); if (index < list.size() - 1) { int lastVal = list.get(list.size() - 1); list.set(index, lastVal); map.put(lastVal, index); } list.remove(list.size() - 1); map.remove(val); return true; }"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c74", "project_name": "interviews-master"}, {"generate_results": [{"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) {\n    return false;\n  }\n  map.put(val, new ArrayList<>());\n  List<Integer> list = map.get(val);\n  list.add(list.size());\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \n */\n", "method_name": "insert", "codes": ["public boolean insert(int val){ if (map.containsKey(val)) { return false; } map.put(val, new ArrayList<>()); List<Integer> list = map.get(val); list.add(list.size()); return true; }"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c78", "project_name": "interviews-master"}, {"generate_results": [{"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return array1.length == array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n", "method_name": "isSameLength", "codes": ["public static boolean isSameLength(final byte[] array1,final byte[] array2){ return array1.length == array2.length; }"], "code_level": "self_contained", "_id": "6367670b1a6d9265ec017a00", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Boolean</code> array, may be <code>null</code>\n * @return a <code>boolean</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }"], "code_level": "self_contained", "_id": "636767081a6d9265ec017989", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String toString(Object obj) {\n  if (obj == null) {\n    return \"\";\n  }\n  return obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string (\"\") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = \"\" ObjectUtils.toString(\"\")           = \"\" ObjectUtils.toString(\"bat\")        = \"bat\" ObjectUtils.toString(Boolean.TRUE) = \"true\" </pre>\n * @see StringUtils#defaultString(String)\n * @see String#valueOf(Object)\n * @param obj  the Object to <code>toString</code>, may be null\n * @return the passed in Object's toString, or nullStr if <code>null</code> input\n * @since 2.0\n */\n", "method_name": "toString", "codes": ["public static String toString(Object obj){ if (obj == null) { return \"\"; } return obj.toString(); }"], "code_level": "self_contained", "_id": "636766f81a6d9265ec01775c", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>\n * @param bool  the boolean to convert\n * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>\n */\n", "method_name": "toBoolean", "codes": ["public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }"], "code_level": "self_contained", "_id": "636766f91a6d9265ec01777f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }"], "code_level": "self_contained", "_id": "6367670b1a6d9265ec0179ff", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179e8", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Byte</code> array, may be <code>null</code>\n * @return a <code>byte</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }"], "code_level": "self_contained", "_id": "636767031a6d9265ec0178e6", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Reverses a String as per  {@link StringBuilder#reverse()}.</p> <p>A <code>null</code> String returns <code>null</code>.</p> <pre> StringUtils.reverse(null)  = null StringUtils.reverse(\"\")    = \"\" StringUtils.reverse(\"bat\") = \"tab\" </pre>\n * @param str  the String to reverse, may be null\n * @return the reversed String, <code>null</code> if null String input\n */\n", "method_name": "reverse", "codes": ["public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }"], "code_level": "slib_runnable", "_id": "636767001a6d9265ec017873", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isDigits(String str) {\n  if (str.length() == 0) return false;\n  for (int i = 0; i < str.length(); i++) {\n    if (!Character.isDigit(str.charAt(i))) return false;\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the <code>String</code> contains only digit characters.</p> <p><code>Null</code> and empty String will return <code>false</code>.</p>\n * @param str  the <code>String</code> to check\n * @return <code>true</code> if str contains only unicode numeric\n */\n", "method_name": "isDigits", "codes": ["public static boolean isDigits(String str){ if (str.length() == 0) return false; for (int i = 0; i < str.length(); i++) { if (!Character.isDigit(str.charAt(i))) return false; } return true; }"], "code_level": "slib_runnable", "_id": "636766ff1a6d9265ec01784b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  final int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n", "method_name": "endsWith", "codes": ["private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (suffix.length() > str.length()) { return false; } final int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"], "code_level": "self_contained", "_id": "6367670c1a6d9265ec017a35", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }"], "code_level": "self_contained", "_id": "636766f11a6d9265ec017651", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (array == null) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Double[] nullToEmpty(final Double[] array){ if (array == null) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else { return array; } }"], "code_level": "self_contained", "_id": "636767021a6d9265ec0178bb", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n * @param array  the array to test\n * @return <code>true</code> if the array is empty or <code>null</code>\n * @since 2.1\n */\n", "method_name": "isEmpty", "codes": ["public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }"], "code_level": "self_contained", "_id": "636766f01a6d9265ec01762e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>\n * @param bool  the boolean to check, null returns <code>true</code>\n * @return <code>true</code> if the input is null or false\n * @since 2.3\n */\n", "method_name": "isNotTrue", "codes": ["public static boolean isNotTrue(Boolean bool){ return !bool; }"], "code_level": "self_contained", "_id": "636766f21a6d9265ec017677", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Doubles to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Double</code> array, may be <code>null</code>\n * @return a <code>double</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }"], "code_level": "self_contained", "_id": "636766ff1a6d9265ec017842", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the Character to a char handling <code>null</code>.</p> <pre> CharUtils.toChar(null, 'X') = 'X' CharUtils.toChar(' ', 'X')  = ' ' CharUtils.toChar('A', 'X')  = 'A' </pre>\n * @param ch  the character to convert\n * @param defaultValue  the value to use if the  Character is null\n * @return the char value of the Character or the default if null\n */\n", "method_name": "toChar", "codes": ["public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179cf", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean isAllZeros(String s) {\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Utility method for  {@link #createNumber(String)}.</p> <p>Returns <code>true</code> if s is <code>null</code>.</p>\n * @param s the String to check\n * @return if it is all zeros or <code>null</code>\n */\n", "method_name": "isAllZeros", "codes": ["private static boolean isAllZeros(String s){ for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') { return false; } } return true; }"], "code_level": "self_contained", "_id": "636767081a6d9265ec0179a2", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Object to String ,when null object then null else return toString(); \n */\n", "method_name": "toString", "codes": ["public static String toString(Object object){ if (object == null) { return null; } else { return object.toString(); } }"], "code_level": "self_contained", "_id": "636766f21a6d9265ec01767d", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Integers to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Integer</code> array, may be <code>null</code>\n * @return an <code>int</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }"], "code_level": "self_contained", "_id": "6367670c1a6d9265ec017a2a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit control.</p> <pre> CharUtils.isAsciiControl('a')  = false CharUtils.isAsciiControl('A')  = false CharUtils.isAsciiControl('3')  = false CharUtils.isAsciiControl('-')  = false CharUtils.isAsciiControl('\\n') = true CharUtils.isAsciiControl('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if less than 32 or equals 127\n */\n", "method_name": "isAsciiControl", "codes": ["public static boolean isAsciiControl(final char ch){ return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'); }"], "code_level": "self_contained", "_id": "636766fa1a6d9265ec01779d", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive booleans to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>boolean</code> array\n * @return a <code>Boolean</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec017796", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive shorts to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>short</code> array\n * @return a <code>Short</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179f1", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Characters to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Character</code> array, may be <code>null</code>\n * @return a <code>char</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }"], "code_level": "self_contained", "_id": "636766fe1a6d9265ec017838", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive ints to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  an <code>int</code> array\n * @return an <code>Integer</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }"], "code_level": "class_runnable", "_id": "636767041a6d9265ec01790f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive doubles to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>double</code> array\n * @return a <code>Double</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec0177a4", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.startsWith(prefix)) {\n    return true;\n  }\n  if (ignoreCase) {\n    return str.toLowerCase().startsWith(prefix.toLowerCase());\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n", "method_name": "startsWith", "codes": ["private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return false; } if (str.startsWith(prefix)) { return true; } if (ignoreCase) { return str.toLowerCase().startsWith(prefix.toLowerCase()); } return false; }"], "code_level": "self_contained", "_id": "636767151a6d9265ec017b6b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (ch >= 'a' && ch <= 'z') {\n    return (char) (ch - 'a' + 'A');\n  } else if (ch >= 'A' && ch <= 'Z') {\n    return (char) (ch - 'A' + 'a');\n  } else {\n    return Character.valueOf(ch);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>\n * @param ch  the character to convert\n * @return a Character of the specified character\n */\n", "method_name": "toCharacterObject", "codes": ["public static Character toCharacterObject(final char ch){ if (ch >= 'a' && ch <= 'z') { return (char) (ch - 'a' + 'A'); } else if (ch >= 'A' && ch <= 'Z') { return (char) (ch - 'A' + 'a'); } else { return Character.valueOf(ch); } }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec01781c", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return (ch >= 'A' && ch <= 'Z');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p> <pre> CharUtils.isAsciiAlphaUpper('a')  = false CharUtils.isAsciiAlphaUpper('A')  = true CharUtils.isAsciiAlphaUpper('3')  = false CharUtils.isAsciiAlphaUpper('-')  = false CharUtils.isAsciiAlphaUpper('\\n') = false CharUtils.isAsciiAlphaUpper('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if between 65 and 90 inclusive\n */\n", "method_name": "isAsciiAlphaUpper", "codes": ["public static boolean isAsciiAlphaUpper(final char ch){ return (ch >= 'A' && ch <= 'Z'); }"], "code_level": "self_contained", "_id": "636766fb1a6d9265ec0177c1", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n * @param str a String or <code>null</code>\n * @return String length or <code>0</code> if the String is <code>null</code>.\n * @since 2.4\n */\n", "method_name": "length", "codes": ["public static int length(final String str){ if (str == null) { return 0; } return str.length(); }"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179d9", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String base64Decode(final String s) {\n  if (s == null) {\n    return null;\n  }\n  final byte[] bytes = Base64.decode(s, Base64.DEFAULT);\n  return new String(bytes, StandardCharsets.UTF_8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decoding a string to a string follow the Base64 regular. \n */\n", "method_name": "base64Decode", "codes": ["public static String base64Decode(final String s){ if (s == null) { return null; } final byte[] bytes = Base64.decode(s, Base64.DEFAULT); return new String(bytes, StandardCharsets.UTF_8); }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec017748", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  if (array1 == null && array2 == null) {\n    return true;\n  }\n  if (array1 == null || array2 == null) {\n    return false;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  for (int i = 0; i < array1.length; i++) {\n    if (array1[i] != array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n", "method_name": "isSameLength", "codes": ["public static boolean isSameLength(final double[] array1,final double[] array2){ if (array1 == null && array2 == null) { return true; } if (array1 == null || array2 == null) { return false; } if (array1.length != array2.length) { return false; } for (int i = 0; i < array1.length; i++) { if (array1[i] != array2[i]) { return false; } } return true; }"], "code_level": "self_contained", "_id": "636766f11a6d9265ec017663", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  the array to clone, may be <code>null</code>\n * @return the cloned array, <code>null</code> if <code>null</code> input\n */\n", "method_name": "clone", "codes": ["public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }"], "code_level": "self_contained", "_id": "636766f31a6d9265ec01768f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isAscii(final char ch) {\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit.</p> <pre> CharUtils.isAscii('a')  = true CharUtils.isAscii('A')  = true CharUtils.isAscii('3')  = true CharUtils.isAscii('-')  = true CharUtils.isAscii('\\n') = true CharUtils.isAscii('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if less than 128\n */\n", "method_name": "isAscii", "codes": ["public static boolean isAscii(final char ch){ return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'); }"], "code_level": "self_contained", "_id": "636766fb1a6d9265ec0177c3", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String toString(final char ch) {\n  return String.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the character to a String that contains the one character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same String object each time.</p> <pre> CharUtils.toString(' ')  = \" \" CharUtils.toString('A')  = \"A\" </pre>\n * @param ch  the character to convert\n * @return a String containing the one specified character\n */\n", "method_name": "toString", "codes": ["public static String toString(final char ch){ return String.valueOf(ch); }"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec017a05", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void enlarge(final int size) {\n  final byte[] newData = new byte[data.length + size];\n  System.arraycopy(data, 0, newData, 0, data.length);\n  data = newData;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n", "method_name": "enlarge", "codes": ["private void enlarge(final int size){ final byte[] newData = new byte[data.length + size]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; }"], "code_level": "class_runnable", "_id": "636767191a6d9265ec017c0f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "int addType(final String value) {\n  if (value == null) {\n    return -1;\n  }\n  int typeIndex = -1;\n  for (int i = 0; i < typeTable.length; i++) {\n    if (typeTable[i] == null) {\n      typeIndex = i;\n      break;\n    }\n  }\n  if (typeIndex == -1) {\n    typeTable = Arrays.copyOf(typeTable, typeTable.length + 1);\n    typeTable[typeTable.length - 1] = value;\n  } else {\n    typeTable[typeIndex] = value;\n  }\n  return typeIndex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n", "method_name": "addType", "codes": ["int addType(final String value){ if (value == null) { return -1; } int typeIndex = -1; for (int i = 0; i < typeTable.length; i++) { if (typeTable[i] == null) { typeIndex = i; break; } } if (typeIndex == -1) { typeTable = Arrays.copyOf(typeTable, typeTable.length + 1); typeTable[typeTable.length - 1] = value; } else { typeTable[typeIndex] = value; } return typeIndex; }"], "code_level": "project_runnable", "_id": "636766ef1a6d9265ec01761a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public long readLong(final int offset) {\n  return ((long) readInt(offset) << 32) | (readInt(offset + 4) & 0xFFFFFFFFL);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n", "method_name": "readLong", "codes": ["public long readLong(final int offset){ return ((long) readInt(offset) << 32) | (readInt(offset + 4) & 0xFFFFFFFFL); }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec01775b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > byteArrayValue.length - byteOffset) {\n    throw new IllegalArgumentException(\n        \"byteLength must be <= byteArrayValue.length - byteOffset\");\n  }\n  if (byteOffset < 0) {\n    throw new IllegalArgumentException(\"byteOffset must be >= 0\");\n  }\n  if (byteLength == 0) {\n    return this;\n  }\n  if (byteLength > this._pos) {\n    if (this._pos > 0) {\n      this._pos -= this._pos;\n    }\n    final int pos = this._pos;\n    this._pos = pos + byteLength;\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this._buffer, this._pos, byteLength);\n  this._pos += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset index of the first byte of byteArrayValue that must be copied.\n * @param byteLength number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n", "method_name": "putByteArray", "codes": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > byteArrayValue.length - byteOffset) { throw new IllegalArgumentException(\"byteLength must be <= byteArrayValue.length - byteOffset\"); } if (byteOffset < 0) { throw new IllegalArgumentException(\"byteOffset must be >= 0\"); } if (byteLength == 0) { return this; } if (byteLength > this._pos) { if (this._pos > 0) { this._pos -= this._pos; } final int pos = this._pos; this._pos = pos + byteLength; } System.arraycopy(byteArrayValue, byteOffset, this._buffer, this._pos, byteLength); this._pos += byteLength; return this; }"], "code_level": "class_runnable", "_id": "6367671a1a6d9265ec017c15", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.length() == 1) {\n    if (descriptor.charAt(0) == 'L') {\n      stack.pop();\n    } else {\n      stack.push(descriptor.charAt(0));\n    }\n  } else {\n    stack.push(descriptor.charAt(0));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n", "method_name": "pop", "codes": ["private void pop(final String descriptor){ if (descriptor.length() == 1) { if (descriptor.charAt(0) == 'L') { stack.pop(); } else { stack.push(descriptor.charAt(0)); } } else { stack.push(descriptor.charAt(0)); } }"], "code_level": "class_runnable", "_id": "636767021a6d9265ec0178b2", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void addInitializedType(final int abstractType) {\n  if (initializedTypes.contains(abstractType)) {\n    return;\n  }\n  initializedTypes.add(abstractType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n", "method_name": "addInitializedType", "codes": ["private void addInitializedType(final int abstractType){ if (initializedTypes.contains(abstractType)) { return; } initializedTypes.add(abstractType); }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec0177a9", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void putAbstractTypes(final int start,final int end){ final int numTypes = end - start; final int numTypesToPut = numTypes - 1; final int numTypesToPutToFrame = numTypesToPut - 1; final int numTypesToPutToFrameToEnd = numTypesToPutToFrame - 1; final int numTypesToPutToFrameToStart = numTypesToPutToFrameToEnd - 1; final int numTypesToPutToFrameToStartToEnd = numTypesToPutToFrameToStart - 1; final int numTypesToPutToFrameToStartToStart = numTypesToPutToFrameToStartToEnd - 1; final int numTypesToPutToFrameToStartToStartToEnd = numTypesToPutToFrameToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutTo", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.\n * @param start index of the first type in {@link #currentFrame} to write.\n * @param end index of last type in {@link #currentFrame} to write (exclusive).\n */\n", "method_name": "putAbstractTypes", "codes": ["private void putAbstractTypes(final int start,final int end){ final int numTypes = end - start; final int numTypesToPut = numTypes - 1; final int numTypesToPutToFrame = numTypesToPut - 1; final int numTypesToPutToFrameToEnd = numTypesToPutToFrame - 1; final int numTypesToPutToFrameToStart = numTypesToPutToFrameToEnd - 1; final int numTypesToPutToFrameToStartToEnd = numTypesToPutToFrameToStart - 1; final int numTypesToPutToFrameToStartToStart = numTypesToPutToFrameToStartToEnd - 1; final int numTypesToPutToFrameToStartToStartToEnd = numTypesToPutToFrameToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutToFrameToStartToStartToStartToStartToStartToEnd = numTypesToPutToFrameToStartToStartToStartToStartToStart - 1; final int numTypesToPutTo"], "code_level": "project_runnable", "_id": "6367670a1a6d9265ec0179dc", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public short readShort(final int offset) {\n  return classFileBuffer.getShort(offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a signed short value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n", "method_name": "readShort", "codes": ["public short readShort(final int offset){ return classFileBuffer.getShort(offset); }"], "code_level": "class_runnable", "_id": "636766f21a6d9265ec017667", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label l = labels[bytecodeOffset];\n  if (l == null) {\n    l = new Label();\n    labels[bytecodeOffset] = l;\n  }\n  return l;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n", "method_name": "readLabel", "codes": ["protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label l = labels[bytecodeOffset]; if (l == null) { l = new Label(); labels[bytecodeOffset] = l; } return l; }"], "code_level": "self_contained", "_id": "636766ff1a6d9265ec017853", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int utfLength = readUnsignedShort(constantPoolEntryIndex);\n  final String utfContents = readUTF(utfLength, charBuffer);\n  return utfContents;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.\n * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.\n * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n */\n", "method_name": "readUtf", "codes": ["final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int utfLength = readUnsignedShort(constantPoolEntryIndex); final String utfContents = readUTF(utfLength, charBuffer); return utfContents; }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec01782a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic int hashCode() {\n  return Objects.hash(id, name, description, type);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a hash code value for this type.\n * @return a hash code value for this type.\n */\n", "method_name": "hashCode", "codes": ["@Override public int hashCode(){ return Objects.hash(id, name, description, type); }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec017758", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int index = cp.addConstantUtf8(name);\n  if (index == 0) {\n    index = cp.addConstantUtf8(descriptor);\n  }\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n", "method_name": "addConstantNameAndType", "codes": ["int addConstantNameAndType(final String name,final String descriptor){ int index = cp.addConstantUtf8(name); if (index == 0) { index = cp.addConstantUtf8(descriptor); } return index; }"], "code_level": "project_runnable", "_id": "636766fe1a6d9265ec017823", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "final void addLineNumber(final int lineNumber) {\n  this.lineNumber += lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n", "method_name": "addLineNumber", "codes": ["final void addLineNumber(final int lineNumber){ this.lineNumber += lineNumber; }"], "code_level": "class_runnable", "_id": "636767131a6d9265ec017b23", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n", "method_name": "indexOfLastSeparator", "codes": ["public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec017658", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Schedules a file to be deleted when JVM exits. If file is directory delete it and all sub-directories.\n * @param file  file or directory to delete, must not be {@code null}\n * @throws NullPointerException if the file is {@code null}\n * @throws IOException in case deletion is unsuccessful\n */\n", "method_name": "forceDeleteOnExit", "codes": ["public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec017833", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n", "method_name": "indexOfExtension", "codes": ["public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }"], "code_level": "class_runnable", "_id": "636767061a6d9265ec01794a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override public void write(byte b[]) throws IOException { if (b == null) { throw new NullPointerException(); } if (b.length == 0) { return; } if (b.length >= 4) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00) { return; } } if (b.length >= 8) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00 && b[4] == 0x00 && b[5] == 0x00 && b[6] == 0x00 && b[7] == 0x00) { return; } } if (b.length >= 16) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00 && b[4] == 0x00 && b[5] == 0x00 && b[6] == 0x00 && b[7] == 0x00 && b[8] == 0x00 && b[9] == 0x00 && b[10] == 0x00 && b[11] == 0x00 && b[12] == 0x00 && b[13] == 0x00 && b[14] == 0x00 && b[15] == 0x00) { return; } } if (b.length >= 24) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00 && b[4] == 0x00 && b[5] == 0x00 && b[6] == 0x00 && b[7] == 0x00 && b[8] == 0x00 && b[9] == 0x00 && b[10] == 0x00 && b[11] == 0x00 && b[12] == 0x00 && b[13] == 0x00 && b[14] == 0x00 && b[15] == 0x00 && b[16] == 0x00) { return; } } if (b.length >= 32) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00 && b[4] == 0x00 && b[5] == 0x00 && b[6] == 0x00 && b[7] == 0x00 && b[8] == 0x00 && b[9] == 0x00 && b[10] == 0x00 && b[11] == 0x00 && b[12] == 0x00 && b[13] == 0x00 && b[14] == 0x00 && b[15] == 0x00 && b[16] == 0x00) { return; } } if (b.length >= 40) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00 && b[4] == 0x00 && b[5] == 0x00 && b[6] == 0x00 && b[7] == 0x00 && b[8] == 0x00 && b[9] == 0x00 && b[10] == 0x00 && b[11] == 0x00 && b[12] == 0x00 && b[13] == 0x00 && b[14] == 0x00 && b[15] == 0x00 && b[16] == 0x00 && b[17] == 0x00) { return; } } if (b.length >=", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Writes <code>b.length</code> bytes from the specified byte array to this output stream.\n * @param b The array of bytes to be written.\n * @exception IOException if an error occurs.\n */\n", "method_name": "write", "codes": ["@Override public void write(byte b[]) throws IOException { if (b == null) { throw new NullPointerException(); } if (b.length == 0) { return; } if (b.length >= 4) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00) { return; } } if (b.length >= 8) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00 && b[4] == 0x00 && b[5] == 0x00 && b[6] == 0x00 && b[7] == 0x00) { return; } } if (b.length >= 16) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00 && b[4] == 0x00 && b[5] == 0x00 && b[6] == 0x00 && b[7] == 0x00 && b[8] == 0x00 && b[9] == 0x00 && b[10] == 0x00 && b[11] == 0x00 && b[12] == 0x00 && b[13] == 0x00 && b[14] == 0x00 && b[15] == 0x00) { return; } } if (b.length >= 24) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00 && b[4] == 0x00 && b[5] == 0x00 && b[6] == 0x00 && b[7] == 0x00 && b[8] == 0x00 && b[9] == 0x00 && b[10] == 0x00 && b[11] == 0x00 && b[12] == 0x00 && b[13] == 0x00 && b[14] == 0x00 && b[15] == 0x00 && b[16] == 0x00) { return; } } if (b.length >= 32) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00 && b[4] == 0x00 && b[5] == 0x00 && b[6] == 0x00 && b[7] == 0x00 && b[8] == 0x00 && b[9] == 0x00 && b[10] == 0x00 && b[11] == 0x00 && b[12] == 0x00 && b[13] == 0x00 && b[14] == 0x00 && b[15] == 0x00 && b[16] == 0x00) { return; } } if (b.length >= 40) { if (b[0] == 0x00 && b[1] == 0x00 && b[2] == 0x00 && b[3] == 0x00 && b[4] == 0x00 && b[5] == 0x00 && b[6] == 0x00 && b[7] == 0x00 && b[8] == 0x00 && b[9] == 0x00 && b[10] == 0x00 && b[11] == 0x00 && b[12] == 0x00 && b[13] == 0x00 && b[14] == 0x00 && b[15] == 0x00 && b[16] == 0x00 && b[17] == 0x00) { return; } } if (b.length >="], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec0179fe", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len < 0) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (len == 0) {\n    return;\n  }\n  if (len >= m_buffer.length) {\n    m_buffer = Arrays.copyOf(m_buffer, m_buffer.length * 2);\n  }\n  System.arraycopy(b, off, m_buffer, m_buffer.length - len, len);\n  m_buffer.length -= len;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.\n * @param b   the data.\n * @param off the start offset in the data.\n * @param len the number of bytes to write.\n */\n", "method_name": "write", "codes": ["@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len < 0) { throw new IndexOutOfBoundsException(); } if (len == 0) { return; } if (len >= m_buffer.length) { m_buffer = Arrays.copyOf(m_buffer, m_buffer.length * 2); } System.arraycopy(b, off, m_buffer, m_buffer.length - len, len); m_buffer.length -= len; }"], "code_level": "class_runnable", "_id": "636766f91a6d9265ec01776e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * @see OutputStream#write(byte[]) \n */\n", "method_name": "write", "codes": ["@Override public void write(final byte[] b) throws IOException { write(b, 0, b.length); }"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179d8", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public String toString() {\n  return this.toString(this.buffer, 0, this.length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p> Gets the String built by this builder. </p>\n * @return the built string\n */\n", "method_name": "toString", "codes": ["public String toString(){ return this.toString(this.buffer, 0, this.length); }"], "code_level": "project_runnable", "_id": "636767001a6d9265ec01787e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  appendDetail(buffer, fieldName, array, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n", "method_name": "appendDetail", "codes": ["protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ appendDetail(buffer, fieldName, array, null); }"], "code_level": "class_runnable", "_id": "636767001a6d9265ec01787f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return new String[0];\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.\n * @param collection The collection to convert\n * @return A new array of Strings.\n */\n", "method_name": "toNoNullStringArray", "codes": ["static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return new String[0]; } return collection.toArray(new String[collection.size()]); }"], "code_level": "project_runnable", "_id": "636766f71a6d9265ec017730", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "static void register(Object value) {\n  if (value != null) {\n    REGISTRY.put(value.getClass(), value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n", "method_name": "register", "codes": ["static void register(Object value){ if (value != null) { REGISTRY.put(value.getClass(), value); } }"], "code_level": "class_runnable", "_id": "636767041a6d9265ec017911", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n", "method_name": "appendDetail", "codes": ["protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec017821", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_STRING_ARRAY;\n  } else {\n    String[] result = new String[array.length];\n    for (int i = 0; i < array.length; i++) {\n      Object value = array[i];\n      if (value == null) {\n        result[i] = null;\n      } else {\n        result[i] = value.toString();\n      }\n    }\n    return result;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.\n * @param array The array to check\n * @return The given array or a new array without null.\n */\n", "method_name": "toNoNullStringArray", "codes": ["static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_STRING_ARRAY; } else { String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { Object value = array[i]; if (value == null) { result[i] = null; } else { result[i] = value.toString(); } } return result; } }"], "code_level": "project_runnable", "_id": "636766fc1a6d9265ec0177ef", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic int available() throws IOException {\n  return (int) (this.length - this.position);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @see InputStream#available() \n */\n", "method_name": "available", "codes": ["@Override public int available() throws IOException { return (int) (this.length - this.position); }"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec017641", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) {\n    return new ArrayList<T>();\n  }\n  return new ArrayList<T>(Arrays.asList(a));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.\n * @return a list backed by the array.\n */\n", "method_name": "asList", "codes": ["public static <T>List<T> asList(T[] a){ if (a == null) { return new ArrayList<T>(); } return new ArrayList<T>(Arrays.asList(a)); }"], "code_level": "slib_runnable", "_id": "636766f01a6d9265ec017639", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static byte convertHexDigit(byte b) {\n  if (b >= '0' && b <= '9') {\n    return (byte) (b - '0');\n  } else if (b >= 'A' && b <= 'F') {\n    return (byte) (b - 'A' + 10);\n  } else if (b >= 'a' && b <= 'f') {\n    return (byte) (b - 'a' + 10);\n  } else {\n    throw new IllegalArgumentException(\"Invalid hex digit: \" + b);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * @param b An ASCII encoded character 0-9 a-f A-F\n * @return The byte value of the character 0-16.\n */\n", "method_name": "convertHexDigit", "codes": ["public static byte convertHexDigit(byte b){ if (b >= '0' && b <= '9') { return (byte) (b - '0'); } else if (b >= 'A' && b <= 'F') { return (byte) (b - 'A' + 10); } else if (b >= 'a' && b <= 'f') { return (byte) (b - 'a' + 10); } else { throw new IllegalArgumentException(\"Invalid hex digit: \" + b); } }"], "code_level": "slib_runnable", "_id": "636766f91a6d9265ec01777d", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.\n * @param clazz Class for which to return a registered Converter\n * @return The registered {@link Converter} or <code>null</code> if not found\n */\n", "method_name": "lookup", "codes": ["public Converter lookup(final Class<?> clazz){ return converters.get(clazz); }"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179e7", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return get(key) != null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Return <code>true</code> if this map contains a mapping for the specified key.\n * @param key  the key to be searched for\n * @return true if the map contains the key\n */\n", "method_name": "containsKey", "codes": ["@Override public boolean containsKey(final Object key){ return get(key) != null; }"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec0179f2", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n", "method_name": "copyStrings", "codes": ["private static String[] copyStrings(final String[] src){ final String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }"], "code_level": "self_contained", "_id": "636767041a6d9265ec0178f8", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (type.equals(String.class)) { return value; } if (type.equals(Integer.class)) { return Integer.valueOf(value.toString()); } if (type.equals(Long.class)) { return Long.valueOf(value.toString()); } if (type.equals(Float.class)) { return Float.valueOf(value.toString()); } if (type.equals(Double.class)) { return Double.valueOf(value.toString()); } if (type.equals(Boolean.class)) { return Boolean.valueOf(value.toString()); } if (type.equals(Date.class)) { return new Date(Long.valueOf(value.toString())); } if (type.equals(BigDecimal.class)) { return new BigDecimal(value.toString()); } if (type.equals(BigInteger.class)) { return new BigInteger(value.toString()); } if (type.equals(Byte.class)) { return Byte.valueOf(value.toString()); } if (type.equals(Short.class)) { return Short.valueOf(value.toString()); } if (type.equals(Byte[].class)) { return value.toString().getBytes(); } if (type.equals(Character.class)) { return value.toString().charAt(0); } if (type.equals(Character[].class)) { return value.toString().toCharArray(); } if (type.equals(BigDecimal[].class)) { return value.toString().getBytes(); } if (type.equals(BigInteger[].class)) { return value.toString().toCharArray(); } if (type.equals(Byte[][].class)) { return value.toString().getBytes(); } if (type.equals(Short[][].class)) { return value.toString().getBytes(); } if (type.equals(Character[][].class)) { return value.toString().toCharArray(); } if (type.equals(BigDecimal[][].class)) { return value.toString().getBytes(); } if (type.equals(BigInteger[][].class)) { return value.toString().toCharArray(); } if (type.equals(Byte[][][].class)) { return value.toString().getBytes(); } if (type.equals(Short[][][].class)) { return value.toString().getBytes(); } if (type.equals(Character[][][].class)) { return value.toString().getBytes(); } if (type.equals(BigDecimal[][][].class)) { return value.toString().getBytes(); } if (type.equals(BigInteger[][][].class)) { return value.toString().getBytes(); } if (type.equals", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n", "method_name": "convertToType", "codes": ["@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (type.equals(String.class)) { return value; } if (type.equals(Integer.class)) { return Integer.valueOf(value.toString()); } if (type.equals(Long.class)) { return Long.valueOf(value.toString()); } if (type.equals(Float.class)) { return Float.valueOf(value.toString()); } if (type.equals(Double.class)) { return Double.valueOf(value.toString()); } if (type.equals(Boolean.class)) { return Boolean.valueOf(value.toString()); } if (type.equals(Date.class)) { return new Date(Long.valueOf(value.toString())); } if (type.equals(BigDecimal.class)) { return new BigDecimal(value.toString()); } if (type.equals(BigInteger.class)) { return new BigInteger(value.toString()); } if (type.equals(Byte.class)) { return Byte.valueOf(value.toString()); } if (type.equals(Short.class)) { return Short.valueOf(value.toString()); } if (type.equals(Byte[].class)) { return value.toString().getBytes(); } if (type.equals(Character.class)) { return value.toString().charAt(0); } if (type.equals(Character[].class)) { return value.toString().toCharArray(); } if (type.equals(BigDecimal[].class)) { return value.toString().getBytes(); } if (type.equals(BigInteger[].class)) { return value.toString().toCharArray(); } if (type.equals(Byte[][].class)) { return value.toString().getBytes(); } if (type.equals(Short[][].class)) { return value.toString().getBytes(); } if (type.equals(Character[][].class)) { return value.toString().toCharArray(); } if (type.equals(BigDecimal[][].class)) { return value.toString().getBytes(); } if (type.equals(BigInteger[][].class)) { return value.toString().toCharArray(); } if (type.equals(Byte[][][].class)) { return value.toString().getBytes(); } if (type.equals(Short[][][].class)) { return value.toString().getBytes(); } if (type.equals(Character[][][].class)) { return value.toString().getBytes(); } if (type.equals(BigDecimal[][][].class)) { return value.toString().getBytes(); } if (type.equals(BigInteger[][][].class)) { return value.toString().getBytes(); } if (type.equals"], "code_level": "project_runnable", "_id": "636767021a6d9265ec0178bf", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public Collection<Object> values() {\n  return Collections.unmodifiableCollection(methods.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the values for the BeanMap.\n * @return values for the BeanMap. The returned collection is not modifiable.\n */\n", "method_name": "values", "codes": ["public Collection<Object> values(){ return Collections.unmodifiableCollection(methods.values()); }"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec01764f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Iterator it = map.keySet().iterator(); it.hasNext(); ) {\n    Object key = it.next();\n    if (key instanceof String) {\n      put((String) key, map.get(key));\n    } else if (key instanceof BeanMap) {\n      putAllWriteable((BeanMap) key, map);\n    } else {\n      throw new IllegalArgumentException(\"Unknown key type: \" + key.getClass().getName());\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts all of the writable properties from the given BeanMap into this BeanMap. Read-only and Write-only properties will be ignored.\n * @param map  the BeanMap whose properties to put\n */\n", "method_name": "putAllWriteable", "codes": ["public void putAllWriteable(BeanMap map){ for (Iterator it = map.keySet().iterator(); it.hasNext(); ) { Object key = it.next(); if (key instanceof String) { put((String) key, map.get(key)); } else if (key instanceof BeanMap) { putAllWriteable((BeanMap) key, map); } else { throw new IllegalArgumentException(\"Unknown key type: \" + key.getClass().getName()); } } }"], "code_level": "class_runnable", "_id": "636767071a6d9265ec017962", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public long contentLength() {\n  return contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Retrieve the content length of the request.\n * @return The content length of the request.\n * @since 1.3\n */\n", "method_name": "contentLength", "codes": ["public long contentLength(){ return contentLength; }"], "code_level": "project_runnable", "_id": "636767031a6d9265ec0178dd", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int index = headerPart.indexOf('\\n', end);\n  if (index == -1) {\n    return -1;\n  }\n  return index;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n", "method_name": "parseEndOfLine", "codes": ["private int parseEndOfLine(String headerPart,int end){ int index = headerPart.indexOf('\\n', end); if (index == -1) { return -1; } return index; }"], "code_level": "self_contained", "_id": "636767121a6d9265ec017b0a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected int findByte(byte value, int pos) {\n  int i = pos;\n  while (i < m_buffer.length && m_buffer[i] != value) {\n    i++;\n  }\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n", "method_name": "findByte", "codes": ["protected int findByte(byte value,int pos){ int i = pos; while (i < m_buffer.length && m_buffer[i] != value) { i++; } return i; }"], "code_level": "class_runnable", "_id": "636766ff1a6d9265ec017851", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public byte readByte() throws IOException {\n  if (bufferPosition >= buffer.length) {\n    throw new IOException(\"Buffer overflow\");\n  }\n  return buffer[bufferPosition++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a byte from the <code>buffer</code>, and refills it as necessary.\n * @return The next byte from the input stream.\n * @throws IOException if there is no more data available.\n */\n", "method_name": "readByte", "codes": ["public byte readByte() throws IOException { if (bufferPosition >= buffer.length) { throw new IOException(\"Buffer overflow\"); } return buffer[bufferPosition++]; }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec01774b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private String parseToken(final char[] terminators) {\n  final StringBuilder token = new StringBuilder();\n  while (true) {\n    final char c = nextChar();\n    if (terminators.length > 0 && c == terminators[0]) {\n      break;\n    }\n    token.append(c);\n  }\n  return token.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n", "method_name": "parseToken", "codes": ["private String parseToken(final char[] terminators){ final StringBuilder token = new StringBuilder(); while (true) { final char c = nextChar(); if (terminators.length > 0 && c == terminators[0]) { break; } token.append(c); } return token.toString(); }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec01779c", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a.length != b.length) return false;\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.\n * @param a     The first array to compare.\n * @param b     The second array to compare.\n * @param count How many bytes should be compared.\n * @return <code>true</code> if <code>count</code> first bytes in arrays<code>a</code> and <code>b</code> are equal.\n */\n", "method_name": "arrayequals", "codes": ["public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a.length != b.length) return false; for (int i = 0; i < count; i++) { if (a[i] != b[i]) return false; } return true; }"], "code_level": "self_contained", "_id": "636766fd1a6d9265ec017814", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  return lastIndexOf(str, searchStr, str.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. \n */\n", "method_name": "lastIndexOf", "codes": ["public static int lastIndexOf(String str,String searchStr){ return lastIndexOf(str, searchStr, str.length()); }"], "code_level": "project_runnable", "_id": "636766f61a6d9265ec017701", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Gets a substring from the specified String avoiding exceptions. \n */\n", "method_name": "sub", "codes": ["public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }"], "code_level": "project_runnable", "_id": "636766ff1a6d9265ec01783b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null || searchStrArray.isEmpty()) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (str.contains(searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Case in-sensitive Checks if the String contains any character in the given set of string. \n */\n", "method_name": "containsAnyIgnoreCase", "codes": ["public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null || searchStrArray.isEmpty()) { return false; } for (String searchStr : searchStrArray) { if (str.contains(searchStr)) { return true; } } return false; }"], "code_level": "project_runnable", "_id": "6367670b1a6d9265ec017a0f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int indexOf(String str, String searchStr) {\n  return indexOf(str, searchStr, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds the first index within a String, handling <code>null</code>. This method uses  {@link String#indexOf(String)}. \n */\n", "method_name": "indexOf", "codes": ["public static int indexOf(String str,String searchStr){ return indexOf(str, searchStr, 0); }"], "code_level": "project_runnable", "_id": "636767021a6d9265ec0178bc", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == '(' || c == ')' || c == ',' || c == ';' || c == ':' || c == '=' || c == '+'\n      || c == '-' || c == '*' || c == '/' || c == '[' || c == ']' || c == '{' || c == '}';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n", "method_name": "isParameterSeparator", "codes": ["private static boolean isParameterSeparator(final char c){ return c == '(' || c == ')' || c == ',' || c == ';' || c == ':' || c == '=' || c == '+' || c == '-' || c == '*' || c == '/' || c == '[' || c == ']' || c == '{' || c == '}'; }"], "code_level": "class_runnable", "_id": "636766fc1a6d9265ec0177da", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  if (array.getClass().isArray()) {\n    final int length = Array.getLength(array);\n    final Object newArray = Array.newInstance(array.getClass().getComponentType(), length + 1);\n    System.arraycopy(array, 0, newArray, 0, length);\n    return newArray;\n  }\n  return Array.newInstance(newArrayComponentType, 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n", "method_name": "copyArrayGrow1", "codes": ["private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } if (array.getClass().isArray()) { final int length = Array.getLength(array); final Object newArray = Array.newInstance(array.getClass().getComponentType(), length + 1); System.arraycopy(array, 0, newArray, 0, length); return newArray; } return Array.newInstance(newArrayComponentType, 1); }"], "code_level": "slib_runnable", "_id": "636767031a6d9265ec0178ef", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String sessionId() {\n  return sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Session ID. \n */\n", "method_name": "sessionId", "codes": ["public static String sessionId(){ return sessionId; }"], "code_level": "plib_runnable", "_id": "636766fe1a6d9265ec017834", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public Boolean isPartialContentResponse() {\n  return isPartialContentResponse;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if the actual response is a Partial Content (HTTP 206 code)\n * @return is partial content or not\n */\n", "method_name": "isPartialContentResponse", "codes": ["public Boolean isPartialContentResponse(){ return isPartialContentResponse; }"], "code_level": "plib_runnable", "_id": "636766ae1a6d9265ec0175dc", "project_name": "framework-master"}, {"generate_results": [{"generate_code": "private String buildContentRange() {\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"bytes \");\n  sb.append(offset);\n  sb.append(\"-\");\n  sb.append(limit);\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n", "method_name": "buildContentRange", "codes": ["private String buildContentRange(){ StringBuilder sb = new StringBuilder(); sb.append(\"bytes \"); sb.append(offset); sb.append(\"-\"); sb.append(limit); return sb.toString(); }"], "code_level": "class_runnable", "_id": "636766ae1a6d9265ec0175d8", "project_name": "framework-master"}, {"generate_results": [{"generate_code": "private static String javaCharset(String charset){ if (charset.equals(\"ISO-8859-1\")) { return \"ISO-8859-1\"; } else if (charset.equals(\"UTF-8\")) { return \"UTF-8\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n", "method_name": "javaCharset", "codes": ["private static String javaCharset(String charset){ if (charset.equals(\"ISO-8859-1\")) { return \"ISO-8859-1\"; } else if (charset.equals(\"UTF-8\")) { return \"UTF-8\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equals(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.equals(\"UTF-16BE\")) { return \""], "code_level": "class_runnable", "_id": "636766f01a6d9265ec01763e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> right = node.getRight();\n  node.setRight(right.getLeft());\n  right.setLeft(node);\n  return right;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}\n */\n", "method_name": "rotateRight", "codes": ["private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> right = node.getRight(); node.setRight(right.getLeft()); right.setLeft(node); return right; }"], "code_level": "file_runnable", "_id": "636767441a6d9265ec017cc1", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Swaps the two elements at the specified indices in the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param i the index of the first element\n * @param j the index of the second element\n */\n", "method_name": "swap", "codes": ["public static final <V>void swap(V[] arr,int i,int j){ V temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }"], "code_level": "self_contained", "_id": "636767551a6d9265ec017f3f", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () -> {\n    StringBuilder sb = new StringBuilder();\n    for (int i = start; i < start + 10; i++) {\n      sb.append(i);\n    }\n    return sb.toString();\n  };\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n", "method_name": "createStringSupplier", "codes": ["@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> { StringBuilder sb = new StringBuilder(); for (int i = start; i < start + 10; i++) { sb.append(i); } return sb.toString(); }; }"], "code_level": "slib_runnable", "_id": "6367675c1a6d9265ec018058", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * {@inheritDoc}\n */\n", "method_name": "previousNode", "codes": ["@Override public ListNode<E> previousNode(){ return previous; }"], "code_level": "class_runnable", "_id": "636767501a6d9265ec017e86", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static long factorial(int n) {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Calculate the factorial of $n$.\n * @param n the input number\n * @return the factorial\n */\n", "method_name": "factorial", "codes": ["public static long factorial(int n){ if (n <= 1) { return 1; } else { return n * factorial(n - 1); } }"], "code_level": "self_contained", "_id": "636767581a6d9265ec017fc4", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == null) {\n    return false;\n  }\n  if (node.prev == null) {\n    head = node.next;\n  } else {\n    node.prev.next = node.next;\n  }\n  if (node.next == null) {\n    tail = node.prev;\n  } else {\n    node.next.prev = node.prev;\n  }\n  size--;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Remove the non null  {@code node} from the list. \n */\n", "method_name": "unlink", "codes": ["private boolean unlink(ListNodeImpl<E> node){ if (node == null) { return false; } if (node.prev == null) { head = node.next; } else { node.prev.next = node.next; } if (node.next == null) { tail = node.prev; } else { node.next.prev = node.prev; } size--; return true; }"], "code_level": "class_runnable", "_id": "636767631a6d9265ec018171", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (arr == null || from < 0 || to > arr.length || from > to) {\n    return;\n  }\n  for (int i = from, j = to; i < j; i++, j--) {\n    V tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Reverses the order of the elements in the specified range within the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param from the index of the first element (inclusive) inside the range to reverse\n * @param to the index of the last element (inclusive) inside the range to reverse\n */\n", "method_name": "reverse", "codes": ["public static final <V>void reverse(V[] arr,int from,int to){ if (arr == null || from < 0 || to > arr.length || from > to) { return; } for (int i = from, j = to; i < j; i++, j--) { V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } }"], "code_level": "class_runnable", "_id": "636767491a6d9265ec017d90", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  if (list.head == null) {\n    return;\n  }\n  DoublyLinkedList<E> newList = new DoublyLinkedList<>();\n  DoublyLinkedList<E> current = list.head;\n  while (current != null) {\n    newList.add(current.data);\n    current = current.next;\n  }\n  list.head = newList.head;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.\n */\n", "method_name": "moveAllListNodes", "codes": ["private void moveAllListNodes(DoublyLinkedList<E> list){ if (list.head == null) { return; } DoublyLinkedList<E> newList = new DoublyLinkedList<>(); DoublyLinkedList<E> current = list.head; while (current != null) { newList.add(current.data); current = current.next; } list.head = newList.head; }"], "code_level": "class_runnable", "_id": "6367674a1a6d9265ec017da9", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).\n * @param graph the input graph\n * @param < V > the graph vertex type\n * @param < E > the graph edge type\n * @return a mapping from graph to graph\n */\n", "method_name": "identity", "codes": ["public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>(graph); }"], "code_level": "project_runnable", "_id": "6367675f1a6d9265ec0180d3", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (target == null) { throw new IllegalArgumentException(\"target is null\"); } if (resultMap == null) { throw new IllegalArgumentException(\"resultMap is null\"); } if (target.getVertices().size() != resultMap.size()) { throw new IllegalArgumentException(\"target and resultMap must have the same number of vertices\"); } if (target.getEdges().size() != resultMap.size()) { throw new IllegalArgumentException(\"target and resultMap must have the same number of edges\"); } if (target.getVertices().size() == 0) { throw new IllegalArgumentException(\"target must have at least one vertex\"); } if (target.getEdges().size() == 0) { throw new IllegalArgumentException(\"target must have at least one edge\"); } if (target.getVertices().size() == 1) { if (!target.getVertices().contains(resultMap.get(\"A\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } } if (target.getEdges().size() == 1) { if (!target.getEdges().contains(resultMap.get(\"B\"))) { throw new IllegalArgumentException(\"target must contain a edge with the same name\"); } } if (target.getVertices().size() == 2) { if (!target.getVertices().contains(resultMap.get(\"A\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } if (!target.getVertices().contains(resultMap.get(\"B\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } } if (target.getEdges().size() == 2) { if (!target.getEdges().contains(resultMap.get(\"A\"))) { throw new IllegalArgumentException(\"target must contain a edge with the same name\"); } if (!target.getEdges().contains(resultMap.get(\"B\"))) { throw new IllegalArgumentException(\"target must contain a edge with the same name\"); } } if (target.getVertices().size() == 3) { if (!target.getVertices().contains(resultMap.get(\"A\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } if (!target.getVertices().contains(resultMap.get(\"B\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } if (!target.getVertices().contains(resultMap.get(\"C\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } } if (target.getEdges().size() == 3) { if (!target.getEdges().contains(resultMap.get(\"A\"))) { throw new IllegalArgumentException(\"target must contain a edge with the same name\"); } if (!target.getEdges().contains(resultMap.get(\"B\"))) { throw new IllegalArgumentException(\"target must", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Construct a complete bipartite graph\n */\n", "method_name": "generateGraph", "codes": ["@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (target == null) { throw new IllegalArgumentException(\"target is null\"); } if (resultMap == null) { throw new IllegalArgumentException(\"resultMap is null\"); } if (target.getVertices().size() != resultMap.size()) { throw new IllegalArgumentException(\"target and resultMap must have the same number of vertices\"); } if (target.getEdges().size() != resultMap.size()) { throw new IllegalArgumentException(\"target and resultMap must have the same number of edges\"); } if (target.getVertices().size() == 0) { throw new IllegalArgumentException(\"target must have at least one vertex\"); } if (target.getEdges().size() == 0) { throw new IllegalArgumentException(\"target must have at least one edge\"); } if (target.getVertices().size() == 1) { if (!target.getVertices().contains(resultMap.get(\"A\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } } if (target.getEdges().size() == 1) { if (!target.getEdges().contains(resultMap.get(\"B\"))) { throw new IllegalArgumentException(\"target must contain a edge with the same name\"); } } if (target.getVertices().size() == 2) { if (!target.getVertices().contains(resultMap.get(\"A\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } if (!target.getVertices().contains(resultMap.get(\"B\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } } if (target.getEdges().size() == 2) { if (!target.getEdges().contains(resultMap.get(\"A\"))) { throw new IllegalArgumentException(\"target must contain a edge with the same name\"); } if (!target.getEdges().contains(resultMap.get(\"B\"))) { throw new IllegalArgumentException(\"target must contain a edge with the same name\"); } } if (target.getVertices().size() == 3) { if (!target.getVertices().contains(resultMap.get(\"A\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } if (!target.getVertices().contains(resultMap.get(\"B\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } if (!target.getVertices().contains(resultMap.get(\"C\"))) { throw new IllegalArgumentException(\"target must contain a vertex with the same name\"); } } if (target.getEdges().size() == 3) { if (!target.getEdges().contains(resultMap.get(\"A\"))) { throw new IllegalArgumentException(\"target must contain a edge with the same name\"); } if (!target.getEdges().contains(resultMap.get(\"B\"))) { throw new IllegalArgumentException(\"target must"], "code_level": "class_runnable", "_id": "636767641a6d9265ec01817d", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket == null) {\n    throw new IllegalArgumentException(\"bucket cannot be null\");\n  }\n  if (this.bucket == null) {\n    this.bucket = bucket;\n  } else {\n    this.bucket.insertBefore(bucket);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Inserts this bucket in the data structure before the  {@code bucket}.\n * @param bucket the bucket, that will be the next to this bucket.\n */\n", "method_name": "insertBefore", "codes": ["void insertBefore(Bucket bucket){ if (bucket == null) { throw new IllegalArgumentException(\"bucket cannot be null\"); } if (this.bucket == null) { this.bucket = bucket; } else { this.bucket.insertBefore(bucket); } }"], "code_level": "class_runnable", "_id": "636767531a6d9265ec017efb", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic boolean hasNext() {\n  return !vertices.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Checks whether there exist unvisited vertices.\n * @return true if there exist unvisited vertices.\n */\n", "method_name": "hasNext", "codes": ["@Override public boolean hasNext(){ return !vertices.isEmpty(); }"], "code_level": "class_runnable", "_id": "636767561a6d9265ec017f63", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "void removeSelf() {\n  if (head == null) {\n    return;\n  }\n  if (head.next == null) {\n    head = null;\n    return;\n  }\n  Node temp = head;\n  while (temp.next.next != null) {\n    temp = temp.next;\n  }\n  temp.next = null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes this bucket from the data structure.\n */\n", "method_name": "removeSelf", "codes": ["void removeSelf(){ if (head == null) { return; } if (head.next == null) { head = null; return; } Node temp = head; while (temp.next.next != null) { temp = temp.next; } temp.next = null; }"], "code_level": "class_runnable", "_id": "6367675a1a6d9265ec018010", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (Edge<V> edge : edges) {\n    vertices.add(edge.getV1());\n    vertices.add(edge.getV2());\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n", "method_name": "initVisibleVertices", "codes": ["private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (Edge<V> edge : edges) { vertices.add(edge.getV1()); vertices.add(edge.getV2()); } return vertices; }"], "code_level": "class_runnable", "_id": "6367674b1a6d9265ec017dc0", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.treeEdgeList != null) {\n    this.treeEdgeList.remove(this);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes this edge from both doubly linked lists of tree edges.\n */\n", "method_name": "removeFromTreeEdgeList", "codes": ["public void removeFromTreeEdgeList(){ if (this.treeEdgeList != null) { this.treeEdgeList.remove(this); } }"], "code_level": "class_runnable", "_id": "6367675c1a6d9265ec01805b", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (sourceVertex == null || targetVertex == null) { throw new NullPointerException(\"Source or target vertex is null\"); } if (e == null) { throw new NullPointerException(\"Edge is null\"); } if (!touchingVerticesToEdgeMap.containsKey(sourceVertex)) { throw new IllegalArgumentException(\"Source vertex does not exist\"); } if (!touchingVerticesToEdgeMap.containsKey(targetVertex)) { throw new IllegalArgumentException(\"Target vertex does not exist\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(targetVertex)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(sourceVertex)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgu", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n", "method_name": "addToIndex", "codes": ["protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (sourceVertex == null || targetVertex == null) { throw new NullPointerException(\"Source or target vertex is null\"); } if (e == null) { throw new NullPointerException(\"Edge is null\"); } if (!touchingVerticesToEdgeMap.containsKey(sourceVertex)) { throw new IllegalArgumentException(\"Source vertex does not exist\"); } if (!touchingVerticesToEdgeMap.containsKey(targetVertex)) { throw new IllegalArgumentException(\"Target vertex does not exist\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(targetVertex)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(sourceVertex)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgumentException(\"Source vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { throw new IllegalArgumentException(\"Target vertex does not touch the edge\"); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { throw new IllegalArgu"], "code_level": "class_runnable", "_id": "636767601a6d9265ec0180fd", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left = new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight());\n  Box2D right =\n      new Box2D(box.getX() + box.getWidth(), box.getY(), box.getWidth(), box.getHeight());\n  return new Pair<Box2D, Box2D>(left, right);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split a box along the x axis into two equal boxes.\n * @param box the box to split\n * @return a pair with the two resulting boxes\n */\n", "method_name": "splitAlongXAxis", "codes": ["public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight()); Box2D right = new Box2D(box.getX() + box.getWidth(), box.getY(), box.getWidth(), box.getHeight()); return new Pair<Box2D, Box2D>(left, right); }"], "code_level": "project_runnable", "_id": "636767521a6d9265ec017ecc", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return (p1.getX() == p2.getX() && p1.getY() == p2.getY());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Compare two points for equality using tolerance 1e-9.\n * @param p1 the first point\n * @param p2 the second point\n * @return whether the two points are equal or not\n */\n", "method_name": "equals", "codes": ["public static boolean equals(Point2D p1,Point2D p2){ return (p1.getX() == p2.getX() && p1.getY() == p2.getY()); }"], "code_level": "project_runnable", "_id": "636767531a6d9265ec017ef1", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  if (o1 < o2) {\n    return -1;\n  } else if (o1 > o2) {\n    return 1;\n  } else {\n    return 0;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares two floating point values. Returns 0 if they are equal, -1 if  {@literal o1 < o2}, 1 otherwise\n * @param o1 the first value\n * @param o2 the second value\n * @return 0 if they are equal, -1 if {@literal o1 < o2}, 1 otherwise\n */\n", "method_name": "compare", "codes": ["@Override public int compare(Double o1,Double o2){ if (o1 < o2) { return -1; } else if (o1 > o2) { return 1; } else { return 0; } }"], "code_level": "slib_runnable", "_id": "6367674a1a6d9265ec017dab", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public String toString() {\n  String s = \"\";\n  for (int i = 0; i < v.length; i++) {\n    s += v[i] + \" \";\n  }\n  return s;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a textual representation of the queue.\n * @return a textual representation of the queue.\n */\n", "method_name": "toString", "codes": ["public String toString(){ String s = \"\"; for (int i = 0; i < v.length; i++) { s += v[i] + \" \"; } return s; }"], "code_level": "class_runnable", "_id": "6367674f1a6d9265ec017e74", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private int computeBinaryLog(int n) {\n  int res = 0;\n  while (n > 0) {\n    res += n % 2;\n    n /= 2;\n  }\n  return res;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n", "method_name": "computeBinaryLog", "codes": ["private int computeBinaryLog(int n){ int res = 0; while (n > 0) { res += n % 2; n /= 2; } return res; }"], "code_level": "self_contained", "_id": "636767431a6d9265ec017c8d", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0;\n  for (V v1 : v) {\n    sum += weight(v1);\n  }\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compute the sum of the weights entering a vertex\n * @param v the vertex\n * @return the sum of the weights entering a vertex\n */\n", "method_name": "vertexWeight", "codes": ["public double vertexWeight(Set<V> v){ double sum = 0; for (V v1 : v) { sum += weight(v1); } return sum; }"], "code_level": "class_runnable", "_id": "636767611a6d9265ec018106", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>();\n  for (V v : set1) {\n    if (set2.contains(v)) {\n      intersection.add(v);\n    }\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n", "method_name": "intersection", "codes": ["private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(); for (V v : set1) { if (set2.contains(v)) { intersection.add(v); } } return intersection; }"], "code_level": "slib_runnable", "_id": "636767611a6d9265ec018116", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (start.getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace()", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.\n * @param predicate the condition the desired node should satisfy\n * @param start the node to start the search from\n * @param stop the node to end the search with\n * @param dir the direction to start the traversal in\n * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node\n */\n", "method_name": "selectOnOuterFace", "codes": ["private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (start.getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace() == null) { return null; } if (start.getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace().getOuterFace()"], "code_level": "class_runnable", "_id": "636767511a6d9265ec017eb6", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "Edge edgeToNext() {\n  return edgeToNext;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n", "method_name": "edgeToNext", "codes": ["Edge edgeToNext(){ return edgeToNext; }"], "code_level": "class_runnable", "_id": "6367675d1a6d9265ec018082", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  GraphPath<V, E> path = new GraphPath<V, E>();\n  for (E edge : tour) {\n    path.addEdge(graph.getEdgeSource(edge), graph.getEdgeTarget(edge));\n  }\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n", "method_name": "edgeSetToTour", "codes": ["protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ GraphPath<V,E> path = new GraphPath<V, E>(); for (E edge : tour) { path.addEdge(graph.getEdgeSource(edge), graph.getEdgeTarget(edge)); } return path; }"], "code_level": "class_runnable", "_id": "636767561a6d9265ec017f7c", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    bucketsByLabel.get(i).clear();\n  }\n  for (int i = 0; i < labels.size(); i++) {\n    bucketsByLabel.get(labels.get(i)).add(i);\n  }\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    if (bucketsByLabel.get(i).size() < minLabel) {\n      bucketsByLabel.remove(i);\n      i--;\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Moves all vertices from the bucket with label  {@code minLabel} to the bucket with label 0.Clears the bucket with label  {@code minLabel}. Updates the labeling accordingly.\n * @param bucketsByLabel the buckets vertices are stored in\n * @param labels the labels of the vertices\n * @param minLabel the minimum value of the non-empty bucket\n */\n", "method_name": "reload", "codes": ["private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = 0; i < bucketsByLabel.size(); i++) { bucketsByLabel.get(i).clear(); } for (int i = 0; i < labels.size(); i++) { bucketsByLabel.get(labels.get(i)).add(i); } for (int i = 0; i < bucketsByLabel.size(); i++) { if (bucketsByLabel.get(i).size() < minLabel) { bucketsByLabel.remove(i); i--; } } }"], "code_level": "self_contained", "_id": "636767641a6d9265ec018190", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\nprotected V provideNextVertex() {\n  return vertexIterator.next();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * {@inheritDoc}\n */\n", "method_name": "provideNextVertex", "codes": ["@Override protected V provideNextVertex(){ return vertexIterator.next(); }"], "code_level": "class_runnable", "_id": "636767611a6d9265ec018112", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> globalSeparatorList = new ArrayList<>();\n  for (E edge : graph.getEdges()) {\n    if (edge.isCircle()) {\n      globalSeparatorList.add(new Pair<>(new ArrayList<>(), edge));\n    } else {\n      List<Pair<Integer, Integer>> separatorList = new ArrayList<>();\n      for (int i = 0; i < graph.getNumOfVertices(); i++) {\n        if (graph.getVertex(i).isSeparator()) {\n          separatorList.add(new Pair<>(i, graph.getVertex(i).getSeparator()));\n        }\n      }\n      globalSeparatorList.add(new Pair<>(separatorList, edge));\n    }\n  }\n  return globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates\n * @return the list of minimal separators of every edge $e$ in the inspected graph\n */\n", "method_name": "computeGlobalSeparatorList", "codes": ["private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<>(); for (E edge : graph.getEdges()) { if (edge.isCircle()) { globalSeparatorList.add(new Pair<>(new ArrayList<>(), edge)); } else { List<Pair<Integer,Integer>> separatorList = new ArrayList<>(); for (int i = 0; i < graph.getNumOfVertices(); i++) { if (graph.getVertex(i).isSeparator()) { separatorList.add(new Pair<>(i, graph.getVertex(i).getSeparator())); } } globalSeparatorList.add(new Pair<>(separatorList, edge)); } } return globalSeparatorList; }"], "code_level": "class_runnable", "_id": "636767601a6d9265ec0180e2", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  long sum = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    sum += bounds.get(i);\n  }\n  return new Pair<>(bounds, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.\n * @param bounds list of integers.\n * @return computed pair of suffix sum list and a sum of all elements.\n */\n", "method_name": "computeSuffixSum", "codes": ["private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ long sum = 0; for (int i = 0; i < bounds.size(); i++) { sum += bounds.get(i); } return new Pair<>(bounds, sum); }"], "code_level": "project_runnable", "_id": "636767461a6d9265ec017d0e", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  for (int i = 0; i < keys.size(); i++) {\n    lowerBounds.add(i);\n  }\n  return lowerBounds;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n", "method_name": "computeLowerBounds", "codes": ["private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); for (int i = 0; i < keys.size(); i++) { lowerBounds.add(i); } return lowerBounds; }"], "code_level": "class_runnable", "_id": "636767431a6d9265ec017c88", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>();\n  for (int i = 0; i < keys.size(); i++) {\n    upperBounds.add(i);\n  }\n  return upperBounds;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n", "method_name": "computeUpperBounds", "codes": ["private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(); for (int i = 0; i < keys.size(); i++) { upperBounds.add(i); } return upperBounds; }"], "code_level": "class_runnable", "_id": "636767581a6d9265ec017fb4", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (graph == null || vertices == null) {\n    return false;\n  }\n  if (graph.getVertices().size() != vertices.size()) {\n    return false;\n  }\n  if (graph.getVertices().size() == 0) {\n    return true;\n  }\n  Set<V> visited = new HashSet<>();\n  Queue<V> queue = new LinkedList<>();\n  queue.add(graph.getVertices().iterator().next());\n  visited.add(graph.getVertices().iterator().next());\n  while (!queue.isEmpty()) {\n    V v = queue.poll();\n    if (visited.contains(v)) {\n      continue;\n    }\n    visited.add(v);\n    for (E edge : graph.getEdges(v)) {\n      if (!visited.contains(edge.getTarget())) {\n        queue.add(edge.getTarget());\n      }\n    }\n  }\n  return visited.size() == graph.getVertices().size();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n", "method_name": "isClique", "codes": ["private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (graph == null || vertices == null) { return false; } if (graph.getVertices().size() != vertices.size()) { return false; } if (graph.getVertices().size() == 0) { return true; } Set<V> visited = new HashSet<>(); Queue<V> queue = new LinkedList<>(); queue.add(graph.getVertices().iterator().next()); visited.add(graph.getVertices().iterator().next()); while (!queue.isEmpty()) { V v = queue.poll(); if (visited.contains(v)) { continue; } visited.add(v); for (E edge : graph.getEdges(v)) { if (!visited.contains(edge.getTarget())) { queue.add(edge.getTarget()); } } } return visited.size() == graph.getVertices().size(); }"], "code_level": "class_runnable", "_id": "6367675f1a6d9265ec0180cf", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public int nonZeros(int row) {\n  int nz = 0;\n  for (int i = 0; i < n; i++) {\n    if (data[row][i] != 0) nz++;\n  }\n  return nz;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Get the number of non-zero entries of a row.\n * @param row the row\n * @return the number of non-zero entries of a row\n */\n", "method_name": "nonZeros", "codes": ["public int nonZeros(int row){ int nz = 0; for (int i = 0; i < n; i++) { if (data[row][i] != 0) nz++; } return nz; }"], "code_level": "class_runnable", "_id": "636767511a6d9265ec017eb0", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private String unescapeId(String input) {\n  if (input.startsWith(\"\\\\\")) {\n    input = input.substring(1);\n  }\n  if (input.endsWith(\"\\\\\")) {\n    input = input.substring(0, input.length() - 1);\n  }\n  return input;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n", "method_name": "unescapeId", "codes": ["private String unescapeId(String input){ if (input.startsWith(\"\\\\\")) { input = input.substring(1); } if (input.endsWith(\"\\\\\")) { input = input.substring(0, input.length() - 1); } return input; }"], "code_level": "class_runnable", "_id": "636767461a6d9265ec017d17", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ if (i == 0) { return 0; } if (i == 1) { bb.put((byte) (bb.get() ^ 0x80)); return 1; } if (i == 2) { bb.put((byte) (bb.get() ^ 0xC0)); return 2; } if (i == 3) { bb.put((byte) (bb.get() ^ 0xE0)); return 3; } if (i == 4) { bb.put((byte) (bb.get() ^ 0xF0)); return 4; } if (i == 5) { bb.put((byte) (bb.get() ^ 0xF8)); return 5; } if (i == 6) { bb.put((byte) (bb.get() ^ 0xF4)); return 6; } if (i == 7) { bb.put((byte) (bb.get() ^ 0xF2)); return 7; } if (i == 8) { bb.put((byte) (bb.get() ^ 0xF1)); return 8; } if (i == 9) { bb.put((byte) (bb.get() ^ 0x80)); return 9; } if (i == 10) { bb.put((byte) (bb.get() ^ 0xC0)); return 10; } if (i == 11) { bb.put((byte) (bb.get() ^ 0xE0)); return 11; } if (i == 12) { bb.put((byte) (bb.get() ^ 0xF0)); return 12; } if (i == 13) { bb.put((byte) (bb.get() ^ 0xF8)); return 13; } if (i == 14) { bb.put((byte) (bb.get() ^ 0xF4)); return 14; } if (i == 15) { bb.put((byte) (bb.get() ^ 0xF2)); return 15; } if (i == 16) { bb.put((byte) (bb.get() ^ 0xF1)); return 16; } if (i == 17) { bb.put((byte) (bb.get() ^ 0x80)); return 17; } if (i == 18) { bb.put((byte) (bb.get() ^ 0xC0)); return 18; } if (i == 19) { bb.put((byte) (bb.get() ^ 0xE0)); return 19; } if (i == 20) { bb.put((byte) (bb.get() ^ 0xF0)); return 20; } if (i == 21) { bb.put((byte) (bb.get() ^ 0xF8)); return 21; } if (i == 22) { bb.put((byte) (bb.get() ^ 0xF4)); return 22; } if (i == 23) { bb.put((byte) (bb.get() ^ 0xF2)); return 23; } if (i == 24) { bb.put((byte) (bb.get() ^ 0xF1)); return 24; } if (i == 25) { bb.put((byte) (bb.get() ^ 0x80)); return 25; } if (i == 26) { bb.put((byte) (bb.get() ^ 0xC0)); return 26; } if (i == 27) { bb.put", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n", "method_name": "decodeOctets", "codes": ["private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ if (i == 0) { return 0; } if (i == 1) { bb.put((byte) (bb.get() ^ 0x80)); return 1; } if (i == 2) { bb.put((byte) (bb.get() ^ 0xC0)); return 2; } if (i == 3) { bb.put((byte) (bb.get() ^ 0xE0)); return 3; } if (i == 4) { bb.put((byte) (bb.get() ^ 0xF0)); return 4; } if (i == 5) { bb.put((byte) (bb.get() ^ 0xF8)); return 5; } if (i == 6) { bb.put((byte) (bb.get() ^ 0xF4)); return 6; } if (i == 7) { bb.put((byte) (bb.get() ^ 0xF2)); return 7; } if (i == 8) { bb.put((byte) (bb.get() ^ 0xF1)); return 8; } if (i == 9) { bb.put((byte) (bb.get() ^ 0x80)); return 9; } if (i == 10) { bb.put((byte) (bb.get() ^ 0xC0)); return 10; } if (i == 11) { bb.put((byte) (bb.get() ^ 0xE0)); return 11; } if (i == 12) { bb.put((byte) (bb.get() ^ 0xF0)); return 12; } if (i == 13) { bb.put((byte) (bb.get() ^ 0xF8)); return 13; } if (i == 14) { bb.put((byte) (bb.get() ^ 0xF4)); return 14; } if (i == 15) { bb.put((byte) (bb.get() ^ 0xF2)); return 15; } if (i == 16) { bb.put((byte) (bb.get() ^ 0xF1)); return 16; } if (i == 17) { bb.put((byte) (bb.get() ^ 0x80)); return 17; } if (i == 18) { bb.put((byte) (bb.get() ^ 0xC0)); return 18; } if (i == 19) { bb.put((byte) (bb.get() ^ 0xE0)); return 19; } if (i == 20) { bb.put((byte) (bb.get() ^ 0xF0)); return 20; } if (i == 21) { bb.put((byte) (bb.get() ^ 0xF8)); return 21; } if (i == 22) { bb.put((byte) (bb.get() ^ 0xF4)); return 22; } if (i == 23) { bb.put((byte) (bb.get() ^ 0xF2)); return 23; } if (i == 24) { bb.put((byte) (bb.get() ^ 0xF1)); return 24; } if (i == 25) { bb.put((byte) (bb.get() ^ 0x80)); return 25; } if (i == 26) { bb.put((byte) (bb.get() ^ 0xC0)); return 26; } if (i == 27) { bb.put"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec017457", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>();\n  String path = u.getPath();\n  if (path == null) {\n    return result;\n  }\n  String[] segments = path.split(\"/\");\n  for (String segment : segments) {\n    if (segment.length() == 0) {\n      continue;\n    }\n    if (segment.equals(\"\")) {\n      continue;\n    }\n    if (segment.equals(\"..\")) {\n      if (result.size() > 0) {\n        result.remove(result.size() - 1);\n      }\n    } else if (segment.equals(\".\")) {\n      if (result.size() > 0) {\n        result.remove(result.size() - 1);\n      }\n    } else if (segment.equals(\"*\")) {\n      if (result.size() > 0) {\n        result.remove(result.size() - 1);\n      }\n    } else if (segment.equals(\"+\")) {\n      if (result.size() > 0) {\n        result.remove(result.size() - 1);\n      }\n    } else {\n      if (result.size() > 0) {\n        result.add(new PathSegmentImpl(segment, decode));\n      }\n    }\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Decode the path component of a URI as path segments.\n * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.\n * @param decode true if the path segments of the path componentshould be in decoded form.\n * @return the list of path segments.\n */\n", "method_name": "decodePath", "codes": ["public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>(); String path = u.getPath(); if (path == null) { return result; } String[] segments = path.split(\"/\"); for (String segment : segments) { if (segment.length() == 0) { continue; } if (segment.equals(\"\")) { continue; } if (segment.equals(\"..\")) { if (result.size() > 0) { result.remove(result.size() - 1); } } else if (segment.equals(\".\")) { if (result.size() > 0) { result.remove(result.size() - 1); } } else if (segment.equals(\"*\")) { if (result.size() > 0) { result.remove(result.size() - 1); } } else if (segment.equals(\"+\")) { if (result.size() > 0) { result.remove(result.size() - 1); } } else { if (result.size() > 0) { result.add(new PathSegmentImpl(segment, decode)); } } } return result; }"], "code_level": "slib_runnable", "_id": "6367667f1a6d9265ec01745d", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public final MatchResult match(CharSequence uri) {\n  if (uri == null) {\n    return null;\n  }\n  if (!uri.equals(this.uri)) {\n    return null;\n  }\n  if (this.pattern.matcher(uri).matches()) {\n    return new MatchResult(this.pattern.group(1), this.pattern.group(2), this.pattern.group(3));\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Match a URI against the pattern.\n * @param uri the uri to match against the template.\n * @return the match result, otherwise null if no match occurs.\n */\n", "method_name": "match", "codes": ["public final MatchResult match(CharSequence uri){ if (uri == null) { return null; } if (!uri.equals(this.uri)) { return null; } if (this.pattern.matcher(uri).matches()) { return new MatchResult(this.pattern.group(1), this.pattern.group(2), this.pattern.group(3)); } return null; }"], "code_level": "project_runnable", "_id": "636766861a6d9265ec01755a", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Ascertain if a template variable is a member of this template.\n * @param name name The template variable.\n * @return true if the template variable is a member of the template, otherwisefalse.\n */\n", "method_name": "isTemplateVariablePresent", "codes": ["public final boolean isTemplateVariablePresent(String name){ return this.templateVariables.containsKey(name); }"], "code_level": "class_runnable", "_id": "636766861a6d9265ec017553", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String encodeTemplateNames(String s) {\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    if (c == '{') {\n      sb.append(\"{\");\n    } else if (c == '}') {\n      sb.append(\"}\");\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Encodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-encoded.\n * @param s the string with zero or more template parameters names\n * @return the string with encoded template parameters names.\n */\n", "method_name": "encodeTemplateNames", "codes": ["public static String encodeTemplateNames(String s){ StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c == '{') { sb.append(\"{\"); } else if (c == '}') { sb.append(\"}\"); } else { sb.append(c); } } return sb.toString(); }"], "code_level": "self_contained", "_id": "636766801a6d9265ec017487", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  File f = new File(dir);\n  if (f.isDirectory()) {\n    File[] files = f.listFiles();\n    for (int i = 0; i < files.length; i++) {\n      addToClassPath(cpV, files[i].getAbsolutePath());\n    }\n  } else {\n    cpV.add(f.toURI().toURL());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n", "method_name": "addToClassPath", "codes": ["@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ File f = new File(dir); if (f.isDirectory()) { File[] files = f.listFiles(); for (int i = 0; i < files.length; i++) { addToClassPath(cpV, files[i].getAbsolutePath()); } } else { cpV.add(f.toURI().toURL()); } }"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec01745c", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String capitalize(String name) {\n  if (name == null || name.length() == 0) {\n    return name;\n  }\n  char[] chars = name.toCharArray();\n  chars[0] = Character.toUpperCase(chars[0]);\n  return new String(chars);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Reverse of Introspector.decapitalize\n */\n", "method_name": "capitalize", "codes": ["public static String capitalize(String name){ if (name == null || name.length() == 0) { return name; } char[] chars = name.toCharArray(); chars[0] = Character.toUpperCase(chars[0]); return new String(chars); }"], "code_level": "slib_runnable", "_id": "636766821a6d9265ec0174bf", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  StringBuffer sb = new StringBuffer();\n  int i = 0;\n  int len = str.length();\n  while (i < len) {\n    char c = str.charAt(i);\n    if (c == '\\\\') {\n      i++;\n      if (i >= len) {\n        throw new Exception(\"Invalid escape sequence\");\n      }\n      c = str.charAt(i);\n      switch (c) {\n        case 'b':\n          sb.append('\\b');\n          break;\n        case 't':\n          sb.append('\\t');\n          break;\n        case 'n':\n          sb.append('\\n');\n          break;\n        case 'f':\n          sb.append('\\f');\n          break;\n        case 'r':\n          sb.append('\\r');\n          break;\n        case '\"':\n          sb.append('\"');\n          break;\n        case '\\'':\n          sb.append('\\'');\n          break;\n        case '\\\\':\n          sb.append('\\\\');\n          break;\n        default:\n          throw new Exception(\"Invalid escape sequence\");\n      }\n    } else {\n      sb.append(c);\n    }\n    i++;\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code> into a newline character, unless the <code>'\\'</code> is preceded by another <code>'\\'</code>.</p>\n * @param str the <code>String</code> to unescape, may be null\n * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n */\n", "method_name": "unescapeJava", "codes": ["public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } StringBuffer sb = new StringBuffer(); int i = 0; int len = str.length(); while (i < len) { char c = str.charAt(i); if (c == '\\\\') { i++; if (i >= len) { throw new Exception(\"Invalid escape sequence\"); } c = str.charAt(i); switch(c) { case 'b': sb.append('\\b'); break; case 't': sb.append('\\t'); break; case 'n': sb.append('\\n'); break; case 'f': sb.append('\\f'); break; case 'r': sb.append('\\r'); break; case '\"': sb.append('\"'); break; case '\\'': sb.append('\\''); break; case '\\\\': sb.append('\\\\'); break; default: throw new Exception(\"Invalid escape sequence\"); } } else { sb.append(c); } i++; } return sb.toString(); }"], "code_level": "slib_runnable", "_id": "6367667d1a6d9265ec017401", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return (char) (c - '0');\n  } else if (c >= 'a' && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  } else if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  } else {\n    throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}.\n * @return The hexadecimal value represented in the ASCII charactergiven, or  {@link Character#MAX_VALUE} if the character is invalid.\n */\n", "method_name": "decodeHexNibble", "codes": ["private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return (char) (c - '0'); } else if (c >= 'a' && c <= 'f') { return (char) (c - 'a' + 10); } else if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } else { throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c); } }"], "code_level": "slib_runnable", "_id": "636766851a6d9265ec01751b", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    if (actualTypeArguments.length == 1) {\n      Type actualTypeArgument = actualTypeArguments[0];\n      if (actualTypeArgument instanceof Class) {\n        Class<?> actualTypeArgumentClass = (Class<?>) actualTypeArgument;\n        if (actualTypeArgumentClass.isArray()) {\n          Class<?> componentType = actualTypeArgumentClass.getComponentType();\n          if (componentType.isPrimitive()) {\n            return new Class<?>[] {componentType};\n          } else {\n            return new Class<?>[] {actualTypeArgumentClass};\n          }\n        } else {\n          return new Class<?>[] {actualTypeArgumentClass};\n        }\n      } else {\n        return new Class<?>[] {actualTypeArgument};\n      }\n    } else {\n      return new Class<?>[] {actualTypeArguments[0]};\n    }\n  } else {\n    return new Class<?>[] {genericType};\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.\n */\n", "method_name": "resolveArguments", "codes": ["public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments.length == 1) { Type actualTypeArgument = actualTypeArguments[0]; if (actualTypeArgument instanceof Class) { Class<?> actualTypeArgumentClass = (Class<?>) actualTypeArgument; if (actualTypeArgumentClass.isArray()) { Class<?> componentType = actualTypeArgumentClass.getComponentType(); if (componentType.isPrimitive()) { return new Class<?>[] { componentType }; } else { return new Class<?>[] { actualTypeArgumentClass }; } } else { return new Class<?>[] { actualTypeArgumentClass }; } } else { return new Class<?>[] { actualTypeArgument }; } } else { return new Class<?>[] { actualTypeArguments[0] }; } } else { return new Class<?>[] { genericType }; } }"], "code_level": "class_runnable", "_id": "636766821a6d9265ec0174b6", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  Type bound = resolveBound(typeVariable.getBounds());\n  if (bound == null) {\n    return typeVariable.getBounds()[0];\n  }\n  return bound;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Resolves the first bound for the  {@code typeVariable}, returning  {@code Unknown.class} if nonecan be resolved.\n */\n", "method_name": "resolveBound", "codes": ["public static Type resolveBound(TypeVariable<?> typeVariable){ Type bound = resolveBound(typeVariable.getBounds()); if (bound == null) { return typeVariable.getBounds()[0]; } return bound; }"], "code_level": "slib_runnable", "_id": "6367667d1a6d9265ec01741d", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Wrap an  {@link HttpServletRequest}.\n * @param request {@link HttpServletRequest}\n * @return an {@link AtmosphereRequest}\n */\n", "method_name": "wrap", "codes": ["public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request); }"], "code_level": "class_runnable", "_id": "636766821a6d9265ec0174d2", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  if (mapping == null) return this;\n  synchronized (atmosphereHandlers) {\n    AtmosphereHandlerWrapper hw = (AtmosphereHandlerWrapper) atmosphereHandlers.remove(mapping);\n    if (hw != null) {\n      hw.removeInitParameter(ApplicationConfig.BROADCASTER_MAPPINGS.getName());\n      hw.removeInitParameter(ApplicationConfig.BROADCASTER_MAPPING_PATH.getName());\n    }\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Remove an  {@link AtmosphereHandler}.\n * @param mapping the mapping used when invoking {@link #addAtmosphereHandler(String,AtmosphereHandler)};\n * @return true if removed\n */\n", "method_name": "removeAtmosphereHandler", "codes": ["public AtmosphereFramework removeAtmosphereHandler(String mapping){ if (mapping == null) return this; synchronized (atmosphereHandlers) { AtmosphereHandlerWrapper hw = (AtmosphereHandlerWrapper) atmosphereHandlers.remove(mapping); if (hw != null) { hw.removeInitParameter(ApplicationConfig.BROADCASTER_MAPPINGS.getName()); hw.removeInitParameter(ApplicationConfig.BROADCASTER_MAPPING_PATH.getName()); } } return this; }"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec017458", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "protected Object filter(Object msg) {\n  if (msg instanceof BroadcastAction) {\n    return null;\n  } else {\n    return msg;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Invoke the  {@link BroadcastFilter}\n * @param msg\n * @return\n */\n", "method_name": "filter", "codes": ["protected Object filter(Object msg){ if (msg instanceof BroadcastAction) { return null; } else { return msg; } }"], "code_level": "project_runnable", "_id": "636766821a6d9265ec0174b3", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().equals(c)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor} implementation class.</p>\n * @param interceptorList the interceptors\n * @param c               the interceptor class\n * @return {@code false} if an instance of the class already exists in the list, {@code true} otherwise\n */\n", "method_name": "checkDuplicate", "codes": ["private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().equals(c)) { return true; } } return false; }"], "code_level": "project_runnable", "_id": "636766811a6d9265ec017499", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public boolean hasBytes() {\n  return (dataBytes != null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * True is the body is a byte array\n * @return True is the body is a byte array\n */\n", "method_name": "hasBytes", "codes": ["public boolean hasBytes(){ return (dataBytes != null); }"], "code_level": "class_runnable", "_id": "6367667c1a6d9265ec0173f7", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String s = r.getParameter(\"meteor\");\n  if (s == null) return null;\n  try {\n    return new Meteor(s);\n  } catch (Exception e) {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Retrieve an instance of  {@link Meteor} based on the {@link HttpServletRequest}.\n * @param r {@link HttpServletRequest}\n * @return a {@link Meteor} or null if not found\n */\n", "method_name": "lookup", "codes": ["public static Meteor lookup(HttpServletRequest r){ String s = r.getParameter(\"meteor\"); if (s == null) return null; try { return new Meteor(s); } catch (Exception e) { return null; } }"], "code_level": "class_runnable", "_id": "6367667d1a6d9265ec0173ff", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (e == null) {\n    throw new IllegalArgumentException(\"eventListener cannot be null\");\n  }\n  if (e.getClass().isAssignableFrom(AtmosphereResourceEventListener.class)) {\n    if (!eventListeners.contains(e)) {\n      eventListeners.add(e);\n    }\n  } else {\n    throw new IllegalArgumentException(\n        \"eventListener must implement AtmosphereResourceEventListener\");\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a  {@link AtmosphereResourceEventListener}.\n * @param e an instance of AtmosphereResourceEventListener\n */\n", "method_name": "addEventListener", "codes": ["@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (e == null) { throw new IllegalArgumentException(\"eventListener cannot be null\"); } if (e.getClass().isAssignableFrom(AtmosphereResourceEventListener.class)) { if (!eventListeners.contains(e)) { eventListeners.add(e); } } else { throw new IllegalArgumentException(\"eventListener must implement AtmosphereResourceEventListener\"); } return this; }"], "code_level": "project_runnable", "_id": "6367667c1a6d9265ec0173fb", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) {\n    return null;\n  } else {\n    return new ByteArrayInputStream(buffer, 0, pos);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Return the next  {@link java.io.File} object or {@code null} if no more files areavailable.\n */\n", "method_name": "next", "codes": ["public InputStream next() throws IOException { if (!hasNext()) { return null; } else { return new ByteArrayInputStream(buffer, 0, pos); } }"], "code_level": "class_runnable", "_id": "636766811a6d9265ec017496", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private static File[] classPath(){ File[] files = new File[] { new File(\"/usr/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the class path of the current JVM instance as an array of  {@link File} objects.\n */\n", "method_name": "classPath", "codes": ["private static File[] classPath(){ File[] files = new File[] { new File(\"/usr/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File(\"/usr/local/bin/java\"), new File"], "code_level": "slib_runnable", "_id": "636766821a6d9265ec0174c9", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  final byte[] buffer = new byte[BUFFER_SIZE];\n  int bytesRead = 0;\n  while ((bytesRead = in.read(buffer)) != -1) {\n    if (bytesRead > 0) {\n      this.write(buffer, 0, bytesRead);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Clear and fill the buffer of this  {@code ClassFileBuffer} with thesupplied byte stream. The read pointer is reset to the start of the byte array.\n */\n", "method_name": "readFrom", "codes": ["public void readFrom(final InputStream in) throws IOException { final byte[] buffer = new byte[BUFFER_SIZE]; int bytesRead = 0; while ((bytesRead = in.read(buffer)) != -1) { if (bytesRead > 0) { this.write(buffer, 0, bytesRead); } } }"], "code_level": "class_runnable", "_id": "636766801a6d9265ec017482", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = 0; i < files.length; i++) {\n    add(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add the specified files in reverse order.\n */\n", "method_name": "addReverse", "codes": ["private void addReverse(final InputStream[] files){ for (int i = 0; i < files.length; i++) { add(files[i]); } }"], "code_level": "class_runnable", "_id": "636766801a6d9265ec017477", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private void addReverse(final File[] files){ for (int i = files.length - 1; i >= 0; i--) { final File file = files[i]; if (file.isDirectory()) { addReverse(file.listFiles()); } else { final String fileName = file.getName(); if (fileName.endsWith(\".java\")) { final String className = fileName.substring(0, fileName.length() - 6); final String packageName = fileName.substring(0, fileName.length() - 6).replace('/', '.'); final String classFileName = packageName + \".\" + className; final String classFilePath = file.getAbsolutePath(); final String classFilePathWithoutExt = classFilePath.replace('\\\\', '.'); final String classFilePathWithoutExtWithoutSlash = classFilePathWithoutExt.replace('/', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDo", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add the specified files in reverse order.\n */\n", "method_name": "addReverse", "codes": ["private void addReverse(final File[] files){ for (int i = files.length - 1; i >= 0; i--) { final File file = files[i]; if (file.isDirectory()) { addReverse(file.listFiles()); } else { final String fileName = file.getName(); if (fileName.endsWith(\".java\")) { final String className = fileName.substring(0, fileName.length() - 6); final String packageName = fileName.substring(0, fileName.length() - 6).replace('/', '.'); final String classFileName = packageName + \".\" + className; final String classFilePath = file.getAbsolutePath(); final String classFilePathWithoutExt = classFilePath.replace('\\\\', '.'); final String classFilePathWithoutExtWithoutSlash = classFilePathWithoutExt.replace('/', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDotWithoutDot = classFilePathWithoutExtWithoutSlash.replace('.', '.'); final String classFilePathWithoutExtWithoutSlashWithoutDotWithoutDo"], "code_level": "class_runnable", "_id": "636766831a6d9265ec0174eb", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * The last time, in milliseconds, a write operation occurred.\n * @return this\n */\n", "method_name": "lastWriteTimeStampInMilliseconds", "codes": ["public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStampInMilliseconds; }"], "code_level": "class_runnable", "_id": "6367667e1a6d9265ec01743a", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) {\n    return Action.CONTINUE;\n  }\n  return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Automatically suspend the  {@link AtmosphereResource} based on {@link AtmosphereResource.TRANSPORT} value.\n * @param r a {@link AtmosphereResource}\n * @return {@link Action#CONTINUE}\n */\n", "method_name": "inspect", "codes": ["@Override public Action inspect(AtmosphereResource r){ if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) { return Action.CONTINUE; } return Action.CONTINUE; }"], "code_level": "project_runnable", "_id": "636766851a6d9265ec017515", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (ObjectUtils.isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.\n * @param array the original String array\n * @return the resulting array (of the same size) with trimmed elements\n */\n", "method_name": "trimArrayElements", "codes": ["public static String[] trimArrayElements(String[] array){ if (ObjectUtils.isEmpty(array)) { return new String[0]; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }"], "code_level": "self_contained", "_id": "6367676d1a6d9265ec018229", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.\n * @param array the long array to obtain a hashcode\n * @return the long array's hashcode, which could be 0 if the array is null.\n */\n", "method_name": "nullSafeHashCode", "codes": ["public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181aa", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWith(str, prefix, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @param str the String to check\n * @param prefix the prefix to look for\n * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @see java.lang.String#startsWith\n */\n", "method_name": "startsWithIgnoreCase", "codes": ["public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWith(str, prefix, true); }"], "code_level": "self_contained", "_id": "6367676b1a6d9265ec0181df", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (candidates.isEmpty()) {\n    return null;\n  }\n  Object first = candidates.iterator().next();\n  if (candidates.size() == 1) {\n    return first;\n  }\n  if (source.contains(first)) {\n    return first;\n  }\n  for (Iterator iter = candidates.iterator(); iter.hasNext(); ) {\n    Object candidate = iter.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.\n * @param source the source Collection\n * @param candidates the candidates to search for\n * @return the first present object, or <code>null</code> if not found\n */\n", "method_name": "findFirstMatch", "codes": ["public static Object findFirstMatch(Collection source,Collection candidates){ if (candidates.isEmpty()) { return null; } Object first = candidates.iterator().next(); if (candidates.size() == 1) { return first; } if (source.contains(first)) { return first; } for (Iterator iter = candidates.iterator(); iter.hasNext(); ) { Object candidate = iter.next(); if (source.contains(candidate)) { return candidate; } } return null; }"], "code_level": "class_runnable", "_id": "6367676b1a6d9265ec0181e2", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Trim trailing whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "method_name": "trimTrailingWhitespace", "codes": ["public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }"], "code_level": "class_runnable", "_id": "6367676b1a6d9265ec0181ee", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return quote((String) obj);\n  }\n  return obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.\n * @param obj the input Object (e.g. \"myString\")\n * @return the quoted String (e.g. \"'myString'\"),or the input object as-is if not a String\n */\n", "method_name": "quoteIfString", "codes": ["public static Object quoteIfString(Object obj){ if (obj instanceof String) { return quote((String) obj); } return obj; }"], "code_level": "class_runnable", "_id": "6367676a1a6d9265ec0181bf", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Trim leading whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "method_name": "trimLeadingWhitespace", "codes": ["public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }"], "code_level": "class_runnable", "_id": "6367676a1a6d9265ec0181cd", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Copy the given Enumeration into a String array. The Enumeration must contain String elements only.\n * @param enumeration the Enumeration to copy\n * @return the String array (<code>null</code> if the passed-inEnumeration was <code>null</code>)\n */\n", "method_name": "toStringArray", "codes": ["public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }"], "code_level": "slib_runnable", "_id": "636767691a6d9265ec0181ae", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString == null || charsToDelete == null) {\n    return null;\n  }\n  StringBuilder out = new StringBuilder();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      out.append(c);\n    }\n  }\n  return out.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Delete any character in a given String.\n * @param inString the original String\n * @param charsToDelete a set of characters to delete.E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n * @return the resulting String\n */\n", "method_name": "deleteAny", "codes": ["public static String deleteAny(String inString,String charsToDelete){ if (inString == null || charsToDelete == null) { return null; } StringBuilder out = new StringBuilder(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { out.append(c); } } return out.toString(); }"], "code_level": "class_runnable", "_id": "6367676c1a6d9265ec01820b", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    return false;\n  }\n  if (element == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Check whether the given Collection contains the given element instance. <p>Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.\n * @param collection the Collection to check\n * @param element the element to look for\n * @return <code>true</code> if found, <code>false</code> else\n */\n", "method_name": "containsInstance", "codes": ["public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { return false; } if (element == null) { return false; } return collection.contains(element); }"], "code_level": "slib_runnable", "_id": "6367676c1a6d9265ec018223", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  String[] result = new String[array1.length + array2.length];\n  System.arraycopy(array1, 0, result, 0, array1.length);\n  System.arraycopy(array2, 0, result, array1.length, array2.length);\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.\n * @param array1 the first array (can be <code>null</code>)\n * @param array2 the second array (can be <code>null</code>)\n * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n */\n", "method_name": "concatenateStringArrays", "codes": ["public static String[] concatenateStringArrays(String[] array1,String[] array2){ String[] result = new String[array1.length + array2.length]; System.arraycopy(array1, 0, result, 0, array1.length); System.arraycopy(array2, 0, result, array1.length, array2.length); return result; }"], "code_level": "slib_runnable", "_id": "6367676c1a6d9265ec018204", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  String[] newArray = new String[array.length + 1];\n  for (int i = 0; i < array.length; i++) {\n    newArray[i] = array[i];\n  }\n  newArray[array.length] = str;\n  return newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.\n * @param array the array to append to (can be <code>null</code>)\n * @param str the String to append\n * @return the new array (never <code>null</code>)\n */\n", "method_name": "addStringToArray", "codes": ["public static String[] addStringToArray(String[] array,String str){ String[] newArray = new String[array.length + 1]; for (int i = 0; i < array.length; i++) { newArray[i] = array[i]; } newArray[array.length] = str; return newArray; }"], "code_level": "slib_runnable", "_id": "6367676a1a6d9265ec0181d4", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  int count = 0;\n  for (int i = 0; i < str.length() - sub.length() + 1; i++) {\n    if (str.substring(i, i + sub.length()).equals(sub)) {\n      count++;\n    }\n  }\n  return count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns the number of occurrences the substring  {@code sub} appears in string {@code str}.\n * @param str string to search in. Return 0 if this is null.\n * @param sub string to search for. Return 0 if this is null.\n * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n */\n", "method_name": "countOccurrencesOf", "codes": ["public static int countOccurrencesOf(String str,String sub){ int count = 0; for (int i = 0; i < str.length() - sub.length() + 1; i++) { if (str.substring(i, i + sub.length()).equals(sub)) { count++; } } return count; }"], "code_level": "self_contained", "_id": "6367676b1a6d9265ec0181dd", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Strip the filename extension from the given path, e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n * @param path the file path (may be <code>null</code>)\n * @return the path with stripped filename extension,or <code>null</code> if none\n */\n", "method_name": "stripFilenameExtension", "codes": ["public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }"], "code_level": "class_runnable", "_id": "6367676c1a6d9265ec018220", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Trim all occurrences of the supplied leading character from the given String.\n * @param str the String to check\n * @param leadingCharacter the leading character to be trimmed\n * @return the trimmed String\n */\n", "method_name": "trimLeadingCharacter", "codes": ["public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181a7", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, -1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.\n * @param toSplit the string to split\n * @param delimiter to split the string up with\n * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String\n */\n", "method_name": "split", "codes": ["public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, -1); }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181a6", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. \"/\" separators).\n * @param path the path to start from (usually a full file path)\n * @param relativePath the relative path to apply(relative to the full file path above)\n * @return the full file path that results from applying the relative path\n */\n", "method_name": "applyRelativePath", "codes": ["public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181ac", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  for (int j = 0; j < substring.length(); j++) {\n    int i = index + j;\n    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns  {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n * @param str the original string (or StringBuilder)\n * @param index the index in the original string to start matching against\n * @param substring the substring to match at the given index\n * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n */\n", "method_name": "substringMatch", "codes": ["public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ for (int j = 0; j < substring.length(); j++) { int i = index + j; if (i >= str.length() || str.charAt(i) != substring.charAt(j)) { return false; } } return true; }"], "code_level": "slib_runnable", "_id": "6367676b1a6d9265ec0181e9", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Delete's the specified file if it exists \n */\n", "method_name": "deleteFile", "codes": ["protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }"], "code_level": "slib_runnable", "_id": "636767821a6d9265ec0183a0", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public String format(LoggingEvent event) {\n  StringBuffer buffer = new StringBuffer();\n  buffer.append(event.getLevel().toString());\n  buffer.append(\": \");\n  buffer.append(event.getMessage());\n  buffer.append(\"\\n\");\n  if (event.getThrowableInformation() != null) {\n    ThrowableInformation throwableInformation = event.getThrowableInformation();\n    buffer.append(\"Caused by: \");\n    buffer.append(throwableInformation.getThrowable().toString());\n    buffer.append(\"\\n\");\n  }\n  return buffer.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Produces a formatted string as specified by the conversion pattern.\n */\n", "method_name": "format", "codes": ["public String format(LoggingEvent event){ StringBuffer buffer = new StringBuffer(); buffer.append(event.getLevel().toString()); buffer.append(\": \"); buffer.append(event.getMessage()); buffer.append(\"\\n\"); if (event.getThrowableInformation() != null) { ThrowableInformation throwableInformation = event.getThrowableInformation(); buffer.append(\"Caused by: \"); buffer.append(throwableInformation.getThrowable().toString()); buffer.append(\"\\n\"); } return buffer.toString(); }"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec01830f", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (!isEnabled()) {\n    return;\n  }\n  if (!isAppend()) {\n    return;\n  }\n  if (!isTempFileExists()) {\n    try {\n      createTempFile();\n    } catch (IOException e) {\n      logger.error(\"Failed to create temp file\", e);\n    }\n  }\n  try {\n    FileOutputStream fos = new FileOutputStream(tempFile, true);\n    fos.write(event.getMessage().getBytes());\n    fos.close();\n  } catch (IOException e) {\n    logger.error(\"Failed to write to temp file\", e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * This method does actual writing\n */\n", "method_name": "subAppend", "codes": ["protected void subAppend(LoggingEvent event){ if (!isEnabled()) { return; } if (!isAppend()) { return; } if (!isTempFileExists()) { try { createTempFile(); } catch (IOException e) { logger.error(\"Failed to create temp file\", e); } } try { FileOutputStream fos = new FileOutputStream(tempFile, true); fos.write(event.getMessage().getBytes()); fos.close(); } catch (IOException e) { logger.error(\"Failed to write to temp file\", e); } }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec01823d", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static String peek() {\n  if (stack.isEmpty()) {\n    return null;\n  }\n  return stack.get(stack.size() - 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string \"\" is returned.\n * @return String The innermost diagnostic context.\n */\n", "method_name": "peek", "codes": ["public static String peek(){ if (stack.isEmpty()) { return null; } return stack.get(stack.size() - 1); }"], "code_level": "class_runnable", "_id": "636767831a6d9265ec0183c9", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public Logger exists(String name) {\n  return loggers.get(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if the named logger exists in the hierarchy. If so return its reference, otherwise returns <code>null</code>.\n * @param name The name of the logger to search for.\n */\n", "method_name": "exists", "codes": ["public Logger exists(String name){ return loggers.get(name); }"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec01832e", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public String format(final LoggingEvent event) {\n  final StringBuilder sb = new StringBuilder();\n  sb.append(event.getLevel().toString());\n  sb.append(\": \");\n  sb.append(event.getMessage());\n  sb.append(\"\\n\");\n  sb.append(event.getThrowableInformation().getThrowable().toString());\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Formats a logging event to a writer.\n * @param event logging event to be formatted.\n */\n", "method_name": "format", "codes": ["public String format(final LoggingEvent event){ final StringBuilder sb = new StringBuilder(); sb.append(event.getLevel().toString()); sb.append(\": \"); sb.append(event.getMessage()); sb.append(\"\\n\"); sb.append(event.getThrowableInformation().getThrowable().toString()); return sb.toString(); }"], "code_level": "project_runnable", "_id": "6367677b1a6d9265ec0182bd", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  Class clazz = null;\n  try {\n    clazz = Class.forName(className);\n  } catch (final ClassNotFoundException e) {\n    clazz = Class.forName(className + \"$\");\n  }\n  return clazz;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n", "method_name": "findClass", "codes": ["private Class findClass(final String className) throws ClassNotFoundException { Class clazz = null; try { clazz = Class.forName(className); } catch (final ClassNotFoundException e) { clazz = Class.forName(className + \"$\"); } return clazz; }"], "code_level": "slib_runnable", "_id": "636767791a6d9265ec018263", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void addMessage(final LogRecord lr){ if (lr.getLevel().intValue() >= Level.SEVERE.intValue()) { final String msg = lr.getMessage(); final String t = lr.getThrown() != null ? lr.getThrown().toString() : \"\"; final String s = msg + \"\\n\" + t; final String ss = s.replaceAll(\"\\n\", \"\\n\\n\"); final String sss = ss.replaceAll(\"\\r\", \"\\n\\n\"); final String ssss = sss.replaceAll(\"\\t\", \"\\n\\n\"); final String sssss = ssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssss = sssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssss = ssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssss = ssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssss = sssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssss = ssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssss = sssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssssss = ssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssssss = sssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssssssss = ssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssssssss = sssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssssssssss = ssssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssssssssss = ssssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssssssssss = sssssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssssssssssss = sssssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssssssssssss = ssssssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssssssssssss = ssssssssssssssssss.replaceAll(\"\\", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a log record message to be displayed in the LogTable. This method is thread-safe as it posts requests to the SwingThread rather than processing directly.\n */\n", "method_name": "addMessage", "codes": ["public void addMessage(final LogRecord lr){ if (lr.getLevel().intValue() >= Level.SEVERE.intValue()) { final String msg = lr.getMessage(); final String t = lr.getThrown() != null ? lr.getThrown().toString() : \"\"; final String s = msg + \"\\n\" + t; final String ss = s.replaceAll(\"\\n\", \"\\n\\n\"); final String sss = ss.replaceAll(\"\\r\", \"\\n\\n\"); final String ssss = sss.replaceAll(\"\\t\", \"\\n\\n\"); final String sssss = ssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssss = sssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssss = ssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssss = ssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssss = sssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssss = ssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssss = sssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssssss = ssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssssss = sssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssssssss = ssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssssssss = sssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssssssssss = ssssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssssssssss = ssssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssssssssss = sssssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssssssssssss = sssssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String ssssssssssssssssss = ssssssssssssssssss.replaceAll(\"\\n\\n\", \"\\n\\n\"); final String sssssssssssssssssss = ssssssssssssssssss.replaceAll(\"\\"], "code_level": "project_runnable", "_id": "636767791a6d9265ec018257", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  if (row < 0 || row >= table.getRowCount()) {\n    return;\n  }\n  table.setRowSelectionInterval(row, row);\n  pane.setViewportView(table);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Selects a the specified row in the specified JTable and scrolls the specified JScrollpane to the newly selected row. More importantly, the call to repaint() delayed long enough to have the table properly paint the newly selected row which may be offscre\n * @param table should belong to the specified JScrollPane\n */\n", "method_name": "selectRow", "codes": ["public static void selectRow(int row,JTable table,JScrollPane pane){ if (row < 0 || row >= table.getRowCount()) { return; } table.setRowSelectionInterval(row, row); pane.setViewportView(table); }"], "code_level": "project_runnable", "_id": "636767841a6d9265ec0183ff", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static void createConfigurationDirectory() {\n  if (!new File(\"lf5\").exists()) {\n    new File(\"lf5\").mkdir();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Creates the directory where the MRU file list will be written. The \"lf5\" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.\n */\n", "method_name": "createConfigurationDirectory", "codes": ["public static void createConfigurationDirectory(){ if (!new File(\"lf5\").exists()) { new File(\"lf5\").mkdir(); } }"], "code_level": "slib_runnable", "_id": "636767871a6d9265ec01846d", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public synchronized void send(final String message) {\n  if (message == null) {\n    return;\n  }\n  if (message.length() == 0) {\n    return;\n  }\n  if (!connected) {\n    return;\n  }\n  if (outputStream == null) {\n    return;\n  }\n  try {\n    outputStream.write(message.getBytes());\n    outputStream.flush();\n  } catch (IOException e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * sends a message to each of the clients in telnet-friendly output. \n */\n", "method_name": "send", "codes": ["public synchronized void send(final String message){ if (message == null) { return; } if (message.length() == 0) { return; } if (!connected) { return; } if (outputStream == null) { return; } try { outputStream.write(message.getBytes()); outputStream.flush(); } catch (IOException e) { e.printStackTrace(); } }"], "code_level": "class_runnable", "_id": "6367677f1a6d9265ec018347", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "protected void append(LoggingEvent event){ if (layout.format(event)) { if (layout.ignoresThrowable()) { event.setThrowable(null); } if (event.getLevel().intValue() >= Level.WARNING.intValue()) { if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) =", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n", "method_name": "append", "codes": ["protected void append(LoggingEvent event){ if (layout.format(event)) { if (layout.ignoresThrowable()) { event.setThrowable(null); } if (event.getLevel().intValue() >= Level.WARNING.intValue()) { if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) == '\\n') { event.setNDC(event.getNDC().substring(1)); } } } if (event.getNDC() != null) { if (event.getNDC().length() > 0) { if (event.getNDC().charAt(0) ="], "code_level": "project_runnable", "_id": "636767781a6d9265ec01823e", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void put(LoggingEvent o) {\n  if (buf.length() > 0) {\n    buf.append(\"\\n\");\n  }\n  buf.append(o.getRenderedMessage());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  \n */\n", "method_name": "put", "codes": ["public void put(LoggingEvent o){ if (buf.length() > 0) { buf.append(\"\\n\"); } buf.append(o.getRenderedMessage()); }"], "code_level": "class_runnable", "_id": "6367677f1a6d9265ec01834b", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static String findAndSubst(String key,Properties props){ String value = props.getProperty(key); if (value == null) { value = props.getProperty(key.toLowerCase()); } if (value == null) { value = props.getProperty(key.toUpperCase()); } if (value == null) { value = props.getProperty(key); } if (value == null) { value = props.getProperty(key.replace('.', '_')); } if (value == null) { value = props.getProperty(key.replace('-', '_')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '-')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '-')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '-')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '-')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '-')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.\n */\n", "method_name": "findAndSubst", "codes": ["public static String findAndSubst(String key,Properties props){ String value = props.getProperty(key); if (value == null) { value = props.getProperty(key.toLowerCase()); } if (value == null) { value = props.getProperty(key.toUpperCase()); } if (value == null) { value = props.getProperty(key); } if (value == null) { value = props.getProperty(key.replace('.', '_')); } if (value == null) { value = props.getProperty(key.replace('-', '_')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '-')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '-')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '-')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '-')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '-')); } if (value == null) { value = props.getProperty(key.replace('-', '.')); } if (value == null) { value = props.getProperty(key.replace('_', '.')); }"], "code_level": "project_runnable", "_id": "636767791a6d9265ec01826d", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public boolean isAttached(Appender appender) {\n  return appenderList.contains(appender);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns <code>true</code> if the specified appender is in the list of attached appenders, <code>false</code> otherwise.\n * @since 1.2 \n */\n", "method_name": "isAttached", "codes": ["public boolean isAttached(Appender appender){ return appenderList.contains(appender); }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018238", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) {\n    return dEfault;\n  }\n  if (value.equalsIgnoreCase(\"true\")) {\n    return true;\n  }\n  if (value.equalsIgnoreCase(\"false\")) {\n    return false;\n  }\n  return dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * If <code>value</code> is \"true\", then <code>true</code> is returned. If <code>value</code> is \"false\", then <code>true</code> is returned. Otherwise, <code>default</code> is returned. <p>Case of value is unimportant.  \n */\n", "method_name": "toBoolean", "codes": ["public static boolean toBoolean(String value,boolean dEfault){ if (value == null) { return dEfault; } if (value.equalsIgnoreCase(\"true\")) { return true; } if (value.equalsIgnoreCase(\"false\")) { return false; } return dEfault; }"], "code_level": "self_contained", "_id": "6367677d1a6d9265ec0182fd", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void add(LoggingEvent event) {\n  if (event.getLevel().isGreaterOrEqual(level)) {\n    events.add(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add an <code>event</code> as the last event in the buffer.\n */\n", "method_name": "add", "codes": ["public void add(LoggingEvent event){ if (event.getLevel().isGreaterOrEqual(level)) { events.add(event); } }"], "code_level": "class_runnable", "_id": "636767841a6d9265ec0183e8", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    if (appenders.containsKey(name)) {\n      appenders.remove(name);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Remove the appender with the name passed as parameter form the list of appenders.  \n */\n", "method_name": "removeAppender", "codes": ["public void removeAppender(String name){ synchronized (appenders) { if (appenders.containsKey(name)) { appenders.remove(name); } } }"], "code_level": "project_runnable", "_id": "636767861a6d9265ec01844c", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int ret = 0;\n  for (Appender appender : appenders) {\n    if (appender instanceof LoopingAppender) {\n      LoopingAppender loopAppender = (LoopingAppender) appender;\n      ret += loopAppender.appendLoopOnAppenders(event);\n    }\n  }\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Call the <code>doAppend</code> method on all attached appenders.  \n */\n", "method_name": "appendLoopOnAppenders", "codes": ["public int appendLoopOnAppenders(LoggingEvent event){ int ret = 0; for (Appender appender : appenders) { if (appender instanceof LoopingAppender) { LoopingAppender loopAppender = (LoopingAppender) appender; ret += loopAppender.appendLoopOnAppenders(event); } } return ret; }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018242", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public boolean hasThrown() {\n  return thrown != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return true if getThrown().toString() is a non-empty string.\n */\n", "method_name": "hasThrown", "codes": ["public boolean hasThrown(){ return thrown != null; }"], "code_level": "class_runnable", "_id": "636767821a6d9265ec0183ab", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  for (int i = 0; i < m_nodeCount; i++) {\n    if (m_nodeList[i].isInactive()) {\n      m_nodeList[i].remove();\n      removed++;\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes any inactive nodes from the Category tree.\n */\n", "method_name": "removeUnusedNodes", "codes": ["protected int removeUnusedNodes(){ int removed = 0; for (int i = 0; i < m_nodeCount; i++) { if (m_nodeList[i].isInactive()) { m_nodeList[i].remove(); removed++; } } return removed; }"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec018314", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event e1 = (Event) aObj1;\n  Event e2 = (Event) aObj2;\n  return e1.getTimeStamp().compareTo(e2.getTimeStamp());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @see Comparator \n */\n", "method_name": "compare", "codes": ["public int compare(Object aObj1,Object aObj2){ Event e1 = (Event) aObj1; Event e2 = (Event) aObj2; return e1.getTimeStamp().compareTo(e2.getTimeStamp()); }"], "code_level": "project_runnable", "_id": "636767841a6d9265ec0183f2", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public int decide(LoggingEvent event) {\n  if (event.getMessage().contains(\"foo\")) {\n    return 0;\n  } else if (event.getMessage().contains(\"bar\")) {\n    return 1;\n  } else {\n    return 2;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns  {@link Filter#NEUTRAL} is there is no string match.\n */\n", "method_name": "decide", "codes": ["public int decide(LoggingEvent event){ if (event.getMessage().contains(\"foo\")) { return 0; } else if (event.getMessage().contains(\"bar\")) { return 1; } else { return 2; } }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018250", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  final int nameEnd = buf.length();\n  for (int i = nameStart; i < nameEnd; i++) {\n    final char c = buf.charAt(i);\n    if (c == '.') {\n      buf.deleteCharAt(i);\n      i--;\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Abbreviate name.\n * @param buf buffer to append abbreviation.\n * @param nameStart start of name to abbreviate.\n */\n", "method_name": "abbreviate", "codes": ["public void abbreviate(final int nameStart,final StringBuffer buf){ final int nameEnd = buf.length(); for (int i = nameStart; i < nameEnd; i++) { final char c = buf.charAt(i); if (c == '.') { buf.deleteCharAt(i); i--; } } }"], "code_level": "class_runnable", "_id": "636767861a6d9265ec018440", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public String id(String entityId) {\n  return entityId + \"_\" + connector.getId();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return the row id\n */\n", "method_name": "id", "codes": ["public String id(String entityId){ return entityId + \"_\" + connector.getId(); }"], "code_level": "project_runnable", "_id": "636767df1a6d9265ec01873c", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (data.getId() == null) {\n    final String id = UUID.randomUUID().toString();\n    data.setId(id);\n  }\n  buffer.add(data);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.\n * @param data to be added potentially.\n */\n", "method_name": "accept", "codes": ["@Override public void accept(final METRICS data){ if (data.getId() == null) { final String id = UUID.randomUUID().toString(); data.setId(id); } buffer.add(data); }"], "code_level": "self_contained", "_id": "636767e11a6d9265ec018781", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<TimeRange>();\n  timeRanges.add(new TimeRange(start, end));\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}\n */\n", "method_name": "buildTimeRanges", "codes": ["protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<TimeRange>(); timeRanges.add(new TimeRange(start, end)); return timeRanges; }"], "code_level": "self_contained", "_id": "636767df1a6d9265ec018744", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value == null) {\n    return;\n  }\n  if (values.containsKey(key)) {\n    Long oldValue = values.get(key);\n    values.put(key, oldValue + value);\n  } else {\n    values.put(key, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Accumulate the value with existing value in the same given key.\n */\n", "method_name": "valueAccumulation", "codes": ["public void valueAccumulation(String key,Long value){ if (value == null) { return; } if (values.containsKey(key)) { Long oldValue = values.get(key); values.put(key, oldValue + value); } else { values.put(key, value); } }"], "code_level": "class_runnable", "_id": "636767de1a6d9265ec01871c", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  return timestamp - lastUpdateTimestamp > expiredThreshold;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * @param timestamp        of current time\n * @param expiredThreshold represents the duration between last update time and the time point removing from cache.\n * @return true means this metrics should be removed from cache.\n */\n", "method_name": "isExpired", "codes": ["public boolean isExpired(long timestamp,long expiredThreshold){ return timestamp - lastUpdateTimestamp > expiredThreshold; }"], "code_level": "class_runnable", "_id": "636767dd1a6d9265ec0186de", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet()) {\n    String key = entry.getKey();\n    JsonElement value = entry.getValue();\n    if (value.isJsonObject()) {\n      content.put(key, buildContent(value.getAsJsonObject()));\n    } else if (value.isJsonArray()) {\n      content.put(key, buildContent(value.getAsJsonArray()));\n    } else {\n      content.put(key, value.getAsString());\n    }\n  }\n  return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * build content,if it has ats someone set the ats\n */\n", "method_name": "buildContent", "codes": ["private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet()) { String key = entry.getKey(); JsonElement value = entry.getValue(); if (value.isJsonObject()) { content.put(key, buildContent(value.getAsJsonObject())); } else if (value.isJsonArray()) { content.put(key, buildContent(value.getAsJsonArray())); } else { content.put(key, value.getAsString()); } } return content; }"], "code_level": "project_runnable", "_id": "636767e01a6d9265ec018755", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (modelName == null) {\n    throw new IllegalStateException(\"Model name cannot be null\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n", "method_name": "check", "codes": ["private void check(String modelName) throws IllegalStateException { if (modelName == null) { throw new IllegalStateException(\"Model name cannot be null\"); } }"], "code_level": "self_contained", "_id": "636767de1a6d9265ec01871e", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void overrideName(String oldName, String newName) {\n  for (int i = 0; i < this.getRowCount(); i++) {\n    if (this.getValueAt(i, 0).equals(oldName)) {\n      this.setValueAt(newName, i, 1);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Keep the same name replacement as  {@link ColumnName#overrideName(String,String)}\n * @param oldName to be replaced.\n * @param newName to use in the storage level.\n */\n", "method_name": "overrideName", "codes": ["public void overrideName(String oldName,String newName){ for (int i = 0; i < this.getRowCount(); i++) { if (this.getValueAt(i, 0).equals(oldName)) { this.setValueAt(newName, i, 1); } } }"], "code_level": "self_contained", "_id": "636767dd1a6d9265ec0186f3", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (dataset.getNumRows() != this.getNumRows()) {\n    return false;\n  }\n  for (int i = 0; i < this.getNumRows(); i++) {\n    if (!this.getRow(i).isCompatible(dataset.getRow(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return true if the bucket is same.\n */\n", "method_name": "isCompatible", "codes": ["public boolean isCompatible(DataTable dataset){ if (dataset.getNumRows() != this.getNumRows()) { return false; } for (int i = 0; i < this.getNumRows(); i++) { if (!this.getRow(i).isCompatible(dataset.getRow(i))) { return false; } } return true; }"], "code_level": "plib_runnable", "_id": "636767e11a6d9265ec018795", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){ if (mappings == null) { return null; } if (mappings.getMappings().isEmpty()) { return null; } if (mappings.getMappings().size() == 1) { return mappings.getMappings().values().iterator().next(); } Map<String, Mapping> dbMappings = new HashMap<>(); for (Mapping mapping : mappings.getMappings().values()) { if (mapping.getTable().equals(tableName)) { dbMappings.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappings = new HashMap<>(); for (Mapping mapping : mappings.getMappings().values()) { if (mapping.getTable().equals(tableName)) { tblMappings.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumn = new HashMap<>(); for (Mapping mapping : dbMappings.values()) { if (!tblMappings.containsKey(mapping.getColumn())) { tblMappingsWithoutColumn.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumnWithoutHistory = new HashMap<>(); for (Mapping mapping : tblMappings.values()) { if (!tblMappingsWithoutColumn.containsKey(mapping.getColumn())) { tblMappingsWithoutColumnWithoutHistory.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumnWithoutHistoryWithHistory = new HashMap<>(); for (Mapping mapping : tblMappingsWithoutColumnWithoutHistory.values()) { if (!tblMappingsWithoutColumnWithoutHistory.containsKey(mapping.getColumn())) { tblMappingsWithoutColumnWithoutHistoryWithHistory.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistory = new HashMap<>(); for (Mapping mapping : tblMappingsWithoutColumnWithoutHistoryWithHistory.values()) { if (!tblMappingsWithoutColumnWithoutHistoryWithHistory.containsKey(mapping.getColumn())) { tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistory.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistoryWithHistory = new HashMap<>(); for (Mapping mapping : tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistory.values()) { if (!tblMappingsWithoutColumnWithoutHistoryWithHistory.containsKey(mapping.getColumn())) { tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistoryWithHistory.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistoryWith", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns mappings with fields that not exist in the input mappings. The input mappings should be history mapping from current index. Do not return _source config to avoid current index update conflict.\n */\n", "method_name": "diffStructure", "codes": ["public Mappings diffStructure(String tableName,Mappings mappings){ if (mappings == null) { return null; } if (mappings.getMappings().isEmpty()) { return null; } if (mappings.getMappings().size() == 1) { return mappings.getMappings().values().iterator().next(); } Map<String, Mapping> dbMappings = new HashMap<>(); for (Mapping mapping : mappings.getMappings().values()) { if (mapping.getTable().equals(tableName)) { dbMappings.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappings = new HashMap<>(); for (Mapping mapping : mappings.getMappings().values()) { if (mapping.getTable().equals(tableName)) { tblMappings.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumn = new HashMap<>(); for (Mapping mapping : dbMappings.values()) { if (!tblMappings.containsKey(mapping.getColumn())) { tblMappingsWithoutColumn.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumnWithoutHistory = new HashMap<>(); for (Mapping mapping : tblMappings.values()) { if (!tblMappingsWithoutColumn.containsKey(mapping.getColumn())) { tblMappingsWithoutColumnWithoutHistory.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumnWithoutHistoryWithHistory = new HashMap<>(); for (Mapping mapping : tblMappingsWithoutColumnWithoutHistory.values()) { if (!tblMappingsWithoutColumnWithoutHistory.containsKey(mapping.getColumn())) { tblMappingsWithoutColumnWithoutHistoryWithHistory.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistory = new HashMap<>(); for (Mapping mapping : tblMappingsWithoutColumnWithoutHistoryWithHistory.values()) { if (!tblMappingsWithoutColumnWithoutHistoryWithHistory.containsKey(mapping.getColumn())) { tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistory.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistoryWithHistory = new HashMap<>(); for (Mapping mapping : tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistory.values()) { if (!tblMappingsWithoutColumnWithoutHistoryWithHistory.containsKey(mapping.getColumn())) { tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistoryWithHistory.put(mapping.getColumn(), mapping); } } Map<String, Mapping> tblMappingsWithoutColumnWithoutHistoryWithHistoryWithHistoryWith"], "code_level": "plib_runnable", "_id": "636767de1a6d9265ec018706", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){ long timeBucketCompressed = timeBucket; if (dayStep == 1) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 2) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 3) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 4) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 5) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 6) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 7) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 8) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 9) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 10) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMAT", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n", "method_name": "compressTimeBucket", "codes": ["static long compressTimeBucket(long timeBucket,int dayStep){ long timeBucketCompressed = timeBucket; if (dayStep == 1) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 2) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 3) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 4) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 5) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 6) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 7) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 8) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 9) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get(); } else if (dayStep == 10) { timeBucketCompressed = timeBucketCompressed * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMATTER.get() * TIME_BUCKET_FORMAT"], "code_level": "project_runnable", "_id": "636767dc1a6d9265ec0186be", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (Field field : fields) {\n    if (!field.isRequired()) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n", "method_name": "containsAllFields", "codes": ["private boolean containsAllFields(Fields fields){ for (Field field : fields) { if (!field.isRequired()) { return false; } } return true; }"], "code_level": "slib_runnable", "_id": "636767dc1a6d9265ec0186c6", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  if (consumer == null) {\n    throw new IllegalArgumentException(\"consumer cannot be null\");\n  }\n  if (channels == null) {\n    throw new IllegalArgumentException(\"channels cannot be null\");\n  }\n  if (consumer.getTargets() == null) {\n    consumer.setTargets(new ArrayList<IConsumer>());\n  }\n  consumer.getTargets().add(consumer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a new target channels.\n */\n", "method_name": "addNewTarget", "codes": ["public void addNewTarget(Channels channels,IConsumer consumer){ if (consumer == null) { throw new IllegalArgumentException(\"consumer cannot be null\"); } if (channels == null) { throw new IllegalArgumentException(\"channels cannot be null\"); } if (consumer.getTargets() == null) { consumer.setTargets(new ArrayList<IConsumer>()); } consumer.getTargets().add(consumer); }"], "code_level": "plib_runnable", "_id": "636767dd1a6d9265ec0186e5", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void init() {\n  if (!directory.exists()) {\n    directory.mkdir();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * initialize config, such as check dist path\n */\n", "method_name": "init", "codes": ["public void init(){ if (!directory.exists()) { directory.mkdir(); } }"], "code_level": "slib_runnable", "_id": "636767dc1a6d9265ec0186cb", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> ranges = new ArrayList<>();\n  for (int i = 0; i < sequences.size(); i++) {\n    Sequence sequence = sequences.get(i);\n    if (sequence.getLowerBound() <= maxSequence && sequence.getUpperBound() >= minSequence) {\n      ranges.add(new SequenceRange(sequence.getLowerBound(), sequence.getUpperBound()));\n    }\n  }\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * build current profiles segment snapshot search sequence ranges\n */\n", "method_name": "buildSequenceRanges", "codes": ["public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> ranges = new ArrayList<>(); for (int i = 0; i < sequences.size(); i++) { Sequence sequence = sequences.get(i); if (sequence.getLowerBound() <= maxSequence && sequence.getUpperBound() >= minSequence) { ranges.add(new SequenceRange(sequence.getLowerBound(), sequence.getUpperBound())); } } return ranges; }"], "code_level": "class_runnable", "_id": "636767de1a6d9265ec018726", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<>();\n  BufferedReader reader = new BufferedReader(new FileReader(file));\n  String line;\n  while ((line = reader.readLine()) != null) {\n    String[] split = line.split(\"\\t\");\n    ProfileAnalyzeTimeRange timeRange = timeRanges.get(Integer.parseInt(split[0]));\n    if (timeRange == null) {\n      throw new IllegalArgumentException(\"Invalid time range: \" + split[0]);\n    }\n    threadSnapshots.add(new ThreadSnapshot(split[1], timeRange));\n  }\n  reader.close();\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * load thread snapshots in appointing time range\n */\n", "method_name": "parseFromFileWithTimeRange", "codes": ["public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { List<ThreadSnapshot> threadSnapshots = new ArrayList<>(); BufferedReader reader = new BufferedReader(new FileReader(file)); String line; while ((line = reader.readLine()) != null) { String[] split = line.split(\"\\t\"); ProfileAnalyzeTimeRange timeRange = timeRanges.get(Integer.parseInt(split[0])); if (timeRange == null) { throw new IllegalArgumentException(\"Invalid time range: \" + split[0]); } threadSnapshots.add(new ThreadSnapshot(split[1], timeRange)); } reader.close(); return threadSnapshots; }"], "code_level": "project_runnable", "_id": "636767e11a6d9265ec018790", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonObject = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    jsonObject.addProperty(property.getKey(), property.getValue());\n  }\n  return jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Convert process properties to source data\n */\n", "method_name": "convertProperties", "codes": ["private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair property : properties) { jsonObject.addProperty(property.getKey(), property.getValue()); } return jsonObject; }"], "code_level": "project_runnable", "_id": "636767e01a6d9265ec018764", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private int pop() {\n  int ret = m_stack[--m_stackTop];\n  m_stackTop = (m_stackTop + 1) % m_stack.length;\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n", "method_name": "pop", "codes": ["private int pop(){ int ret = m_stack[--m_stackTop]; m_stackTop = (m_stackTop + 1) % m_stack.length; return ret; }"], "code_level": "self_contained", "_id": "636766a91a6d9265ec0175c2", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if ((offset < 0) || (offset >= mFrames.length)) {\n    throw new IllegalArgumentException(\"offset out of range: offset=\" + offset);\n  }\n  if (numLocal < 0) {\n    throw new IllegalArgumentException(\"numLocal out of range: numLocal=\" + numLocal);\n  }\n  if (numStack < 0) {\n    throw new IllegalArgumentException(\"numStack out of range: numStack=\" + numStack);\n  }\n  if (numLocal > mFrames[offset].getNumStack()) {\n    throw new IllegalArgumentException(\"numLocal out of range: numLocal=\" + numLocal);\n  }\n  if (numStack > mFrames[offset].getNumLocals()) {\n    throw new IllegalArgumentException(\"numStack out of range: numStack=\" + numStack);\n  }\n  mFrames[offset].setNumLocals(numLocal);\n  mFrames[offset].setNumStack(numStack);\n  return 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.\n * @param offset   the bytecode offset of the instruction to which the frame corresponds.\n * @param numLocal the number of local variables in the frame.\n * @param numStack the number of stack elements in the frame.\n * @return the index of the next element to be written in this frame.\n */\n", "method_name": "visitFrameStart", "codes": ["int visitFrameStart(final int offset,final int numLocal,final int numStack){ if ((offset < 0) || (offset >= mFrames.length)) { throw new IllegalArgumentException(\"offset out of range: offset=\" + offset); } if (numLocal < 0) { throw new IllegalArgumentException(\"numLocal out of range: numLocal=\" + numLocal); } if (numStack < 0) { throw new IllegalArgumentException(\"numStack out of range: numStack=\" + numStack); } if (numLocal > mFrames[offset].getNumStack()) { throw new IllegalArgumentException(\"numLocal out of range: numLocal=\" + numLocal); } if (numStack > mFrames[offset].getNumLocals()) { throw new IllegalArgumentException(\"numStack out of range: numStack=\" + numStack); } mFrames[offset].setNumLocals(numLocal); mFrames[offset].setNumStack(numStack); return 3; }"], "code_level": "self_contained", "_id": "636766aa1a6d9265ec0175ce", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private void enlarge(final int size) {\n  final byte[] tmp = new byte[size];\n  System.arraycopy(data, 0, tmp, 0, size);\n  data = tmp;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n", "method_name": "enlarge", "codes": ["private void enlarge(final int size){ final byte[] tmp = new byte[size]; System.arraycopy(data, 0, tmp, 0, size); data = tmp; }"], "code_level": "self_contained", "_id": "636766a91a6d9265ec0175c1", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > byteArrayValue.length - byteOffset) {\n    throw new IllegalArgumentException(\"byteArrayValue.length > byteOffset\");\n  }\n  if (byteLength < 0) {\n    throw new IllegalArgumentException(\"byteLength < 0\");\n  }\n  if (byteOffset < 0) {\n    throw new IllegalArgumentException(\"byteOffset < 0\");\n  }\n  if (byteOffset + byteLength > byteArrayValue.length) {\n    throw new IllegalArgumentException(\"byteOffset + byteLength > byteArrayValue.length\");\n  }\n  if (this.byteArray == null) {\n    this.byteArray = new byte[byteLength];\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.byteArray, 0, byteLength);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n * @param byteLength     number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n", "method_name": "putByteArray", "codes": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > byteArrayValue.length - byteOffset) { throw new IllegalArgumentException(\"byteArrayValue.length > byteOffset\"); } if (byteLength < 0) { throw new IllegalArgumentException(\"byteLength < 0\"); } if (byteOffset < 0) { throw new IllegalArgumentException(\"byteOffset < 0\"); } if (byteOffset + byteLength > byteArrayValue.length) { throw new IllegalArgumentException(\"byteOffset + byteLength > byteArrayValue.length\"); } if (this.byteArray == null) { this.byteArray = new byte[byteLength]; } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, 0, byteLength); return this; }"], "code_level": "class_runnable", "_id": "636766a91a6d9265ec0175ae", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private void pop(final int elements) {\n  if (elements > 0) {\n    stack.pop();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n", "method_name": "pop", "codes": ["private void pop(final int elements){ if (elements > 0) { stack.pop(); } }"], "code_level": "self_contained", "_id": "636766a81a6d9265ec017586", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "public ByteVector putInt(final int intValue) {\n  if (this.length - this.pos < 4) {\n    resize(this.length << 1);\n  }\n  this.data[this.pos++] = (byte) (intValue >>> 24);\n  this.data[this.pos++] = (byte) (intValue >>> 16);\n  this.data[this.pos++] = (byte) (intValue >>> 8);\n  this.data[this.pos++] = (byte) intValue;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param intValue an int.\n * @return this byte vector.\n */\n", "method_name": "putInt", "codes": ["public ByteVector putInt(final int intValue){ if (this.length - this.pos < 4) { resize(this.length << 1); } this.data[this.pos++] = (byte) (intValue >>> 24); this.data[this.pos++] = (byte) (intValue >>> 16); this.data[this.pos++] = (byte) (intValue >>> 8); this.data[this.pos++] = (byte) intValue; return this; }"], "code_level": "class_runnable", "_id": "636766a81a6d9265ec017596", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.length() == 1) {\n    if (descriptor.charAt(0) == 'L') {\n      stack.pop();\n    } else {\n      stack.pop();\n      stack.pop();\n    }\n  } else {\n    stack.pop();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n", "method_name": "pop", "codes": ["private void pop(final String descriptor){ if (descriptor.length() == 1) { if (descriptor.charAt(0) == 'L') { stack.pop(); } else { stack.pop(); stack.pop(); } } else { stack.pop(); } }"], "code_level": "class_runnable", "_id": "636766a91a6d9265ec0175c4", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  if (length == data.length) {\n    final byte[] newData = new byte[Math.max(length << 1, data.length << 1)];\n    System.arraycopy(data, 0, newData, 0, length);\n    data = newData;\n  }\n  data[length++] = (byte) (byteValue1 << 4 | byteValue2);\n  return this;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n", "method_name": "put11", "codes": ["final ByteVector put11(final int byteValue1,final int byteValue2){ if (length == data.length) { final byte[] newData = new byte[Math.max(length << 1, data.length << 1)]; System.arraycopy(data, 0, newData, 0, length); data = newData; } data[length++] = (byte) (byteValue1 << 4 | byteValue2); return this; }"], "code_level": "class_runnable", "_id": "636766a81a6d9265ec017595", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return toString(JSONWriter.Feature.QuoteFieldNames, features);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Serialize to JSON  {@link String}\n * @param features features to be enabled in serialization\n * @return JSON {@link String}\n */\n", "method_name": "toString", "codes": ["@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return toString(JSONWriter.Feature.QuoteFieldNames, features); }"], "code_level": "self_contained", "_id": "636766a81a6d9265ec01757b", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int prime = 2;\n  while (true) {\n    if (isPrime(prime)) {\n      return prime;\n    }\n    prime++;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).\n * @param desiredCapacity the capacity desired by the user.\n * @return the capacity which should be used for a hashtable.\n */\n", "method_name": "nextPrime", "codes": ["public static int nextPrime(int desiredCapacity){ int prime = 2; while (true) { if (isPrime(prime)) { return prime; } prime++; } }"], "code_level": "slib_runnable", "_id": "636766a81a6d9265ec01758e", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else if (c >= 'a' && c <= 'f') {\n    return c - 'a' + 10;\n  } else if (c >= 'A' && c <= 'F') {\n    return c - 'A' + 10;\n  } else {\n    throw new IllegalArgumentException(\"Invalid digit value: \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()} but we don't accept non-ASCII digits.\n */\n", "method_name": "digitValue", "codes": ["private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } else if (c >= 'a' && c <= 'f') { return c - 'a' + 10; } else if (c >= 'A' && c <= 'F') { return c - 'A' + 10; } else { throw new IllegalArgumentException(\"Invalid digit value: \" + c); } }"], "code_level": "self_contained", "_id": "636767a61a6d9265ec0185b7", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Is this a hex digit?\n */\n", "method_name": "isHex", "codes": ["private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F'; }"], "code_level": "self_contained", "_id": "636767ab1a6d9265ec018676", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer == null) { throw new NullPointerException(\"buffer\"); } if (schema == null) { throw new NullPointerException(\"schema\"); } if (message == null) { throw new NullPointerException(\"message\"); } if (out == null) { throw new NullPointerException(\"out\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.capacity() < message.getSerializedSize()) { throw new IllegalArgumentException(\"buffer capacity is too small\"); } if (buffer.remaining() < schema.getSerializedSize()) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize()) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.\n * @return the size of the message\n */\n", "method_name": "writeDelimitedTo", "codes": ["public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer == null) { throw new NullPointerException(\"buffer\"); } if (schema == null) { throw new NullPointerException(\"schema\"); } if (message == null) { throw new NullPointerException(\"message\"); } if (out == null) { throw new NullPointerException(\"out\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.capacity() < message.getSerializedSize()) { throw new IllegalArgumentException(\"buffer capacity is too small\"); } if (buffer.remaining() < schema.getSerializedSize()) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize()) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\"buffer remaining is too small\"); } if (buffer.isDirect()) { throw new IllegalArgumentException(\"buffer is a direct buffer\"); } if (buffer.remaining() < schema.getSerializedSize() + message.getSerializedSize() + 4) { throw new IllegalArgumentException(\""], "code_level": "project_runnable", "_id": "636767a41a6d9265ec018582", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == null) {\n    return false;\n  }\n  if (len == 0) {\n    return true;\n  }\n  if (len > data.length) {\n    return false;\n  }\n  for (int i = 0; i < len; i++) {\n    if (data[offset + i] != this.data[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Returns true if the contents of the internal array and the provided array match.\n */\n", "method_name": "equals", "codes": ["public boolean equals(final byte[] data,int offset,final int len){ if (data == null) { return false; } if (len == 0) { return true; } if (len > data.length) { return false; } for (int i = 0; i < len; i++) { if (data[offset + i] != this.data[i]) { return false; } } return true; }"], "code_level": "class_runnable", "_id": "636767a51a6d9265ec01859d", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  if (str == null) {\n    return 0;\n  }\n  final int utfSize = computeUTF8Size(str.toString(), index, len);\n  return utfSize;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.\n */\n", "method_name": "computeUTF8Size", "codes": ["public static int computeUTF8Size(final CharSequence str,final int index,final int len){ if (str == null) { return 0; } final int utfSize = computeUTF8Size(str.toString(), index, len); return utfSize; }"], "code_level": "self_contained", "_id": "636767a41a6d9265ec01856c", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ if (str == null) { return lb; } final int len = str.length(); final int sz = lb.size(); final int sz2 = lb.size(); final int sz3 = lb.size(); final int sz4 = lb.size(); final int sz5 = lb.size(); final int sz6 = lb.size(); final int sz7 = lb.size(); final int sz8 = lb.size(); final int sz9 = lb.size(); final int sz10 = lb.size(); final int sz11 = lb.size(); final int sz12 = lb.size(); final int sz13 = lb.size(); final int sz14 = lb.size(); final int sz15 = lb.size(); final int sz16 = lb.size(); final int sz17 = lb.size(); final int sz18 = lb.size(); final int sz19 = lb.size(); final int sz20 = lb.size(); final int sz21 = lb.size(); final int sz22 = lb.size(); final int sz23 = lb.size(); final int sz24 = lb.size(); final int sz25 = lb.size(); final int sz26 = lb.size(); final int sz27 = lb.size(); final int sz28 = lb.size(); final int sz29 = lb.size(); final int sz30 = lb.size(); final int sz31 = lb.size(); final int sz32 = lb.size(); final int sz33 = lb.size(); final int sz34 = lb.size(); final int sz35 = lb.size(); final int sz36 = lb.size(); final int sz37 = lb.size(); final int sz38 = lb.size(); final int sz39 = lb.size(); final int sz40 = lb.size(); final int sz41 = lb.size(); final int sz42 = lb.size(); final int sz43 = lb.size(); final int sz44 = lb.size(); final int sz45 = lb.size(); final int sz46 = lb.size(); final int sz47 = lb.size(); final int sz48 = lb.size(); final int sz49 = lb.size(); final int sz50 = lb.size(); final int sz51 = lb.size(); final int sz52 = lb.size(); final int sz53 = lb.size(); final int sz54 = lb.size(); final int sz55 = lb.size(); final int sz56 = lb.size(); final int sz57 = lb.size(); final int sz58 = lb.size(); final int sz59 = lb.size(); final int sz60 = lb.size(); final int sz61 = lb.size(); final int sz62 = lb.size(); final int sz63 = lb.size(); final int sz64 = lb.size(); final int sz65 = lb.size(); final int sz66 = lb.size(); final int sz67 = lb.size", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Writes the utf8-encoded bytes from the string into the  {@link LinkedBuffer}.\n */\n", "method_name": "writeUTF8", "codes": ["public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ if (str == null) { return lb; } final int len = str.length(); final int sz = lb.size(); final int sz2 = lb.size(); final int sz3 = lb.size(); final int sz4 = lb.size(); final int sz5 = lb.size(); final int sz6 = lb.size(); final int sz7 = lb.size(); final int sz8 = lb.size(); final int sz9 = lb.size(); final int sz10 = lb.size(); final int sz11 = lb.size(); final int sz12 = lb.size(); final int sz13 = lb.size(); final int sz14 = lb.size(); final int sz15 = lb.size(); final int sz16 = lb.size(); final int sz17 = lb.size(); final int sz18 = lb.size(); final int sz19 = lb.size(); final int sz20 = lb.size(); final int sz21 = lb.size(); final int sz22 = lb.size(); final int sz23 = lb.size(); final int sz24 = lb.size(); final int sz25 = lb.size(); final int sz26 = lb.size(); final int sz27 = lb.size(); final int sz28 = lb.size(); final int sz29 = lb.size(); final int sz30 = lb.size(); final int sz31 = lb.size(); final int sz32 = lb.size(); final int sz33 = lb.size(); final int sz34 = lb.size(); final int sz35 = lb.size(); final int sz36 = lb.size(); final int sz37 = lb.size(); final int sz38 = lb.size(); final int sz39 = lb.size(); final int sz40 = lb.size(); final int sz41 = lb.size(); final int sz42 = lb.size(); final int sz43 = lb.size(); final int sz44 = lb.size(); final int sz45 = lb.size(); final int sz46 = lb.size(); final int sz47 = lb.size(); final int sz48 = lb.size(); final int sz49 = lb.size(); final int sz50 = lb.size(); final int sz51 = lb.size(); final int sz52 = lb.size(); final int sz53 = lb.size(); final int sz54 = lb.size(); final int sz55 = lb.size(); final int sz56 = lb.size(); final int sz57 = lb.size(); final int sz58 = lb.size(); final int sz59 = lb.size(); final int sz60 = lb.size(); final int sz61 = lb.size(); final int sz62 = lb.size(); final int sz63 = lb.size(); final int sz64 = lb.size(); final int sz65 = lb.size(); final int sz66 = lb.size(); final int sz67 = lb.size"], "code_level": "project_runnable", "_id": "636767ab1a6d9265ec01867b", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public long readRawVarint64() throws IOException {\n  long result = 0;\n  int shift = 0;\n  int byteCount = 0;\n  while (shift < 64) {\n    byte b = readByte();\n    result |= (long) (b & 0x7F) << shift;\n    if ((b & 0x80) == 0) {\n      return result;\n    }\n    shift += 7;\n  }\n  throw InvalidProtocolBufferException.truncatedMessage();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Read a raw Varint from the stream.\n */\n", "method_name": "readRawVarint64", "codes": ["public long readRawVarint64() throws IOException { long result = 0; int shift = 0; int byteCount = 0; while (shift < 64) { byte b = readByte(); result |= (long) (b & 0x7F) << shift; if ((b & 0x80) == 0) { return result; } shift += 7; } throw InvalidProtocolBufferException.truncatedMessage(); }"], "code_level": "class_runnable", "_id": "636767a41a6d9265ec018572", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  if (node == null) {\n    out.writeBoolean(false);\n    return 0;\n  }\n  out.writeBoolean(true);\n  out.writeInt(node.size());\n  for (int i = 0; i < node.size(); i++) {\n    out.writeInt(node.get(i));\n  }\n  return node.size();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Writes the contents of the  {@link LinkedBuffer} into the {@link DataOutput}.\n * @return the total content size of the buffer.\n */\n", "method_name": "writeTo", "codes": ["public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { if (node == null) { out.writeBoolean(false); return 0; } out.writeBoolean(true); out.writeInt(node.size()); for (int i = 0; i < node.size(); i++) { out.writeInt(node.get(i)); } return node.size(); }"], "code_level": "class_runnable", "_id": "636767aa1a6d9265ec01865a", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "@Override\npublic String readString() throws IOException {\n  int length = readInt();\n  if (length == 0) {\n    return \"\";\n  }\n  byte[] bytes = new byte[length];\n  readFully(bytes);\n  return new String(bytes, \"UTF-8\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Read a  {@code string} field value from the stream.\n */\n", "method_name": "readString", "codes": ["@Override public String readString() throws IOException { int length = readInt(); if (length == 0) { return \"\"; } byte[] bytes = new byte[length]; readFully(bytes); return new String(bytes, \"UTF-8\"); }"], "code_level": "project_runnable", "_id": "636767a31a6d9265ec018552", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public final byte[] toByteArray() {\n  byte[] arr = new byte[size];\n  System.arraycopy(buffer, 0, arr, 0, size);\n  return arr;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Returns a single byte array containg all the contents written to the buffer(s).\n */\n", "method_name": "toByteArray", "codes": ["public final byte[] toByteArray(){ byte[] arr = new byte[size]; System.arraycopy(buffer, 0, arr, 0, size); return arr; }"], "code_level": "project_runnable", "_id": "636767a21a6d9265ec018517", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "private static int compareSigned(long a, long b) {\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares the two specified  {@code long} values. The sign of the value returned is the same as that of{@code ((Long) a).compareTo(b)}. <p> <b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the equivalent {@link Long#compare} method instead.\n * @param a the first  {@code long} to compare\n * @param b the second  {@code long} to compare\n * @return a negative value if {@code a} is less than {@code b}; a positive value if  {@code a} is greater than{@code b}; or zero if they are equal\n */\n", "method_name": "compareSigned", "codes": ["private static int compareSigned(long a,long b){ if (a < b) return -1; if (a > b) return 1; return 0; }"], "code_level": "self_contained", "_id": "636767a41a6d9265ec01857e", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public byte[] toByteArray() {\n  byte[] ret = new byte[size()];\n  for (int i = 0; i < size(); i++) {\n    ret[i] = get(i);\n  }\n  return ret;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Copies bytes to a  {@code byte[]}.\n */\n", "method_name": "toByteArray", "codes": ["public byte[] toByteArray(){ byte[] ret = new byte[size()]; for (int i = 0; i < size(); i++) { ret[i] = get(i); } return ret; }"], "code_level": "self_contained", "_id": "636767aa1a6d9265ec01864a", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "private void checkIfPackedField() throws IOException {\n  if (!field.isPacked()) {\n    throw new IOException(\"Field \" + field.getName() + \" is not packed\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n", "method_name": "checkIfPackedField", "codes": ["private void checkIfPackedField() throws IOException { if (!field.isPacked()) { throw new IOException(\"Field \" + field.getName() + \" is not packed\"); } }"], "code_level": "class_runnable", "_id": "636767a31a6d9265ec01854f", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public int readTag() throws IOException {\n  int tag = readByte();\n  if (tag == 0) {\n    return 0;\n  } else {\n    return tag;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.\n */\n", "method_name": "readTag", "codes": ["public int readTag() throws IOException { int tag = readByte(); if (tag == 0) { return 0; } else { return tag; } }"], "code_level": "class_runnable", "_id": "636767a81a6d9265ec0185fc", "project_name": "protostuff-master"}]