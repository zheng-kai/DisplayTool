[{"generate_results": [{"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (map.containsKey(timestamp)) {\n    if (map.get(timestamp).equals(message)) {\n      map.remove(timestamp);\n      return false;\n    }\n  }\n  map.put(timestamp, message);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (map.containsKey(message)) {\n    if (map.get(message).intValue() >= timestamp) {\n      map.put(message, new Integer(map.get(message).intValue() + 1));\n      return true;\n    }\n  } else {\n    map.put(message, new Integer(timestamp));\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!map.containsKey(message)) {\n    map.put(message, timestamp);\n    return true;\n  }\n  if (map.get(message) > timestamp - 10) {\n    map.put(message, timestamp);\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!dict.containsKey(message)) {\n    dict.put(message, timestamp);\n    return true;\n  }\n  if (dict.get(message) > timestamp - 10) {\n    dict.put(message, timestamp);\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (timestamps.containsKey(message)) {\n    if (timestamps.get(message).compareTo(timestamp) >= 0) {\n      return false;\n    }\n  } else {\n    timestamps.put(message, timestamp);\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!dict.containsKey(message)) {\n    dict.put(message, timestamp);\n    return true;\n  }\n  if (dict.get(message) > timestamp - 10) {\n    dict.remove(message);\n    dict.put(message, timestamp);\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (dict.containsKey(message)) {\n    int previousTimestamp = dict.get(message);\n    if (timestamp - previousTimestamp > 10) {\n      dict.remove(message);\n      dict.put(message, timestamp);\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!dict.containsKey(timestamp)) {\n    dict.put(timestamp, message);\n    return true;\n  }\n  if (dict.get(timestamp).equals(message)) {\n    dict.remove(timestamp);\n    return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (dict.containsKey(message)) {\n    if (timestamp - dict.get(message) > 10) {\n      System.out.println(message);\n      dict.put(message, timestamp);\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    dict.put(message, timestamp);\n    return true;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean shouldPrintMessage(int timestamp, String message) {\n  if (!map.containsKey(timestamp)) {\n    map.put(timestamp, new ArrayList<>());\n  }\n  ArrayList<String> list = map.get(timestamp);\n  if (list.contains(message)) {\n    return false;\n  }\n  list.add(message);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. \n */\n", "method_name": "shouldPrintMessage", "codes": ["public boolean shouldPrintMessage(int timestamp,String message){ if (map.containsKey(timestamp)) { if (map.get(timestamp).equals(message)) { map.remove(timestamp); return false; } } map.put(timestamp, message); return true; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (map.containsKey(message)) { if (map.get(message).intValue() >= timestamp) { map.put(message, new Integer(map.get(message).intValue() + 1)); return true; } } else { map.put(message, new Integer(timestamp)); } return false; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!map.containsKey(message)) { map.put(message, timestamp); return true; } if (map.get(message) > timestamp - 10) { map.put(message, timestamp); return true; } return false; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!dict.containsKey(message)) { dict.put(message, timestamp); return true; } if (dict.get(message) > timestamp - 10) { dict.put(message, timestamp); return true; } return false; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (timestamps.containsKey(message)) { if (timestamps.get(message).compareTo(timestamp) >= 0) { return false; } } else { timestamps.put(message, timestamp); } return true; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!dict.containsKey(message)) { dict.put(message, timestamp); return true; } if (dict.get(message) > timestamp - 10) { dict.remove(message); dict.put(message, timestamp); return true; } return false; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (dict.containsKey(message)) { int previousTimestamp = dict.get(message); if (timestamp - previousTimestamp > 10) { dict.remove(message); dict.put(message, timestamp); return true; } } return false; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!dict.containsKey(timestamp)) { dict.put(timestamp, message); return true; } if (dict.get(timestamp).equals(message)) { dict.remove(timestamp); return true; } return false; }", "public boolean shouldPrintMessage(int timestamp,String message){ if (dict.containsKey(message)) { if (timestamp - dict.get(message) > 10) { System.out.println(message); dict.put(message, timestamp); return true; } else { return false; } } else { dict.put(message, timestamp); return true; } }", "public boolean shouldPrintMessage(int timestamp,String message){ if (!map.containsKey(timestamp)) { map.put(timestamp, new ArrayList<>()); } ArrayList<String> list = map.get(timestamp); if (list.contains(message)) { return false; } list.add(message); return true; }"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c73", "project_name": "interviews-master"}, {"generate_results": [{"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) return false;\n  int pos = map.get(val);\n  if (pos >= vals.size()) {\n    int last = vals.size() - 1;\n    vals.set(pos, last);\n    map.put(last, pos);\n  } else {\n    int last = vals.get(pos);\n    vals.set(pos, last);\n    map.put(last, pos);\n  }\n  map.remove(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val);\n  if (index < list.size() - 1) {\n    int last = list.get(list.size() - 1);\n    list.set(index, last);\n    map.put(last, index);\n  }\n  map.remove(val);\n  list.remove(list.size() - 1);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val).iterator().next();\n  map.get(val).remove(index);\n  if (map.get(val).size() == 0) {\n    map.remove(val);\n  }\n  int lastVal = map.get(val).iterator().next();\n  map.get(lastVal).remove(map.get(val).size() - 1);\n  map.get(lastVal).add(index);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val).iterator().next();\n  map.get(val).remove(index);\n  if (map.get(val).size() == 0) {\n    map.remove(val);\n  }\n  int lastVal = list.get(list.size() - 1);\n  list.set(index, lastVal);\n  map.get(lastVal).remove(list.size() - 1);\n  if (map.get(lastVal).size() == 0) {\n    map.remove(lastVal);\n  }\n  list.remove(list.size() - 1);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val);\n  int lastVal = values[index];\n  values[index] = lastVal;\n  map.put(lastVal, index);\n  map.remove(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) return false;\n  int index = map.get(val);\n  if (index < list.size() - 1) {\n    int lastVal = list.get(list.size() - 1);\n    list.set(index, lastVal);\n    map.put(lastVal, index);\n  }\n  map.remove(val);\n  list.remove(list.size() - 1);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) return false;\n  int index = map.get(val);\n  if (index < list.size() - 1) {\n    int lastVal = list.get(list.size() - 1);\n    list.set(index, lastVal);\n    map.put(lastVal, index);\n  }\n  map.remove(val);\n  list.remove(list.size() - 1);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!values.containsKey(val)) return false;\n  int index = values.get(val);\n  values.remove(val);\n  int last = vals.get(size - 1);\n  vals.set(index, last);\n  vals.remove(size - 1);\n  values.put(last, index);\n  size--;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) {\n    return false;\n  }\n  int index = map.get(val).iterator().next();\n  map.get(val).remove(index);\n  if (map.get(val).size() == 0) {\n    map.remove(val);\n  }\n  int lastVal = list.get(list.size() - 1).iterator().next();\n  list.get(lastVal).remove(list.size() - 1);\n  list.get(val).add(index);\n  if (list.get(val).size() == 0) {\n    list.remove(val);\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val) {\n  if (!map.containsKey(val)) return false;\n  int index = map.get(val);\n  if (index < size - 1) {\n    int lastValue = values[size - 1];\n    values[index] = lastValue;\n    map.put(lastValue, index);\n    map.remove(val);\n  }\n  size--;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes a value from the set. Returns true if the set contained the specified element. \n */\n", "method_name": "remove", "codes": ["public boolean remove(int val){ if (!map.containsKey(val)) return false; int pos = map.get(val); if (pos >= vals.size()) { int last = vals.size() - 1; vals.set(pos, last); map.put(last, pos); } else { int last = vals.get(pos); vals.set(pos, last); map.put(last, pos); } map.remove(val); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val); if (index < list.size() - 1) { int last = list.get(list.size() - 1); list.set(index, last); map.put(last, index); } map.remove(val); list.remove(list.size() - 1); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val).iterator().next(); map.get(val).remove(index); if (map.get(val).size() == 0) { map.remove(val); } int lastVal = map.get(val).iterator().next(); map.get(lastVal).remove(map.get(val).size() - 1); map.get(lastVal).add(index); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val).iterator().next(); map.get(val).remove(index); if (map.get(val).size() == 0) { map.remove(val); } int lastVal = list.get(list.size() - 1); list.set(index, lastVal); map.get(lastVal).remove(list.size() - 1); if (map.get(lastVal).size() == 0) { map.remove(lastVal); } list.remove(list.size() - 1); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val); int lastVal = values[index]; values[index] = lastVal; map.put(lastVal, index); map.remove(val); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) return false; int index = map.get(val); if (index < list.size() - 1) { int lastVal = list.get(list.size() - 1); list.set(index, lastVal); map.put(lastVal, index); } map.remove(val); list.remove(list.size() - 1); return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) return false; int index = map.get(val); if (index < list.size() - 1) { int lastVal = list.get(list.size() - 1); list.set(index, lastVal); map.put(lastVal, index); } map.remove(val); list.remove(list.size() - 1); return true; }", "public boolean remove(int val){ if (!values.containsKey(val)) return false; int index = values.get(val); values.remove(val); int last = vals.get(size - 1); vals.set(index, last); vals.remove(size - 1); values.put(last, index); size--; return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) { return false; } int index = map.get(val).iterator().next(); map.get(val).remove(index); if (map.get(val).size() == 0) { map.remove(val); } int lastVal = list.get(list.size() - 1).iterator().next(); list.get(lastVal).remove(list.size() - 1); list.get(val).add(index); if (list.get(val).size() == 0) { list.remove(val); } return true; }", "public boolean remove(int val){ if (!map.containsKey(val)) return false; int index = map.get(val); if (index < size - 1) { int lastValue = values[size - 1]; values[index] = lastValue; map.put(lastValue, index); map.remove(val); } size--; return true; }"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c74", "project_name": "interviews-master"}, {"generate_results": [{"generate_code": "public boolean insert(int val) {\n  if (!map.containsKey(val)) {\n    map.put(val, new LinkedList<Integer>());\n  }\n  map.get(val).add(list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) {\n    return false;\n  }\n  map.put(val, new Node(val));\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) {\n    return false;\n  }\n  map.put(val, new ArrayList<Integer>());\n  List<Integer> list = map.get(val);\n  list.add(list.size());\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) {\n    return false;\n  }\n  map.put(val, new ArrayList<>());\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) return false;\n  map.put(val, new LinkedList<>());\n  List<List<Integer>> list = map.get(val);\n  list.add(new LinkedList<>());\n  list.get(0).add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (!map.containsKey(val)) {\n    map.put(val, new ArrayList<>());\n  }\n  map.get(val).add(list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (!map.containsKey(val)) {\n    map.put(val, new ArrayList<Integer>());\n  }\n  map.get(val).add(list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (!map.containsKey(val)) {\n    map.put(val, new ArrayList<>());\n  }\n  map.get(val).add(list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (map.containsKey(val)) {\n    return false;\n  }\n  map.put(val, list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val) {\n  if (!map.containsKey(val)) {\n    map.put(val, new ArrayList<>());\n  }\n  map.get(val).add(list.size());\n  list.add(val);\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \n */\n", "method_name": "insert", "codes": ["public boolean insert(int val){ if (!map.containsKey(val)) { map.put(val, new LinkedList<Integer>()); } map.get(val).add(list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (map.containsKey(val)) { return false; } map.put(val, new Node(val)); return true; }", "public boolean insert(int val){ if (map.containsKey(val)) { return false; } map.put(val, new ArrayList<Integer>()); List<Integer> list = map.get(val); list.add(list.size()); return true; }", "public boolean insert(int val){ if (map.containsKey(val)) { return false; } map.put(val, new ArrayList<>()); return true; }", "public boolean insert(int val){ if (map.containsKey(val)) return false; map.put(val, new LinkedList<>()); List<List<Integer>> list = map.get(val); list.add(new LinkedList<>()); list.get(0).add(val); return true; }", "public boolean insert(int val){ if (!map.containsKey(val)) { map.put(val, new ArrayList<>()); } map.get(val).add(list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (!map.containsKey(val)) { map.put(val, new ArrayList<Integer>()); } map.get(val).add(list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (!map.containsKey(val)) { map.put(val, new ArrayList<>()); } map.get(val).add(list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (map.containsKey(val)) { return false; } map.put(val, list.size()); list.add(val); return true; }", "public boolean insert(int val){ if (!map.containsKey(val)) { map.put(val, new ArrayList<>()); } map.get(val).add(list.size()); list.add(val); return true; }"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c78", "project_name": "interviews-master"}, {"generate_results": [{"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  if (array1 == null) {\n    return array2 == null;\n  }\n  if (array2 == null) {\n    return false;\n  }\n  return array1.length == array2.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  if (array1 == null && array2 == null) {\n    return true;\n  }\n  if (array1 == null || array2 == null) {\n    return false;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return array1 == null && array2 == null || array1 != null && array1.length == array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  if (array1 == array2) {\n    return true;\n  }\n  if (array1 == null || array2 == null) {\n    return false;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  if (array1 == null || array2 == null) {\n    return false;\n  }\n  return array1.length == array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return array1.length == array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return array1 == array2 || (array1 != null && array2 != null && array1.length == array2.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return array1.length == array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  if (array1 == array2) {\n    return true;\n  }\n  if ((array1 == null) || (array2 == null)) {\n    return false;\n  }\n  return array1.length == array2.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n  return array1.length == array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n", "method_name": "isSameLength", "codes": ["public static boolean isSameLength(final byte[] array1,final byte[] array2){ if (array1 == null) { return array2 == null; } if (array2 == null) { return false; } return array1.length == array2.length; }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ if (array1 == null && array2 == null) { return true; } if (array1 == null || array2 == null) { return false; } if (array1.length != array2.length) { return false; } return true; }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return array1 == null && array2 == null || array1 != null && array1.length == array2.length; }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ if (array1 == array2) { return true; } if (array1 == null || array2 == null) { return false; } if (array1.length != array2.length) { return false; } return true; }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ if (array1 == null || array2 == null) { return false; } return array1.length == array2.length; }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return array1.length == array2.length; }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return array1 == array2 || (array1 != null && array2 != null && array1.length == array2.length); }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return array1.length == array2.length; }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ if (array1 == array2) { return true; } if ((array1 == null) || (array2 == null)) { return false; } return array1.length == array2.length; }", "public static boolean isSameLength(final byte[] array1,final byte[] array2){ return array1.length == array2.length; }"], "code_level": "self_contained", "_id": "6367670b1a6d9265ec017a00", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i];\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  } else if (array.length == 0) {\n    return null;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i];\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result = new boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].booleanValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Boolean</code> array, may be <code>null</code>\n * @return a <code>boolean</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } else if (array.length == 0) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i]; } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } else if (array.length == 0) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } else if (array.length == 0) { return null; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i]; } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }", "public static boolean[] toPrimitive(final Boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_BOOLEAN_ARRAY; } final boolean[] result = new boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].booleanValue(); } return result; }"], "code_level": "self_contained", "_id": "636767081a6d9265ec017989", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String toString(Object obj) {\n  return (obj == null ? \"\" : obj.toString());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj) {\n  if (obj == null) {\n    return \"\";\n  }\n  return obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj) {\n  if (obj == null) {\n    return \"\";\n  }\n  return obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj) {\n  if (obj == null) {\n    return \"\";\n  } else {\n    return obj.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj) {\n  if (obj == null) return \"\";\n  return obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj) {\n  if (obj == null) {\n    return \"\";\n  }\n  return obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj) {\n  if (obj == null) {\n    return \"\";\n  }\n  if (obj instanceof String) {\n    return (String) obj;\n  }\n  if (obj instanceof Integer) {\n    return ((Integer) obj).toString();\n  }\n  if (obj instanceof Long) {\n    return ((Long) obj).toString();\n  }\n  if (obj instanceof Double) {\n    return ((Double) obj).toString();\n  }\n  if (obj instanceof Float) {\n    return ((Float) obj).toString();\n  }\n  if (obj instanceof Boolean) {\n    return ((Boolean) obj).toString();\n  }\n  if (obj instanceof Date) {\n    return DateUtil.formatDate((Date) obj);\n  }\n  if (obj instanceof Character) {\n    return ((Character) obj).toString();\n  }\n  if (obj instanceof Character[]) {\n    char[] chars = ((Character[]) obj);\n    return new String(chars);\n  }\n  if (obj instanceof Collection) {\n    Collection<?> coll = (Collection<?>) obj;\n    List<String> list = new ArrayList<String>();\n    Iterator<?> it = coll.iterator();\n    while (it.hasNext()) {\n      Object o = it.next();\n      list.add(toString(o));\n    }\n    return StringUtil.join(list, \",\");\n  }\n  if (obj.getClass().isArray()) {\n    int length = Array.getLength(obj);\n    String[] array = new String[length];\n    for (int i = 0; i < length; i++) {\n      array[i] = toString(Array.get(obj, i));\n    }\n    return StringUtil.join(array, \",\");\n  }\n  return obj.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj) {\n  if (obj == null) {\n    return \"\";\n  }\n  return obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj) {\n  if (obj == null) {\n    return \"\";\n  } else {\n    return obj.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj) {\n  if (obj == null) {\n    return \"\";\n  }\n  return obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string (\"\") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = \"\" ObjectUtils.toString(\"\")           = \"\" ObjectUtils.toString(\"bat\")        = \"bat\" ObjectUtils.toString(Boolean.TRUE) = \"true\" </pre>\n * @see StringUtils#defaultString(String)\n * @see String#valueOf(Object)\n * @param obj  the Object to <code>toString</code>, may be null\n * @return the passed in Object's toString, or nullStr if <code>null</code> input\n * @since 2.0\n */\n", "method_name": "toString", "codes": ["public static String toString(Object obj){ return (obj == null ? \"\" : obj.toString()); }", "public static String toString(Object obj){ if (obj == null) { return \"\"; } return obj.toString(); }", "public static String toString(Object obj){ if (obj == null) { return \"\"; } return obj.toString(); }", "public static String toString(Object obj){ if (obj == null) { return \"\"; } else { return obj.toString(); } }", "public static String toString(Object obj){ if (obj == null) return \"\"; return obj.toString(); }", "public static String toString(Object obj){ if (obj == null) { return \"\"; } return obj.toString(); }", "public static String toString(Object obj){ if (obj == null) { return \"\"; } if (obj instanceof String) { return (String) obj; } if (obj instanceof Integer) { return ((Integer) obj).toString(); } if (obj instanceof Long) { return ((Long) obj).toString(); } if (obj instanceof Double) { return ((Double) obj).toString(); } if (obj instanceof Float) { return ((Float) obj).toString(); } if (obj instanceof Boolean) { return ((Boolean) obj).toString(); } if (obj instanceof Date) { return DateUtil.formatDate((Date) obj); } if (obj instanceof Character) { return ((Character) obj).toString(); } if (obj instanceof Character[]) { char[] chars = ((Character[]) obj); return new String(chars); } if (obj instanceof Collection) { Collection<?> coll = (Collection<?>) obj; List<String> list = new ArrayList<String>(); Iterator<?> it = coll.iterator(); while (it.hasNext()) { Object o = it.next(); list.add(toString(o)); } return StringUtil.join(list, \",\"); } if (obj.getClass().isArray()) { int length = Array.getLength(obj); String[] array = new String[length]; for (int i = 0; i < length; i++) { array[i] = toString(Array.get(obj, i)); } return StringUtil.join(array, \",\"); } return obj.toString(); }", "public static String toString(Object obj){ if (obj == null) { return \"\"; } return obj.toString(); }", "public static String toString(Object obj){ if (obj == null) { return \"\"; } else { return obj.toString(); } }", "public static String toString(Object obj){ if (obj == null) { return \"\"; } return obj.toString(); }"], "code_level": "self_contained", "_id": "636766f81a6d9265ec01775c", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  if (bool == null) return false;\n  else return bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  if (bool == null) {\n    return false;\n  } else {\n    return bool;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool != null ? bool.booleanValue() : false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  if (bool == null) {\n    return false;\n  }\n  return bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool) {\n  return bool == null ? false : bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>\n * @param bool  the boolean to convert\n * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>\n */\n", "method_name": "toBoolean", "codes": ["public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool; }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool; }", "public static boolean toBoolean(Boolean bool){ if (bool == null) return false; else return bool; }", "public static boolean toBoolean(Boolean bool){ if (bool == null) { return false; } else { return bool; } }", "public static boolean toBoolean(Boolean bool){ return bool != null ? bool.booleanValue() : false; }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }", "public static boolean toBoolean(Boolean bool){ if (bool == null) { return false; } return bool.booleanValue(); }", "public static boolean toBoolean(Boolean bool){ return bool == null ? false : bool.booleanValue(); }"], "code_level": "self_contained", "_id": "636766f91a6d9265ec01777f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BYTE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }", "public static Byte[] nullToEmpty(final Byte[] array){ if (isEmpty(array)) { return EMPTY_BYTE_OBJECT_ARRAY; } return array; }"], "code_level": "self_contained", "_id": "6367670b1a6d9265ec0179ff", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }", "public static Boolean[] nullToEmpty(final Boolean[] array){ if (isEmpty(array)) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } return array; }"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179e8", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result = new byte[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].byteValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Byte</code> array, may be <code>null</code>\n * @return a <code>byte</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }", "public static byte[] toPrimitive(final Byte[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BYTE_ARRAY; } final byte[] result = new byte[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].byteValue(); } return result; }"], "code_level": "self_contained", "_id": "636767031a6d9265ec0178e6", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String reverse(final String str) {\n  StringBuilder sb = new StringBuilder();\n  for (int i = str.length() - 1; i >= 0; i--) {\n    sb.append(str.charAt(i));\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  final int len = str.length();\n  if (len <= 1) {\n    return str;\n  }\n  return reverse(str.substring(1)) + str.charAt(0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str.isEmpty()) {\n    return str;\n  }\n  return reverse(str.substring(1)) + str.charAt(0);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str) {\n  final char[] chars = str.toCharArray();\n  final int left = 0;\n  final int right = chars.length - 1;\n  while (left < right) {\n    char temp = chars[left];\n    chars[left] = chars[right];\n    chars[right] = temp;\n    left++;\n    right--;\n  }\n  return new String(chars);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String reverse(final String str) {\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str) {\n  final StringBuilder sb = new StringBuilder();\n  for (int i = str.length() - 1; i >= 0; i--) {\n    sb.append(str.charAt(i));\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str) {\n  String reversed = \"\";\n  for (int i = str.length() - 1; i >= 0; i--) {\n    reversed += str.charAt(i);\n  }\n  return reversed;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  if (str == null || str.length() <= 1) {\n    return str;\n  }\n  return reverse(str.substring(1)) + str.charAt(0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str) {\n  String result = \"\";\n  for (int i = str.length() - 1; i >= 0; i--) {\n    result = result + str.charAt(i);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Reverses a String as per  {@link StringBuilder#reverse()}.</p> <p>A <code>null</code> String returns <code>null</code>.</p> <pre> StringUtils.reverse(null)  = null StringUtils.reverse(\"\")    = \"\" StringUtils.reverse(\"bat\") = \"tab\" </pre>\n * @param str  the String to reverse, may be null\n * @return the reversed String, <code>null</code> if null String input\n */\n", "method_name": "reverse", "codes": ["public static String reverse(final String str){ StringBuilder sb = new StringBuilder(); for (int i = str.length() - 1; i >= 0; i--) { sb.append(str.charAt(i)); } return sb.toString(); }", "public static String reverse(final String str){ if (str == null) { return null; } final int len = str.length(); if (len <= 1) { return str; } return reverse(str.substring(1)) + str.charAt(0); }", "public static String reverse(final String str){ if (str.isEmpty()) { return str; } return reverse(str.substring(1)) + str.charAt(0); }", "public static String reverse(final String str){ final char[] chars = str.toCharArray(); final int left = 0; final int right = chars.length - 1; while (left < right) { char temp = chars[left]; chars[left] = chars[right]; chars[right] = temp; left++; right--; } return new String(chars); }", "public static String reverse(final String str){ return new StringBuilder(str).reverse().toString(); }", "public static String reverse(final String str){ final StringBuilder sb = new StringBuilder(); for (int i = str.length() - 1; i >= 0; i--) { sb.append(str.charAt(i)); } return sb.toString(); }", "public static String reverse(final String str){ String reversed = \"\"; for (int i = str.length() - 1; i >= 0; i--) { reversed += str.charAt(i); } return reversed; }", "public static String reverse(final String str){ if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }", "public static String reverse(final String str){ if (str == null || str.length() <= 1) { return str; } return reverse(str.substring(1)) + str.charAt(0); }", "public static String reverse(final String str){ String result = \"\"; for (int i = str.length() - 1; i >= 0; i--) { result = result + str.charAt(i); } return result; }"], "code_level": "slib_runnable", "_id": "636767001a6d9265ec017873", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isDigits(String str) {\n  return str.matches(\"[0-9]+\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  return str.matches(\"[0-9]+\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  for (int i = 0; i < str.length(); i++) {\n    char c = str.charAt(i);\n    if (!Character.isDigit(c)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  if (str == null) return false;\n  return str.matches(\"[0-9]+\");\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isDigits(String str) {\n  return str.matches(\"^[0-9]*\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  for (int i = 0; i < str.length(); i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  try {\n    Integer.parseInt(str);\n  } catch (NumberFormatException e) {\n    return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isDigits(String str) {\n  char[] charArray = str.toCharArray();\n  for (char c : charArray) {\n    if (!Character.isDigit(c)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  if (str == null) {\n    return false;\n  }\n  for (int i = 0; i < str.length(); i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str) {\n  char[] chars = str.toCharArray();\n  for (char c : chars) {\n    if (!Character.isDigit(c)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the <code>String</code> contains only digit characters.</p> <p><code>Null</code> and empty String will return <code>false</code>.</p>\n * @param str  the <code>String</code> to check\n * @return <code>true</code> if str contains only unicode numeric\n */\n", "method_name": "isDigits", "codes": ["public static boolean isDigits(String str){ return str.matches(\"[0-9]+\"); }", "public static boolean isDigits(String str){ return str.matches(\"[0-9]+\"); }", "public static boolean isDigits(String str){ for (int i = 0; i < str.length(); i++) { char c = str.charAt(i); if (!Character.isDigit(c)) { return false; } } return true; }", "public static boolean isDigits(String str){ if (str == null) return false; return str.matches(\"[0-9]+\"); }", "public static boolean isDigits(String str){ return str.matches(\"^[0-9]*\"); }", "public static boolean isDigits(String str){ for (int i = 0; i < str.length(); i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }", "public static boolean isDigits(String str){ try { Integer.parseInt(str); } catch (NumberFormatException e) { return false; } return true; }", "public static boolean isDigits(String str){ char[] charArray = str.toCharArray(); for (char c : charArray) { if (!Character.isDigit(c)) { return false; } } return true; }", "public static boolean isDigits(String str){ if (str == null) { return false; } for (int i = 0; i < str.length(); i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }", "public static boolean isDigits(String str){ char[] chars = str.toCharArray(); for (char c : chars) { if (!Character.isDigit(c)) { return false; } } return true; }"], "code_level": "slib_runnable", "_id": "636766ff1a6d9265ec01784b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(\n      ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  final int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(\n      ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  final int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return (str == null && suffix == null);\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str.length() > suffix.length()) {\n    return false;\n  } else {\n    int strOffset = str.length() - suffix.length();\n    if (ignoreCase) {\n      for (int i = strOffset; i < str.length(); i++) {\n        if (str.charAt(i) != suffix.charAt(i)) {\n          return false;\n        }\n      }\n    } else {\n      for (int i = strOffset; i < str.length(); i++) {\n        if (str.charAt(i) != suffix.charAt(i)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(\n      ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return str == null && suffix == null;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n  if (str == null || suffix == null) {\n    return false;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  final int strOffset = str.length() - suffix.length();\n  return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n", "method_name": "endsWith", "codes": ["private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (suffix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (suffix.length() > str.length()) { return false; } final int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (suffix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (suffix.length() > str.length()) { return false; } final int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return (str == null && suffix == null); } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str.length() > suffix.length()) { return false; } else { int strOffset = str.length() - suffix.length(); if (ignoreCase) { for (int i = strOffset; i < str.length(); i++) { if (str.charAt(i) != suffix.charAt(i)) { return false; } } } else { for (int i = strOffset; i < str.length(); i++) { if (str.charAt(i) != suffix.charAt(i)) { return false; } } } return true; } }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (suffix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, str.length() - suffix.length(), suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){ if (str == null || suffix == null) { return false; } if (suffix.length() > str.length()) { return false; } final int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"], "code_level": "self_contained", "_id": "6367670c1a6d9265ec017a35", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (array == null) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (array == null) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (array == null || array.length == 0) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (array == null) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (array == null) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Character[] nullToEmpty(final Character[] array){ if (array == null) { return EMPTY_CHARACTER_OBJECT_ARRAY; } else { return array; } }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (array == null) { return EMPTY_CHARACTER_OBJECT_ARRAY; } else { return array; } }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (array == null || array.length == 0) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (array == null) { return EMPTY_CHARACTER_OBJECT_ARRAY; } else { return array; } }", "public static Character[] nullToEmpty(final Character[] array){ if (array == null) { return EMPTY_CHARACTER_OBJECT_ARRAY; } else { return array; } }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Character[] nullToEmpty(final Character[] array){ if (isEmpty(array)) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }"], "code_level": "self_contained", "_id": "636766f11a6d9265ec017651", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (array == null) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (array == null) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (array == null || array.length == 0) {\n    return EMPTY_CHARACTER_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (array == null) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (array == null) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (array == null) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (array == null) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  System.arraycopy(array, 0, result, 0, array.length);\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (array == null) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array) {\n  if (array == null) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  } else {\n    return array;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Double[] nullToEmpty(final Double[] array){ if (array == null) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else { return array; } }", "public static Double[] nullToEmpty(final Double[] array){ if (array == null) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else { return array; } }", "public static Double[] nullToEmpty(final Double[] array){ if (array == null || array.length == 0) { return EMPTY_CHARACTER_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (array == null) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else { return array; } }", "public static Double[] nullToEmpty(final Double[] array){ if (isEmpty(array)) { return EMPTY_DOUBLE_OBJECT_ARRAY; } return array; }", "public static Double[] nullToEmpty(final Double[] array){ if (array == null) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else { return array; } }", "public static Double[] nullToEmpty(final Double[] array){ if (array == null) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else { return array; } }", "public static Double[] nullToEmpty(final Double[] array){ if (array == null) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; System.arraycopy(array, 0, result, 0, array.length); return result; }", "public static Double[] nullToEmpty(final Double[] array){ if (array == null) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else { return array; } }", "public static Double[] nullToEmpty(final Double[] array){ if (array == null) { return EMPTY_DOUBLE_OBJECT_ARRAY; } else { return array; } }"], "code_level": "self_contained", "_id": "636767021a6d9265ec0178bb", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return (array == null || array.length == 0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array) {\n  return array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n * @param array  the array to test\n * @return <code>true</code> if the array is empty or <code>null</code>\n * @since 2.1\n */\n", "method_name": "isEmpty", "codes": ["public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return (array == null || array.length == 0); }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }", "public static boolean isEmpty(final double[] array){ return array == null || array.length == 0; }"], "code_level": "self_contained", "_id": "636766f01a6d9265ec01762e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return bool != null && !bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return bool != null && !bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool) {\n  return !bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>\n * @param bool  the boolean to check, null returns <code>true</code>\n * @return <code>true</code> if the input is null or false\n * @since 2.3\n */\n", "method_name": "isNotTrue", "codes": ["public static boolean isNotTrue(Boolean bool){ return !bool; }", "public static boolean isNotTrue(Boolean bool){ return !bool; }", "public static boolean isNotTrue(Boolean bool){ return !bool; }", "public static boolean isNotTrue(Boolean bool){ return !bool.booleanValue(); }", "public static boolean isNotTrue(Boolean bool){ return bool != null && !bool.booleanValue(); }", "public static boolean isNotTrue(Boolean bool){ return !bool; }", "public static boolean isNotTrue(Boolean bool){ return !bool; }", "public static boolean isNotTrue(Boolean bool){ return !bool; }", "public static boolean isNotTrue(Boolean bool){ return bool != null && !bool; }", "public static boolean isNotTrue(Boolean bool){ return !bool; }"], "code_level": "self_contained", "_id": "636766f21a6d9265ec017677", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result = new double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].doubleValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Doubles to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Double</code> array, may be <code>null</code>\n * @return a <code>double</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }", "public static double[] toPrimitive(final Double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_ARRAY; } final double[] result = new double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].doubleValue(); } return result; }"], "code_level": "self_contained", "_id": "636766ff1a6d9265ec017842", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  return (ch == null ? defaultValue : ch.charValue());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  return (ch == null ? defaultValue : ch.charValue());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch, final char defaultValue) {\n  if (ch == null) {\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the Character to a char handling <code>null</code>.</p> <pre> CharUtils.toChar(null, 'X') = 'X' CharUtils.toChar(' ', 'X')  = ' ' CharUtils.toChar('A', 'X')  = 'A' </pre>\n * @param ch  the character to convert\n * @param defaultValue  the value to use if the  Character is null\n * @return the char value of the Character or the default if null\n */\n", "method_name": "toChar", "codes": ["public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ return (ch == null ? defaultValue : ch.charValue()); }", "public static char toChar(final Character ch,final char defaultValue){ return (ch == null ? defaultValue : ch.charValue()); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }", "public static char toChar(final Character ch,final char defaultValue){ if (ch == null) { return defaultValue; } return ch.charValue(); }"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179cf", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean isAllZeros(String s) {\n  boolean flag = true;\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  boolean result = true;\n  for (char c : s.toCharArray()) {\n    if (c != '0') {\n      result = false;\n      break;\n    }\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') return false;\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  for (char c : s.toCharArray()) {\n    if (c != '0') {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  if (s.length() == 0) {\n    return true;\n  }\n  if (s.charAt(0) == '0') {\n    return false;\n  }\n  for (int i = 1; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s) {\n  boolean result = true;\n  for (int i = 0; i < s.length(); i++) {\n    if (s.charAt(i) != '0') {\n      result = false;\n    }\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Utility method for  {@link #createNumber(String)}.</p> <p>Returns <code>true</code> if s is <code>null</code>.</p>\n * @param s the String to check\n * @return if it is all zeros or <code>null</code>\n */\n", "method_name": "isAllZeros", "codes": ["private static boolean isAllZeros(String s){ boolean flag = true; for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') { flag = false; break; } } return flag; }", "private static boolean isAllZeros(String s){ for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') { return false; } } return true; }", "private static boolean isAllZeros(String s){ for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') { return false; } } return true; }", "private static boolean isAllZeros(String s){ for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') { return false; } } return true; }", "private static boolean isAllZeros(String s){ for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') { return false; } } return true; }", "private static boolean isAllZeros(String s){ boolean result = true; for (char c : s.toCharArray()) { if (c != '0') { result = false; break; } } return result; }", "private static boolean isAllZeros(String s){ for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') return false; } return true; }", "private static boolean isAllZeros(String s){ for (char c : s.toCharArray()) { if (c != '0') { return false; } } return true; }", "private static boolean isAllZeros(String s){ if (s.length() == 0) { return true; } if (s.charAt(0) == '0') { return false; } for (int i = 1; i < s.length(); i++) { if (s.charAt(i) != '0') { return false; } } return true; }", "private static boolean isAllZeros(String s){ boolean result = true; for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != '0') { result = false; } } return result; }"], "code_level": "self_contained", "_id": "636767081a6d9265ec0179a2", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  return object != null ? object.toString() : null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  }\n  return object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  }\n  return object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object) {\n  if (object == null) {\n    return null;\n  } else if (object instanceof String) {\n    return (String) object;\n  } else if (object instanceof Object[]) {\n    return toString((Object[]) object);\n  } else if (object instanceof boolean[]) {\n    return toString((boolean[]) object);\n  } else if (object instanceof byte[]) {\n    return toString((byte[]) object);\n  } else if (object instanceof char[]) {\n    return toString((char[]) object);\n  } else if (object instanceof double[]) {\n    return toString((double[]) object);\n  } else if (object instanceof float[]) {\n    return toString((float[]) object);\n  } else if (object instanceof int[]) {\n    return toString((int[]) object);\n  } else if (object instanceof long[]) {\n    return toString((long[]) object);\n  } else if (object instanceof short[]) {\n    return toString((short[]) object);\n  } else {\n    return object.toString();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Object to String ,when null object then null else return toString(); \n */\n", "method_name": "toString", "codes": ["public static String toString(Object object){ if (object == null) { return null; } else { return object.toString(); } }", "public static String toString(Object object){ if (object == null) { return null; } else { return object.toString(); } }", "public static String toString(Object object){ return object != null ? object.toString() : null; }", "public static String toString(Object object){ if (object == null) { return null; } else { return object.toString(); } }", "public static String toString(Object object){ if (object == null) { return null; } else { return object.toString(); } }", "public static String toString(Object object){ if (object == null) { return null; } else { return object.toString(); } }", "public static String toString(Object object){ if (object == null) { return null; } return object.toString(); }", "public static String toString(Object object){ if (object == null) { return null; } return object.toString(); }", "public static String toString(Object object){ if (object == null) { return null; } else { return object.toString(); } }", "public static String toString(Object object){ if (object == null) { return null; } else if (object instanceof String) { return (String) object; } else if (object instanceof Object[]) { return toString((Object[]) object); } else if (object instanceof boolean[]) { return toString((boolean[]) object); } else if (object instanceof byte[]) { return toString((byte[]) object); } else if (object instanceof char[]) { return toString((char[]) object); } else if (object instanceof double[]) { return toString((double[]) object); } else if (object instanceof float[]) { return toString((float[]) object); } else if (object instanceof int[]) { return toString((int[]) object); } else if (object instanceof long[]) { return toString((long[]) object); } else if (object instanceof short[]) { return toString((short[]) object); } else { return object.toString(); } }"], "code_level": "self_contained", "_id": "636766f21a6d9265ec01767d", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  } else {\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; ++i) {\n      result[i] = array[i].intValue();\n    }\n    return result;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] primitiveArray = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    primitiveArray[i] = array[i].intValue();\n  }\n  return primitiveArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result = new int[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].intValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Integers to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Integer</code> array, may be <code>null</code>\n * @return an <code>int</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } else { final int[] result = new int[array.length]; for (int i = 0; i < array.length; ++i) { result[i] = array[i].intValue(); } return result; } }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } final int[] primitiveArray = new int[array.length]; for (int i = 0; i < array.length; i++) { primitiveArray[i] = array[i].intValue(); } return primitiveArray; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return ArrayUtils.EMPTY_INT_ARRAY; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }", "public static int[] toPrimitive(final Integer[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_INT_ARRAY; } final int[] result = new int[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].intValue(); } return result; }"], "code_level": "self_contained", "_id": "6367670c1a6d9265ec017a2a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return ch >= ' ' && ch <= '~' && ch != ' ' && ch != '\\t' && ch != '\\n' && ch != '\\r';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') || (ch >= 'a' && ch <= 'f');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= 0x80 && ch <= 0x9F) || (ch >= 0xC0 && ch <= 0xDF);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return ch == '\\u0007'\n      || ch == '\\u0008'\n      || ch == '\\u0009'\n      || ch == '\\u000c'\n      || ch == '\\u0010'\n      || ch == '\\u0011'\n      || ch == '\\u0012'\n      || ch == '\\u0013'\n      || ch == '\\u0014'\n      || ch == '\\u0015'\n      || ch == '\\u0016'\n      || ch == '\\u0017'\n      || ch == '\\u0018'\n      || ch == '\\u0019'\n      || ch == '\\u001a'\n      || ch == '\\u001b'\n      || ch == '\\u001c'\n      || ch == '\\u001d'\n      || ch == '\\u001e'\n      || ch == '\\u001f';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= '0' && ch <= '7');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return ch >= 'A' && ch <= 'Z';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= 'A' && ch <= 'Z')\n      || (ch >= 'a' && ch <= 'z')\n      || (ch >= '0' && ch <= '9')\n      || (ch == '+')\n      || (ch == '/')\n      || (ch == '=')\n      || (ch == '_')\n      || (ch == '~');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return ch >= 'a' && ch <= 'z'\n      || ch >= 'A' && ch <= 'Z'\n      || ch >= '0' && ch <= '9'\n      || ch == '+'\n      || ch == '-'\n      || ch == '.';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiControl(final char ch) {\n  return (ch >= 0x0001) && (ch <= 0x007F);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit control.</p> <pre> CharUtils.isAsciiControl('a')  = false CharUtils.isAsciiControl('A')  = false CharUtils.isAsciiControl('3')  = false CharUtils.isAsciiControl('-')  = false CharUtils.isAsciiControl('\\n') = true CharUtils.isAsciiControl('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if less than 32 or equals 127\n */\n", "method_name": "isAsciiControl", "codes": ["public static boolean isAsciiControl(final char ch){ return ch >= ' ' && ch <= '~' && ch != ' ' && ch != '\\t' && ch != '\\n' && ch != '\\r'; }", "public static boolean isAsciiControl(final char ch){ return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') || (ch >= 'a' && ch <= 'f'); }", "public static boolean isAsciiControl(final char ch){ return (ch >= 0x80 && ch <= 0x9F) || (ch >= 0xC0 && ch <= 0xDF); }", "public static boolean isAsciiControl(final char ch){ return ch == '\\u0007' || ch == '\\u0008' || ch == '\\u0009' || ch == '\\u000c' || ch == '\\u0010' || ch == '\\u0011' || ch == '\\u0012' || ch == '\\u0013' || ch == '\\u0014' || ch == '\\u0015' || ch == '\\u0016' || ch == '\\u0017' || ch == '\\u0018' || ch == '\\u0019' || ch == '\\u001a' || ch == '\\u001b' || ch == '\\u001c' || ch == '\\u001d' || ch == '\\u001e' || ch == '\\u001f'; }", "public static boolean isAsciiControl(final char ch){ return (ch >= '0' && ch <= '7'); }", "public static boolean isAsciiControl(final char ch){ return ch >= 'A' && ch <= 'Z'; }", "public static boolean isAsciiControl(final char ch){ return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9') || (ch == '+') || (ch == '/') || (ch == '=') || (ch == '_') || (ch == '~'); }", "public static boolean isAsciiControl(final char ch){ return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); }", "public static boolean isAsciiControl(final char ch){ return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch == '+' || ch == '-' || ch == '.'; }", "public static boolean isAsciiControl(final char ch){ return (ch >= 0x0001) && (ch <= 0x007F); }"], "code_level": "self_contained", "_id": "636766fa1a6d9265ec01779d", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Boolean.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; ++i) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Boolean.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result = new Boolean[array.length];\n  for (int i = 0; i < array.length; ++i) {\n    result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive booleans to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>boolean</code> array\n * @return a <code>Boolean</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Boolean.valueOf(array[i]); } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; ++i) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Boolean.valueOf(array[i]); } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }", "public static Boolean[] toObject(final boolean[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_BOOLEAN_OBJECT_ARRAY; } final Boolean[] result = new Boolean[array.length]; for (int i = 0; i < array.length; ++i) { result[i] = array[i] ? Boolean.TRUE : Boolean.FALSE; } return result; }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec017796", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; ++i) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result = new Short[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Short.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive shorts to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>short</code> array\n * @return a <code>Short</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; ++i) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }", "public static Short[] toObject(final short[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_SHORT_OBJECT_ARRAY; } final Short[] result = new Short[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Short.valueOf(array[i]); } return result; }"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179f1", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; ++i) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return ArrayUtils.EMPTY_CHAR_ARRAY;\n  }\n  final char[] result = new char[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = array[i].charValue();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Characters to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Character</code> array, may be <code>null</code>\n * @return a <code>char</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; ++i) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }", "public static char[] toPrimitive(final Character[] array){ if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CHAR_ARRAY; } final char[] result = new char[array.length]; for (int i = 0; i < array.length; i++) { result[i] = array[i].charValue(); } return result; }"], "code_level": "self_contained", "_id": "636766fe1a6d9265ec017838", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Integer[] toObject(final int[] array) {\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Integer(array[i]);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Integer(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = new Integer(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return new Integer[0];\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return new Integer[0];\n  }\n  final Integer[] result = new Integer[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Integer.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive ints to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  an <code>int</code> array\n * @return an <code>Integer</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Integer[] toObject(final int[] array){ final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Integer(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Integer(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = new Integer(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return new Integer[0]; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_INTEGER_OBJECT_ARRAY; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }", "public static Integer[] toObject(final int[] array){ if (array == null) { return null; } else if (array.length == 0) { return new Integer[0]; } final Integer[] result = new Integer[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Integer.valueOf(array[i]); } return result; }"], "code_level": "class_runnable", "_id": "636767041a6d9265ec01790f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result = new Double[array.length];\n  for (int i = 0; i < array.length; i++) {\n    result[i] = Double.valueOf(array[i]);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive doubles to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>double</code> array\n * @return a <code>Double</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }", "public static Double[] toObject(final double[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_DOUBLE_OBJECT_ARRAY; } final Double[] result = new Double[array.length]; for (int i = 0; i < array.length; i++) { result[i] = Double.valueOf(array[i]); } return result; }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec0177a4", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  return startsWith(str, prefix, ignoreCase, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null) {\n    return false;\n  }\n  if (prefix == null) {\n    return true;\n  }\n  if (str.startsWith(prefix)) {\n    return true;\n  }\n  if (!ignoreCase) {\n    return str.regionMatches(true, 0, prefix, 0, prefix.length());\n  }\n  return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  return startsWith(str, prefix, ignoreCase, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  return startsWith(str, prefix, ignoreCase, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  return startsWith(str, prefix, ignoreCase, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (ignoreCase) {\n    return str.toLowerCase().startsWith(prefix.toLowerCase());\n  }\n  return str.startsWith(prefix);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.startsWith(prefix)) {\n    return true;\n  }\n  if (!ignoreCase) {\n    return str.toLowerCase().startsWith(prefix.toLowerCase());\n  } else {\n    return str.toLowerCase().startsWith(prefix.toLowerCase().toUpperCase());\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(\n    final String str, final String prefix, final boolean ignoreCase) {\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.isEmpty()) {\n    return true;\n  }\n  if (str.startsWith(prefix)) {\n    return true;\n  }\n  if (ignoreCase) {\n    return str.toLowerCase().startsWith(prefix.toLowerCase());\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n", "method_name": "startsWith", "codes": ["private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return false; } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ return startsWith(str, prefix, ignoreCase, false); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null) { return false; } if (prefix == null) { return true; } if (str.startsWith(prefix)) { return true; } if (!ignoreCase) { return str.regionMatches(true, 0, prefix, 0, prefix.length()); } return false; }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ return startsWith(str, prefix, ignoreCase, false); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ return startsWith(str, prefix, ignoreCase, false); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return str == null && prefix == null; } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ return startsWith(str, prefix, ignoreCase, false); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return str == null && prefix == null; } if (ignoreCase) { return str.toLowerCase().startsWith(prefix.toLowerCase()); } return str.startsWith(prefix); }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return false; } if (str.startsWith(prefix)) { return true; } if (!ignoreCase) { return str.toLowerCase().startsWith(prefix.toLowerCase()); } else { return str.toLowerCase().startsWith(prefix.toLowerCase().toUpperCase()); } }", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){ if (str == null || prefix == null) { return str == null && prefix == null; } if (prefix.isEmpty()) { return true; } if (str.startsWith(prefix)) { return true; } if (ignoreCase) { return str.toLowerCase().startsWith(prefix.toLowerCase()); } return false; }"], "code_level": "self_contained", "_id": "636767151a6d9265ec017b6b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (ch >= 'a' && ch <= 'z') {\n    return (char) (ch - 'a' + 'A');\n  } else if (ch >= 'A' && ch <= 'Z') {\n    return (char) (ch - 'A' + 'a');\n  } else {\n    return ch;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (ch >= 'a' && ch <= 'z') return (char) (ch - 'a' + 'A');\n  if (ch >= 'A' && ch <= 'Z') return (char) (ch - 'A' + 'a');\n  return Character.valueOf(ch);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  switch (ch) {\n    case '\\n':\n      return '\\n';\n    case '\\r':\n      return '\\r';\n    case '\\t':\n      return '\\t';\n    case '\\\\':\n      return '\\\\';\n    default:\n      return (char) ch;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (ch >= '0' && ch <= '9') {\n    return new Character(ch);\n  }\n  if (ch >= 'a' && ch <= 'f') {\n    return new Character((char) (ch - 'a' + 10));\n  }\n  if (ch >= 'A' && ch <= 'F') {\n    return new Character((char) (ch - 'A' + 10));\n  }\n  return new Character(ch);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (ch >= 'a' && ch <= 'z') {\n    return (char) (ch - 'a' + 'A');\n  } else if (ch >= 'A' && ch <= 'Z') {\n    return (char) (ch - 'A' + 'a');\n  } else if (ch >= '0' && ch <= '9') {\n    return (char) (ch - '0' + '0');\n  } else {\n    return ch;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (Character.isDigit(ch)) {\n    return new Character(ch);\n  } else if (ch == '-') {\n    return new Character('-');\n  } else if (ch == '_') {\n    return new Character('_');\n  } else if (ch == '.') {\n    return new Character('.');\n  } else if (ch == ':') {\n    return new Character(':');\n  } else if (ch == '/') {\n    return new Character('/');\n  } else if (ch == '*') {\n    return new Character('*');\n  } else if (ch == '\\\\') {\n    return new Character('\\\\');\n  } else if (ch == '!') {\n    return new Character('!');\n  } else if (ch == '=') {\n    return new Character('=');\n  } else if (ch == '&') {\n    return new Character('&');\n  } else if (ch == '|') {\n    return new Character('|');\n  } else if (ch == '?') {\n    return new Character('?');\n  } else if (ch == '+') {\n    return new Character('+');\n  } else if (ch == ',') {\n    return new Character(',');\n  } else if (ch == ';') {\n    return new Character(';');\n  } else if (ch == '[') {\n    return new Character('[');\n  } else if (ch == ']') {\n    return new Character(']');\n  } else if (ch == '(') {\n    return new Character('(');\n  } else if (ch == ')') {\n    return new Character(')');\n  } else if (ch == '{') {\n    return new Character('{');\n  } else if (ch == '}') {\n    return new Character('}');\n  } else if (ch == ' ') {\n    return new Character(' ');\n  }\n  throw new IllegalArgumentException(\"Illegal character: \" + ch);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  if (ch >= 'A' && ch <= 'Z') {\n    return (char) (ch - 'A' + 'a');\n  } else {\n    return (char) (ch - 'a' + 'A');\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  switch (ch) {\n    case 'A':\n      return 'A';\n    case 'B':\n      return 'B';\n    case 'C':\n      return 'C';\n    case 'D':\n      return 'D';\n    case 'E':\n      return 'E';\n    case 'F':\n      return 'F';\n    case 'G':\n      return 'G';\n    case 'H':\n      return 'H';\n    case 'I':\n      return 'I';\n    case 'J':\n      return 'J';\n    case 'K':\n      return 'K';\n    case 'L':\n      return 'L';\n    case 'M':\n      return 'M';\n    case 'N':\n      return 'N';\n    case 'O':\n      return 'O';\n    case 'P':\n      return 'P';\n    case 'Q':\n      return 'Q';\n    case 'R':\n      return 'R';\n    case 'S':\n      return 'S';\n    case 'T':\n      return 'T';\n    case 'U':\n      return 'U';\n    case 'V':\n      return 'V';\n    case 'W':\n      return 'W';\n    case 'X':\n      return 'X';\n    case 'Y':\n      return 'Y';\n    case 'Z':\n      return 'Z';\n    default:\n      return null;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  return (char) (ch - 'a' + 'A');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Character toCharacterObject(final char ch) {\n  return Character.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>\n * @param ch  the character to convert\n * @return a Character of the specified character\n */\n", "method_name": "toCharacterObject", "codes": ["public static Character toCharacterObject(final char ch){ if (ch >= 'a' && ch <= 'z') { return (char) (ch - 'a' + 'A'); } else if (ch >= 'A' && ch <= 'Z') { return (char) (ch - 'A' + 'a'); } else { return ch; } }", "public static Character toCharacterObject(final char ch){ if (ch >= 'a' && ch <= 'z') return (char) (ch - 'a' + 'A'); if (ch >= 'A' && ch <= 'Z') return (char) (ch - 'A' + 'a'); return Character.valueOf(ch); }", "public static Character toCharacterObject(final char ch){ switch(ch) { case '\\n': return '\\n'; case '\\r': return '\\r'; case '\\t': return '\\t'; case '\\\\': return '\\\\'; default: return (char) ch; } }", "public static Character toCharacterObject(final char ch){ if (ch >= '0' && ch <= '9') { return new Character(ch); } if (ch >= 'a' && ch <= 'f') { return new Character((char) (ch - 'a' + 10)); } if (ch >= 'A' && ch <= 'F') { return new Character((char) (ch - 'A' + 10)); } return new Character(ch); }", "public static Character toCharacterObject(final char ch){ if (ch >= 'a' && ch <= 'z') { return (char) (ch - 'a' + 'A'); } else if (ch >= 'A' && ch <= 'Z') { return (char) (ch - 'A' + 'a'); } else if (ch >= '0' && ch <= '9') { return (char) (ch - '0' + '0'); } else { return ch; } }", "public static Character toCharacterObject(final char ch){ if (Character.isDigit(ch)) { return new Character(ch); } else if (ch == '-') { return new Character('-'); } else if (ch == '_') { return new Character('_'); } else if (ch == '.') { return new Character('.'); } else if (ch == ':') { return new Character(':'); } else if (ch == '/') { return new Character('/'); } else if (ch == '*') { return new Character('*'); } else if (ch == '\\\\') { return new Character('\\\\'); } else if (ch == '!') { return new Character('!'); } else if (ch == '=') { return new Character('='); } else if (ch == '&') { return new Character('&'); } else if (ch == '|') { return new Character('|'); } else if (ch == '?') { return new Character('?'); } else if (ch == '+') { return new Character('+'); } else if (ch == ',') { return new Character(','); } else if (ch == ';') { return new Character(';'); } else if (ch == '[') { return new Character('['); } else if (ch == ']') { return new Character(']'); } else if (ch == '(') { return new Character('('); } else if (ch == ')') { return new Character(')'); } else if (ch == '{') { return new Character('{'); } else if (ch == '}') { return new Character('}'); } else if (ch == ' ') { return new Character(' '); } throw new IllegalArgumentException(\"Illegal character: \" + ch); }", "public static Character toCharacterObject(final char ch){ if (ch >= 'A' && ch <= 'Z') { return (char) (ch - 'A' + 'a'); } else { return (char) (ch - 'a' + 'A'); } }", "public static Character toCharacterObject(final char ch){ switch(ch) { case 'A': return 'A'; case 'B': return 'B'; case 'C': return 'C'; case 'D': return 'D'; case 'E': return 'E'; case 'F': return 'F'; case 'G': return 'G'; case 'H': return 'H'; case 'I': return 'I'; case 'J': return 'J'; case 'K': return 'K'; case 'L': return 'L'; case 'M': return 'M'; case 'N': return 'N'; case 'O': return 'O'; case 'P': return 'P'; case 'Q': return 'Q'; case 'R': return 'R'; case 'S': return 'S'; case 'T': return 'T'; case 'U': return 'U'; case 'V': return 'V'; case 'W': return 'W'; case 'X': return 'X'; case 'Y': return 'Y'; case 'Z': return 'Z'; default: return null; } }", "public static Character toCharacterObject(final char ch){ return (char) (ch - 'a' + 'A'); }", "public static Character toCharacterObject(final char ch){ return Character.valueOf(ch); }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec01781c", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return ((ch >= 'a') && (ch <= 'z'));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return ch >= 'A' && ch <= 'Z';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return ch >= 'A' && ch <= 'Z';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  if (ch >= 'A' && ch <= 'Z') {\n    return true;\n  } else {\n    return false;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return ch >= 'A' && ch <= 'Z';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return ((ch >= 'a') && (ch <= 'z'));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch) {\n  return ((ch >= 'A') && (ch <= 'Z'));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p> <pre> CharUtils.isAsciiAlphaUpper('a')  = false CharUtils.isAsciiAlphaUpper('A')  = true CharUtils.isAsciiAlphaUpper('3')  = false CharUtils.isAsciiAlphaUpper('-')  = false CharUtils.isAsciiAlphaUpper('\\n') = false CharUtils.isAsciiAlphaUpper('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if between 65 and 90 inclusive\n */\n", "method_name": "isAsciiAlphaUpper", "codes": ["public static boolean isAsciiAlphaUpper(final char ch){ return ((ch >= 'a') && (ch <= 'z')); }", "public static boolean isAsciiAlphaUpper(final char ch){ return ch >= 'A' && ch <= 'Z'; }", "public static boolean isAsciiAlphaUpper(final char ch){ return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')); }", "public static boolean isAsciiAlphaUpper(final char ch){ return ch >= 'A' && ch <= 'Z'; }", "public static boolean isAsciiAlphaUpper(final char ch){ return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'); }", "public static boolean isAsciiAlphaUpper(final char ch){ if (ch >= 'A' && ch <= 'Z') { return true; } else { return false; } }", "public static boolean isAsciiAlphaUpper(final char ch){ return ch >= 'A' && ch <= 'Z'; }", "public static boolean isAsciiAlphaUpper(final char ch){ return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); }", "public static boolean isAsciiAlphaUpper(final char ch){ return ((ch >= 'a') && (ch <= 'z')); }", "public static boolean isAsciiAlphaUpper(final char ch){ return ((ch >= 'A') && (ch <= 'Z')); }"], "code_level": "self_contained", "_id": "636766fb1a6d9265ec0177c1", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int length(final String str) {\n  return str == null ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  return str == null ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  return str == null ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  return str == null ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  if (str == null) {\n    return 0;\n  }\n  return str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  return str == null ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str) {\n  return (str == null) ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n * @param str a String or <code>null</code>\n * @return String length or <code>0</code> if the String is <code>null</code>.\n * @since 2.4\n */\n", "method_name": "length", "codes": ["public static int length(final String str){ return str == null ? 0 : str.length(); }", "public static int length(final String str){ if (str == null) { return 0; } return str.length(); }", "public static int length(final String str){ if (str == null) { return 0; } return str.length(); }", "public static int length(final String str){ return str == null ? 0 : str.length(); }", "public static int length(final String str){ if (str == null) { return 0; } return str.length(); }", "public static int length(final String str){ return str == null ? 0 : str.length(); }", "public static int length(final String str){ return str == null ? 0 : str.length(); }", "public static int length(final String str){ if (str == null) { return 0; } return str.length(); }", "public static int length(final String str){ return str == null ? 0 : str.length(); }", "public static int length(final String str){ return (str == null) ? 0 : str.length(); }"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179d9", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String base64Decode(final String s) {\n  return base64Decode(s.getBytes());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  try {\n    if (s != null && s.length() > 0) {\n      byte[] bytes = Base64.getDecoder().decode(s);\n      return new String(bytes, StandardCharsets.UTF_8);\n    }\n  } catch (IllegalArgumentException e) {\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  if (s == null) return null;\n  final byte[] data = Base64.decodeBase64(s);\n  return new String(data, StandardCharsets.UTF_8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  if (s == null) {\n    return null;\n  }\n  final byte[] bytes = Base64.getDecoder().decode(s);\n  return new String(bytes, StandardCharsets.UTF_8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return new String(base64Decode(s.getBytes()), StandardCharsets.UTF_8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return base64Decode(s, Charset.forName(\"UTF-8\"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  if (s == null) {\n    return null;\n  }\n  if (s.length() % 2 != 0) {\n    throw new IllegalArgumentException(\"Input string is not a valid base64 encoded string\");\n  }\n  final byte[] bytes = new byte[s.length() / 2];\n  for (int i = 0; i < s.length(); i += 2) {\n    final byte b0 = (byte) (Character.digit(s.charAt(i), 16) << 4);\n    final byte b1 = (byte) (Character.digit(s.charAt(i + 1), 16));\n    bytes[i / 2] = (byte) (b0 | b1);\n  }\n  return new String(bytes, StandardCharsets.UTF_8);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String base64Decode(final String s) {\n  try {\n    return new String(Base64.decodeBase64(s), \"UTF-8\");\n  } catch (final UnsupportedEncodingException e) {\n    throw new RuntimeException(e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return base64Decode(s, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s) {\n  return new String(Base64.getDecoder().decode(s));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decoding a string to a string follow the Base64 regular. \n */\n", "method_name": "base64Decode", "codes": ["public static String base64Decode(final String s){ return base64Decode(s.getBytes()); }", "public static String base64Decode(final String s){ try { if (s != null && s.length() > 0) { byte[] bytes = Base64.getDecoder().decode(s); return new String(bytes, StandardCharsets.UTF_8); } } catch (IllegalArgumentException e) { } return null; }", "public static String base64Decode(final String s){ if (s == null) return null; final byte[] data = Base64.decodeBase64(s); return new String(data, StandardCharsets.UTF_8); }", "public static String base64Decode(final String s){ if (s == null) { return null; } final byte[] bytes = Base64.getDecoder().decode(s); return new String(bytes, StandardCharsets.UTF_8); }", "public static String base64Decode(final String s){ return new String(base64Decode(s.getBytes()), StandardCharsets.UTF_8); }", "public static String base64Decode(final String s){ return base64Decode(s, Charset.forName(\"UTF-8\")); }", "public static String base64Decode(final String s){ if (s == null) { return null; } if (s.length() % 2 != 0) { throw new IllegalArgumentException(\"Input string is not a valid base64 encoded string\"); } final byte[] bytes = new byte[s.length() / 2]; for (int i = 0; i < s.length(); i += 2) { final byte b0 = (byte) (Character.digit(s.charAt(i), 16) << 4); final byte b1 = (byte) (Character.digit(s.charAt(i + 1), 16)); bytes[i / 2] = (byte) (b0 | b1); } return new String(bytes, StandardCharsets.UTF_8); }", "public static String base64Decode(final String s){ try { return new String(Base64.decodeBase64(s), \"UTF-8\"); } catch (final UnsupportedEncodingException e) { throw new RuntimeException(e); } }", "public static String base64Decode(final String s){ return base64Decode(s, false); }", "public static String base64Decode(final String s){ return new String(Base64.getDecoder().decode(s)); }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec017748", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  if (array1 == null && array2 != null) {\n    return false;\n  }\n  if (array2 == null && array1 != null) {\n    return false;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  for (int i = 0; i < array1.length; i++) {\n    if (array1[i] != array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  if (array1 == null) {\n    return ((array2 == null) || (array2.length == 0));\n  } else if (array2 == null) {\n    return false;\n  } else if (array1.length != array2.length) {\n    return false;\n  } else {\n    return true;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return array1 == array2 || array1 == null || array2 == null || array1.length != array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return array1 == null && array2 == null || array1 != null && array1.length == array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return array1 == null && array2 == null || array1.length == array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  if (array1 == null) {\n    return array2 == null;\n  } else if (array2 == null) {\n    return false;\n  } else if (array1.length != array2.length) {\n    return false;\n  } else {\n    for (int i = 0; i < array1.length; i++) {\n      if (array1[i] != array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  if (array1 == array2) {\n    return true;\n  }\n  if (array1 == null || array2 == null) {\n    return false;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  for (int i = 0; i < array1.length; i++) {\n    if (array1[i] != array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return (array1 == null && array2 != null)\n      || (array2 == null && array1 != null)\n      || (array1.length == array2.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  if (array1 == null && array2 == null) {\n    return true;\n  } else if (array1 == null || array2 == null) {\n    return false;\n  } else if (array1.length != array2.length) {\n    return false;\n  } else {\n    for (int i = 0; i < array1.length; i++) {\n      if (array1[i] != array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final double[] array1, final double[] array2) {\n  return isSameLength(array1, array2, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n", "method_name": "isSameLength", "codes": ["public static boolean isSameLength(final double[] array1,final double[] array2){ if (array1 == null && array2 != null) { return false; } if (array2 == null && array1 != null) { return false; } if (array1.length != array2.length) { return false; } for (int i = 0; i < array1.length; i++) { if (array1[i] != array2[i]) { return false; } } return true; }", "public static boolean isSameLength(final double[] array1,final double[] array2){ if (array1 == null) { return ((array2 == null) || (array2.length == 0)); } else if (array2 == null) { return false; } else if (array1.length != array2.length) { return false; } else { return true; } }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return array1 == array2 || array1 == null || array2 == null || array1.length != array2.length; }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return array1 == null && array2 == null || array1 != null && array1.length == array2.length; }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return array1 == null && array2 == null || array1.length == array2.length; }", "public static boolean isSameLength(final double[] array1,final double[] array2){ if (array1 == null) { return array2 == null; } else if (array2 == null) { return false; } else if (array1.length != array2.length) { return false; } else { for (int i = 0; i < array1.length; i++) { if (array1[i] != array2[i]) { return false; } } return true; } }", "public static boolean isSameLength(final double[] array1,final double[] array2){ if (array1 == array2) { return true; } if (array1 == null || array2 == null) { return false; } if (array1.length != array2.length) { return false; } for (int i = 0; i < array1.length; i++) { if (array1[i] != array2[i]) { return false; } } return true; }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return (array1 == null && array2 != null) || (array2 == null && array1 != null) || (array1.length == array2.length); }", "public static boolean isSameLength(final double[] array1,final double[] array2){ if (array1 == null && array2 == null) { return true; } else if (array1 == null || array2 == null) { return false; } else if (array1.length != array2.length) { return false; } else { for (int i = 0; i < array1.length; i++) { if (array1[i] != array2[i]) { return false; } } return true; } }", "public static boolean isSameLength(final double[] array1,final double[] array2){ return isSameLength(array1, array2, null); }"], "code_level": "self_contained", "_id": "636766f11a6d9265ec017663", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  return array != null ? array.clone() : null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  return array == null ? null : (char[]) array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array) {\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  the array to clone, may be <code>null</code>\n * @return the cloned array, <code>null</code> if <code>null</code> input\n */\n", "method_name": "clone", "codes": ["public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ return array != null ? array.clone() : null; }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ return array == null ? null : (char[]) array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }", "public static char[] clone(final char[] array){ if (array == null) { return null; } return array.clone(); }"], "code_level": "self_contained", "_id": "636766f31a6d9265ec01768f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean isAscii(final char ch) {\n  return ch >= 0x30 && ch <= 0x39;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return ch >= 0 && ch <= 255;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return ch >= '0' && ch <= '9';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return ch >= 0 && ch <= 127;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return ch >= '0' && ch <= '9';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return ch < ' ' || ch > '~';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  if (ch >= '0' && ch <= '9') {\n    return true;\n  } else if (ch >= 'a' && ch <= 'f') {\n    return true;\n  } else if (ch >= 'A' && ch <= 'F') {\n    return true;\n  } else {\n    return false;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isAscii(final char ch) {\n  return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit.</p> <pre> CharUtils.isAscii('a')  = true CharUtils.isAscii('A')  = true CharUtils.isAscii('3')  = true CharUtils.isAscii('-')  = true CharUtils.isAscii('\\n') = true CharUtils.isAscii('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if less than 128\n */\n", "method_name": "isAscii", "codes": ["public static boolean isAscii(final char ch){ return ch >= 0x30 && ch <= 0x39; }", "public static boolean isAscii(final char ch){ return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F'); }", "public static boolean isAscii(final char ch){ return ch >= 0 && ch <= 255; }", "public static boolean isAscii(final char ch){ return ch >= '0' && ch <= '9'; }", "public static boolean isAscii(final char ch){ return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'); }", "public static boolean isAscii(final char ch){ return ch >= 0 && ch <= 127; }", "public static boolean isAscii(final char ch){ return ch >= '0' && ch <= '9'; }", "public static boolean isAscii(final char ch){ return ch < ' ' || ch > '~'; }", "public static boolean isAscii(final char ch){ if (ch >= '0' && ch <= '9') { return true; } else if (ch >= 'a' && ch <= 'f') { return true; } else if (ch >= 'A' && ch <= 'F') { return true; } else { return false; } }", "public static boolean isAscii(final char ch){ return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')); }"], "code_level": "self_contained", "_id": "636766fb1a6d9265ec0177c3", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String toString(final char ch){ if (ch == '\\n') { return \"\\n\"; } if (ch == '\\r') { return \"\\r\"; } if (ch == '\\t') { return \"\\t\"; } if (ch == '\\b') { return \"\\b\"; } if (ch == '\\f') { return \"\\f\"; } if (ch == '\\u00a0') { return \"\\u00a0\"; } if (ch == '\\u1680') { return \"\\u1680\"; } if (ch == '\\u180e') { return \"\\u180e\"; } if (ch == '\\u2000') { return \"\\u2000\"; } if (ch == '\\u2028') { return \"\\u2028\"; } if (ch == '\\u2029') { return \"\\u2029\"; } if (ch == '\\u00a1') { return \"\\u00a1\"; } if (ch == '\\u20ac') { return \"\\u20ac\"; } if (ch == '\\u2600') { return \"\\u2600\"; } if (ch == '\\u2601') { return \"\\u2601\"; } if (ch == '\\u2610') { return \"\\u2610\"; } if (ch == '\\u2611') { return \"\\u2611\"; } if (ch == '\\u2612') { return \"\\u2612\"; } if (ch == '\\u2613') { return \"\\u2613\"; } if (ch == '\\u2614') { return \"\\u2614\"; } if (ch == '\\u2615') { return \"\\u2615\"; } if (ch == '\\u2616') { return \"\\u2616\"; } if (ch == '\\u2617') { return \"\\u2617\"; } if (ch == '\\u2618') { return \"\\u2618\"; } if (ch == '\\u2619') { return \"\\u2619\"; } if (ch == '\\u2603') { return \"\\u2603\"; } if (ch == '\\u2604') { return \"\\u2604\"; } if (ch == '\\u2655') { return \"\\u2655\"; } if (ch == '\\u2658') { return \"\\u2658\"; } if (ch == '\\u2659') { return \"\\u2659\"; } if (ch == '\\u2660') { return \"\\u2660\"; } if (ch == '\\u2661') { return \"\\u2661\"; } if (ch == '\\u2662') { return \"\\u2662\"; } if (ch == '\\u2663') { return \"\\u2663\"; } if (ch == '\\u2664') { return \"\\u2664\"; } if (ch == '\\u2665') { return \"\\u2665\"; } if (ch == '\\u2666') { return \"\\u2666\"; } if (ch == '\\u2667') { return \"\\u2667\"; } if (ch == '\\u2668') { return \"\\u2668\"; }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  return new String(new char[] {ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch) {\n  return new String(new char[] {ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch) {\n  if (ch == '\\u0000') {\n    return \"\\u0000\";\n  } else if (ch >= '\\u0020' && ch <= '\\u007F') {\n    return \"\\\\u\" + Integer.toHexString(ch);\n  } else if (ch >= '\\uE000' && ch <= '\\uFFFF') {\n    return \"\\\\u\" + Integer.toHexString(ch);\n  } else {\n    return \"\\\\u\" + Integer.toHexString(ch);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  return new String(new char[] {ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch) {\n  return ch + \"\";\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch) {\n  return new String(new char[] {ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch) {\n  if (ch < 0x80) {\n    return String.valueOf(ch);\n  } else if (ch < 0x800) {\n    return String.valueOf((char) (ch - 0x80)) + \"-\" + String.valueOf((char) (ch - 0x80 + 0x80));\n  } else {\n    return String.valueOf((char) (ch - 0x800))\n        + \"-\"\n        + String.valueOf((char) (ch - 0x800 + 0x80 + 0x80));\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  if (ch <= 0x80) {\n    return String.valueOf(ch);\n  } else {\n    return String.valueOf(\"\\\\u\" + Integer.toHexString(ch));\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String toString(final char ch) {\n  return new String(new char[] {ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the character to a String that contains the one character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same String object each time.</p> <pre> CharUtils.toString(' ')  = \" \" CharUtils.toString('A')  = \"A\" </pre>\n * @param ch  the character to convert\n * @return a String containing the one specified character\n */\n", "method_name": "toString", "codes": ["public static String toString(final char ch){ if (ch == '\\n') { return \"\\n\"; } if (ch == '\\r') { return \"\\r\"; } if (ch == '\\t') { return \"\\t\"; } if (ch == '\\b') { return \"\\b\"; } if (ch == '\\f') { return \"\\f\"; } if (ch == '\\u00a0') { return \"\\u00a0\"; } if (ch == '\\u1680') { return \"\\u1680\"; } if (ch == '\\u180e') { return \"\\u180e\"; } if (ch == '\\u2000') { return \"\\u2000\"; } if (ch == '\\u2028') { return \"\\u2028\"; } if (ch == '\\u2029') { return \"\\u2029\"; } if (ch == '\\u00a1') { return \"\\u00a1\"; } if (ch == '\\u20ac') { return \"\\u20ac\"; } if (ch == '\\u2600') { return \"\\u2600\"; } if (ch == '\\u2601') { return \"\\u2601\"; } if (ch == '\\u2610') { return \"\\u2610\"; } if (ch == '\\u2611') { return \"\\u2611\"; } if (ch == '\\u2612') { return \"\\u2612\"; } if (ch == '\\u2613') { return \"\\u2613\"; } if (ch == '\\u2614') { return \"\\u2614\"; } if (ch == '\\u2615') { return \"\\u2615\"; } if (ch == '\\u2616') { return \"\\u2616\"; } if (ch == '\\u2617') { return \"\\u2617\"; } if (ch == '\\u2618') { return \"\\u2618\"; } if (ch == '\\u2619') { return \"\\u2619\"; } if (ch == '\\u2603') { return \"\\u2603\"; } if (ch == '\\u2604') { return \"\\u2604\"; } if (ch == '\\u2655') { return \"\\u2655\"; } if (ch == '\\u2658') { return \"\\u2658\"; } if (ch == '\\u2659') { return \"\\u2659\"; } if (ch == '\\u2660') { return \"\\u2660\"; } if (ch == '\\u2661') { return \"\\u2661\"; } if (ch == '\\u2662') { return \"\\u2662\"; } if (ch == '\\u2663') { return \"\\u2663\"; } if (ch == '\\u2664') { return \"\\u2664\"; } if (ch == '\\u2665') { return \"\\u2665\"; } if (ch == '\\u2666') { return \"\\u2666\"; } if (ch == '\\u2667') { return \"\\u2667\"; } if (ch == '\\u2668') { return \"\\u2668\"; }", "public static String toString(final char ch){ return new String(new char[] { ch }); }", "public static String toString(final char ch){ return new String(new char[] { ch }); }", "public static String toString(final char ch){ if (ch == '\\u0000') { return \"\\u0000\"; } else if (ch >= '\\u0020' && ch <= '\\u007F') { return \"\\\\u\" + Integer.toHexString(ch); } else if (ch >= '\\uE000' && ch <= '\\uFFFF') { return \"\\\\u\" + Integer.toHexString(ch); } else { return \"\\\\u\" + Integer.toHexString(ch); } }", "public static String toString(final char ch){ return new String(new char[] { ch }); }", "public static String toString(final char ch){ return ch + \"\"; }", "public static String toString(final char ch){ return new String(new char[] { ch }); }", "public static String toString(final char ch){ if (ch < 0x80) { return String.valueOf(ch); } else if (ch < 0x800) { return String.valueOf((char) (ch - 0x80)) + \"-\" + String.valueOf((char) (ch - 0x80 + 0x80)); } else { return String.valueOf((char) (ch - 0x800)) + \"-\" + String.valueOf((char) (ch - 0x800 + 0x80 + 0x80)); } }", "public static String toString(final char ch){ if (ch <= 0x80) { return String.valueOf(ch); } else { return String.valueOf(\"\\\\u\" + Integer.toHexString(ch)); } }", "public static String toString(final char ch){ return new String(new char[] { ch }); }"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec017a05", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void enlarge(final int size) {\n  if (this.bytes.length < size) {\n    this.bytes = new byte[size];\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] newBytes = new byte[size];\n  System.arraycopy(this.bytes, 0, newBytes, 0, this.bytes.length);\n  this.bytes = newBytes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  byte[] newData = new byte[data.length + size];\n  System.arraycopy(data, 0, newData, 0, data.length);\n  data = newData;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int[] tmp = new int[this.data.length * 2];\n  for (int i = 0; i < this.data.length; i++) {\n    tmp[i] = this.data[i];\n  }\n  this.data = tmp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] v = new byte[size];\n  System.arraycopy(buffer, 0, v, 0, size);\n  buffer = v;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int[] newData = new int[size * 2];\n  System.arraycopy(this.data, 0, newData, 0, this.data.length);\n  this.data = newData;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  if (size > byteVector.length) {\n    final byte[] newByteVector = new byte[size];\n    System.arraycopy(byteVector, 0, newByteVector, 0, byteVector.length);\n    byteVector = newByteVector;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int[] data = this.data;\n  final int pos = this.pos;\n  this.pos = 0;\n  this.data = new int[size];\n  System.arraycopy(data, 0, this.data, 0, pos);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] newData = new byte[data.length * size];\n  System.arraycopy(data, 0, newData, 0, data.length);\n  data = newData;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int newSize = Math.max(this.size + size, this.capacity);\n  final byte[] newData = new byte[newSize];\n  System.arraycopy(this.data, 0, newData, 0, this.size);\n  this.data = newData;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n", "method_name": "enlarge", "codes": ["private void enlarge(final int size){ if (this.bytes.length < size) { this.bytes = new byte[size]; } }", "private void enlarge(final int size){ final byte[] newBytes = new byte[size]; System.arraycopy(this.bytes, 0, newBytes, 0, this.bytes.length); this.bytes = newBytes; }", "private void enlarge(final int size){ byte[] newData = new byte[data.length + size]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; }", "private void enlarge(final int size){ final int[] tmp = new int[this.data.length * 2]; for (int i = 0; i < this.data.length; i++) { tmp[i] = this.data[i]; } this.data = tmp; }", "private void enlarge(final int size){ final byte[] v = new byte[size]; System.arraycopy(buffer, 0, v, 0, size); buffer = v; }", "private void enlarge(final int size){ final int[] newData = new int[size * 2]; System.arraycopy(this.data, 0, newData, 0, this.data.length); this.data = newData; }", "private void enlarge(final int size){ if (size > byteVector.length) { final byte[] newByteVector = new byte[size]; System.arraycopy(byteVector, 0, newByteVector, 0, byteVector.length); byteVector = newByteVector; } }", "private void enlarge(final int size){ final int[] data = this.data; final int pos = this.pos; this.pos = 0; this.data = new int[size]; System.arraycopy(data, 0, this.data, 0, pos); }", "private void enlarge(final int size){ final byte[] newData = new byte[data.length * size]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; }", "private void enlarge(final int size){ final int newSize = Math.max(this.size + size, this.capacity); final byte[] newData = new byte[newSize]; System.arraycopy(this.data, 0, newData, 0, this.size); this.data = newData; }"], "code_level": "class_runnable", "_id": "636767191a6d9265ec017c0f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "int addType(final String value) {\n  int index = -1;\n  for (int i = 0; i < this.typeTable.length; ++i) {\n    if (this.typeTable[i].equals(value)) {\n      index = i;\n      break;\n    }\n  }\n  if (index == -1) {\n    final int[] typeTable = new int[this.typeTable.length + 1];\n    System.arraycopy(this.typeTable, 0, typeTable, 0, this.typeTable.length);\n    typeTable[typeTable.length - 1] = this.typeTable.length;\n    this.typeTable = typeTable;\n    final int size = this.typeTable.length;\n    for (int i = 0; i < size; ++i) {\n      this.typeTable[i] = this.typeTable[i].intern();\n    }\n  }\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  if (symbolTable.containsKey(value)) {\n    return symbolTable.get(value);\n  } else {\n    symbolTable.put(value, symbolTable.size());\n    return symbolTable.size() - 1;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  if (typeTable == null) {\n    return -1;\n  } else {\n    final int index = typeTable.add(value);\n    if (index == -1) {\n      return -1;\n    } else {\n      return index;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  if (value.equals(\"int\")) {\n    return addType(Type.INT);\n  } else if (value.equals(\"char\")) {\n    return addType(Type.CHAR);\n  } else if (value.equals(\"boolean\")) {\n    return addType(Type.BOOLEAN);\n  } else if (value.equals(\"float\")) {\n    return addType(Type.FLOAT);\n  } else if (value.equals(\"double\")) {\n    return addType(Type.DOUBLE);\n  } else if (value.equals(\"void\")) {\n    return addType(Type.VOID);\n  } else {\n    throw new RuntimeException(\"Cannot add type \" + value + \" to type table\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  final int type_index = m_type_table.add(value);\n  return type_index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  int n = 0;\n  for (int i = 0; i < m_types.length; i++) {\n    if (m_types[i].equals(value)) {\n      return i;\n    }\n    n += m_types[i].getTypeLength();\n  }\n  if (n > m_typeTableSize) {\n    m_typeTableSize = n;\n    m_typeTable = new Type[m_typeTableSize];\n    m_typeTableSize = 0;\n  }\n  m_typeTable[n++] = new Type(value);\n  return n - 1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  if (this.typeTable.containsKey(value)) {\n    return this.typeTable.get(value);\n  }\n  final int index = this.typeTable.size();\n  this.typeTable.put(value, index);\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  if (value.equals(\"void\")) {\n    return VOID_TYPE;\n  }\n  if (value.equals(\"boolean\")) {\n    return BOOLEAN_TYPE;\n  }\n  if (value.equals(\"byte\")) {\n    return BYTE_TYPE;\n  }\n  if (value.equals(\"char\")) {\n    return CHAR_TYPE;\n  }\n  if (value.equals(\"double\")) {\n    return DOUBLE_TYPE;\n  }\n  if (value.equals(\"float\")) {\n    return FLOAT_TYPE;\n  }\n  if (value.equals(\"int\")) {\n    return INT_TYPE;\n  }\n  if (value.equals(\"long\")) {\n    return LONG_TYPE;\n  }\n  if (value.equals(\"short\")) {\n    return SHORT_TYPE;\n  }\n  if (value.equals(\"void\")) {\n    return VOID_TYPE;\n  }\n  throw new IllegalArgumentException(\"Unknown type: \" + value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  int id = -1;\n  if (types.containsKey(value)) {\n    id = types.get(value);\n  } else {\n    id = nTypes;\n    types.put(value, id);\n  }\n  return id;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value) {\n  return addType(value, -1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n", "method_name": "addType", "codes": ["int addType(final String value){ int index = -1; for (int i = 0; i < this.typeTable.length; ++i) { if (this.typeTable[i].equals(value)) { index = i; break; } } if (index == -1) { final int[] typeTable = new int[this.typeTable.length + 1]; System.arraycopy(this.typeTable, 0, typeTable, 0, this.typeTable.length); typeTable[typeTable.length - 1] = this.typeTable.length; this.typeTable = typeTable; final int size = this.typeTable.length; for (int i = 0; i < size; ++i) { this.typeTable[i] = this.typeTable[i].intern(); } } return index; }", "int addType(final String value){ if (symbolTable.containsKey(value)) { return symbolTable.get(value); } else { symbolTable.put(value, symbolTable.size()); return symbolTable.size() - 1; } }", "int addType(final String value){ if (typeTable == null) { return -1; } else { final int index = typeTable.add(value); if (index == -1) { return -1; } else { return index; } } }", "int addType(final String value){ if (value.equals(\"int\")) { return addType(Type.INT); } else if (value.equals(\"char\")) { return addType(Type.CHAR); } else if (value.equals(\"boolean\")) { return addType(Type.BOOLEAN); } else if (value.equals(\"float\")) { return addType(Type.FLOAT); } else if (value.equals(\"double\")) { return addType(Type.DOUBLE); } else if (value.equals(\"void\")) { return addType(Type.VOID); } else { throw new RuntimeException(\"Cannot add type \" + value + \" to type table\"); } }", "int addType(final String value){ final int type_index = m_type_table.add(value); return type_index; }", "int addType(final String value){ int n = 0; for (int i = 0; i < m_types.length; i++) { if (m_types[i].equals(value)) { return i; } n += m_types[i].getTypeLength(); } if (n > m_typeTableSize) { m_typeTableSize = n; m_typeTable = new Type[m_typeTableSize]; m_typeTableSize = 0; } m_typeTable[n++] = new Type(value); return n - 1; }", "int addType(final String value){ if (this.typeTable.containsKey(value)) { return this.typeTable.get(value); } final int index = this.typeTable.size(); this.typeTable.put(value, index); return index; }", "int addType(final String value){ if (value.equals(\"void\")) { return VOID_TYPE; } if (value.equals(\"boolean\")) { return BOOLEAN_TYPE; } if (value.equals(\"byte\")) { return BYTE_TYPE; } if (value.equals(\"char\")) { return CHAR_TYPE; } if (value.equals(\"double\")) { return DOUBLE_TYPE; } if (value.equals(\"float\")) { return FLOAT_TYPE; } if (value.equals(\"int\")) { return INT_TYPE; } if (value.equals(\"long\")) { return LONG_TYPE; } if (value.equals(\"short\")) { return SHORT_TYPE; } if (value.equals(\"void\")) { return VOID_TYPE; } throw new IllegalArgumentException(\"Unknown type: \" + value); }", "int addType(final String value){ int id = -1; if (types.containsKey(value)) { id = types.get(value); } else { id = nTypes; types.put(value, id); } return id; }", "int addType(final String value){ return addType(value, -1); }"], "code_level": "project_runnable", "_id": "636766ef1a6d9265ec01761a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public long readLong(final int offset) {\n  final int start = offset;\n  while (true) {\n    final int n = read(offset);\n    if (n == -1) {\n      return -1L;\n    }\n    final int i = n & 0x7;\n    if (i > 7) {\n      throw new RuntimeException(\"Invalid long value: \" + n + \" (offset \" + offset + \")\");\n    }\n    final long l = (n & 0x7F) << i;\n    offset += i;\n    if (offset >= end) {\n      return l;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return readLong(offset, 0xffffffffL);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return readLong(offset, -1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return readLong(offset, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return readLong(offset, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return ((long) readInt(offset) << 32) | (readInt(offset + 4) & 0xFFFFFFFFL);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public long readLong(final int offset) {\n  return UNSAFE.getLong(address + offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return (long) this.readByte(offset) << 56\n      | (long) this.readByte(offset + 1) << 48\n      | (long) this.readByte(offset + 2) << 40\n      | (long) this.readByte(offset + 3) << 32\n      | (long) this.readByte(offset + 4) << 24\n      | (long) this.readByte(offset + 5) << 16\n      | (long) this.readByte(offset + 6) << 8\n      | (long) this.readByte(offset + 7);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public long readLong(final int offset) {\n  return readLong(offset, ByteOrder.BIG_ENDIAN);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset) {\n  return this.readLong(offset, (byte) 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n", "method_name": "readLong", "codes": ["public long readLong(final int offset){ final int start = offset; while (true) { final int n = read(offset); if (n == -1) { return -1L; } final int i = n & 0x7; if (i > 7) { throw new RuntimeException(\"Invalid long value: \" + n + \" (offset \" + offset + \")\"); } final long l = (n & 0x7F) << i; offset += i; if (offset >= end) { return l; } } }", "public long readLong(final int offset){ return readLong(offset, 0xffffffffL); }", "public long readLong(final int offset){ return readLong(offset, -1); }", "public long readLong(final int offset){ return readLong(offset, false); }", "public long readLong(final int offset){ return readLong(offset, 0); }", "public long readLong(final int offset){ return ((long) readInt(offset) << 32) | (readInt(offset + 4) & 0xFFFFFFFFL); }", "public long readLong(final int offset){ return UNSAFE.getLong(address + offset); }", "public long readLong(final int offset){ return (long) this.readByte(offset) << 56 | (long) this.readByte(offset + 1) << 48 | (long) this.readByte(offset + 2) << 40 | (long) this.readByte(offset + 3) << 32 | (long) this.readByte(offset + 4) << 24 | (long) this.readByte(offset + 5) << 16 | (long) this.readByte(offset + 6) << 8 | (long) this.readByte(offset + 7); }", "public long readLong(final int offset){ return readLong(offset, ByteOrder.BIG_ENDIAN); }", "public long readLong(final int offset){ return this.readLong(offset, (byte) 0); }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec01775b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (this.length + byteLength > this.value.length) {\n    enlarge(byteLength);\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.value, this.length, byteLength);\n  this.length += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteArrayValue == null) {\n    if (length == byteLength) {\n      return this;\n    }\n  } else {\n    final int byteLength2 = byteLength;\n    if (byteLength > length) {\n      byte[] byteArrayNew = new byte[byteLength2];\n      System.arraycopy(byteArrayValue, byteOffset, byteArrayNew, 0, byteLength2);\n      byteArray = byteArrayNew;\n    } else {\n      byteArray = byteArrayValue;\n    }\n    length = byteLength;\n  }\n  if (length > MAX_BYTE_ARRAY_LENGTH) {\n    throw new IllegalArgumentException(\"length > MAX_BYTE_ARRAY_LENGTH\");\n  }\n  if (byteOffset < 0) {\n    if (byteOffset + byteLength > byteArrayValue.length) {\n      throw new IllegalArgumentException(\"byteOffset + byteLength > byteArrayValue.length\");\n    }\n  } else {\n    if (byteOffset + byteLength > length) {\n      throw new IllegalArgumentException(\"byteOffset + byteLength < length\");\n    }\n  }\n  if (byteLength == 0) {\n    return this;\n  }\n  if (byteOffset == 0) {\n    if (byteLength >= byteArrayValue.length) {\n      byte[] byteArrayNew = new byte[byteArrayValue.length];\n      System.arraycopy(byteArrayValue, 0, byteArrayNew, 0, byteArrayValue.length);\n      byteArray = byteArrayNew;\n    }\n  } else {\n    byte[] byteArrayNew = new byte[byteLength];\n    System.arraycopy(byteArrayValue, byteOffset, byteArrayNew, 0, byteLength);\n    byteArray = byteArrayNew;\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > 4) {\n    throw new IllegalArgumentException();\n  }\n  int newlength = length + byteLength;\n  if (newlength > data.length) {\n    enlarge(newlength);\n  }\n  System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n  length = newlength;\n  return this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > byteArrayValue.length - byteOffset) {\n    throw new IllegalArgumentException(\"byteArrayValue.length > byteOffset + byteLength\");\n  }\n  if (this._buffer.length - this._position < byteLength) {\n    expand(byteLength);\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this._buffer, this._position, byteLength);\n  this._position += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > byteArray.length) {\n    final int resize = byteLength + (byteArray.length - byteOffset);\n    byte[] newArray = new byte[resize];\n    System.arraycopy(byteArray, byteOffset, newArray, 0, byteLength);\n    byteArray = newArray;\n  }\n  System.arraycopy(byteArrayValue, byteOffset, byteArray, byteOffset + byteLength, byteLength);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > byteArrayLength) {\n    enlarge(byteLength);\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteArrayPointer, byteLength);\n  this.byteArrayPointer += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > 8) {\n    throw new RuntimeException(\"Cannot store more than 8 byte values\");\n  }\n  if (byteLength == 0) {\n    return this;\n  }\n  if (byteLength == byteArrayValue.length) {\n    putByte(byteArrayValue[byteOffset]);\n    return this;\n  }\n  int currentOffset = byteOffset;\n  final int arrayLength = byteLength;\n  final int newLength = this.array.length + arrayLength;\n  byte[] newArray = new byte[newLength];\n  System.arraycopy(this.array, 0, newArray, 0, currentOffset);\n  System.arraycopy(byteArrayValue, 0, newArray, currentOffset, arrayLength);\n  this.array = newArray;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  int currentLength = this.length;\n  if (byteLength > currentLength) {\n    throw new BufferOverflowException();\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.bytes, this.length, byteLength);\n  this.length = currentLength + byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength == 0) {\n    return this;\n  }\n  if (byteLength > length()) {\n    enlarge(byteLength);\n  }\n  System.arraycopy(\n      byteArrayValue, byteOffset, this.byteArray, this.byteArrayPosition, byteLength);\n  this.byteArrayPosition += byteLength;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > byteArrayLength) {\n    byteLength = byteArrayLength;\n  }\n  putBytes(byteArrayValue, byteOffset, byteLength);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset index of the first byte of byteArrayValue that must be copied.\n * @param byteLength number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n", "method_name": "putByteArray", "codes": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (this.length + byteLength > this.value.length) { enlarge(byteLength); } System.arraycopy(byteArrayValue, byteOffset, this.value, this.length, byteLength); this.length += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteArrayValue == null) { if (length == byteLength) { return this; } } else { final int byteLength2 = byteLength; if (byteLength > length) { byte[] byteArrayNew = new byte[byteLength2]; System.arraycopy(byteArrayValue, byteOffset, byteArrayNew, 0, byteLength2); byteArray = byteArrayNew; } else { byteArray = byteArrayValue; } length = byteLength; } if (length > MAX_BYTE_ARRAY_LENGTH) { throw new IllegalArgumentException(\"length > MAX_BYTE_ARRAY_LENGTH\"); } if (byteOffset < 0) { if (byteOffset + byteLength > byteArrayValue.length) { throw new IllegalArgumentException(\"byteOffset + byteLength > byteArrayValue.length\"); } } else { if (byteOffset + byteLength > length) { throw new IllegalArgumentException(\"byteOffset + byteLength < length\"); } } if (byteLength == 0) { return this; } if (byteOffset == 0) { if (byteLength >= byteArrayValue.length) { byte[] byteArrayNew = new byte[byteArrayValue.length]; System.arraycopy(byteArrayValue, 0, byteArrayNew, 0, byteArrayValue.length); byteArray = byteArrayNew; } } else { byte[] byteArrayNew = new byte[byteLength]; System.arraycopy(byteArrayValue, byteOffset, byteArrayNew, 0, byteLength); byteArray = byteArrayNew; } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > 4) { throw new IllegalArgumentException(); } int newlength = length + byteLength; if (newlength > data.length) { enlarge(newlength); } System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength); length = newlength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > byteArrayValue.length - byteOffset) { throw new IllegalArgumentException(\"byteArrayValue.length > byteOffset + byteLength\"); } if (this._buffer.length - this._position < byteLength) { expand(byteLength); } System.arraycopy(byteArrayValue, byteOffset, this._buffer, this._position, byteLength); this._position += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > byteArray.length) { final int resize = byteLength + (byteArray.length - byteOffset); byte[] newArray = new byte[resize]; System.arraycopy(byteArray, byteOffset, newArray, 0, byteLength); byteArray = newArray; } System.arraycopy(byteArrayValue, byteOffset, byteArray, byteOffset + byteLength, byteLength); return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > byteArrayLength) { enlarge(byteLength); } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteArrayPointer, byteLength); this.byteArrayPointer += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > 8) { throw new RuntimeException(\"Cannot store more than 8 byte values\"); } if (byteLength == 0) { return this; } if (byteLength == byteArrayValue.length) { putByte(byteArrayValue[byteOffset]); return this; } int currentOffset = byteOffset; final int arrayLength = byteLength; final int newLength = this.array.length + arrayLength; byte[] newArray = new byte[newLength]; System.arraycopy(this.array, 0, newArray, 0, currentOffset); System.arraycopy(byteArrayValue, 0, newArray, currentOffset, arrayLength); this.array = newArray; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ int currentLength = this.length; if (byteLength > currentLength) { throw new BufferOverflowException(); } System.arraycopy(byteArrayValue, byteOffset, this.bytes, this.length, byteLength); this.length = currentLength + byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength == 0) { return this; } if (byteLength > length()) { enlarge(byteLength); } System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteArrayPosition, byteLength); this.byteArrayPosition += byteLength; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > byteArrayLength) { byteLength = byteArrayLength; } putBytes(byteArrayValue, byteOffset, byteLength); return this; }"], "code_level": "class_runnable", "_id": "6367671a1a6d9265ec017c15", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void pop(final String descriptor) {\n  if (this.value == null) {\n    throw new IllegalStateException(\"Cannot pop a value without a value\");\n  } else {\n    this.value.pop(descriptor);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.length() > 1) {\n    final int i = descriptor.charAt(0) - '0';\n    if (descriptor.length() > 2) {\n      final int j = descriptor.charAt(1) - '0';\n      if (descriptor.length() > 3) {\n        final int k = descriptor.charAt(2) - '0';\n        if (descriptor.length() > 4) {\n          final int l = descriptor.charAt(3) - '0';\n          if (descriptor.length() > 5) {\n            final int m = descriptor.charAt(4) - '0';\n            if (descriptor.length() > 6) {\n              final int n = descriptor.charAt(5) - '0';\n              if (descriptor.length() > 7) {\n                final int o = descriptor.charAt(6) - '0';\n                if (descriptor.length() > 8) {\n                  final int p = descriptor.charAt(7) - '0';\n                  if (descriptor.length() > 9) {\n                    final int q = descriptor.charAt(8) - '0';\n                    if (descriptor.length() > 10) {\n                      final int r = descriptor.charAt(9) - '0';\n                      if (descriptor.length() > 11) {\n                        final int s = descriptor.charAt(10) - '0';\n                        if (descriptor.length() > 12) {\n                          final int t = descriptor.charAt(11) - '0';\n                          if (descriptor.length() > 13) {\n                            final int u = descriptor.charAt(12) - '0';\n                            if (descriptor.length() > 14) {\n                              final int v = descriptor.charAt(13) - '0';\n                              if (descriptor.length() > 15) {\n                                final int w = descriptor.charAt(14) - '0';\n                                if (descriptor.length() > 16) {\n                                  final int x = descriptor.charAt(15) - '0';\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  final int size = getSize(descriptor);\n  if (size > 0) {\n    mv.visitInsn(DUP);\n    mv.visitInsn(POP);\n    mv.visitInsn(DUP);\n    mv.visitInsn(POP);\n    mv.visitInsn(DUP);\n    mv.visitInsn(POP);\n    mv.visitInsn(DUP);\n    mv.visitInsn(POP);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.length() > 1) {\n    final String trimmed = descriptor.substring(0, descriptor.length() - 1);\n    if (trimmed.length() > 0) {\n      if (trimmed.charAt(0) == 'L') {\n        final int index = trimmed.indexOf(';');\n        if (index == -1) {\n          valueStack.pop();\n        } else {\n          valueStack.pop();\n          valueStack.push(new Integer(trimmed.substring(1, index)));\n        }\n      } else {\n        valueStack.pop();\n        valueStack.push(new Integer(trimmed));\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.length() <= 1) {\n    return;\n  }\n  char first = descriptor.charAt(0);\n  if (first == '(') {\n    stack.pop();\n  } else if (first == '[') {\n    stack.pop();\n  } else {\n    stack.pop();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  final int index = descriptor.indexOf('(');\n  if (index >= 0) {\n    final String type = descriptor.substring(0, index).trim();\n    final String value = descriptor.substring(index + 1).trim();\n    if (type.equals(\"L\")) {\n      if (value.startsWith(\"[\")) {\n        pop(value.substring(1));\n      } else {\n        pop(value);\n      }\n    } else {\n      pop(type);\n    }\n  } else {\n    pop(descriptor);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.length() == 1) {\n    pop();\n  } else {\n    pop(2);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  String value = popStack.pop();\n  if (value.length() == 0) {\n    if (!isExternal(descriptor)) {\n      throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptor);\n    }\n  } else {\n    if (value.charAt(0) != descriptor.charAt(0)) {\n      throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptor);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.length() > 0) {\n    if (descriptor.charAt(0) == '(') {\n      if (descriptor.charAt(descriptor.length() - 1) == ')') {\n        this.instructions.add(\n            new Instruction(Opcode.POP, descriptor.substring(1, descriptor.length() - 1)));\n      } else {\n        throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptor);\n      }\n    } else {\n      this.instructions.add(new Instruction(Opcode.POP, descriptor));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.length() >= 2) {\n    final char firstChar = descriptor.charAt(0);\n    if (firstChar == 'L') {\n      pop(descriptor.substring(1));\n    } else if (firstChar == '[') {\n      pop(descriptor.substring(1));\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n", "method_name": "pop", "codes": ["private void pop(final String descriptor){ if (this.value == null) { throw new IllegalStateException(\"Cannot pop a value without a value\"); } else { this.value.pop(descriptor); } }", "private void pop(final String descriptor){ if (descriptor.length() > 1) { final int i = descriptor.charAt(0) - '0'; if (descriptor.length() > 2) { final int j = descriptor.charAt(1) - '0'; if (descriptor.length() > 3) { final int k = descriptor.charAt(2) - '0'; if (descriptor.length() > 4) { final int l = descriptor.charAt(3) - '0'; if (descriptor.length() > 5) { final int m = descriptor.charAt(4) - '0'; if (descriptor.length() > 6) { final int n = descriptor.charAt(5) - '0'; if (descriptor.length() > 7) { final int o = descriptor.charAt(6) - '0'; if (descriptor.length() > 8) { final int p = descriptor.charAt(7) - '0'; if (descriptor.length() > 9) { final int q = descriptor.charAt(8) - '0'; if (descriptor.length() > 10) { final int r = descriptor.charAt(9) - '0'; if (descriptor.length() > 11) { final int s = descriptor.charAt(10) - '0'; if (descriptor.length() > 12) { final int t = descriptor.charAt(11) - '0'; if (descriptor.length() > 13) { final int u = descriptor.charAt(12) - '0'; if (descriptor.length() > 14) { final int v = descriptor.charAt(13) - '0'; if (descriptor.length() > 15) { final int w = descriptor.charAt(14) - '0'; if (descriptor.length() > 16) { final int x = descriptor.charAt(15) - '0'; } } } } } } } } } } } } } } } } }", "private void pop(final String descriptor){ final int size = getSize(descriptor); if (size > 0) { mv.visitInsn(DUP); mv.visitInsn(POP); mv.visitInsn(DUP); mv.visitInsn(POP); mv.visitInsn(DUP); mv.visitInsn(POP); mv.visitInsn(DUP); mv.visitInsn(POP); } }", "private void pop(final String descriptor){ if (descriptor.length() > 1) { final String trimmed = descriptor.substring(0, descriptor.length() - 1); if (trimmed.length() > 0) { if (trimmed.charAt(0) == 'L') { final int index = trimmed.indexOf(';'); if (index == -1) { valueStack.pop(); } else { valueStack.pop(); valueStack.push(new Integer(trimmed.substring(1, index))); } } else { valueStack.pop(); valueStack.push(new Integer(trimmed)); } } } }", "private void pop(final String descriptor){ if (descriptor.length() <= 1) { return; } char first = descriptor.charAt(0); if (first == '(') { stack.pop(); } else if (first == '[') { stack.pop(); } else { stack.pop(); } }", "private void pop(final String descriptor){ final int index = descriptor.indexOf('('); if (index >= 0) { final String type = descriptor.substring(0, index).trim(); final String value = descriptor.substring(index + 1).trim(); if (type.equals(\"L\")) { if (value.startsWith(\"[\")) { pop(value.substring(1)); } else { pop(value); } } else { pop(type); } } else { pop(descriptor); } }", "private void pop(final String descriptor){ if (descriptor.length() == 1) { pop(); } else { pop(2); } }", "private void pop(final String descriptor){ String value = popStack.pop(); if (value.length() == 0) { if (!isExternal(descriptor)) { throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptor); } } else { if (value.charAt(0) != descriptor.charAt(0)) { throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptor); } } }", "private void pop(final String descriptor){ if (descriptor.length() > 0) { if (descriptor.charAt(0) == '(') { if (descriptor.charAt(descriptor.length() - 1) == ')') { this.instructions.add(new Instruction(Opcode.POP, descriptor.substring(1, descriptor.length() - 1))); } else { throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptor); } } else { this.instructions.add(new Instruction(Opcode.POP, descriptor)); } } }", "private void pop(final String descriptor){ if (descriptor.length() >= 2) { final char firstChar = descriptor.charAt(0); if (firstChar == 'L') { pop(descriptor.substring(1)); } else if (firstChar == '[') { pop(descriptor.substring(1)); } } }"], "code_level": "class_runnable", "_id": "636767021a6d9265ec0178b2", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void addInitializedType(final int abstractType) {\n  if (!initializedTypes.containsKey(abstractType)) {\n    initializedTypes.put(abstractType, new HashMap<Integer, Integer>());\n  }\n  final Map<Integer, Integer> abstractTypes = initializedTypes.get(abstractType);\n  abstractTypes.put(initializations.size(), abstractType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  if (this.initializedTypes.containsKey(abstractType)) {\n    return;\n  }\n  this.initializedTypes.put(abstractType, new HashSet<Integer>());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  if (initializedTypes.containsKey(abstractType)) {\n    initializedTypes.get(abstractType).add(abstractType);\n  } else {\n    final LinkedList<Integer> l = new LinkedList<Integer>();\n    l.add(abstractType);\n    initializedTypes.put(abstractType, l);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  if (initializedTypes.contains(abstractType)) {\n    return;\n  }\n  initializedTypes.add(abstractType);\n  if (abstractType == CLASS_OBJECT) {\n    if (!initializedClassObjects.isEmpty()) {\n      initializedClassObjects.add(new InitializedClassObject(classObject.getDeclaration()));\n    }\n  } else if (abstractType == CLASS_INTERFACE) {\n    if (!initializedClassInterfaces.isEmpty()) {\n      initializedClassInterfaces.add(\n          new InitializedClassInterface(classInterface.getDeclaration()));\n    }\n  } else if (abstractType == CLASS_ENUM) {\n    if (!initializedClassEnums.isEmpty()) {\n      initializedClassEnums.add(new InitializedClassEnum(classEnum.getDeclaration()));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  final int type = getInitializedType(abstractType);\n  final Type typed = new Type(type, abstractType);\n  initializedTypes.add(typed);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  final Type t = new Type(abstractType);\n  if (!initializations.containsKey(t)) {\n    initializations.put(t, new ArrayList<Type>());\n  }\n  initializations.get(t).add(t);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  if (!initializedTypes.containsKey(abstractType)) {\n    initializedTypes.put(abstractType, new ArrayList<Integer>());\n  }\n  initializedTypes.get(abstractType).add(abstractType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  if (this.initializedTypes.contains(abstractType)) {\n    return;\n  }\n  this.initializedTypes.add(abstractType);\n  if (this.initializedTypes.size() == 1) {\n    this.type = this.initializedTypes.get(0);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  final int abstractTypeIndex = abstractType - 1;\n  if (initializedTypes[abstractTypeIndex] == -1) {\n    initializedTypes[abstractTypeIndex] = abstractType;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType) {\n  final int type = abstractType;\n  if (initializedTypes.containsKey(type)) {\n    return;\n  }\n  initializedTypes.put(type, abstractType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n", "method_name": "addInitializedType", "codes": ["private void addInitializedType(final int abstractType){ if (!initializedTypes.containsKey(abstractType)) { initializedTypes.put(abstractType, new HashMap<Integer, Integer>()); } final Map<Integer, Integer> abstractTypes = initializedTypes.get(abstractType); abstractTypes.put(initializations.size(), abstractType); }", "private void addInitializedType(final int abstractType){ if (this.initializedTypes.containsKey(abstractType)) { return; } this.initializedTypes.put(abstractType, new HashSet<Integer>()); }", "private void addInitializedType(final int abstractType){ if (initializedTypes.containsKey(abstractType)) { initializedTypes.get(abstractType).add(abstractType); } else { final LinkedList<Integer> l = new LinkedList<Integer>(); l.add(abstractType); initializedTypes.put(abstractType, l); } }", "private void addInitializedType(final int abstractType){ if (initializedTypes.contains(abstractType)) { return; } initializedTypes.add(abstractType); if (abstractType == CLASS_OBJECT) { if (!initializedClassObjects.isEmpty()) { initializedClassObjects.add(new InitializedClassObject(classObject.getDeclaration())); } } else if (abstractType == CLASS_INTERFACE) { if (!initializedClassInterfaces.isEmpty()) { initializedClassInterfaces.add(new InitializedClassInterface(classInterface.getDeclaration())); } } else if (abstractType == CLASS_ENUM) { if (!initializedClassEnums.isEmpty()) { initializedClassEnums.add(new InitializedClassEnum(classEnum.getDeclaration())); } } }", "private void addInitializedType(final int abstractType){ final int type = getInitializedType(abstractType); final Type typed = new Type(type, abstractType); initializedTypes.add(typed); }", "private void addInitializedType(final int abstractType){ final Type t = new Type(abstractType); if (!initializations.containsKey(t)) { initializations.put(t, new ArrayList<Type>()); } initializations.get(t).add(t); }", "private void addInitializedType(final int abstractType){ if (!initializedTypes.containsKey(abstractType)) { initializedTypes.put(abstractType, new ArrayList<Integer>()); } initializedTypes.get(abstractType).add(abstractType); }", "private void addInitializedType(final int abstractType){ if (this.initializedTypes.contains(abstractType)) { return; } this.initializedTypes.add(abstractType); if (this.initializedTypes.size() == 1) { this.type = this.initializedTypes.get(0); } }", "private void addInitializedType(final int abstractType){ final int abstractTypeIndex = abstractType - 1; if (initializedTypes[abstractTypeIndex] == -1) { initializedTypes[abstractTypeIndex] = abstractType; } }", "private void addInitializedType(final int abstractType){ final int type = abstractType; if (initializedTypes.containsKey(type)) { return; } initializedTypes.put(type, abstractType); }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec0177a9", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  final AbstractType<?> t = AbstractType.getInstance(this.column.type);\n  for (int i = start; i < end; i++) {\n    this.types.add(t);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){ final int n = end - start; final int n2 = n >> 3; final int n3 = n & 7; final int n4 = n2; final int n5 = n3; final int n6 = n4; final int n7 = n5; final int n8 = n6; final int n9 = n7; final int n10 = n8; final int n11 = n9; final int n12 = n10; final int n13 = n11; final int n14 = n12; final int n15 = n13; final int n16 = n14; final int n17 = n15; final int n18 = n16; final int n19 = n17; final int n20 = n18; final int n21 = n19; final int n22 = n20; final int n23 = n21; final int n24 = n22; final int n25 = n24; final int n26 = n25; final int n27 = n26; final int n28 = n27; final int n29 = n28; final int n30 = n29; final int n31 = n30; final int n32 = n31; final int n33 = n32; final int n34 = n33; final int n35 = n34; final int n36 = n35; final int n37 = n36; final int n38 = n37; final int n39 = n38; final int n40 = n39; final int n41 = n40; final int n42 = n41; final int n43 = n42; final int n44 = n43; final int n45 = n44; final int n46 = n45; final int n47 = n46; final int n48 = n47; final int n49 = n48; final int n50 = n49; final int n51 = n50; final int n52 = n51; final int n53 = n52; final int n54 = n53; final int n55 = n54; final int n56 = n55; final int n57 = n56; final int n58 = n57; final int n59 = n58; final int n60 = n59; final int n61 = n60; final int n62 = n61; final int n63 = n62; final int n64 = n63; final int n65 = n64; final int n66 = n65; final int n67 = n66; final int n68 = n67; final int n69 = n68; final int n70 = n69; final int n71 = n70; final int n72 = n71; final int n73 = n72; final int n74 = n73; final int n75 = n74; final int n76 = n75; final int n77 = n76; final int n78 = n77; final int n79 = n78; final int n80 = n79; final int n81 = n80; final int n82 = n81; final int n83 = n82; final int n84 = n83; final int n85 = n84; final int n86 = n85; final int n87 = n86; final int n88 = n87; final int n89 = n88; final in", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  final int currentLength = end - start;\n  for (int i = start; i < end; ++i) {\n    putAbstractType(i);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  final int[] tmp = new int[end - start];\n  for (int i = start; i < end; i++) {\n    tmp[i - start] = this.types[i];\n  }\n  this.types = tmp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  final boolean[] abstractTypes = new boolean[end - start];\n  for (int i = start; i < end; i++) {\n    abstractTypes[i - start] = true;\n  }\n  for (int i = 0; i < abstractTypes.length; i++) {\n    if (abstractTypes[i]) {\n      if (i == 0) {\n        m_Frame.put(i, new Integer(\"0\"));\n      } else {\n        m_Frame.put(i, new Integer(\"1\"));\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  if (start >= end) {\n    return;\n  }\n  final int i = start;\n  while (i < end) {\n    final TypeInfo type = types.get(i);\n    final int j = i + 1;\n    while (j < end) {\n      if (type.isAbstract()) {\n        types.set(j, type.newAbstractType(type.getName()));\n      }\n      j++;\n    }\n    i++;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  final int currentFrameOffset = currentFrame.getOffset();\n  if (currentFrameOffset >= start && currentFrameOffset <= end) {\n    final int currentFrameLength = currentFrame.getLength();\n    final int typeId = currentFrame.getTypeId();\n    if (typeId == TypeIds.OBJECT || typeId == TypeIds.OBJECT_ARRAY) {\n      final int typeArrayOffset = currentFrameOffset + currentFrameLength + 1;\n      final int typeArrayLength = currentFrameLength - typeArrayOffset;\n      currentFrame.setTypeArray(typeArrayOffset, typeArrayLength);\n    } else if (typeId == TypeIds.BOOLEAN) {\n      putBoolean(currentFrameOffset, currentFrameLength);\n    } else if (typeId == TypeIds.BYTE) {\n      putByte(currentFrameOffset, currentFrameLength);\n    } else if (typeId == TypeIds.CHAR) {\n      putChar(currentFrameOffset, currentFrameLength);\n    } else if (typeId == TypeIds.DOUBLE) {\n      putDouble(currentFrameOffset, currentFrameLength);\n    } else if (typeId == TypeIds.FLOAT) {\n      putFloat(currentFrameOffset, currentFrameLength);\n    } else if (typeId == TypeIds.INT) {\n      putInt(currentFrameOffset, currentFrameLength);\n    } else if (typeId == TypeIds.LONG) {\n      putLong(currentFrameOffset, currentFrameLength);\n    } else if (typeId == TypeIds.SHORT) {\n      putShort(currentFrameOffset, currentFrameLength);\n    } else if (typeId == TypeIds.OBJECT_ARRAY) {\n      putObjectArray(currentFrameOffset, currentFrameLength);\n    } else {\n      throw new IllegalStateException(\"Unknown type id: \" + typeId);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  for (int i = start; i < end; i++) {\n    this.abstractTypes.put(i, this.frame.get(i).getAbstractType());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  for (int i = start; i < end; i++) {\n    final AbstractType<?> t = AbstractType.getInstance(getColumn(i).getType());\n    addFrame(i, t);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start, final int end) {\n  if (!isAbstract) {\n    final int numTypes = typeList.size();\n    final int numElements = end - start;\n    if (numTypes > 0) {\n      final int[] abstractTypes = new int[numTypes];\n      final int[] elementTypes = new int[numElements];\n      for (int i = 0; i < numTypes; i++) {\n        abstractTypes[i] = typeList.get(i).getAbstractType();\n        elementTypes[i] = typeList.get(i).getElementType();\n      }\n      put(abstractTypes);\n      put(elementTypes);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.\n * @param start index of the first type in {@link #currentFrame} to write.\n * @param end index of last type in {@link #currentFrame} to write (exclusive).\n */\n", "method_name": "putAbstractTypes", "codes": ["private void putAbstractTypes(final int start,final int end){ final AbstractType<?> t = AbstractType.getInstance(this.column.type); for (int i = start; i < end; i++) { this.types.add(t); } }", "private void putAbstractTypes(final int start,final int end){ final int n = end - start; final int n2 = n >> 3; final int n3 = n & 7; final int n4 = n2; final int n5 = n3; final int n6 = n4; final int n7 = n5; final int n8 = n6; final int n9 = n7; final int n10 = n8; final int n11 = n9; final int n12 = n10; final int n13 = n11; final int n14 = n12; final int n15 = n13; final int n16 = n14; final int n17 = n15; final int n18 = n16; final int n19 = n17; final int n20 = n18; final int n21 = n19; final int n22 = n20; final int n23 = n21; final int n24 = n22; final int n25 = n24; final int n26 = n25; final int n27 = n26; final int n28 = n27; final int n29 = n28; final int n30 = n29; final int n31 = n30; final int n32 = n31; final int n33 = n32; final int n34 = n33; final int n35 = n34; final int n36 = n35; final int n37 = n36; final int n38 = n37; final int n39 = n38; final int n40 = n39; final int n41 = n40; final int n42 = n41; final int n43 = n42; final int n44 = n43; final int n45 = n44; final int n46 = n45; final int n47 = n46; final int n48 = n47; final int n49 = n48; final int n50 = n49; final int n51 = n50; final int n52 = n51; final int n53 = n52; final int n54 = n53; final int n55 = n54; final int n56 = n55; final int n57 = n56; final int n58 = n57; final int n59 = n58; final int n60 = n59; final int n61 = n60; final int n62 = n61; final int n63 = n62; final int n64 = n63; final int n65 = n64; final int n66 = n65; final int n67 = n66; final int n68 = n67; final int n69 = n68; final int n70 = n69; final int n71 = n70; final int n72 = n71; final int n73 = n72; final int n74 = n73; final int n75 = n74; final int n76 = n75; final int n77 = n76; final int n78 = n77; final int n79 = n78; final int n80 = n79; final int n81 = n80; final int n82 = n81; final int n83 = n82; final int n84 = n83; final int n85 = n84; final int n86 = n85; final int n87 = n86; final int n88 = n87; final int n89 = n88; final in", "private void putAbstractTypes(final int start,final int end){ final int currentLength = end - start; for (int i = start; i < end; ++i) { putAbstractType(i); } }", "private void putAbstractTypes(final int start,final int end){ final int[] tmp = new int[end - start]; for (int i = start; i < end; i++) { tmp[i - start] = this.types[i]; } this.types = tmp; }", "private void putAbstractTypes(final int start,final int end){ final boolean[] abstractTypes = new boolean[end - start]; for (int i = start; i < end; i++) { abstractTypes[i - start] = true; } for (int i = 0; i < abstractTypes.length; i++) { if (abstractTypes[i]) { if (i == 0) { m_Frame.put(i, new Integer(\"0\")); } else { m_Frame.put(i, new Integer(\"1\")); } } } }", "private void putAbstractTypes(final int start,final int end){ if (start >= end) { return; } final int i = start; while (i < end) { final TypeInfo type = types.get(i); final int j = i + 1; while (j < end) { if (type.isAbstract()) { types.set(j, type.newAbstractType(type.getName())); } j++; } i++; } }", "private void putAbstractTypes(final int start,final int end){ final int currentFrameOffset = currentFrame.getOffset(); if (currentFrameOffset >= start && currentFrameOffset <= end) { final int currentFrameLength = currentFrame.getLength(); final int typeId = currentFrame.getTypeId(); if (typeId == TypeIds.OBJECT || typeId == TypeIds.OBJECT_ARRAY) { final int typeArrayOffset = currentFrameOffset + currentFrameLength + 1; final int typeArrayLength = currentFrameLength - typeArrayOffset; currentFrame.setTypeArray(typeArrayOffset, typeArrayLength); } else if (typeId == TypeIds.BOOLEAN) { putBoolean(currentFrameOffset, currentFrameLength); } else if (typeId == TypeIds.BYTE) { putByte(currentFrameOffset, currentFrameLength); } else if (typeId == TypeIds.CHAR) { putChar(currentFrameOffset, currentFrameLength); } else if (typeId == TypeIds.DOUBLE) { putDouble(currentFrameOffset, currentFrameLength); } else if (typeId == TypeIds.FLOAT) { putFloat(currentFrameOffset, currentFrameLength); } else if (typeId == TypeIds.INT) { putInt(currentFrameOffset, currentFrameLength); } else if (typeId == TypeIds.LONG) { putLong(currentFrameOffset, currentFrameLength); } else if (typeId == TypeIds.SHORT) { putShort(currentFrameOffset, currentFrameLength); } else if (typeId == TypeIds.OBJECT_ARRAY) { putObjectArray(currentFrameOffset, currentFrameLength); } else { throw new IllegalStateException(\"Unknown type id: \" + typeId); } } }", "private void putAbstractTypes(final int start,final int end){ for (int i = start; i < end; i++) { this.abstractTypes.put(i, this.frame.get(i).getAbstractType()); } }", "private void putAbstractTypes(final int start,final int end){ for (int i = start; i < end; i++) { final AbstractType<?> t = AbstractType.getInstance(getColumn(i).getType()); addFrame(i, t); } }", "private void putAbstractTypes(final int start,final int end){ if (!isAbstract) { final int numTypes = typeList.size(); final int numElements = end - start; if (numTypes > 0) { final int[] abstractTypes = new int[numTypes]; final int[] elementTypes = new int[numElements]; for (int i = 0; i < numTypes; i++) { abstractTypes[i] = typeList.get(i).getAbstractType(); elementTypes[i] = typeList.get(i).getElementType(); } put(abstractTypes); put(elementTypes); } } }"], "code_level": "project_runnable", "_id": "6367670a1a6d9265ec0179dc", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public short readShort(final int offset) {\n  return (short) (readByte(offset) << 8 | readByte(offset + 1) & 0xff);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public short readShort(final int offset) {\n  return classFileBuffer.readShort(offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return classFileBuffer[offset];\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  final int byteOffset = offset;\n  return (short)\n      ((classFileBuffer[byteOffset] & 0xff) | ((classFileBuffer[byteOffset + 1] << 8) & 0xff00));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return (short) ((classFileBuffer.getShort(offset)) & 0xffff);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return classFileBuffer.getShort(offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return m_buffer.getShort(offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return classFileBuffer.getShort(offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return classFileBuffer[offset];\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public short readShort(final int offset) {\n  return classFileBuffer.getShort(offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a signed short value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n", "method_name": "readShort", "codes": ["public short readShort(final int offset){ return (short) (readByte(offset) << 8 | readByte(offset + 1) & 0xff); }", "public short readShort(final int offset){ return classFileBuffer.readShort(offset); }", "public short readShort(final int offset){ return classFileBuffer[offset]; }", "public short readShort(final int offset){ final int byteOffset = offset; return (short) ((classFileBuffer[byteOffset] & 0xff) | ((classFileBuffer[byteOffset + 1] << 8) & 0xff00)); }", "public short readShort(final int offset){ return (short) ((classFileBuffer.getShort(offset)) & 0xffff); }", "public short readShort(final int offset){ return classFileBuffer.getShort(offset); }", "public short readShort(final int offset){ return m_buffer.getShort(offset); }", "public short readShort(final int offset){ return classFileBuffer.getShort(offset); }", "public short readShort(final int offset){ return classFileBuffer[offset]; }", "public short readShort(final int offset){ return classFileBuffer.getShort(offset); }"], "code_level": "class_runnable", "_id": "636766f21a6d9265ec017667", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label l = labels[bytecodeOffset];\n  if (l == null) {\n    l = new Label();\n    labels[bytecodeOffset] = l;\n  }\n  return l;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label l = labels[bytecodeOffset];\n  if (l == null) {\n    l = new Label();\n    labels[bytecodeOffset] = l;\n  }\n  return l;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label label = labels[bytecodeOffset];\n  if (label == null) {\n    label = new Label();\n    labels[bytecodeOffset] = label;\n  }\n  return label;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  if (bytecodeOffset == 0) {\n    return labels[0];\n  }\n  int index = bytecodeOffset >>> 8;\n  Label l = labels[index];\n  if (l == null) {\n    l = new Label();\n    labels[index] = l;\n  }\n  return l;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label l = labels[bytecodeOffset];\n  if (l == null) {\n    l = new Label();\n    labels[bytecodeOffset] = l;\n  }\n  return l;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label ret = labels[bytecodeOffset];\n  if (ret == null) {\n    ret = new Label();\n    labels[bytecodeOffset] = ret;\n  }\n  return ret;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label ret = labels[bytecodeOffset];\n  if (ret == null) {\n    ret = new Label();\n    labels[bytecodeOffset] = ret;\n  }\n  return ret;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  if (bytecodeOffset == 0) {\n    return labels[0];\n  } else {\n    Label label = labels[bytecodeOffset - 1];\n    if (label == null) {\n      label = new Label();\n      labels[bytecodeOffset - 1] = label;\n    }\n    return label;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label l = labels[bytecodeOffset];\n  if (l == null) {\n    l = new Label();\n    labels[bytecodeOffset] = l;\n  }\n  return l;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n  Label label = labels[bytecodeOffset];\n  if (label == null) {\n    label = new Label();\n    labels[bytecodeOffset] = label;\n  }\n  return label;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n", "method_name": "readLabel", "codes": ["protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label l = labels[bytecodeOffset]; if (l == null) { l = new Label(); labels[bytecodeOffset] = l; } return l; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label l = labels[bytecodeOffset]; if (l == null) { l = new Label(); labels[bytecodeOffset] = l; } return l; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label label = labels[bytecodeOffset]; if (label == null) { label = new Label(); labels[bytecodeOffset] = label; } return label; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ if (bytecodeOffset == 0) { return labels[0]; } int index = bytecodeOffset >>> 8; Label l = labels[index]; if (l == null) { l = new Label(); labels[index] = l; } return l; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label l = labels[bytecodeOffset]; if (l == null) { l = new Label(); labels[bytecodeOffset] = l; } return l; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label ret = labels[bytecodeOffset]; if (ret == null) { ret = new Label(); labels[bytecodeOffset] = ret; } return ret; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label ret = labels[bytecodeOffset]; if (ret == null) { ret = new Label(); labels[bytecodeOffset] = ret; } return ret; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ if (bytecodeOffset == 0) { return labels[0]; } else { Label label = labels[bytecodeOffset - 1]; if (label == null) { label = new Label(); labels[bytecodeOffset - 1] = label; } return label; } }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label l = labels[bytecodeOffset]; if (l == null) { l = new Label(); labels[bytecodeOffset] = l; } return l; }", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){ Label label = labels[bytecodeOffset]; if (label == null) { label = new Label(); labels[bytecodeOffset] = label; } return label; }"], "code_level": "self_contained", "_id": "636766ff1a6d9265ec017853", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int utf8Length = this.readUnsignedShort(constantPoolEntryIndex);\n  if (utf8Length < 0) {\n    return null;\n  }\n  final String utf8 = new String(charBuffer, 0, utf8Length);\n  this.readUnsignedShort(constantPoolEntryIndex + 2);\n  return utf8;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  int utf8Index = constantPoolEntryIndex;\n  if (utf8Index >= this.maxConstantPoolEntries) {\n    throw new RuntimeException(\n        \"This method requires at least \"\n            + this.maxConstantPoolEntries\n            + \" constant pool entries\");\n  }\n  final int utf8Count = this.readUnsignedShort(utf8Index);\n  utf8Index += 2;\n  final int charCount = this.readUnsignedShort(utf8Index);\n  utf8Index += 2;\n  final StringBuilder utf8 = new StringBuilder(charCount);\n  if (utf8Count > charCount) {\n    throw new RuntimeException(\"This method requires \" + charCount + \" chars in the utf8 value\");\n  }\n  for (int i = 0; i < utf8Count; i++) {\n    utf8.append(charBuffer, charIndex, charIndex + charCount);\n    charIndex += charCount;\n  }\n  return utf8.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int index = constantPoolEntryIndex - 1;\n  final int utf8Length = readUnsignedShort(index);\n  final byte[] utf8Bytes = new byte[utf8Length];\n  System.arraycopy(classFileBuffer, index + 2, utf8Bytes, 0, utf8Length);\n  return new String(utf8Bytes, charBuffer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int index = this.readUnsignedShort(constantPoolEntryIndex);\n  if (index < 0) {\n    return null;\n  }\n  this.readUnsignedShort(index);\n  final int nameIndex = this.readUnsignedShort(index);\n  final int signatureIndex = this.readUnsignedShort(index + 2);\n  final int valueIndex = this.readUnsignedShort(index + 4);\n  if (nameIndex < 0) {\n    return null;\n  }\n  if (signatureIndex < 0) {\n    return null;\n  }\n  final int nameAndTypeIndex = this.readUnsignedShort(index + 6);\n  if (nameAndTypeIndex < 0) {\n    return null;\n  }\n  final int nameAndTypeLength = this.readUnsignedShort(nameAndTypeIndex);\n  if (nameAndTypeLength < 0) {\n    return null;\n  }\n  final char[] nameAndType = new char[nameAndTypeLength];\n  for (int j = 0; j < nameAndTypeLength; j++) {\n    nameAndType[j] = charBuffer[index + 6 + j];\n  }\n  return new String(nameAndType);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  int cpIndex = constantPoolEntryIndex;\n  final int utfSize = cpIndex - cpIndexBegin;\n  final char[] chars = new char[utfSize];\n  for (int i = 0; i < utfSize; i++) {\n    chars[i] = charBuffer[cpIndex++];\n  }\n  return new String(chars);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int utfLength = readUtf(constantPoolEntryIndex, charBuffer, 0, charBuffer.length);\n  return new String(charBuffer, 0, utfLength);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int index = charBuffer.length * 2;\n  final int charPos = charBuffer[index];\n  if (charPos == 0) {\n    return \"\";\n  }\n  final int charCount = (charPos & 0xFF) >> 5;\n  final int stringIndex = (charPos & 0x1F);\n  final int stringLength = (charPos & 0x1F) + 1;\n  final byte[] stringBuffer = this.stringBuffer;\n  charBuffer[index] = (char) (stringBuffer[stringIndex] & 0xFF);\n  charBuffer[index + 1] = (char) (stringBuffer[stringIndex + 1] & 0xFF);\n  charBuffer[index + 2] = (char) (stringBuffer[stringIndex + 2] & 0xFF);\n  charBuffer[index + 3] = (char) (stringBuffer[stringIndex + 3] & 0xFF);\n  return new String(charBuffer, 0, charCount);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int utfLength = readUtf(constantPoolEntryIndex, charBuffer, 0);\n  return new String(charBuffer, 0, utfLength);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  if (constantPoolEntryIndex < 0) {\n    return null;\n  }\n  final int charBufferIndex = constantPoolEntryIndex >>> 6;\n  final int charBufferOffset = constantPoolEntryIndex & 0x3f;\n  final int utf8Offset = charBufferOffset + (charBuffer.length - 1);\n  final int utf8Length = this.readUnsignedShort(utf8Offset);\n  final char[] utf8Chars = new char[utf8Length];\n  this.readChars(utf8Chars, charBufferOffset, utf8Length);\n  return new String(utf8Chars);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n  final int utfLength = readUnsignedShort(constantPoolEntryIndex);\n  if (utfLength > charBuffer.length) {\n    charBuffer = new char[utfLength];\n  }\n  readFully(constantPoolEntryIndex, charBuffer);\n  return new String(charBuffer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.\n * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.\n * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n */\n", "method_name": "readUtf", "codes": ["final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int utf8Length = this.readUnsignedShort(constantPoolEntryIndex); if (utf8Length < 0) { return null; } final String utf8 = new String(charBuffer, 0, utf8Length); this.readUnsignedShort(constantPoolEntryIndex + 2); return utf8; }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ int utf8Index = constantPoolEntryIndex; if (utf8Index >= this.maxConstantPoolEntries) { throw new RuntimeException(\"This method requires at least \" + this.maxConstantPoolEntries + \" constant pool entries\"); } final int utf8Count = this.readUnsignedShort(utf8Index); utf8Index += 2; final int charCount = this.readUnsignedShort(utf8Index); utf8Index += 2; final StringBuilder utf8 = new StringBuilder(charCount); if (utf8Count > charCount) { throw new RuntimeException(\"This method requires \" + charCount + \" chars in the utf8 value\"); } for (int i = 0; i < utf8Count; i++) { utf8.append(charBuffer, charIndex, charIndex + charCount); charIndex += charCount; } return utf8.toString(); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int index = constantPoolEntryIndex - 1; final int utf8Length = readUnsignedShort(index); final byte[] utf8Bytes = new byte[utf8Length]; System.arraycopy(classFileBuffer, index + 2, utf8Bytes, 0, utf8Length); return new String(utf8Bytes, charBuffer); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int index = this.readUnsignedShort(constantPoolEntryIndex); if (index < 0) { return null; } this.readUnsignedShort(index); final int nameIndex = this.readUnsignedShort(index); final int signatureIndex = this.readUnsignedShort(index + 2); final int valueIndex = this.readUnsignedShort(index + 4); if (nameIndex < 0) { return null; } if (signatureIndex < 0) { return null; } final int nameAndTypeIndex = this.readUnsignedShort(index + 6); if (nameAndTypeIndex < 0) { return null; } final int nameAndTypeLength = this.readUnsignedShort(nameAndTypeIndex); if (nameAndTypeLength < 0) { return null; } final char[] nameAndType = new char[nameAndTypeLength]; for (int j = 0; j < nameAndTypeLength; j++) { nameAndType[j] = charBuffer[index + 6 + j]; } return new String(nameAndType); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ int cpIndex = constantPoolEntryIndex; final int utfSize = cpIndex - cpIndexBegin; final char[] chars = new char[utfSize]; for (int i = 0; i < utfSize; i++) { chars[i] = charBuffer[cpIndex++]; } return new String(chars); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int utfLength = readUtf(constantPoolEntryIndex, charBuffer, 0, charBuffer.length); return new String(charBuffer, 0, utfLength); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int index = charBuffer.length * 2; final int charPos = charBuffer[index]; if (charPos == 0) { return \"\"; } final int charCount = (charPos & 0xFF) >> 5; final int stringIndex = (charPos & 0x1F); final int stringLength = (charPos & 0x1F) + 1; final byte[] stringBuffer = this.stringBuffer; charBuffer[index] = (char) (stringBuffer[stringIndex] & 0xFF); charBuffer[index + 1] = (char) (stringBuffer[stringIndex + 1] & 0xFF); charBuffer[index + 2] = (char) (stringBuffer[stringIndex + 2] & 0xFF); charBuffer[index + 3] = (char) (stringBuffer[stringIndex + 3] & 0xFF); return new String(charBuffer, 0, charCount); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int utfLength = readUtf(constantPoolEntryIndex, charBuffer, 0); return new String(charBuffer, 0, utfLength); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ if (constantPoolEntryIndex < 0) { return null; } final int charBufferIndex = constantPoolEntryIndex >>> 6; final int charBufferOffset = constantPoolEntryIndex & 0x3f; final int utf8Offset = charBufferOffset + (charBuffer.length - 1); final int utf8Length = this.readUnsignedShort(utf8Offset); final char[] utf8Chars = new char[utf8Length]; this.readChars(utf8Chars, charBufferOffset, utf8Length); return new String(utf8Chars); }", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){ final int utfLength = readUnsignedShort(constantPoolEntryIndex); if (utfLength > charBuffer.length) { charBuffer = new char[utfLength]; } readFully(constantPoolEntryIndex, charBuffer); return new String(charBuffer); }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec01782a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic int hashCode() {\n  int result = type.hashCode();\n  result = 31 * result + Arrays.hashCode(data);\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  int result = 17;\n  result = 31 * result + (this.name == null ? 0 : this.name.hashCode());\n  result = 31 * result + (this.sex == null ? 0 : this.sex.hashCode());\n  result = 31 * result + (this.age == null ? 0 : this.age.hashCode());\n  result = 31 * result + (this.address == null ? 0 : this.address.hashCode());\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  final int prime = 31;\n  int result = 1;\n  result = prime * result + ((id == null) ? 0 : id.hashCode());\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  final int prime = 31;\n  int result = 1;\n  result = prime * result + ((m_id == null) ? 0 : m_id.hashCode());\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  final int prime = 31;\n  int result = 1;\n  result = prime * result + ((id == null) ? 0 : id.hashCode());\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  return Objects.hash(id, userId, type, createdAt, updatedAt);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  final int prime = 31;\n  int result = 1;\n  result = prime * result + ((id == null) ? 0 : id.hashCode());\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  int result = type != null ? type.hashCode() : 0;\n  result = 31 * result + (name != null ? name.hashCode() : 0);\n  result = 31 * result + (value != null ? value.hashCode() : 0);\n  result = 31 * result + (valueType != null ? valueType.hashCode() : 0);\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  int result = super.hashCode();\n  result = 31 * result + (email != null ? email.hashCode() : 0);\n  result = 31 * result + (username != null ? username.hashCode() : 0);\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int hashCode() {\n  final int prime = 31;\n  int result = 1;\n  result = prime * result + ((date == null) ? 0 : date.hashCode());\n  result = prime * result + ((id == null) ? 0 : id.hashCode());\n  result = prime * result + ((name == null) ? 0 : name.hashCode());\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a hash code value for this type.\n * @return a hash code value for this type.\n */\n", "method_name": "hashCode", "codes": ["@Override public int hashCode(){ int result = type.hashCode(); result = 31 * result + Arrays.hashCode(data); return result; }", "@Override public int hashCode(){ int result = 17; result = 31 * result + (this.name == null ? 0 : this.name.hashCode()); result = 31 * result + (this.sex == null ? 0 : this.sex.hashCode()); result = 31 * result + (this.age == null ? 0 : this.age.hashCode()); result = 31 * result + (this.address == null ? 0 : this.address.hashCode()); return result; }", "@Override public int hashCode(){ final int prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); return result; }", "@Override public int hashCode(){ final int prime = 31; int result = 1; result = prime * result + ((m_id == null) ? 0 : m_id.hashCode()); return result; }", "@Override public int hashCode(){ final int prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); return result; }", "@Override public int hashCode(){ return Objects.hash(id, userId, type, createdAt, updatedAt); }", "@Override public int hashCode(){ final int prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); return result; }", "@Override public int hashCode(){ int result = type != null ? type.hashCode() : 0; result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + (value != null ? value.hashCode() : 0); result = 31 * result + (valueType != null ? valueType.hashCode() : 0); return result; }", "@Override public int hashCode(){ int result = super.hashCode(); result = 31 * result + (email != null ? email.hashCode() : 0); result = 31 * result + (username != null ? username.hashCode() : 0); return result; }", "@Override public int hashCode(){ final int prime = 31; int result = 1; result = prime * result + ((date == null) ? 0 : date.hashCode()); result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec017758", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  if (name == null) {\n    return -1;\n  }\n  if (descriptor == null) {\n    return -1;\n  }\n  int nameIndex = constantPool.addConstantUtf8(name);\n  if (descriptor.equals(\"Ljava/lang/Object;\")) {\n    nameIndex -= 2;\n  }\n  constantPool.addConstantUtf8(descriptor);\n  return nameIndex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name,final String descriptor){ if (this.constantPool.length == this.poolSize) { final int[] old = this.constantPool; this.constantPool = new int[old.length * 2]; System.arraycopy(old, 0, this.constantPool, 0, old.length); } this.constantPool[this.poolSize++] = this.poolIndex++; this.constantPool[this.poolSize++] = this.poolIndex++; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int index = addConstantUtf8(name);\n  if (index != -1) {\n    if (descriptor.charAt(0) == 'L') {\n      index = addConstantClass(descriptor);\n    } else {\n      index = addConstantInternalName(descriptor);\n    }\n  }\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  if (constantPool.length < constantPoolCount + 1) {\n    final int[] newPool = new int[constantPoolCount + 1];\n    System.arraycopy(constantPool, 0, newPool, 0, constantPoolCount);\n    constantPool = newPool;\n  }\n  final int index = constantPoolCount++;\n  constantPool[index] = constantPoolCount;\n  constantPool[index].setNameAndType(name, descriptor);\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int index = cp.addUtf8(name);\n  cp.addUtf8(descriptor);\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int index = cp.addConstantUtf8(name);\n  index = cp.addConstantUtf8(descriptor);\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int index = cp.addConstantUtf8(name);\n  cp.addConstantUtf8(descriptor);\n  return index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int i;\n  if (name == null) {\n    i = cp.addUtf8(\"null\");\n  } else {\n    i = cp.addUtf8(name);\n  }\n  if (descriptor == null) {\n    i = cp.addUtf8(\"null\");\n  } else {\n    i = cp.addUtf8(descriptor);\n  }\n  constantPool.addUtf8Info(i);\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  int index = addConstantUtf8(name);\n  index = addConstantUtf8(descriptor);\n  return index;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "int addConstantNameAndType(final String name, final String descriptor) {\n  if ((name == null)\n      || (name.length() == 0)\n      || (descriptor == null)\n      || (descriptor.length() == 0)) {\n    return 0;\n  }\n  char c = descriptor.charAt(0);\n  if (c == '(') {\n    return addConstantParameters(name, descriptor, -1);\n  } else if (c == 'J') {\n    return addConstantMethodType(name, descriptor);\n  } else if (c == 'D') {\n    return addConstantDouble(name, descriptor);\n  } else if (c == 'F') {\n    return addConstantFloat(name, descriptor);\n  } else if (c == 'I') {\n    return addConstantInteger(name, descriptor);\n  } else if (c == 'L') {\n    return addConstantLong(name, descriptor);\n  } else if (c == '[') {\n    return addConstantInterfaceMethodTypes(name, descriptor);\n  } else if (c == 'S') {\n    return addConstantString(name, descriptor);\n  } else {\n    return addConstantUtf8(name, descriptor);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n", "method_name": "addConstantNameAndType", "codes": ["int addConstantNameAndType(final String name,final String descriptor){ if (name == null) { return -1; } if (descriptor == null) { return -1; } int nameIndex = constantPool.addConstantUtf8(name); if (descriptor.equals(\"Ljava/lang/Object;\")) { nameIndex -= 2; } constantPool.addConstantUtf8(descriptor); return nameIndex; }", "int addConstantNameAndType(final String name,final String descriptor){ if (this.constantPool.length == this.poolSize) { final int[] old = this.constantPool; this.constantPool = new int[old.length * 2]; System.arraycopy(old, 0, this.constantPool, 0, old.length); } this.constantPool[this.poolSize++] = this.poolIndex++; this.constantPool[this.poolSize++] = this.poolIndex++; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.constantPool[this.poolSize++] = 0; this.constantPool[this.poolSize++] = this.poolIndex; this.", "int addConstantNameAndType(final String name,final String descriptor){ int index = addConstantUtf8(name); if (index != -1) { if (descriptor.charAt(0) == 'L') { index = addConstantClass(descriptor); } else { index = addConstantInternalName(descriptor); } } return index; }", "int addConstantNameAndType(final String name,final String descriptor){ if (constantPool.length < constantPoolCount + 1) { final int[] newPool = new int[constantPoolCount + 1]; System.arraycopy(constantPool, 0, newPool, 0, constantPoolCount); constantPool = newPool; } final int index = constantPoolCount++; constantPool[index] = constantPoolCount; constantPool[index].setNameAndType(name, descriptor); return index; }", "int addConstantNameAndType(final String name,final String descriptor){ int index = cp.addUtf8(name); cp.addUtf8(descriptor); return index; }", "int addConstantNameAndType(final String name,final String descriptor){ int index = cp.addConstantUtf8(name); index = cp.addConstantUtf8(descriptor); return index; }", "int addConstantNameAndType(final String name,final String descriptor){ int index = cp.addConstantUtf8(name); cp.addConstantUtf8(descriptor); return index; }", "int addConstantNameAndType(final String name,final String descriptor){ int i; if (name == null) { i = cp.addUtf8(\"null\"); } else { i = cp.addUtf8(name); } if (descriptor == null) { i = cp.addUtf8(\"null\"); } else { i = cp.addUtf8(descriptor); } constantPool.addUtf8Info(i); return i; }", "int addConstantNameAndType(final String name,final String descriptor){ int index = addConstantUtf8(name); index = addConstantUtf8(descriptor); return index; }", "int addConstantNameAndType(final String name,final String descriptor){ if ((name == null) || (name.length() == 0) || (descriptor == null) || (descriptor.length() == 0)) { return 0; } char c = descriptor.charAt(0); if (c == '(') { return addConstantParameters(name, descriptor, -1); } else if (c == 'J') { return addConstantMethodType(name, descriptor); } else if (c == 'D') { return addConstantDouble(name, descriptor); } else if (c == 'F') { return addConstantFloat(name, descriptor); } else if (c == 'I') { return addConstantInteger(name, descriptor); } else if (c == 'L') { return addConstantLong(name, descriptor); } else if (c == '[') { return addConstantInterfaceMethodTypes(name, descriptor); } else if (c == 'S') { return addConstantString(name, descriptor); } else { return addConstantUtf8(name, descriptor); } }"], "code_level": "project_runnable", "_id": "636766fe1a6d9265ec017823", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "final void addLineNumber(final int lineNumber) {\n  this.lineNumber += lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  this.lineNumber += lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  final int previousLineNumber = this.lineNumber;\n  this.lineNumber = lineNumber;\n  if (previousLineNumber != lineNumber) {\n    firePropertyChange(\"lineNumber\", previousLineNumber, lineNumber);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  this.lines.add(lineNumber);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  this.lineNumber += lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  this.lineNumber += lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  this.lineNumber += lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  this.lineNumber += lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  this.lineNumber += lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber) {\n  if (lineNumber <= 0) {\n    return;\n  }\n  this.lineNumber += lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n", "method_name": "addLineNumber", "codes": ["final void addLineNumber(final int lineNumber){ this.lineNumber += lineNumber; }", "final void addLineNumber(final int lineNumber){ this.lineNumber += lineNumber; }", "final void addLineNumber(final int lineNumber){ final int previousLineNumber = this.lineNumber; this.lineNumber = lineNumber; if (previousLineNumber != lineNumber) { firePropertyChange(\"lineNumber\", previousLineNumber, lineNumber); } }", "final void addLineNumber(final int lineNumber){ this.lines.add(lineNumber); }", "final void addLineNumber(final int lineNumber){ this.lineNumber += lineNumber; }", "final void addLineNumber(final int lineNumber){ this.lineNumber += lineNumber; }", "final void addLineNumber(final int lineNumber){ this.lineNumber += lineNumber; }", "final void addLineNumber(final int lineNumber){ this.lineNumber += lineNumber; }", "final void addLineNumber(final int lineNumber){ this.lineNumber += lineNumber; }", "final void addLineNumber(final int lineNumber){ if (lineNumber <= 0) { return; } this.lineNumber += lineNumber; }"], "code_level": "class_runnable", "_id": "636767131a6d9265ec017b23", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  int lastSeparatorPos = filename.lastIndexOf(PATH_SEPARATOR);\n  return Math.max(lastUnixPos, Math.max(lastWindowsPos, lastSeparatorPos));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  int lastSeparatorPos = Math.max(lastUnixPos, lastWindowsPos);\n  return lastSeparatorPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n", "method_name": "indexOfLastSeparator", "codes": ["public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); int lastSeparatorPos = filename.lastIndexOf(PATH_SEPARATOR); return Math.max(lastUnixPos, Math.max(lastWindowsPos, lastSeparatorPos)); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); int lastSeparatorPos = Math.max(lastUnixPos, lastWindowsPos); return lastSeparatorPos; }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }", "public static int indexOfLastSeparator(String filename){ if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec017658", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    File[] files = file.listFiles();\n    if (files != null) {\n      for (File f : files) forceDeleteOnExit(f);\n    }\n  }\n  boolean filePresent = file.exists();\n  if (filePresent) {\n    if (file.delete()) {\n      System.out.println(\"File deleted successfully\");\n    } else {\n      System.out.println(\"Unable to delete file\");\n    }\n  } else {\n    System.out.println(\"File does not exist\");\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    boolean filePresent = file.exists();\n    if (!file.delete()) {\n      if (!filePresent) {\n        throw new FileNotFoundException(\"File does not exist: \" + file);\n      }\n      String message = \"Unable to delete file: \" + file;\n      throw new IOException(message);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    boolean filePresent = file.exists();\n    if (file.deleteOnExit()) {\n      if (!filePresent) {\n        throw new FileNotFoundException(\"File does not exist: \" + file);\n      }\n    } else {\n      throw new IOException(\"Unable to delete on exit of \" + file);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    file.deleteOnExit();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  } else {\n    if (!file.delete()) {\n      throw new IOException(\"Could not delete on exit\");\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Schedules a file to be deleted when JVM exits. If file is directory delete it and all sub-directories.\n * @param file  file or directory to delete, must not be {@code null}\n * @throws NullPointerException if the file is {@code null}\n * @throws IOException in case deletion is unsuccessful\n */\n", "method_name": "forceDeleteOnExit", "codes": ["public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { File[] files = file.listFiles(); if (files != null) { for (File f : files) forceDeleteOnExit(f); } } boolean filePresent = file.exists(); if (filePresent) { if (file.delete()) { System.out.println(\"File deleted successfully\"); } else { System.out.println(\"Unable to delete file\"); } } else { System.out.println(\"File does not exist\"); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { boolean filePresent = file.exists(); if (!file.delete()) { if (!filePresent) { throw new FileNotFoundException(\"File does not exist: \" + file); } String message = \"Unable to delete file: \" + file; throw new IOException(message); } } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { boolean filePresent = file.exists(); if (file.deleteOnExit()) { if (!filePresent) { throw new FileNotFoundException(\"File does not exist: \" + file); } } else { throw new IOException(\"Unable to delete on exit of \" + file); } } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { file.deleteOnExit(); } }", "public static void forceDeleteOnExit(File file) throws IOException { if (file.isDirectory()) { deleteDirectoryOnExit(file); } else { if (!file.delete()) { throw new IOException(\"Could not delete on exit\"); } } }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec017833", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return (lastSeparator > extensionPos ? -1 : extensionPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return Math.max(extensionPos, lastSeparator);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return Math.max(lastSeparator, extensionPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename) {\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator = indexOfLastSeparator(filename);\n  return Math.max(extensionPos, lastSeparator);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n", "method_name": "indexOfExtension", "codes": ["public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return (lastSeparator > extensionPos ? -1 : extensionPos); }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return Math.max(extensionPos, lastSeparator); }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return Math.max(lastSeparator, extensionPos); }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return lastSeparator > extensionPos ? -1 : extensionPos; }", "public static int indexOfExtension(String filename){ if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return Math.max(extensionPos, lastSeparator); }"], "code_level": "class_runnable", "_id": "636767061a6d9265ec01794a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  this.out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  os.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  os.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  os.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(byte b[]) throws IOException {\n  byte[] bytes = new byte[1];\n  bytes[0] = b;\n  write(bytes, 0, 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Writes <code>b.length</code> bytes from the specified byte array to this output stream.\n * @param b The array of bytes to be written.\n * @exception IOException if an error occurs.\n */\n", "method_name": "write", "codes": ["@Override public void write(byte b[]) throws IOException { this.out.write(b); }", "@Override public void write(byte b[]) throws IOException { os.write(b); }", "@Override public void write(byte b[]) throws IOException { out.write(b); }", "@Override public void write(byte b[]) throws IOException { out.write(b); }", "@Override public void write(byte b[]) throws IOException { out.write(b); }", "@Override public void write(byte b[]) throws IOException { os.write(b); }", "@Override public void write(byte b[]) throws IOException { out.write(b); }", "@Override public void write(byte b[]) throws IOException { os.write(b); }", "@Override public void write(byte b[]) throws IOException { out.write(b); }", "@Override public void write(byte b[]) throws IOException { byte[] bytes = new byte[1]; bytes[0] = b; write(bytes, 0, 1); }"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec0179fe", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len == 0) {\n    return;\n  }\n  if (pos + len > buf.length) {\n    resize(len);\n  }\n  System.arraycopy(b, off, buf, pos, len);\n  pos += len;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (this.buf == null) {\n    this.out.write(b, off, len);\n  } else {\n    this.buf.write(b, off, len);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (off < 0 || off > b.length || len < 0 || off + len > b.length) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (len == 0) {\n    return;\n  }\n  if (pos >= limit) {\n    flush();\n  }\n  if (pos >= limit - len) {\n    if (len > pos) {\n      System.arraycopy(b, off, buffer, pos, len);\n      pos += len;\n    } else {\n      System.arraycopy(b, off, buffer, pos, pos + len);\n      pos += len;\n    }\n  } else {\n    System.arraycopy(b, off, buffer, pos, len);\n    pos += len;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len < 0) {\n    throw new IOException(\"Negative length: \" + len);\n  }\n  if (len == 0) {\n    return;\n  }\n  final int newcount = count + len;\n  if (newcount > buf.length) {\n    final byte[] newBuf = new byte[Math.max(buf.length << 1, newcount)];\n    System.arraycopy(buf, 0, newBuf, 0, count);\n    buf = newBuf;\n  }\n  System.arraycopy(b, off, buf, count, len);\n  count = newcount;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len > 0) {\n    final int size = _size + len;\n    if (size > _buffer.length) {\n      _buffer = Arrays.copyOf(_buffer, size);\n    }\n    System.arraycopy(b, off, _buffer, _size, len);\n    _size = size;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (this.enabled) {\n    this.out.write(b, off, len);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len == 0) {\n    return;\n  }\n  if (len == 1) {\n    out.write(b);\n    return;\n  }\n  if (len > 0) {\n    out.write(b, off, len);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len < 0) {\n    throw new IndexOutOfBoundsException(\"len < 0: \" + len);\n  }\n  if (off < 0) {\n    throw new IndexOutOfBoundsException(\"off < 0: \" + off);\n  }\n  if (off + len > b.length) {\n    throw new IndexOutOfBoundsException(\n        \"off + len > b.length: \" + off + \" + \" + len + \" < \" + b.length);\n  }\n  if (len == 0) {\n    return;\n  }\n  final int n = m_buf.remaining();\n  if (n <= 0) {\n    return;\n  }\n  final int n2 = m_buf.limit() - m_buf.position();\n  if (n2 < len) {\n    final int n3 = n2 + len;\n    m_buf.limit(m_buf.position() + len);\n    m_buf.put(b, off, len);\n    m_buf.limit(n3);\n  } else {\n    m_buf.put(b, off, len);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  if (len > 0) {\n    final int n = Math.min(len, buffer.length - bufferPos);\n    System.arraycopy(b, off, buffer, bufferPos, n);\n    bufferPos += n;\n    if (bufferPos >= buffer.length) {\n      flush();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte b[], final int off, final int len) throws IOException {\n  checkOpen();\n  if (len == 0) {\n    return;\n  }\n  checkOffsetAndCount(len, off, len);\n  while (len > 0) {\n    final int count = Math.min(len, bytes.length - position);\n    System.arraycopy(b, off, bytes, position, count);\n    position += count;\n    off += count;\n    len -= count;\n    if (position >= bytes.length) {\n      flush();\n      position = 0;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.\n * @param b   the data.\n * @param off the start offset in the data.\n * @param len the number of bytes to write.\n */\n", "method_name": "write", "codes": ["@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len == 0) { return; } if (pos + len > buf.length) { resize(len); } System.arraycopy(b, off, buf, pos, len); pos += len; }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (this.buf == null) { this.out.write(b, off, len); } else { this.buf.write(b, off, len); } }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (off < 0 || off > b.length || len < 0 || off + len > b.length) { throw new IndexOutOfBoundsException(); } if (len == 0) { return; } if (pos >= limit) { flush(); } if (pos >= limit - len) { if (len > pos) { System.arraycopy(b, off, buffer, pos, len); pos += len; } else { System.arraycopy(b, off, buffer, pos, pos + len); pos += len; } } else { System.arraycopy(b, off, buffer, pos, len); pos += len; } }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len < 0) { throw new IOException(\"Negative length: \" + len); } if (len == 0) { return; } final int newcount = count + len; if (newcount > buf.length) { final byte[] newBuf = new byte[Math.max(buf.length << 1, newcount)]; System.arraycopy(buf, 0, newBuf, 0, count); buf = newBuf; } System.arraycopy(b, off, buf, count, len); count = newcount; }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len > 0) { final int size = _size + len; if (size > _buffer.length) { _buffer = Arrays.copyOf(_buffer, size); } System.arraycopy(b, off, _buffer, _size, len); _size = size; } }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (this.enabled) { this.out.write(b, off, len); } }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len == 0) { return; } if (len == 1) { out.write(b); return; } if (len > 0) { out.write(b, off, len); } }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len < 0) { throw new IndexOutOfBoundsException(\"len < 0: \" + len); } if (off < 0) { throw new IndexOutOfBoundsException(\"off < 0: \" + off); } if (off + len > b.length) { throw new IndexOutOfBoundsException(\"off + len > b.length: \" + off + \" + \" + len + \" < \" + b.length); } if (len == 0) { return; } final int n = m_buf.remaining(); if (n <= 0) { return; } final int n2 = m_buf.limit() - m_buf.position(); if (n2 < len) { final int n3 = n2 + len; m_buf.limit(m_buf.position() + len); m_buf.put(b, off, len); m_buf.limit(n3); } else { m_buf.put(b, off, len); } }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { if (len > 0) { final int n = Math.min(len, buffer.length - bufferPos); System.arraycopy(b, off, buffer, bufferPos, n); bufferPos += n; if (bufferPos >= buffer.length) { flush(); } } }", "@Override public void write(final byte b[],final int off,final int len) throws IOException { checkOpen(); if (len == 0) { return; } checkOffsetAndCount(len, off, len); while (len > 0) { final int count = Math.min(len, bytes.length - position); System.arraycopy(b, off, bytes, position, count); position += count; off += count; len -= count; if (position >= bytes.length) { flush(); position = 0; } } }"], "code_level": "class_runnable", "_id": "636766f91a6d9265ec01776e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  if (b == null) {\n    throw new NullPointerException();\n  }\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  this.buffer.put(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  final int length = b.length;\n  if (buffer == null) {\n    buffer = new ByteArrayOutputStream();\n  }\n  buffer.write(b, 0, length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  if (b != null) {\n    this.write(b, 0, b.length);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  if (b == null) {\n    return;\n  }\n  if (this.buffer == null) {\n    this.buffer = new byte[b.length];\n  }\n  this.buffer = Arrays.copyOf(this.buffer, this.buffer.length + b.length);\n  System.arraycopy(b, 0, this.buffer, this.buffer.length - b.length, b.length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  if (b == null) {\n    write((byte) 0);\n  } else {\n    write(b, 0, b.length);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void write(final byte[] b) throws IOException {\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * @see OutputStream#write(byte[]) \n */\n", "method_name": "write", "codes": ["@Override public void write(final byte[] b) throws IOException { if (b == null) { throw new NullPointerException(); } write(b, 0, b.length); }", "@Override public void write(final byte[] b) throws IOException { this.buffer.put(b); }", "@Override public void write(final byte[] b) throws IOException { write(b, 0, b.length); }", "@Override public void write(final byte[] b) throws IOException { final int length = b.length; if (buffer == null) { buffer = new ByteArrayOutputStream(); } buffer.write(b, 0, length); }", "@Override public void write(final byte[] b) throws IOException { if (b != null) { this.write(b, 0, b.length); } }", "@Override public void write(final byte[] b) throws IOException { if (b == null) { return; } if (this.buffer == null) { this.buffer = new byte[b.length]; } this.buffer = Arrays.copyOf(this.buffer, this.buffer.length + b.length); System.arraycopy(b, 0, this.buffer, this.buffer.length - b.length, b.length); }", "@Override public void write(final byte[] b) throws IOException { if (b == null) { write((byte) 0); } else { write(b, 0, b.length); } }", "@Override public void write(final byte[] b) throws IOException { write(b, 0, b.length); }", "@Override public void write(final byte[] b) throws IOException { write(b, 0, b.length); }", "@Override public void write(final byte[] b) throws IOException { write(b, 0, b.length); }"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179d8", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public String toString() {\n  return \"<\" + this.prefix + \":\" + this.uri + \">\";\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return new String(buf, 0, len);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  String s = \"\";\n  for (int i = 0; i < size(); i++) {\n    s += get(i);\n    if (i < size() - 1) s += \", \";\n  }\n  return s;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return this.toString(false);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String toString() {\n  return new String(data, 0, count);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  if (length == 0) {\n    return \"\";\n  }\n  StringBuilder sb = new StringBuilder();\n  sb.append('[');\n  for (int i = 0; i < length; i++) {\n    sb.append(data[i]);\n    if (i != length - 1) {\n      sb.append(\", \");\n    }\n  }\n  sb.append(']');\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"[\");\n  for (int i = 0; i < size; i++) {\n    if (i > 0) {\n      sb.append(\", \");\n    }\n    sb.append(data[i]);\n  }\n  sb.append(\"]\");\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return this.getClass().getName()\n      + \"(\"\n      + this.getFileName()\n      + \":\"\n      + this.getLineNumber()\n      + \", \"\n      + this.getMessage()\n      + \")\";\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return this.toString(false);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p> Gets the String built by this builder. </p>\n * @return the built string\n */\n", "method_name": "toString", "codes": ["public String toString(){ return \"<\" + this.prefix + \":\" + this.uri + \">\"; }", "public String toString(){ return new String(buf, 0, len); }", "public String toString(){ String s = \"\"; for (int i = 0; i < size(); i++) { s += get(i); if (i < size() - 1) s += \", \"; } return s; }", "public String toString(){ return this.toString(false); }", "public String toString(){ return new String(data, 0, count); }", "public String toString(){ if (length == 0) { return \"\"; } StringBuilder sb = new StringBuilder(); sb.append('['); for (int i = 0; i < length; i++) { sb.append(data[i]); if (i != length - 1) { sb.append(\", \"); } } sb.append(']'); return sb.toString(); }", "public String toString(){ StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (int i = 0; i < size; i++) { if (i > 0) { sb.append(\", \"); } sb.append(data[i]); } sb.append(\"]\"); return sb.toString(); }", "public String toString(){ return this.getClass().getName() + \"(\" + this.getFileName() + \":\" + this.getLineNumber() + \", \" + this.getMessage() + \")\"; }", "public String toString(){ return sb.toString(); }", "public String toString(){ return this.toString(false); }"], "code_level": "project_runnable", "_id": "636767001a6d9265ec01787e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  appendDetail(buffer, fieldName, array, null, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  appendDetail(buffer, fieldName, array, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  appendDetail(buffer, fieldName, array, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  appendDetail(buffer, fieldName, array, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  appendDetail(buffer, fieldName, array, null, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  appendFieldStart(buffer, fieldName);\n  if (array == null) {\n    appendNullText(buffer, fieldName);\n  } else {\n    for (int i = 0; i < array.length; i++) {\n      if (i > 0) {\n        buffer.append(arraySeparator);\n      }\n      appendDetail(buffer, fieldName, array[i]);\n    }\n  }\n  appendFieldEnd(buffer, fieldName);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  appendDetail(buffer, fieldName, array, null, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    buffer.append(String.valueOf(array[i]));\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n  appendDetail(buffer, fieldName, array, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n", "method_name": "appendDetail", "codes": ["protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ appendDetail(buffer, fieldName, array, null, null); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ appendDetail(buffer, fieldName, array, null); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ appendDetail(buffer, fieldName, array, null); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ appendDetail(buffer, fieldName, array, null); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ appendDetail(buffer, fieldName, array, null, null); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ appendFieldStart(buffer, fieldName); if (array == null) { appendNullText(buffer, fieldName); } else { for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } } appendFieldEnd(buffer, fieldName); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ appendDetail(buffer, fieldName, array, null, null); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } buffer.append(String.valueOf(array[i])); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){ appendDetail(buffer, fieldName, array, null); }"], "code_level": "class_runnable", "_id": "636767001a6d9265ec01787f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return new String[0];\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return new String[0];\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return new String[0];\n  } else {\n    return collection.toArray(new String[collection.size()]);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return new String[0];\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return new String[0];\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return EMPTY_STRING_ARRAY;\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return new String[0];\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return new String[0];\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return new String[0];\n  }\n  return collection.toArray(new String[collection.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection) {\n  if (collection == null) {\n    return null;\n  } else if (collection.isEmpty()) {\n    return new String[0];\n  } else {\n    String[] result = new String[collection.size()];\n    int i = 0;\n    for (Object element : collection) {\n      result[i++] = element == null ? null : element.toString();\n    }\n    return result;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.\n * @param collection The collection to convert\n * @return A new array of Strings.\n */\n", "method_name": "toNoNullStringArray", "codes": ["static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return new String[0]; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return new String[0]; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return new String[0]; } else { return collection.toArray(new String[collection.size()]); } }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return new String[0]; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return new String[0]; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return EMPTY_STRING_ARRAY; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return new String[0]; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return new String[0]; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return new String[0]; } return collection.toArray(new String[collection.size()]); }", "static String[] toNoNullStringArray(Collection<?> collection){ if (collection == null) { return null; } else if (collection.isEmpty()) { return new String[0]; } else { String[] result = new String[collection.size()]; int i = 0; for (Object element : collection) { result[i++] = element == null ? null : element.toString(); } return result; } }"], "code_level": "project_runnable", "_id": "636766f71a6d9265ec017730", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "static void register(Object value) {\n  if (value != null) {\n    REGISTRY.put(value, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value != null) {\n    REGISTRY.put(value, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value == null) {\n    return;\n  }\n  if (!REGISTRY.containsKey(value)) {\n    REGISTRY.put(value, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value != null) {\n    REGISTRY.put(value.getClass(), value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value == null) {\n    return;\n  }\n  if (REGISTRY.containsKey(value)) {\n    throw new IllegalArgumentException(\"Value already registered: \" + value);\n  }\n  REGISTRY.put(value, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value == null) {\n    REGISTRY.remove(NULL_KEY);\n  } else {\n    REGISTRY.put(value.getClass(), value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value != null) {\n    REGISTRY.put(value.getClass(), value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value != null) {\n    REGISTRY.put(value.getClass(), value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value == null) {\n    REGISTRY.remove(null);\n  } else {\n    REGISTRY.put(value, null);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value) {\n  if (value != null) {\n    REGISTRY.put(value.getClass(), value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n", "method_name": "register", "codes": ["static void register(Object value){ if (value != null) { REGISTRY.put(value, value); } }", "static void register(Object value){ if (value != null) { REGISTRY.put(value, value); } }", "static void register(Object value){ if (value == null) { return; } if (!REGISTRY.containsKey(value)) { REGISTRY.put(value, value); } }", "static void register(Object value){ if (value != null) { REGISTRY.put(value.getClass(), value); } }", "static void register(Object value){ if (value == null) { return; } if (REGISTRY.containsKey(value)) { throw new IllegalArgumentException(\"Value already registered: \" + value); } REGISTRY.put(value, value); }", "static void register(Object value){ if (value == null) { REGISTRY.remove(NULL_KEY); } else { REGISTRY.put(value.getClass(), value); } }", "static void register(Object value){ if (value != null) { REGISTRY.put(value.getClass(), value); } }", "static void register(Object value){ if (value != null) { REGISTRY.put(value.getClass(), value); } }", "static void register(Object value){ if (value == null) { REGISTRY.remove(null); } else { REGISTRY.put(value, null); } }", "static void register(Object value){ if (value != null) { REGISTRY.put(value.getClass(), value); } }"], "code_level": "class_runnable", "_id": "636767041a6d9265ec017911", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(array.length);\n  buffer.append('/');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer, fieldName, array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  buffer.append(arrayStart);\n  for (int i = 0; i < array.length; i++) {\n    appendDetail(buffer, fieldName, array[i]);\n    if (i < (array.length - 1)) {\n      buffer.append(arraySeparator);\n    }\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  appendDetail(buffer, fieldName, array, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n  appendSummarySize(buffer, fieldName, array.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n", "method_name": "appendDetail", "codes": ["protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(array.length); buffer.append('/'); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { if (i > 0) { buffer.append(arraySeparator); } appendDetail(buffer, fieldName, array[i]); } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ buffer.append(arrayStart); for (int i = 0; i < array.length; i++) { appendDetail(buffer, fieldName, array[i]); if (i < (array.length - 1)) { buffer.append(arraySeparator); } } buffer.append(arrayEnd); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ appendDetail(buffer, fieldName, array, null); }", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){ appendSummarySize(buffer, fieldName, array.length); }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec017821", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  }\n  return Arrays.copyOf(array, array.length, String[].class);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  return toStringArray(array, true, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    Object value = array[i];\n    if (value != null) {\n      result[i] = value.toString();\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  }\n  int length = array.length;\n  if (length == 0) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] result = new String[length];\n  for (int i = 0; i < length; i++) {\n    Object element = array[i];\n    if (element != null) {\n      result[i] = element.toString();\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  }\n  int length = array.length;\n  if (length == 0) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] result = new String[length];\n  for (int i = 0; i < length; i++) {\n    Object element = array[i];\n    if (element == null) {\n      result[i] = null;\n    } else {\n      result[i] = element.toString();\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_STRING_ARRAY;\n  } else {\n    String[] result = new String[array.length];\n    for (int i = 0; i < array.length; i++) {\n      Object value = array[i];\n      if (value != null) {\n        result[i] = value.toString();\n      }\n    }\n    return result;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return EMPTY_STRING_ARRAY;\n  } else {\n    return toStringArray(array);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (isEmpty(array)) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    Object element = array[i];\n    if (element != null) {\n      result[i] = element.toString();\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return new String[0];\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    Object element = array[i];\n    if (element == null) {\n      result[i] = \"\";\n    } else {\n      result[i] = element.toString();\n    }\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array) {\n  if (array == null) {\n    return null;\n  } else if (array.length == 0) {\n    return EMPTY_STRING_ARRAY;\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    if (array[i] == null) {\n      throw new IllegalArgumentException(\n          \"Array element \" + i + \" is null, it cannot be converted to String array\");\n    }\n    result[i] = array[i].toString();\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.\n * @param array The array to check\n * @return The given array or a new array without null.\n */\n", "method_name": "toNoNullStringArray", "codes": ["static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } return Arrays.copyOf(array, array.length, String[].class); }", "static String[] toNoNullStringArray(Object[] array){ return toStringArray(array, true, false); }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_STRING_ARRAY; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { Object value = array[i]; if (value != null) { result[i] = value.toString(); } } return result; }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } int length = array.length; if (length == 0) { return EMPTY_STRING_ARRAY; } String[] result = new String[length]; for (int i = 0; i < length; i++) { Object element = array[i]; if (element != null) { result[i] = element.toString(); } } return result; }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } int length = array.length; if (length == 0) { return EMPTY_STRING_ARRAY; } String[] result = new String[length]; for (int i = 0; i < length; i++) { Object element = array[i]; if (element == null) { result[i] = null; } else { result[i] = element.toString(); } } return result; }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_STRING_ARRAY; } else { String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { Object value = array[i]; if (value != null) { result[i] = value.toString(); } } return result; } }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return EMPTY_STRING_ARRAY; } else { return toStringArray(array); } }", "static String[] toNoNullStringArray(Object[] array){ if (isEmpty(array)) { return EMPTY_STRING_ARRAY; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { Object element = array[i]; if (element != null) { result[i] = element.toString(); } } return result; }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return new String[0]; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { Object element = array[i]; if (element == null) { result[i] = \"\"; } else { result[i] = element.toString(); } } return result; }", "static String[] toNoNullStringArray(Object[] array){ if (array == null) { return null; } else if (array.length == 0) { return EMPTY_STRING_ARRAY; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { if (array[i] == null) { throw new IllegalArgumentException(\"Array element \" + i + \" is null, it cannot be converted to String array\"); } result[i] = array[i].toString(); } return result; }"], "code_level": "project_runnable", "_id": "636766fc1a6d9265ec0177ef", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic int available() throws IOException {\n  return available;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return m_in.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return is.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return data.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  if (currentIndex == -1) {\n    return 0;\n  }\n  int available = (int) ((currentIndex + 1) * currentFileSize);\n  if (available >= size) {\n    return size - available;\n  } else {\n    return available;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  if (closed) {\n    throw new IOException(\"Stream closed\");\n  }\n  if (pos == end) {\n    return 0;\n  }\n  return (end - pos);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  return (int)\n      Math.min(\n          InputStream.this.getTotalSpace(),\n          InputStream.this.getLength() - InputStream.this.getPosition());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  if (this.isClosed) {\n    throw new IOException(\"Stream is closed.\");\n  }\n  return this.in.available();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  if (this.available <= 0) {\n    return 0;\n  }\n  return this.available;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic int available() throws IOException {\n  if (isClosed) {\n    throw new IOException(\"Stream is closed\");\n  }\n  return (int) ((count - position) + maxReadBytes);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @see InputStream#available() \n */\n", "method_name": "available", "codes": ["@Override public int available() throws IOException { return available; }", "@Override public int available() throws IOException { return m_in.available(); }", "@Override public int available() throws IOException { return is.available(); }", "@Override public int available() throws IOException { return data.available(); }", "@Override public int available() throws IOException { if (currentIndex == -1) { return 0; } int available = (int) ((currentIndex + 1) * currentFileSize); if (available >= size) { return size - available; } else { return available; } }", "@Override public int available() throws IOException { if (closed) { throw new IOException(\"Stream closed\"); } if (pos == end) { return 0; } return (end - pos); }", "@Override public int available() throws IOException { return (int) Math.min(InputStream.this.getTotalSpace(), InputStream.this.getLength() - InputStream.this.getPosition()); }", "@Override public int available() throws IOException { if (this.isClosed) { throw new IOException(\"Stream is closed.\"); } return this.in.available(); }", "@Override public int available() throws IOException { if (this.available <= 0) { return 0; } return this.available; }", "@Override public int available() throws IOException { if (isClosed) { throw new IOException(\"Stream is closed\"); } return (int) ((count - position) + maxReadBytes); }"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec017641", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null || a.length == 0) {\n    return Collections.emptyList();\n  }\n  List<T> list = new ArrayList<T>(a.length);\n  for (int i = 0; i < a.length; i++) {\n    list.add(a[i]);\n  }\n  return list;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) {\n    return new ArrayList<>();\n  }\n  return Arrays.asList(a);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  return new ArrayList<T>(a.length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) {\n    return Collections.emptyList();\n  } else {\n    return Arrays.asList(a);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) {\n    return Collections.emptyList();\n  }\n  return new ArrayList<T>(Arrays.asList(a));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) {\n    return new ArrayList<T>();\n  }\n  return new ArrayList<T>(Arrays.asList(a));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) {\n    return new ArrayList<T>();\n  }\n  return new ArrayList<T>(Arrays.asList(a));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) return new ArrayList<T>();\n  return new ArrayList<T>(Arrays.asList(a));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  return new ArrayList<T>(Arrays.asList(a));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> List<T> asList(T[] a) {\n  if (a == null) return emptyList();\n  return new AbstractList<T>() {\n    public T get(int index) {\n      return a[index];\n    }\n\n    public int size() {\n      return a.length;\n    }\n  };\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.\n * @return a list backed by the array.\n */\n", "method_name": "asList", "codes": ["public static <T>List<T> asList(T[] a){ if (a == null || a.length == 0) { return Collections.emptyList(); } List<T> list = new ArrayList<T>(a.length); for (int i = 0; i < a.length; i++) { list.add(a[i]); } return list; }", "public static <T>List<T> asList(T[] a){ if (a == null) { return new ArrayList<>(); } return Arrays.asList(a); }", "public static <T>List<T> asList(T[] a){ return new ArrayList<T>(a.length); }", "public static <T>List<T> asList(T[] a){ if (a == null) { return Collections.emptyList(); } else { return Arrays.asList(a); } }", "public static <T>List<T> asList(T[] a){ if (a == null) { return Collections.emptyList(); } return new ArrayList<T>(Arrays.asList(a)); }", "public static <T>List<T> asList(T[] a){ if (a == null) { return new ArrayList<T>(); } return new ArrayList<T>(Arrays.asList(a)); }", "public static <T>List<T> asList(T[] a){ if (a == null) { return new ArrayList<T>(); } return new ArrayList<T>(Arrays.asList(a)); }", "public static <T>List<T> asList(T[] a){ if (a == null) return new ArrayList<T>(); return new ArrayList<T>(Arrays.asList(a)); }", "public static <T>List<T> asList(T[] a){ return new ArrayList<T>(Arrays.asList(a)); }", "public static <T>List<T> asList(T[] a){ if (a == null) return emptyList(); return new AbstractList<T>() { public T get(int index) { return a[index]; } public int size() { return a.length; } }; }"], "code_level": "slib_runnable", "_id": "636766f01a6d9265ec017639", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static byte convertHexDigit(byte b) {\n  if (b >= '0' && b <= '9') {\n    return b;\n  }\n  if (b >= 'a' && b <= 'f') {\n    return (byte) (b - 'a' + 10);\n  }\n  if (b >= 'A' && b <= 'F') {\n    return (byte) (b - 'A' + 10);\n  }\n  throw new IllegalArgumentException(\"Invalid hex digit '\" + b + \"'\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if (b >= '0' && b <= '9') {\n    return (byte) (b - '0');\n  }\n  if (b >= 'A' && b <= 'F') {\n    return (byte) (b - 'A' + 10);\n  }\n  if (b >= 'a' && b <= 'f') {\n    return (byte) (b - 'a' + 10);\n  }\n  throw new IllegalArgumentException(\"Invalid hex digit: \" + b);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if ((b >= '0') && (b <= '9')) {\n    return (byte) (b - '0');\n  }\n  if ((b >= 'A') && (b <= 'F')) {\n    return (byte) (b - 'A' + 10);\n  }\n  if ((b >= 'a') && (b <= 'f')) {\n    return (byte) (b - 'a' + 10);\n  }\n  throw new RuntimeException(\"Invalid hex digit: \" + b);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if (b < 0x10) {\n    return (byte) ('0' + b);\n  } else {\n    return (byte) ('A' + (b - 0x10));\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  return (byte) ((b & 0xf0) >> 4);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if (b >= '0' && b <= '9') {\n    return b;\n  } else if (b >= 'A' && b <= 'F') {\n    return (byte) (b - 'A' + 10);\n  } else {\n    return (byte) (b - '0' + 10);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  byte c = 0;\n  if (b < 0) {\n    c = (byte) (b + 256);\n  } else {\n    c = (byte) (b);\n  }\n  return c;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if (b >= '0' && b <= '9') return (byte) (b - '0');\n  else if (b >= 'A' && b <= 'F') return (byte) (b - 'A' + 10);\n  else if (b >= 'a' && b <= 'f') return (byte) (b - 'a' + 10);\n  else return -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  return (byte) (b & 0xF);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static byte convertHexDigit(byte b) {\n  if (b >= '0' && b <= '9') return (byte) (b - '0');\n  else if (b >= 'a' && b <= 'f') return (byte) (b - 'a' + 10);\n  else if (b >= 'A' && b <= 'F') return (byte) (b - 'A' + 10);\n  else return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * @param b An ASCII encoded character 0-9 a-f A-F\n * @return The byte value of the character 0-16.\n */\n", "method_name": "convertHexDigit", "codes": ["public static byte convertHexDigit(byte b){ if (b >= '0' && b <= '9') { return b; } if (b >= 'a' && b <= 'f') { return (byte) (b - 'a' + 10); } if (b >= 'A' && b <= 'F') { return (byte) (b - 'A' + 10); } throw new IllegalArgumentException(\"Invalid hex digit '\" + b + \"'\"); }", "public static byte convertHexDigit(byte b){ if (b >= '0' && b <= '9') { return (byte) (b - '0'); } if (b >= 'A' && b <= 'F') { return (byte) (b - 'A' + 10); } if (b >= 'a' && b <= 'f') { return (byte) (b - 'a' + 10); } throw new IllegalArgumentException(\"Invalid hex digit: \" + b); }", "public static byte convertHexDigit(byte b){ if ((b >= '0') && (b <= '9')) { return (byte) (b - '0'); } if ((b >= 'A') && (b <= 'F')) { return (byte) (b - 'A' + 10); } if ((b >= 'a') && (b <= 'f')) { return (byte) (b - 'a' + 10); } throw new RuntimeException(\"Invalid hex digit: \" + b); }", "public static byte convertHexDigit(byte b){ if (b < 0x10) { return (byte) ('0' + b); } else { return (byte) ('A' + (b - 0x10)); } }", "public static byte convertHexDigit(byte b){ return (byte) ((b & 0xf0) >> 4); }", "public static byte convertHexDigit(byte b){ if (b >= '0' && b <= '9') { return b; } else if (b >= 'A' && b <= 'F') { return (byte) (b - 'A' + 10); } else { return (byte) (b - '0' + 10); } }", "public static byte convertHexDigit(byte b){ byte c = 0; if (b < 0) { c = (byte) (b + 256); } else { c = (byte) (b); } return c; }", "public static byte convertHexDigit(byte b){ if (b >= '0' && b <= '9') return (byte) (b - '0'); else if (b >= 'A' && b <= 'F') return (byte) (b - 'A' + 10); else if (b >= 'a' && b <= 'f') return (byte) (b - 'a' + 10); else return -1; }", "public static byte convertHexDigit(byte b){ return (byte) (b & 0xF); }", "public static byte convertHexDigit(byte b){ if (b >= '0' && b <= '9') return (byte) (b - '0'); else if (b >= 'a' && b <= 'f') return (byte) (b - 'a' + 10); else if (b >= 'A' && b <= 'F') return (byte) (b - 'A' + 10); else return 0; }"], "code_level": "slib_runnable", "_id": "636766f91a6d9265ec01777d", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public Converter lookup(final Class<?> clazz) {\n  for (final Converter converter : converters) {\n    if (clazz.isInstance(converter)) {\n      return converter;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return lookup(clazz.getName());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return this.converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  for (Converter converter : converters) {\n    if (converter.getClass().equals(clazz)) {\n      return converter;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return lookup(clazz.getName());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return this.converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  for (final Converter converter : converters) {\n    if (clazz.isAssignableFrom(converter.getClass())) {\n      return converter;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  return lookup(clazz, null);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  for (Converter converter : converters) {\n    if (clazz.isAssignableFrom(converter.getClass())) {\n      return converter;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz) {\n  for (final Converter converter : converters) {\n    if (clazz.isAssignableFrom(converter.getClass())) {\n      return converter;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.\n * @param clazz Class for which to return a registered Converter\n * @return The registered {@link Converter} or <code>null</code> if not found\n */\n", "method_name": "lookup", "codes": ["public Converter lookup(final Class<?> clazz){ for (final Converter converter : converters) { if (clazz.isInstance(converter)) { return converter; } } return null; }", "public Converter lookup(final Class<?> clazz){ return lookup(clazz.getName()); }", "public Converter lookup(final Class<?> clazz){ return this.converters.get(clazz); }", "public Converter lookup(final Class<?> clazz){ for (Converter converter : converters) { if (converter.getClass().equals(clazz)) { return converter; } } return null; }", "public Converter lookup(final Class<?> clazz){ return lookup(clazz.getName()); }", "public Converter lookup(final Class<?> clazz){ return this.converters.get(clazz); }", "public Converter lookup(final Class<?> clazz){ for (final Converter converter : converters) { if (clazz.isAssignableFrom(converter.getClass())) { return converter; } } return null; }", "public Converter lookup(final Class<?> clazz){ return lookup(clazz, null); }", "public Converter lookup(final Class<?> clazz){ for (Converter converter : converters) { if (clazz.isAssignableFrom(converter.getClass())) { return converter; } } return null; }", "public Converter lookup(final Class<?> clazz){ for (final Converter converter : converters) { if (clazz.isAssignableFrom(converter.getClass())) { return converter; } } return null; }"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179e7", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  if (key == null) return false;\n  final int index = this.index(key);\n  return index != -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return super.containsKey(key);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return get(key) != null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return map.containsKey(key);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return map.containsKey(key);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return this.containsKey(key.toString());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return map.containsKey(key);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return this.map.containsKey(key);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return getMap().containsKey(key);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean containsKey(final Object key) {\n  return getMap().containsKey(key);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Return <code>true</code> if this map contains a mapping for the specified key.\n * @param key  the key to be searched for\n * @return true if the map contains the key\n */\n", "method_name": "containsKey", "codes": ["@Override public boolean containsKey(final Object key){ if (key == null) return false; final int index = this.index(key); return index != -1; }", "@Override public boolean containsKey(final Object key){ return super.containsKey(key); }", "@Override public boolean containsKey(final Object key){ return get(key) != null; }", "@Override public boolean containsKey(final Object key){ return map.containsKey(key); }", "@Override public boolean containsKey(final Object key){ return map.containsKey(key); }", "@Override public boolean containsKey(final Object key){ return this.containsKey(key.toString()); }", "@Override public boolean containsKey(final Object key){ return map.containsKey(key); }", "@Override public boolean containsKey(final Object key){ return this.map.containsKey(key); }", "@Override public boolean containsKey(final Object key){ return getMap().containsKey(key); }", "@Override public boolean containsKey(final Object key){ return getMap().containsKey(key); }"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec0179f2", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] copy = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    copy[i] = src[i].toLowerCase();\n  }\n  return copy;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] res = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    res[i] = src[i].toLowerCase();\n  }\n  return res;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] res = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    res[i] = src[i];\n  }\n  return res;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] dst = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    dst[i] = src[i].toLowerCase();\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] copy = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    copy[i] = src[i].toLowerCase();\n  }\n  return copy;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] res = new String[src.length];\n  for (int i = 0; i < src.length; i++) res[i] = src[i].toLowerCase();\n  return res;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  String[] res = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    res[i] = src[i].toLowerCase();\n  }\n  return res;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src) {\n  final String[] result = new String[src.length];\n  for (int i = 0; i < src.length; i++) {\n    result[i] = src[i].toLowerCase();\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n", "method_name": "copyStrings", "codes": ["private static String[] copyStrings(final String[] src){ final String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ final String[] copy = new String[src.length]; for (int i = 0; i < src.length; i++) { copy[i] = src[i].toLowerCase(); } return copy; }", "private static String[] copyStrings(final String[] src){ final String[] res = new String[src.length]; for (int i = 0; i < src.length; i++) { res[i] = src[i].toLowerCase(); } return res; }", "private static String[] copyStrings(final String[] src){ String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ final String[] res = new String[src.length]; for (int i = 0; i < src.length; i++) { res[i] = src[i]; } return res; }", "private static String[] copyStrings(final String[] src){ final String[] dst = new String[src.length]; for (int i = 0; i < src.length; i++) { dst[i] = src[i].toLowerCase(); } return dst; }", "private static String[] copyStrings(final String[] src){ final String[] copy = new String[src.length]; for (int i = 0; i < src.length; i++) { copy[i] = src[i].toLowerCase(); } return copy; }", "private static String[] copyStrings(final String[] src){ final String[] res = new String[src.length]; for (int i = 0; i < src.length; i++) res[i] = src[i].toLowerCase(); return res; }", "private static String[] copyStrings(final String[] src){ String[] res = new String[src.length]; for (int i = 0; i < src.length; i++) { res[i] = src[i].toLowerCase(); } return res; }", "private static String[] copyStrings(final String[] src){ final String[] result = new String[src.length]; for (int i = 0; i < src.length; i++) { result[i] = src[i].toLowerCase(); } return result; }"], "code_level": "self_contained", "_id": "636767041a6d9265ec0178f8", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (type == String.class) {\n    return value.toString();\n  }\n  if (type == Integer.class || type == int.class) {\n    return Integer.parseInt(value.toString());\n  }\n  if (type == Long.class || type == long.class) {\n    return Long.parseLong(value.toString());\n  }\n  if (type == Double.class || type == double.class) {\n    return Double.parseDouble(value.toString());\n  }\n  if (type == Float.class || type == float.class) {\n    return Float.parseFloat(value.toString());\n  }\n  if (type == Boolean.class || type == boolean.class) {\n    return Boolean.parseBoolean(value.toString());\n  }\n  if (type == Short.class || type == short.class) {\n    return Short.parseShort(value.toString());\n  }\n  if (type == Byte.class || type == byte.class) {\n    return Byte.parseByte(value.toString());\n  }\n  if (type == Character.class || type == char.class) {\n    return value.toString().charAt(0);\n  }\n  if (type == BigDecimal.class) {\n    return new BigDecimal(value.toString());\n  }\n  if (type == BigInteger.class) {\n    return new BigInteger(value.toString());\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (value instanceof String) {\n    return value;\n  }\n  if (value instanceof Long) {\n    return value;\n  }\n  if (value instanceof Integer) {\n    return value;\n  }\n  if (value instanceof Short) {\n    return value;\n  }\n  if (value instanceof Byte) {\n    return value;\n  }\n  if (value instanceof Float) {\n    return value;\n  }\n  if (value instanceof Double) {\n    return value;\n  }\n  if (value instanceof Boolean) {\n    return value;\n  }\n  if (value instanceof BigDecimal) {\n    return value;\n  }\n  if (value instanceof BigInteger) {\n    return value;\n  }\n  if (value instanceof Date) {\n    return value;\n  }\n  if (value instanceof Calendar) {\n    return value;\n  }\n  if (value instanceof URI) {\n    return value;\n  }\n  if (value instanceof File) {\n    return value;\n  }\n  if (value instanceof URL) {\n    return value;\n  }\n  if (value instanceof byte[]) {\n    return value;\n  }\n  if (value instanceof Character) {\n    return value;\n  }\n  throw new Exception(\"Cannot convert '\" + value + \"' to \" + type.getName());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (value instanceof String) {\n    return value;\n  }\n  if (value instanceof Integer) {\n    return value;\n  }\n  if (value instanceof Long) {\n    return value;\n  }\n  if (value instanceof Float) {\n    return value;\n  }\n  if (value instanceof Double) {\n    return value;\n  }\n  if (value instanceof Boolean) {\n    return value;\n  }\n  if (value instanceof Character) {\n    return value;\n  }\n  if (value instanceof Date) {\n    return value;\n  }\n  if (value instanceof DateTime) {\n    return value;\n  }\n  if (value instanceof byte[]) {\n    return value;\n  }\n  if (value instanceof InputStream) {\n    return value;\n  }\n  if (value instanceof Reader) {\n    return value;\n  }\n  if (value instanceof URI) {\n    return value;\n  }\n  if (value instanceof URL) {\n    return value;\n  }\n  throw new Exception(\"Cannot convert \" + value.getClass().getName() + \" to \" + type.getName());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (String.class.equals(type)) {\n    return convertToString(value);\n  }\n  if (Integer.class.equals(type)) {\n    return convertToInteger(value);\n  }\n  if (Long.class.equals(type)) {\n    return convertToLong(value);\n  }\n  if (Double.class.equals(type)) {\n    return convertToDouble(value);\n  }\n  if (Float.class.equals(type)) {\n    return convertToFloat(value);\n  }\n  if (BigDecimal.class.equals(type)) {\n    return convertToBigDecimal(value);\n  }\n  if (BigInteger.class.equals(type)) {\n    return convertToBigInteger(value);\n  }\n  if (Date.class.equals(type)) {\n    return convertToDate(value);\n  }\n  if (Time.class.equals(type)) {\n    return convertToTime(value);\n  }\n  if (Timestamp.class.equals(type)) {\n    return convertToTimestamp(value);\n  }\n  if (Byte.class.equals(type)) {\n    return convertToByte(value);\n  }\n  if (Short.class.equals(type)) {\n    return convertToShort(value);\n  }\n  if (Boolean.class.equals(type)) {\n    return convertToBoolean(value);\n  }\n  if (Character.class.equals(type)) {\n    return convertToCharacter(value);\n  }\n  if (Byte[].class.equals(type)) {\n    return convertToByteArray(value);\n  }\n  if (Object[].class.equals(type)) {\n    return convertToObjectArray(value);\n  }\n  if (Collection.class.equals(type)) {\n    return convertToCollection(value);\n  }\n  if (Map.class.equals(type)) {\n    return convertToMap(value);\n  }\n  if (Collection.class.isAssignableFrom(type)) {\n    return convertToCollection(value);\n  }\n  if (Map.class.isAssignableFrom(type)) {\n    return convertToMap(value);\n  }\n  if (type.isArray()) {\n    return convertToArray(value);\n  }\n  if (value instanceof String) {\n    return value;\n  }\n  if (value instanceof byte[]) {\n    return new String((byte[]) value);\n  }\n  if (value instanceof Byte) {\n    return value;\n  }\n  if (value instanceof Short) {\n    return value;\n  }\n  if (value instanceof Character) {\n    return value;\n  }\n  if (value instanceof BigInteger) {\n    return value;\n  }\n  if (value instanceof BigDecimal) {\n    return value;\n  }\n  if (value instanceof Date) {\n    return value;\n  }\n  if (value instanceof Time) {\n    return value;\n  }\n  if (value instanceof Timestamp) {\n    return value;\n  }\n  if (value instanceof Boolean) {\n    return value;\n  }\n  if (value instanceof Character[]) {\n    return convertToCharacterArray(value);\n  }\n  if (value instanceof Collection) {\n    return convertToCollection(value);\n  }\n  if (value instanceof Map) {\n    return convertToMap(value);\n  }\n  if (value instanceof Object[]) {\n    return convertToObjectArray(value);\n  }\n  throw new IllegalArgumentException(\"Cannot convert type \" + type + \" to \" + type.getName());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    if (type.equals(String.class)) {\n      return \"\";\n    }\n    return null;\n  }\n  if (type.equals(String.class)) {\n    return value;\n  }\n  if (type.equals(Integer.class)) {\n    if (value instanceof Integer) {\n      return (Integer) value;\n    }\n    if (value instanceof String) {\n      return Integer.valueOf((String) value);\n    }\n  }\n  if (type.equals(Long.class)) {\n    if (value instanceof Long) {\n      return (Long) value;\n    }\n    if (value instanceof String) {\n      return Long.valueOf((String) value);\n    }\n  }\n  if (type.equals(Double.class)) {\n    if (value instanceof Double) {\n      return (Double) value;\n    }\n    if (value instanceof String) {\n      return Double.valueOf((String) value);\n    }\n  }\n  if (type.equals(Float.class)) {\n    if (value instanceof Float) {\n      return (Float) value;\n    }\n    if (value instanceof String) {\n      return Float.valueOf((String) value);\n    }\n  }\n  if (type.equals(Boolean.class)) {\n    if (value instanceof Boolean) {\n      return (Boolean) value;\n    }\n    if (value instanceof String) {\n      return Boolean.valueOf((String) value);\n    }\n  }\n  if (type.equals(Short.class)) {\n    if (value instanceof Short) {\n      return (Short) value;\n    }\n    if (value instanceof String) {\n      return Short.valueOf((String) value);\n    }\n  }\n  if (type.equals(Byte.class)) {\n    if (value instanceof Byte) {\n      return (Byte) value;\n    }\n    if (value instanceof String) {\n      return Byte.valueOf((String) value);\n    }\n  }\n  if (type.equals(Character.class)) {\n    if (value instanceof Character) {\n      return (Character) value;\n    }\n    if (value instanceof String) {\n      return Character.valueOf((String) value);\n    }\n  }\n  if (type.equals(Date.class)) {\n    if (value instanceof Date) {\n      return (Date) value;\n    }\n  }\n  if (type.equals(Calendar.class)) {\n    if (value instanceof Calendar) {\n      return (Calendar) value;\n    }\n  }\n  if (type.equals(java.sql.Date.class)) {\n    if (value instanceof java.sql.Date) {\n      return (java.sql.Date) value;\n    }\n  }\n  if (type.equals(Timestamp.class)) {\n    if (value instanceof Timestamp) {\n      return (Timestamp) value;\n    }\n  }\n  return super.convertToType(type, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  final String valueString = value.toString();\n  if (valueString.length() == 0) {\n    return null;\n  }\n  if (type.equals(Boolean.class)) {\n    return Boolean.valueOf(valueString);\n  } else if (type.equals(Integer.class)) {\n    return Integer.valueOf(valueString);\n  } else if (type.equals(Long.class)) {\n    return Long.valueOf(valueString);\n  } else if (type.equals(Float.class)) {\n    return Float.valueOf(valueString);\n  } else if (type.equals(Double.class)) {\n    return Double.valueOf(valueString);\n  } else if (type.equals(String.class)) {\n    return valueString;\n  } else if (type.equals(Date.class)) {\n    return DateUtils.parseDate(valueString, DefaultDateFormat);\n  } else {\n    return valueString;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (type == String.class) {\n    return value.toString();\n  } else if (type == byte[].class) {\n    return value.toString().getBytes(\"UTF-8\");\n  } else if (type == Character.class) {\n    return value.toString().charAt(0);\n  } else {\n    return super.convertToType(type, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  if (type.equals(Integer.class)) {\n    if (value instanceof Integer) {\n      return (Integer) value;\n    } else {\n      return null;\n    }\n  } else if (type.equals(Long.class)) {\n    if (value instanceof Long) {\n      return (Long) value;\n    } else {\n      return null;\n    }\n  } else if (type.equals(Double.class)) {\n    if (value instanceof Double) {\n      return (Double) value;\n    } else {\n      return null;\n    }\n  } else if (type.equals(Float.class)) {\n    if (value instanceof Float) {\n      return (Float) value;\n    } else {\n      return null;\n    }\n  } else if (type.equals(Short.class)) {\n    if (value instanceof Short) {\n      return (Short) value;\n    } else {\n      return null;\n    }\n  } else if (type.equals(Byte.class)) {\n    if (value instanceof Byte) {\n      return (Byte) value;\n    } else {\n      return null;\n    }\n  } else if (type.equals(Boolean.class)) {\n    if (value instanceof Boolean) {\n      return (Boolean) value;\n    } else {\n      return null;\n    }\n  } else if (type.equals(Character.class)) {\n    if (value instanceof Character) {\n      return (Character) value;\n    } else {\n      return null;\n    }\n  } else if (type.equals(String.class)) {\n    if (value instanceof String) {\n      return value;\n    } else {\n      return null;\n    }\n  } else if (type.equals(BigDecimal.class)) {\n    if (value instanceof BigDecimal) {\n      return (BigDecimal) value;\n    } else {\n      return null;\n    }\n  } else if (type.equals(Date.class)) {\n    if (value instanceof Date) {\n      return (Date) value;\n    } else {\n      return null;\n    }\n  } else {\n    throw new Exception(\"Unknown type for conversion: \" + type);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (value == null) {\n    return null;\n  }\n  final String str = (String) value;\n  if (str.length() == 0) {\n    return null;\n  }\n  if (type.equals(String.class)) {\n    return str;\n  }\n  if (type.equals(Integer.class)) {\n    return Integer.parseInt(str);\n  }\n  if (type.equals(Long.class)) {\n    return Long.parseLong(str);\n  }\n  if (type.equals(Float.class)) {\n    return Float.parseFloat(str);\n  }\n  if (type.equals(Double.class)) {\n    return Double.parseDouble(str);\n  }\n  if (type.equals(Boolean.class)) {\n    return Boolean.parseBoolean(str);\n  }\n  if (type.equals(Date.class)) {\n    return convertToDate(str);\n  }\n  if (type.equals(Timestamp.class)) {\n    return convertToTimestamp(str);\n  }\n  if (type.equals(Byte.class)) {\n    return Byte.parseByte(str);\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected Object convertToType(final Class<?> type, final Object value) throws Exception {\n  if (type == String.class) {\n    return value;\n  } else if (type == Integer.class) {\n    return Integer.parseInt(value.toString());\n  } else if (type == Long.class) {\n    return Long.parseLong(value.toString());\n  } else if (type == Short.class) {\n    return Short.parseShort(value.toString());\n  } else if (type == Byte.class) {\n    return Byte.parseByte(value.toString());\n  } else if (type == Float.class) {\n    return Float.parseFloat(value.toString());\n  } else if (type == Double.class) {\n    return Double.parseDouble(value.toString());\n  } else if (type == Boolean.class) {\n    return Boolean.parseBoolean(value.toString());\n  } else if (type == Date.class) {\n    return new Date(Long.parseLong(value.toString()));\n  } else if (type == Character.class) {\n    return value.toString().charAt(0);\n  } else {\n    throw new IllegalArgumentException(\"Unsupported type: \" + type);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n", "method_name": "convertToType", "codes": ["@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (type == String.class) { return value.toString(); } if (type == Integer.class || type == int.class) { return Integer.parseInt(value.toString()); } if (type == Long.class || type == long.class) { return Long.parseLong(value.toString()); } if (type == Double.class || type == double.class) { return Double.parseDouble(value.toString()); } if (type == Float.class || type == float.class) { return Float.parseFloat(value.toString()); } if (type == Boolean.class || type == boolean.class) { return Boolean.parseBoolean(value.toString()); } if (type == Short.class || type == short.class) { return Short.parseShort(value.toString()); } if (type == Byte.class || type == byte.class) { return Byte.parseByte(value.toString()); } if (type == Character.class || type == char.class) { return value.toString().charAt(0); } if (type == BigDecimal.class) { return new BigDecimal(value.toString()); } if (type == BigInteger.class) { return new BigInteger(value.toString()); } return null; }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (value instanceof String) { return value; } if (value instanceof Long) { return value; } if (value instanceof Integer) { return value; } if (value instanceof Short) { return value; } if (value instanceof Byte) { return value; } if (value instanceof Float) { return value; } if (value instanceof Double) { return value; } if (value instanceof Boolean) { return value; } if (value instanceof BigDecimal) { return value; } if (value instanceof BigInteger) { return value; } if (value instanceof Date) { return value; } if (value instanceof Calendar) { return value; } if (value instanceof URI) { return value; } if (value instanceof File) { return value; } if (value instanceof URL) { return value; } if (value instanceof byte[]) { return value; } if (value instanceof Character) { return value; } throw new Exception(\"Cannot convert '\" + value + \"' to \" + type.getName()); }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (value instanceof String) { return value; } if (value instanceof Integer) { return value; } if (value instanceof Long) { return value; } if (value instanceof Float) { return value; } if (value instanceof Double) { return value; } if (value instanceof Boolean) { return value; } if (value instanceof Character) { return value; } if (value instanceof Date) { return value; } if (value instanceof DateTime) { return value; } if (value instanceof byte[]) { return value; } if (value instanceof InputStream) { return value; } if (value instanceof Reader) { return value; } if (value instanceof URI) { return value; } if (value instanceof URL) { return value; } throw new Exception(\"Cannot convert \" + value.getClass().getName() + \" to \" + type.getName()); }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (String.class.equals(type)) { return convertToString(value); } if (Integer.class.equals(type)) { return convertToInteger(value); } if (Long.class.equals(type)) { return convertToLong(value); } if (Double.class.equals(type)) { return convertToDouble(value); } if (Float.class.equals(type)) { return convertToFloat(value); } if (BigDecimal.class.equals(type)) { return convertToBigDecimal(value); } if (BigInteger.class.equals(type)) { return convertToBigInteger(value); } if (Date.class.equals(type)) { return convertToDate(value); } if (Time.class.equals(type)) { return convertToTime(value); } if (Timestamp.class.equals(type)) { return convertToTimestamp(value); } if (Byte.class.equals(type)) { return convertToByte(value); } if (Short.class.equals(type)) { return convertToShort(value); } if (Boolean.class.equals(type)) { return convertToBoolean(value); } if (Character.class.equals(type)) { return convertToCharacter(value); } if (Byte[].class.equals(type)) { return convertToByteArray(value); } if (Object[].class.equals(type)) { return convertToObjectArray(value); } if (Collection.class.equals(type)) { return convertToCollection(value); } if (Map.class.equals(type)) { return convertToMap(value); } if (Collection.class.isAssignableFrom(type)) { return convertToCollection(value); } if (Map.class.isAssignableFrom(type)) { return convertToMap(value); } if (type.isArray()) { return convertToArray(value); } if (value instanceof String) { return value; } if (value instanceof byte[]) { return new String((byte[]) value); } if (value instanceof Byte) { return value; } if (value instanceof Short) { return value; } if (value instanceof Character) { return value; } if (value instanceof BigInteger) { return value; } if (value instanceof BigDecimal) { return value; } if (value instanceof Date) { return value; } if (value instanceof Time) { return value; } if (value instanceof Timestamp) { return value; } if (value instanceof Boolean) { return value; } if (value instanceof Character[]) { return convertToCharacterArray(value); } if (value instanceof Collection) { return convertToCollection(value); } if (value instanceof Map) { return convertToMap(value); } if (value instanceof Object[]) { return convertToObjectArray(value); } throw new IllegalArgumentException(\"Cannot convert type \" + type + \" to \" + type.getName()); }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { if (type.equals(String.class)) { return \"\"; } return null; } if (type.equals(String.class)) { return value; } if (type.equals(Integer.class)) { if (value instanceof Integer) { return (Integer) value; } if (value instanceof String) { return Integer.valueOf((String) value); } } if (type.equals(Long.class)) { if (value instanceof Long) { return (Long) value; } if (value instanceof String) { return Long.valueOf((String) value); } } if (type.equals(Double.class)) { if (value instanceof Double) { return (Double) value; } if (value instanceof String) { return Double.valueOf((String) value); } } if (type.equals(Float.class)) { if (value instanceof Float) { return (Float) value; } if (value instanceof String) { return Float.valueOf((String) value); } } if (type.equals(Boolean.class)) { if (value instanceof Boolean) { return (Boolean) value; } if (value instanceof String) { return Boolean.valueOf((String) value); } } if (type.equals(Short.class)) { if (value instanceof Short) { return (Short) value; } if (value instanceof String) { return Short.valueOf((String) value); } } if (type.equals(Byte.class)) { if (value instanceof Byte) { return (Byte) value; } if (value instanceof String) { return Byte.valueOf((String) value); } } if (type.equals(Character.class)) { if (value instanceof Character) { return (Character) value; } if (value instanceof String) { return Character.valueOf((String) value); } } if (type.equals(Date.class)) { if (value instanceof Date) { return (Date) value; } } if (type.equals(Calendar.class)) { if (value instanceof Calendar) { return (Calendar) value; } } if (type.equals(java.sql.Date.class)) { if (value instanceof java.sql.Date) { return (java.sql.Date) value; } } if (type.equals(Timestamp.class)) { if (value instanceof Timestamp) { return (Timestamp) value; } } return super.convertToType(type, value); }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } final String valueString = value.toString(); if (valueString.length() == 0) { return null; } if (type.equals(Boolean.class)) { return Boolean.valueOf(valueString); } else if (type.equals(Integer.class)) { return Integer.valueOf(valueString); } else if (type.equals(Long.class)) { return Long.valueOf(valueString); } else if (type.equals(Float.class)) { return Float.valueOf(valueString); } else if (type.equals(Double.class)) { return Double.valueOf(valueString); } else if (type.equals(String.class)) { return valueString; } else if (type.equals(Date.class)) { return DateUtils.parseDate(valueString, DefaultDateFormat); } else { return valueString; } }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (type == String.class) { return value.toString(); } else if (type == byte[].class) { return value.toString().getBytes(\"UTF-8\"); } else if (type == Character.class) { return value.toString().charAt(0); } else { return super.convertToType(type, value); } }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } if (type.equals(Integer.class)) { if (value instanceof Integer) { return (Integer) value; } else { return null; } } else if (type.equals(Long.class)) { if (value instanceof Long) { return (Long) value; } else { return null; } } else if (type.equals(Double.class)) { if (value instanceof Double) { return (Double) value; } else { return null; } } else if (type.equals(Float.class)) { if (value instanceof Float) { return (Float) value; } else { return null; } } else if (type.equals(Short.class)) { if (value instanceof Short) { return (Short) value; } else { return null; } } else if (type.equals(Byte.class)) { if (value instanceof Byte) { return (Byte) value; } else { return null; } } else if (type.equals(Boolean.class)) { if (value instanceof Boolean) { return (Boolean) value; } else { return null; } } else if (type.equals(Character.class)) { if (value instanceof Character) { return (Character) value; } else { return null; } } else if (type.equals(String.class)) { if (value instanceof String) { return value; } else { return null; } } else if (type.equals(BigDecimal.class)) { if (value instanceof BigDecimal) { return (BigDecimal) value; } else { return null; } } else if (type.equals(Date.class)) { if (value instanceof Date) { return (Date) value; } else { return null; } } else { throw new Exception(\"Unknown type for conversion: \" + type); } }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (value == null) { return null; } final String str = (String) value; if (str.length() == 0) { return null; } if (type.equals(String.class)) { return str; } if (type.equals(Integer.class)) { return Integer.parseInt(str); } if (type.equals(Long.class)) { return Long.parseLong(str); } if (type.equals(Float.class)) { return Float.parseFloat(str); } if (type.equals(Double.class)) { return Double.parseDouble(str); } if (type.equals(Boolean.class)) { return Boolean.parseBoolean(str); } if (type.equals(Date.class)) { return convertToDate(str); } if (type.equals(Timestamp.class)) { return convertToTimestamp(str); } if (type.equals(Byte.class)) { return Byte.parseByte(str); } return null; }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception { if (type == String.class) { return value; } else if (type == Integer.class) { return Integer.parseInt(value.toString()); } else if (type == Long.class) { return Long.parseLong(value.toString()); } else if (type == Short.class) { return Short.parseShort(value.toString()); } else if (type == Byte.class) { return Byte.parseByte(value.toString()); } else if (type == Float.class) { return Float.parseFloat(value.toString()); } else if (type == Double.class) { return Double.parseDouble(value.toString()); } else if (type == Boolean.class) { return Boolean.parseBoolean(value.toString()); } else if (type == Date.class) { return new Date(Long.parseLong(value.toString())); } else if (type == Character.class) { return value.toString().charAt(0); } else { throw new IllegalArgumentException(\"Unsupported type: \" + type); } }"], "code_level": "project_runnable", "_id": "636767021a6d9265ec0178bf", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public Collection<Object> values() {\n  return Collections.unmodifiableCollection(methods.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return Collections.unmodifiableCollection(methods.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return Collections.unmodifiableList(methods.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return map.values();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return Collections.unmodifiableCollection(beanMap.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return this.methods.values();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return Collections.unmodifiableCollection(map.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return Collections.unmodifiableList(methods.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return Collections.unmodifiableCollection(values);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values() {\n  return Collections.unmodifiableCollection(methodMap.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the values for the BeanMap.\n * @return values for the BeanMap. The returned collection is not modifiable.\n */\n", "method_name": "values", "codes": ["public Collection<Object> values(){ return Collections.unmodifiableCollection(methods.values()); }", "public Collection<Object> values(){ return Collections.unmodifiableCollection(methods.values()); }", "public Collection<Object> values(){ return Collections.unmodifiableList(methods.values()); }", "public Collection<Object> values(){ return map.values(); }", "public Collection<Object> values(){ return Collections.unmodifiableCollection(beanMap.values()); }", "public Collection<Object> values(){ return this.methods.values(); }", "public Collection<Object> values(){ return Collections.unmodifiableCollection(map.values()); }", "public Collection<Object> values(){ return Collections.unmodifiableList(methods.values()); }", "public Collection<Object> values(){ return Collections.unmodifiableCollection(values); }", "public Collection<Object> values(){ return Collections.unmodifiableCollection(methodMap.values()); }"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec01764f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public void putAllWriteable(BeanMap map) {\n  putAllWriteable(map, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Object key : map.keySet()) {\n    putWriteable(key, map.get(key));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  if (!map.isEmpty()) {\n    for (Iterator it = map.keySet().iterator(); it.hasNext(); ) {\n      Object key = it.next();\n      put(key, map.get(key));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  if (map == null) {\n    return;\n  }\n  if (map.size() == 0) {\n    return;\n  }\n  for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n    Map.Entry entry = (Map.Entry) it.next();\n    put(entry.getKey(), entry.getValue());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Iterator iterator = map.entrySet().iterator(); iterator.hasNext(); ) {\n    Map.Entry entry = (Map.Entry) iterator.next();\n    putWriteable((String) entry.getKey(), (BeanValue) entry.getValue());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Object key : map.keySet()) {\n    put(key, map.get(key));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Iterator it = map.keySet().iterator(); it.hasNext(); ) {\n    Object key = it.next();\n    put(key, map.getWriteable(key));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  if (map == null) {\n    throw new IllegalArgumentException(\"Cannot put null map.\");\n  }\n  map.forEach((key, value) -> put(key, value.toWritable()));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (Iterator<String> iter = map.keySet().iterator(); iter.hasNext(); ) {\n    String key = iter.next();\n    if (map.getWriteable(key) != null) {\n      put(key, map.getWriteable(key));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map) {\n  for (BeanPropertyWriter prop : map.getProperties()) {\n    if (prop.getSerializationConfig().isEnabled(SerializationFeature.WRITE_MAP_VALUES_AS_ARRAY)) {\n      if (prop.getType().isArray()) {\n        putAllWriteable(prop.getType(), prop.getName(), prop.getValue());\n      } else {\n        putAllWriteable(prop.getType(), prop.getName(), prop.getValue(), prop.getType());\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts all of the writable properties from the given BeanMap into this BeanMap. Read-only and Write-only properties will be ignored.\n * @param map  the BeanMap whose properties to put\n */\n", "method_name": "putAllWriteable", "codes": ["public void putAllWriteable(BeanMap map){ putAllWriteable(map, false); }", "public void putAllWriteable(BeanMap map){ for (Object key : map.keySet()) { putWriteable(key, map.get(key)); } }", "public void putAllWriteable(BeanMap map){ if (!map.isEmpty()) { for (Iterator it = map.keySet().iterator(); it.hasNext(); ) { Object key = it.next(); put(key, map.get(key)); } } }", "public void putAllWriteable(BeanMap map){ if (map == null) { return; } if (map.size() == 0) { return; } for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) { Map.Entry entry = (Map.Entry) it.next(); put(entry.getKey(), entry.getValue()); } }", "public void putAllWriteable(BeanMap map){ for (Iterator iterator = map.entrySet().iterator(); iterator.hasNext(); ) { Map.Entry entry = (Map.Entry) iterator.next(); putWriteable((String) entry.getKey(), (BeanValue) entry.getValue()); } }", "public void putAllWriteable(BeanMap map){ for (Object key : map.keySet()) { put(key, map.get(key)); } }", "public void putAllWriteable(BeanMap map){ for (Iterator it = map.keySet().iterator(); it.hasNext(); ) { Object key = it.next(); put(key, map.getWriteable(key)); } }", "public void putAllWriteable(BeanMap map){ if (map == null) { throw new IllegalArgumentException(\"Cannot put null map.\"); } map.forEach((key, value) -> put(key, value.toWritable())); }", "public void putAllWriteable(BeanMap map){ for (Iterator<String> iter = map.keySet().iterator(); iter.hasNext(); ) { String key = iter.next(); if (map.getWriteable(key) != null) { put(key, map.getWriteable(key)); } } }", "public void putAllWriteable(BeanMap map){ for (BeanPropertyWriter prop : map.getProperties()) { if (prop.getSerializationConfig().isEnabled(SerializationFeature.WRITE_MAP_VALUES_AS_ARRAY)) { if (prop.getType().isArray()) { putAllWriteable(prop.getType(), prop.getName(), prop.getValue()); } else { putAllWriteable(prop.getType(), prop.getName(), prop.getValue(), prop.getType()); } } } }"], "code_level": "class_runnable", "_id": "636767071a6d9265ec017962", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public long contentLength() {\n  try {\n    return getRequest().getContentLengthLong();\n  } catch (NumberFormatException ex) {\n    return -1;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return this.contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public long contentLength() {\n  return contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  if (!isContentLengthSet) {\n    try {\n      contentLength = Long.parseLong(contentLengthHeader());\n    } catch (NumberFormatException e) {\n      throw new IllegalStateException(\n          \"Unable to parse the Content-Length header in the request\", e);\n    }\n  }\n  return contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return (long) headers.get(\"Content-Length\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength() {\n  return (long) request.getContentLength();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public long contentLength() {\n  return -1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public long contentLength() {\n  if (headers().containsKey(CONTENT_LENGTH)) {\n    return Long.parseLong(headers().get(CONTENT_LENGTH));\n  } else {\n    throw new IllegalStateException(\"Content length is not specified\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Retrieve the content length of the request.\n * @return The content length of the request.\n * @since 1.3\n */\n", "method_name": "contentLength", "codes": ["public long contentLength(){ try { return getRequest().getContentLengthLong(); } catch (NumberFormatException ex) { return -1; } }", "public long contentLength(){ return this.contentLength; }", "public long contentLength(){ return contentLength; }", "public long contentLength(){ return 0; }", "public long contentLength(){ return contentLength; }", "public long contentLength(){ if (!isContentLengthSet) { try { contentLength = Long.parseLong(contentLengthHeader()); } catch (NumberFormatException e) { throw new IllegalStateException(\"Unable to parse the Content-Length header in the request\", e); } } return contentLength; }", "public long contentLength(){ return (long) headers.get(\"Content-Length\"); }", "public long contentLength(){ return (long) request.getContentLength(); }", "public long contentLength(){ return -1; }", "public long contentLength(){ if (headers().containsKey(CONTENT_LENGTH)) { return Long.parseLong(headers().get(CONTENT_LENGTH)); } else { throw new IllegalStateException(\"Content length is not specified\"); } }"], "code_level": "project_runnable", "_id": "636767031a6d9265ec0178dd", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  if (headerPart == null || end < 0) {\n    return -1;\n  }\n  int index = headerPart.indexOf(\"\\r\\n\", end);\n  if (index != -1) {\n    return index;\n  }\n  index = headerPart.indexOf(\"\\n\", end);\n  if (index != -1) {\n    return index;\n  }\n  index = headerPart.indexOf(\"\\r\", end);\n  if (index != -1) {\n    return index;\n  }\n  return headerPart.length();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  for (int i = end - 1; i >= 0; i--) {\n    char c = headerPart.charAt(i);\n    if (c == '\\n') return i;\n  }\n  return -1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int index = headerPart.indexOf(\"\\n\", end);\n  if (index == -1) {\n    throw new IllegalArgumentException(\"Header part not found: \" + headerPart);\n  }\n  return index;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  if (headerPart.startsWith(\"\\r\")) {\n    return headerPart.indexOf(\"\\r\");\n  }\n  if (headerPart.startsWith(\"\\n\")) {\n    return headerPart.indexOf(\"\\n\");\n  }\n  if (headerPart.startsWith(\"\\t\")) {\n    return headerPart.indexOf(\"\\t\");\n  }\n  if (headerPart.startsWith(\"\\f\")) {\n    return headerPart.indexOf(\"\\f\");\n  }\n  if (headerPart.startsWith(\"\\b\")) {\n    return headerPart.indexOf(\"\\b\");\n  }\n  return end;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int index = end;\n  while (index < headerPart.length() && headerPart.charAt(index) == '\\r') {\n    index++;\n  }\n  return index;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int index = end;\n  if (headerPart.charAt(index) == '\\n') {\n    index--;\n  }\n  return index;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int index = end - 1;\n  while (index >= 0 && headerPart.charAt(index) != '\\n') index--;\n  return index + 1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  for (int i = end - 1; i >= 0; i--) {\n    char c = headerPart.charAt(i);\n    if (c == '\\n') {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  if (headerPart.length() > end) {\n    char c = headerPart.charAt(end);\n    if (c == '\\r') {\n      end += 1;\n    } else if (c == '\\n') {\n      end += 2;\n    } else {\n      return end;\n    }\n  }\n  return end;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart, int end) {\n  int pos = headerPart.indexOf('\\n', end);\n  if (pos < 0) {\n    return -1;\n  }\n  return pos;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n", "method_name": "parseEndOfLine", "codes": ["private int parseEndOfLine(String headerPart,int end){ if (headerPart == null || end < 0) { return -1; } int index = headerPart.indexOf(\"\\r\\n\", end); if (index != -1) { return index; } index = headerPart.indexOf(\"\\n\", end); if (index != -1) { return index; } index = headerPart.indexOf(\"\\r\", end); if (index != -1) { return index; } return headerPart.length(); }", "private int parseEndOfLine(String headerPart,int end){ for (int i = end - 1; i >= 0; i--) { char c = headerPart.charAt(i); if (c == '\\n') return i; } return -1; }", "private int parseEndOfLine(String headerPart,int end){ int index = headerPart.indexOf(\"\\n\", end); if (index == -1) { throw new IllegalArgumentException(\"Header part not found: \" + headerPart); } return index; }", "private int parseEndOfLine(String headerPart,int end){ if (headerPart.startsWith(\"\\r\")) { return headerPart.indexOf(\"\\r\"); } if (headerPart.startsWith(\"\\n\")) { return headerPart.indexOf(\"\\n\"); } if (headerPart.startsWith(\"\\t\")) { return headerPart.indexOf(\"\\t\"); } if (headerPart.startsWith(\"\\f\")) { return headerPart.indexOf(\"\\f\"); } if (headerPart.startsWith(\"\\b\")) { return headerPart.indexOf(\"\\b\"); } return end; }", "private int parseEndOfLine(String headerPart,int end){ int index = end; while (index < headerPart.length() && headerPart.charAt(index) == '\\r') { index++; } return index; }", "private int parseEndOfLine(String headerPart,int end){ int index = end; if (headerPart.charAt(index) == '\\n') { index--; } return index; }", "private int parseEndOfLine(String headerPart,int end){ int index = end - 1; while (index >= 0 && headerPart.charAt(index) != '\\n') index--; return index + 1; }", "private int parseEndOfLine(String headerPart,int end){ for (int i = end - 1; i >= 0; i--) { char c = headerPart.charAt(i); if (c == '\\n') { return i; } } return -1; }", "private int parseEndOfLine(String headerPart,int end){ if (headerPart.length() > end) { char c = headerPart.charAt(end); if (c == '\\r') { end += 1; } else if (c == '\\n') { end += 2; } else { return end; } } return end; }", "private int parseEndOfLine(String headerPart,int end){ int pos = headerPart.indexOf('\\n', end); if (pos < 0) { return -1; } return pos; }"], "code_level": "self_contained", "_id": "636767121a6d9265ec017b0a", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "protected int findByte(byte value, int pos) {\n  if (pos < 0 || pos >= count) {\n    throw new ArrayIndexOutOfBoundsException();\n  }\n  for (int i = pos; i < count; i++) {\n    if (buffer[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value, int pos) {\n  for (int i = pos; i < buf.length; i++) {\n    if (buf[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value, int pos) {\n  int i;\n  for (i = pos; i < _buffer.length; i++) {\n    if (_buffer[i] == value) {\n      break;\n    }\n  }\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value, int pos) {\n  int s = pos;\n  for (int i = pos; i < s; i++) {\n    if (buffer[i] == value) {\n      return i;\n    }\n  }\n  return s;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected int findByte(byte value, int pos) {\n  byte[] buffer = this.buffer;\n  int end = this.end;\n  int s = pos;\n  while (s < end) {\n    byte v = buffer[s];\n    if (v == value) {\n      return s;\n    }\n    s++;\n  }\n  return -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value, int pos) {\n  for (int i = pos; i < length; i++) {\n    if (buffer[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value, int pos) {\n  for (int i = pos; i < buf.length; i++) {\n    if (buf[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value, int pos) {\n  int ret = -1;\n  for (int i = pos; i < buffer.length; i++) {\n    if (buffer[i] == value) {\n      ret = i;\n      break;\n    }\n  }\n  return ret;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected int findByte(byte value, int pos) {\n  int i = pos;\n  while (i < limit && ((buffer[i]) & 0xff) == value) {\n    i++;\n  }\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value, int pos) {\n  if (pos >= m_buffer.length) {\n    return -1;\n  }\n  for (int i = pos; i < m_buffer.length; i++) {\n    if (m_buffer[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n", "method_name": "findByte", "codes": ["protected int findByte(byte value,int pos){ if (pos < 0 || pos >= count) { throw new ArrayIndexOutOfBoundsException(); } for (int i = pos; i < count; i++) { if (buffer[i] == value) { return i; } } return -1; }", "protected int findByte(byte value,int pos){ for (int i = pos; i < buf.length; i++) { if (buf[i] == value) { return i; } } return -1; }", "protected int findByte(byte value,int pos){ int i; for (i = pos; i < _buffer.length; i++) { if (_buffer[i] == value) { break; } } return i; }", "protected int findByte(byte value,int pos){ int s = pos; for (int i = pos; i < s; i++) { if (buffer[i] == value) { return i; } } return s; }", "protected int findByte(byte value,int pos){ byte[] buffer = this.buffer; int end = this.end; int s = pos; while (s < end) { byte v = buffer[s]; if (v == value) { return s; } s++; } return -1; }", "protected int findByte(byte value,int pos){ for (int i = pos; i < length; i++) { if (buffer[i] == value) { return i; } } return -1; }", "protected int findByte(byte value,int pos){ for (int i = pos; i < buf.length; i++) { if (buf[i] == value) { return i; } } return -1; }", "protected int findByte(byte value,int pos){ int ret = -1; for (int i = pos; i < buffer.length; i++) { if (buffer[i] == value) { ret = i; break; } } return ret; }", "protected int findByte(byte value,int pos){ int i = pos; while (i < limit && ((buffer[i]) & 0xff) == value) { i++; } return i; }", "protected int findByte(byte value,int pos){ if (pos >= m_buffer.length) { return -1; } for (int i = pos; i < m_buffer.length; i++) { if (m_buffer[i] == value) { return i; } } return -1; }"], "code_level": "class_runnable", "_id": "636766ff1a6d9265ec017851", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public byte readByte() throws IOException {\n  if (pos >= end) {\n    fillBuffer();\n    if (pos >= end) {\n      return -1;\n    }\n  }\n  return buf[pos++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  if (!isOpen()) {\n    throw new IOException(\"Stream closed\");\n  }\n  if (pos >= bytes.length) {\n    if (!readNextBlock()) {\n      throw new IOException(\"Unable to read any bytes\");\n    }\n  }\n  return bytes[pos++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  byte b = 0;\n  if (this.eof) {\n    return -1;\n  }\n  b = this.buffer[this.currentPosition];\n  this.currentPosition++;\n  if (this.currentPosition >= this.buffer.length) {\n    this.eof = true;\n  }\n  return b;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  if (!buffer.hasRemaining()) {\n    readBuffer();\n  }\n  return buffer.get();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  int i = read();\n  if (i == -1) {\n    throw new EOFException();\n  }\n  return (byte) i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  return buffer[pos++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  return m_buffer[m_position++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  int i = read();\n  if (i == -1) {\n    throw new EOFException();\n  }\n  return (byte) i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  if (this.bufferIndex == this.bufferLength) {\n    if (this.bufferLength > 0) {\n      byte[] tmp = new byte[this.bufferLength];\n      System.arraycopy(this.buffer, 0, tmp, 0, this.bufferLength);\n      this.buffer = tmp;\n    }\n    this.bufferIndex = 0;\n    this.bufferLength = this.in.read(this.buffer);\n    if (this.bufferLength == -1) {\n      this.closed = true;\n      return -1;\n    }\n  }\n  return this.buffer[this.bufferIndex++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n  return (byte) read(Byte.BYTES);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a byte from the <code>buffer</code>, and refills it as necessary.\n * @return The next byte from the input stream.\n * @throws IOException if there is no more data available.\n */\n", "method_name": "readByte", "codes": ["public byte readByte() throws IOException { if (pos >= end) { fillBuffer(); if (pos >= end) { return -1; } } return buf[pos++]; }", "public byte readByte() throws IOException { if (!isOpen()) { throw new IOException(\"Stream closed\"); } if (pos >= bytes.length) { if (!readNextBlock()) { throw new IOException(\"Unable to read any bytes\"); } } return bytes[pos++]; }", "public byte readByte() throws IOException { byte b = 0; if (this.eof) { return -1; } b = this.buffer[this.currentPosition]; this.currentPosition++; if (this.currentPosition >= this.buffer.length) { this.eof = true; } return b; }", "public byte readByte() throws IOException { if (!buffer.hasRemaining()) { readBuffer(); } return buffer.get(); }", "public byte readByte() throws IOException { int i = read(); if (i == -1) { throw new EOFException(); } return (byte) i; }", "public byte readByte() throws IOException { return buffer[pos++]; }", "public byte readByte() throws IOException { return m_buffer[m_position++]; }", "public byte readByte() throws IOException { int i = read(); if (i == -1) { throw new EOFException(); } return (byte) i; }", "public byte readByte() throws IOException { if (this.bufferIndex == this.bufferLength) { if (this.bufferLength > 0) { byte[] tmp = new byte[this.bufferLength]; System.arraycopy(this.buffer, 0, tmp, 0, this.bufferLength); this.buffer = tmp; } this.bufferIndex = 0; this.bufferLength = this.in.read(this.buffer); if (this.bufferLength == -1) { this.closed = true; return -1; } } return this.buffer[this.bufferIndex++]; }", "public byte readByte() throws IOException { return (byte) read(Byte.BYTES); }"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec01774b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private String parseToken(final char[] terminators) {\n  StringBuilder token = new StringBuilder();\n  while (true) {\n    if (!isNextCharacter(terminators[index])) break;\n    token.append(terminators[index++]);\n  }\n  return token.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  StringBuilder token = new StringBuilder();\n  int i = 0;\n  while (i < terminators.length) {\n    char c = terminators[i];\n    if (c == '\\\\') {\n      if (++i < terminators.length) {\n        c = terminators[i];\n        if (c == 'n') {\n          token.append('\\n');\n        } else if (c == 't') {\n          token.append('\\t');\n        } else if (c == 'r') {\n          token.append('\\r');\n        } else if (c == 'f') {\n          token.append('\\f');\n        } else if (c == '\"') {\n          token.append('\"');\n        } else if (c == '\\'') {\n          token.append('\\'');\n        } else if (c == '\\\\') {\n          token.append('\\\\');\n        } else if (c == 'x') {\n          token.append('x');\n        } else if (c == 'X') {\n          token.append('X');\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized escape character: \" + c);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Missing escape character\");\n      }\n    } else {\n      token.append(c);\n    }\n    i++;\n  }\n  return token.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  StringBuilder token = new StringBuilder();\n  boolean escape = false;\n  boolean escaped = false;\n  while (!escape) {\n    if (chars.length <= pos) {\n      throw new RuntimeException(\"Unexpected end of input\");\n    }\n    char c = chars[pos];\n    if (escaped) {\n      escaped = false;\n      if (c == '\\\\') {\n        escape = true;\n      } else if (c == '\\'') {\n        escaped = true;\n      } else {\n        throw new RuntimeException(\"Unexpected character in token\");\n      }\n    } else if (c == '\\\\') {\n      escape = true;\n    } else if (c == '\\'') {\n      escaped = true;\n    } else {\n      escaped = true;\n    }\n    if (c == '\"') {\n      escape = true;\n    } else if (c == '\\'') {\n      escape = true;\n    } else if (c == terminators[0]) {\n      pos++;\n      token.append(c);\n    } else if (c == '\\n' || c == '\\r') {\n      pos++;\n      break;\n    } else {\n      token.append(c);\n    }\n  }\n  return token.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators){ final int n = terminators.length; int i = 0; while (i < n) { final char c = terminators[i]; switch(c) { case '\\n': case '\\r': case '\\t': case '\\f': case '\\b': case '\\'': case '\"': case '\\\\': case '`': case '{': case '}': case '[': case ']': case '(': case ')': case ',': case ';': case ':': case '=': case ':': case '+': case '-': case '*': case '/': case '?': case '^': case '!': case '&': case '|': case '~': case '&': case '|': case '^': case '?': case '~': case '*': case '/': case '=': case '!': case '*': case '/': case '|': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-':", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  final StringBuilder sb = new StringBuilder();\n  final char c = next();\n  while (c != '\\0' && c != terminators[0]) {\n    sb.append(c);\n    c = next();\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  final StringBuilder token = new StringBuilder();\n  final char[] buffer = new char[1024];\n  int read = 0;\n  int i = 0;\n  while (read < buffer.length) {\n    final char c = buffer[read];\n    if (c == '\\\\') {\n      i = parseEscapeSequence(terminators, i, buffer);\n    } else if (c == '\\'') {\n      i = parseSingleCharacter(terminators, i, buffer);\n    } else if (c == '\"') {\n      i = parseDoubleQuotedString(terminators, i, buffer);\n    } else if (c == '\\n') {\n      i = parseNewline(terminators, i);\n    } else if (c == '\\r') {\n      i = parseNewline(terminators, i);\n    } else if (c == '\\t') {\n      i = parseTab(terminators, i);\n    } else {\n      i = parseCharacter(terminators, i, buffer);\n    }\n    read++;\n  }\n  return token.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  int pos = 0;\n  while (pos < terminators.length) {\n    final char c = terminators[pos];\n    if (c == ' ' || c == '\\t') {\n      pos++;\n      continue;\n    }\n    if (c == '\\n' || c == '\\r') {\n      break;\n    }\n    pos++;\n  }\n  final StringBuilder sb = new StringBuilder();\n  while (pos < terminators.length) {\n    final char c = terminators[pos];\n    if (c == ' ' || c == '\\t') {\n      pos++;\n      continue;\n    }\n    if (c == '\\n' || c == '\\r') {\n      break;\n    }\n    sb.append(c);\n    pos++;\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  final StringBuilder token = new StringBuilder();\n  boolean foundTerminator = false;\n  boolean foundEscape = false;\n  int index = 0;\n  while (!foundTerminator && index < terminators.length) {\n    final char c = terminators[index];\n    if (c == '\\\\') {\n      foundEscape = true;\n      index++;\n      continue;\n    }\n    if (c == '\\'') {\n      foundTerminator = true;\n      continue;\n    }\n    if (foundTerminator) {\n      if (foundEscape) {\n        token.append(c);\n        foundEscape = false;\n      } else {\n        token.append(terminators[index]);\n      }\n      index++;\n    } else {\n      token.append(c);\n    }\n    foundTerminator = false;\n  }\n  return token.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  final int i = index;\n  while (i < length && (terminators[i] == ' ' || terminators[i] == '\\t')) {\n    i++;\n  }\n  if (i == length) {\n    return null;\n  }\n  final StringBuilder builder = new StringBuilder(length - i);\n  while (i < length) {\n    if (terminators[i] == ' ' || terminators[i] == '\\t') {\n      i++;\n    } else {\n      builder.append(terminators[i++]);\n    }\n  }\n  return builder.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators) {\n  final StringBuilder sb = new StringBuilder();\n  while (true) {\n    final int i = pos;\n    if (terminators == null || terminators.length == 0 || pos >= chars.length) {\n      if (sb.length() > 0) {\n        return sb.toString();\n      } else {\n        return null;\n      }\n    }\n    final char c = chars[pos];\n    if (terminators != null && terminators.length > 0 && terminators[0] == c) {\n      pos++;\n    } else {\n      if (c == '\\'') {\n        pos++;\n      } else {\n        break;\n      }\n    }\n    sb.append(c);\n  }\n  throw new IllegalArgumentException(\"Unexpected end of input\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n", "method_name": "parseToken", "codes": ["private String parseToken(final char[] terminators){ StringBuilder token = new StringBuilder(); while (true) { if (!isNextCharacter(terminators[index])) break; token.append(terminators[index++]); } return token.toString(); }", "private String parseToken(final char[] terminators){ StringBuilder token = new StringBuilder(); int i = 0; while (i < terminators.length) { char c = terminators[i]; if (c == '\\\\') { if (++i < terminators.length) { c = terminators[i]; if (c == 'n') { token.append('\\n'); } else if (c == 't') { token.append('\\t'); } else if (c == 'r') { token.append('\\r'); } else if (c == 'f') { token.append('\\f'); } else if (c == '\"') { token.append('\"'); } else if (c == '\\'') { token.append('\\''); } else if (c == '\\\\') { token.append('\\\\'); } else if (c == 'x') { token.append('x'); } else if (c == 'X') { token.append('X'); } else { throw new IllegalArgumentException(\"Unrecognized escape character: \" + c); } } else { throw new IllegalArgumentException(\"Missing escape character\"); } } else { token.append(c); } i++; } return token.toString(); }", "private String parseToken(final char[] terminators){ StringBuilder token = new StringBuilder(); boolean escape = false; boolean escaped = false; while (!escape) { if (chars.length <= pos) { throw new RuntimeException(\"Unexpected end of input\"); } char c = chars[pos]; if (escaped) { escaped = false; if (c == '\\\\') { escape = true; } else if (c == '\\'') { escaped = true; } else { throw new RuntimeException(\"Unexpected character in token\"); } } else if (c == '\\\\') { escape = true; } else if (c == '\\'') { escaped = true; } else { escaped = true; } if (c == '\"') { escape = true; } else if (c == '\\'') { escape = true; } else if (c == terminators[0]) { pos++; token.append(c); } else if (c == '\\n' || c == '\\r') { pos++; break; } else { token.append(c); } } return token.toString(); }", "private String parseToken(final char[] terminators){ final int n = terminators.length; int i = 0; while (i < n) { final char c = terminators[i]; switch(c) { case '\\n': case '\\r': case '\\t': case '\\f': case '\\b': case '\\'': case '\"': case '\\\\': case '`': case '{': case '}': case '[': case ']': case '(': case ')': case ',': case ';': case ':': case '=': case ':': case '+': case '-': case '*': case '/': case '?': case '^': case '!': case '&': case '|': case '~': case '&': case '|': case '^': case '?': case '~': case '*': case '/': case '=': case '!': case '*': case '/': case '|': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-': case '*': case '/': case '=': case '!': case '*': case '/': case '?': case '~': case '&': case '|': case '^': case '?': case '~': case '+': case '-':", "private String parseToken(final char[] terminators){ final StringBuilder sb = new StringBuilder(); final char c = next(); while (c != '\\0' && c != terminators[0]) { sb.append(c); c = next(); } return sb.toString(); }", "private String parseToken(final char[] terminators){ final StringBuilder token = new StringBuilder(); final char[] buffer = new char[1024]; int read = 0; int i = 0; while (read < buffer.length) { final char c = buffer[read]; if (c == '\\\\') { i = parseEscapeSequence(terminators, i, buffer); } else if (c == '\\'') { i = parseSingleCharacter(terminators, i, buffer); } else if (c == '\"') { i = parseDoubleQuotedString(terminators, i, buffer); } else if (c == '\\n') { i = parseNewline(terminators, i); } else if (c == '\\r') { i = parseNewline(terminators, i); } else if (c == '\\t') { i = parseTab(terminators, i); } else { i = parseCharacter(terminators, i, buffer); } read++; } return token.toString(); }", "private String parseToken(final char[] terminators){ int pos = 0; while (pos < terminators.length) { final char c = terminators[pos]; if (c == ' ' || c == '\\t') { pos++; continue; } if (c == '\\n' || c == '\\r') { break; } pos++; } final StringBuilder sb = new StringBuilder(); while (pos < terminators.length) { final char c = terminators[pos]; if (c == ' ' || c == '\\t') { pos++; continue; } if (c == '\\n' || c == '\\r') { break; } sb.append(c); pos++; } return sb.toString(); }", "private String parseToken(final char[] terminators){ final StringBuilder token = new StringBuilder(); boolean foundTerminator = false; boolean foundEscape = false; int index = 0; while (!foundTerminator && index < terminators.length) { final char c = terminators[index]; if (c == '\\\\') { foundEscape = true; index++; continue; } if (c == '\\'') { foundTerminator = true; continue; } if (foundTerminator) { if (foundEscape) { token.append(c); foundEscape = false; } else { token.append(terminators[index]); } index++; } else { token.append(c); } foundTerminator = false; } return token.toString(); }", "private String parseToken(final char[] terminators){ final int i = index; while (i < length && (terminators[i] == ' ' || terminators[i] == '\\t')) { i++; } if (i == length) { return null; } final StringBuilder builder = new StringBuilder(length - i); while (i < length) { if (terminators[i] == ' ' || terminators[i] == '\\t') { i++; } else { builder.append(terminators[i++]); } } return builder.toString(); }", "private String parseToken(final char[] terminators){ final StringBuilder sb = new StringBuilder(); while (true) { final int i = pos; if (terminators == null || terminators.length == 0 || pos >= chars.length) { if (sb.length() > 0) { return sb.toString(); } else { return null; } } final char c = chars[pos]; if (terminators != null && terminators.length > 0 && terminators[0] == c) { pos++; } else { if (c == '\\'') { pos++; } else { break; } } sb.append(c); } throw new IllegalArgumentException(\"Unexpected end of input\"); }"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec01779c", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  int aLen = a.length;\n  int bLen = b.length;\n  if (aLen != bLen) {\n    return false;\n  }\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a.length != b.length) return false;\n  for (int i = 0; i < count; i++) if (a[i] != b[i]) return false;\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a.length != b.length) return false;\n  for (int i = 0; i < a.length; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (count <= 0) return false;\n  if (count > a.length) return false;\n  if (count > b.length) return false;\n  if (count == 0) return true;\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a == b && count == 0) {\n    return true;\n  }\n  if (a == null || b == null || a.length != b.length) {\n    return false;\n  }\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a.length != b.length) return false;\n  for (int i = 0; i < count; i++) if (a[i] != b[i]) return false;\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a.length != b.length) return false;\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a == b) {\n    return true;\n  }\n  if (a == null || b == null || a.length != b.length) {\n    return false;\n  }\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (count > a.length) {\n    return false;\n  } else {\n    if (count > b.length) {\n      return false;\n    } else {\n      for (int i = 0; i < count; i++) {\n        if (a[i] != b[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a, byte[] b, int count) {\n  if (a.length != b.length) {\n    return false;\n  }\n  for (int i = 0; i < count; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.\n * @param a     The first array to compare.\n * @param b     The second array to compare.\n * @param count How many bytes should be compared.\n * @return <code>true</code> if <code>count</code> first bytes in arrays<code>a</code> and <code>b</code> are equal.\n */\n", "method_name": "arrayequals", "codes": ["public static boolean arrayequals(byte[] a,byte[] b,int count){ int aLen = a.length; int bLen = b.length; if (aLen != bLen) { return false; } for (int i = 0; i < count; i++) { if (a[i] != b[i]) { return false; } } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a.length != b.length) return false; for (int i = 0; i < count; i++) if (a[i] != b[i]) return false; return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a.length != b.length) return false; for (int i = 0; i < a.length; i++) { if (a[i] != b[i]) { return false; } } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (count <= 0) return false; if (count > a.length) return false; if (count > b.length) return false; if (count == 0) return true; for (int i = 0; i < count; i++) { if (a[i] != b[i]) return false; } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a == b && count == 0) { return true; } if (a == null || b == null || a.length != b.length) { return false; } for (int i = 0; i < count; i++) { if (a[i] != b[i]) { return false; } } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a.length != b.length) return false; for (int i = 0; i < count; i++) if (a[i] != b[i]) return false; return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a.length != b.length) return false; for (int i = 0; i < count; i++) { if (a[i] != b[i]) return false; } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a == b) { return true; } if (a == null || b == null || a.length != b.length) { return false; } for (int i = 0; i < count; i++) { if (a[i] != b[i]) { return false; } } return true; }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (count > a.length) { return false; } else { if (count > b.length) { return false; } else { for (int i = 0; i < count; i++) { if (a[i] != b[i]) { return false; } } return true; } } }", "public static boolean arrayequals(byte[] a,byte[] b,int count){ if (a.length != b.length) { return false; } for (int i = 0; i < count; i++) { if (a[i] != b[i]) { return false; } } return true; }"], "code_level": "self_contained", "_id": "636766fd1a6d9265ec017814", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  return lastIndexOf(str, searchStr, str.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if (str == null || searchStr == null || searchStr.length() == 0) {\n    return INDEXNOTFOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEXNOTFOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEXNOTFOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEXNOTFOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  return lastIndexOf(str, searchStr, str.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  return lastIndexOf(str, searchStr, str.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEXNOTFOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  return lastIndexOf(str, searchStr, str.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str, String searchStr) {\n  return lastIndexOf(str, searchStr, str.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. \n */\n", "method_name": "lastIndexOf", "codes": ["public static int lastIndexOf(String str,String searchStr){ return lastIndexOf(str, searchStr, str.length()); }", "public static int lastIndexOf(String str,String searchStr){ if (str == null || searchStr == null || searchStr.length() == 0) { return INDEXNOTFOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEXNOTFOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEXNOTFOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEXNOTFOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ return lastIndexOf(str, searchStr, str.length()); }", "public static int lastIndexOf(String str,String searchStr){ return lastIndexOf(str, searchStr, str.length()); }", "public static int lastIndexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEXNOTFOUND; } return str.lastIndexOf(searchStr); }", "public static int lastIndexOf(String str,String searchStr){ return lastIndexOf(str, searchStr, str.length()); }", "public static int lastIndexOf(String str,String searchStr){ return lastIndexOf(str, searchStr, str.length()); }"], "code_level": "project_runnable", "_id": "636766f61a6d9265ec017701", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String sub(String str, int start, int end) {\n  return sub(str, start, end, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  return sub(str, start, end, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  return sub(str, start, end, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end < 0) {\n    end = str.length() + end;\n  }\n  if (start < 0) {\n    start = str.length() + start;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    return EMPTY;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  if (str == null) {\n    return null;\n  }\n  if (end <= 0) {\n    end = str.length();\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end > str.length()) {\n    end = str.length();\n  }\n  if (start > end) {\n    int temp = end;\n    end = start;\n    start = temp;\n  }\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  return str.substring(start, end);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String sub(String str, int start, int end) {\n  return sub(str, start, end, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  return sub(str, start, end, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str, int start, int end) {\n  return str.substring(start, end);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Gets a substring from the specified String avoiding exceptions. \n */\n", "method_name": "sub", "codes": ["public static String sub(String str,int start,int end){ return sub(str, start, end, null); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ return sub(str, start, end, null); }", "public static String sub(String str,int start,int end){ return sub(str, start, end, null); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end < 0) { end = str.length() + end; } if (start < 0) { start = str.length() + start; } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ if (str == null) { return null; } if (end <= 0) { end = str.length(); } if (start < 0) { start = 0; } if (end > str.length()) { end = str.length(); } if (start > end) { int temp = end; end = start; start = temp; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }", "public static String sub(String str,int start,int end){ return sub(str, start, end, null); }", "public static String sub(String str,int start,int end){ return sub(str, start, end, null); }", "public static String sub(String str,int start,int end){ return str.substring(start, end); }"], "code_level": "project_runnable", "_id": "636766ff1a6d9265ec01783b", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (isEmpty(str) || searchStrArray == null || searchStrArray.size() == 0) {\n    return false;\n  }\n  for (String s : searchStrArray) {\n    if (str.indexOf(s) >= 0) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null || searchStrArray.isEmpty()) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (str.contains(searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null) {\n    return false;\n  }\n  if (str.length() > 0) {\n    for (String s : searchStrArray) {\n      if (str.toLowerCase().contains(s.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str != null && searchStrArray != null) {\n    for (String s : searchStrArray) {\n      if (str.toLowerCase().contains(s.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null || searchStrArray.size() == 0) return false;\n  for (String searchStr : searchStrArray) {\n    if (str.contains(searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null || searchStrArray.size() == 0) return false;\n  for (String s : searchStrArray) {\n    if (str.equalsIgnoreCase(s)) return true;\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  for (String searchStr : searchStrArray) {\n    if (str.toLowerCase().contains(searchStr.toLowerCase())) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null || searchStrArray.isEmpty()) return false;\n  for (String searchStr : searchStrArray) {\n    if (str.contains(searchStr)) return true;\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (str.contains(searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n  if (str == null || searchStrArray == null || searchStrArray.isEmpty()) {\n    return false;\n  }\n  for (String searchStr : searchStrArray) {\n    if (containsIgnoreCase(str, searchStr)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Case in-sensitive Checks if the String contains any character in the given set of string. \n */\n", "method_name": "containsAnyIgnoreCase", "codes": ["public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (isEmpty(str) || searchStrArray == null || searchStrArray.size() == 0) { return false; } for (String s : searchStrArray) { if (str.indexOf(s) >= 0) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null || searchStrArray.isEmpty()) { return false; } for (String searchStr : searchStrArray) { if (str.contains(searchStr)) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null) { return false; } if (str.length() > 0) { for (String s : searchStrArray) { if (str.toLowerCase().contains(s.toLowerCase())) { return true; } } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str != null && searchStrArray != null) { for (String s : searchStrArray) { if (str.toLowerCase().contains(s.toLowerCase())) { return true; } } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null || searchStrArray.size() == 0) return false; for (String searchStr : searchStrArray) { if (str.contains(searchStr)) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null || searchStrArray.size() == 0) return false; for (String s : searchStrArray) { if (str.equalsIgnoreCase(s)) return true; } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ for (String searchStr : searchStrArray) { if (str.toLowerCase().contains(searchStr.toLowerCase())) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null || searchStrArray.isEmpty()) return false; for (String searchStr : searchStrArray) { if (str.contains(searchStr)) return true; } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null) { return false; } for (String searchStr : searchStrArray) { if (str.contains(searchStr)) { return true; } } return false; }", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){ if (str == null || searchStrArray == null || searchStrArray.isEmpty()) { return false; } for (String searchStr : searchStrArray) { if (containsIgnoreCase(str, searchStr)) { return true; } } return false; }"], "code_level": "project_runnable", "_id": "6367670b1a6d9265ec017a0f", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static int indexOf(String str, String searchStr) {\n  return indexOf(str, searchStr, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return -1;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null || searchStr.length() == 0) {\n    return -1;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  return indexOf(str, searchStr, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return -1;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return INDEX_NOT_FOUND;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  return indexOf(str, searchStr, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  return str.indexOf(searchStr);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  return indexOf(str, searchStr, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str, String searchStr) {\n  if (str == null || searchStr == null) {\n    return -1;\n  }\n  return str.indexOf(searchStr);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Finds the first index within a String, handling <code>null</code>. This method uses  {@link String#indexOf(String)}. \n */\n", "method_name": "indexOf", "codes": ["public static int indexOf(String str,String searchStr){ return indexOf(str, searchStr, 0); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null) { return -1; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null || searchStr.length() == 0) { return -1; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ return indexOf(str, searchStr, 0); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null) { return -1; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ return indexOf(str, searchStr, 0); }", "public static int indexOf(String str,String searchStr){ return str.indexOf(searchStr); }", "public static int indexOf(String str,String searchStr){ return indexOf(str, searchStr, 0); }", "public static int indexOf(String str,String searchStr){ if (str == null || searchStr == null) { return -1; } return str.indexOf(searchStr); }"], "code_level": "project_runnable", "_id": "636767021a6d9265ec0178bc", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == ',' || c == ';';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == ',' || c == ';' || c == '(' || c == ')';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return (c == '(' || c == '[' || c == '{')\n      && !(c == '\\\\')\n      && !(c == '\"')\n      && !(c == ',')\n      && !(c == ')')\n      && !(c == '}')\n      && !(c == ')');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == '(' || c == ')' || c == ',';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == '(' || c == ')' || c == ',';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return Character.isLetterOrDigit(c) || c == '_' || c == '.' || c == '-';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == ',' || c == ';' || c == '(' || c == ')' || c == '\\\\';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return (c == '(' || c == ')' || c == ',' || c == ';' || c == '=' || c == '.' || c == '+'\n      || c == '-' || c == '*' || c == '/' || c == '^' || c == '%');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == ',' || c == ';' || c == ':' || c == '=' || c == '+' || c == '-';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c) {\n  return c == '(' || c == ')';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n", "method_name": "isParameterSeparator", "codes": ["private static boolean isParameterSeparator(final char c){ return c == ',' || c == ';'; }", "private static boolean isParameterSeparator(final char c){ return c == ',' || c == ';' || c == '(' || c == ')'; }", "private static boolean isParameterSeparator(final char c){ return (c == '(' || c == '[' || c == '{') && !(c == '\\\\') && !(c == '\"') && !(c == ',') && !(c == ')') && !(c == '}') && !(c == ')'); }", "private static boolean isParameterSeparator(final char c){ return c == '(' || c == ')' || c == ','; }", "private static boolean isParameterSeparator(final char c){ return c == '(' || c == ')' || c == ','; }", "private static boolean isParameterSeparator(final char c){ return Character.isLetterOrDigit(c) || c == '_' || c == '.' || c == '-'; }", "private static boolean isParameterSeparator(final char c){ return c == ',' || c == ';' || c == '(' || c == ')' || c == '\\\\'; }", "private static boolean isParameterSeparator(final char c){ return (c == '(' || c == ')' || c == ',' || c == ';' || c == '=' || c == '.' || c == '+' || c == '-' || c == '*' || c == '/' || c == '^' || c == '%'); }", "private static boolean isParameterSeparator(final char c){ return c == ',' || c == ';' || c == ':' || c == '=' || c == '+' || c == '-'; }", "private static boolean isParameterSeparator(final char c){ return c == '(' || c == ')'; }"], "code_level": "class_runnable", "_id": "636766fc1a6d9265ec0177da", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  Object result = Array.newInstance(newArrayComponentType, array.length);\n  System.arraycopy(array, 0, result, 0, array.length);\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  Object result = Array.newInstance(newArrayComponentType, ((Object[]) array).length);\n  System.arraycopy(((Object[]) array), 0, result, 0, Array.getLength(array));\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  if (array.getClass().isArray()) {\n    final int length = Array.getLength(array);\n    final Object newArray = Array.newInstance(array.getClass().getComponentType(), length + 1);\n    System.arraycopy(array, 0, newArray, 0, length);\n    return newArray;\n  }\n  return Array.newInstance(array.getClass().getComponentType(), 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  int newLength = Array.getLength(array);\n  if (newLength == 0) {\n    return Array.newInstance(newArrayComponentType, 1);\n  }\n  if (newLength > Array.getLength(array)) {\n    throw new IllegalArgumentException(\n        \"Cannot create an array of length \"\n            + newLength\n            + \" at index \"\n            + newLength\n            + \". The array must have at least one element.\");\n  }\n  final Object result = Array.newInstance(newArrayComponentType, newLength + 1);\n  System.arraycopy(array, 0, result, 0, Math.min(newLength, Array.getLength(array)));\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  if (array.getClass().isArray()) {\n    final int length = Array.getLength(array);\n    final Object newArray = Array.newInstance(array.getClass().getComponentType(), length + 1);\n    System.arraycopy(array, 0, newArray, 0, length);\n    return newArray;\n  }\n  return Array.newInstance(array.getClass().getComponentType(), 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  final int length = Array.getLength(array);\n  final Object newArray = Array.newInstance(newArrayComponentType, length + 1);\n  System.arraycopy(array, 0, newArray, 0, length);\n  return newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  if (array.getClass().isArray()) {\n    final int length = Array.getLength(array);\n    final Object newArray = Array.newInstance(newArrayComponentType, length + 1);\n    System.arraycopy(array, 0, newArray, 0, length);\n    return newArray;\n  }\n  return Array.newInstance(newArrayComponentType, 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  if (array.getClass().isArray()) {\n    int length = Array.getLength(array);\n    if (newArrayComponentType == boolean.class) {\n      boolean[] result = (boolean[]) Array.newInstance(newArrayComponentType, length + 1);\n      System.arraycopy((boolean[]) array, 0, result, 0, length);\n      return result;\n    } else if (newArrayComponentType == byte.class) {\n      byte[] result = (byte[]) Array.newInstance(newArrayComponentType, length + 1);\n      System.arraycopy((byte[]) array, 0, result, 0, length);\n      return result;\n    } else if (newArrayComponentType == char.class) {\n      char[] result = (char[]) Array.newInstance(newArrayComponentType, length + 1);\n      System.arraycopy((char[]) array, 0, result, 0, length);\n      return result;\n    } else if (newArrayComponentType == double.class) {\n      double[] result = (double[]) Array.newInstance(newArrayComponentType, length + 1);\n      System.arraycopy((double[]) array, 0, result, 0, length);\n      return result;\n    } else if (newArrayComponentType == float.class) {\n      float[] result = (float[]) Array.newInstance(newArrayComponentType, length + 1);\n      System.arraycopy((float[]) array, 0, result, 0, length);\n      return result;\n    } else if (newArrayComponentType == int.class) {\n      int[] result = (int[]) Array.newInstance(newArrayComponentType, length + 1);\n      System.arraycopy((int[]) array, 0, result, 0, length);\n      return result;\n    } else if (newArrayComponentType == long.class) {\n      long[] result = (long[]) Array.newInstance(newArrayComponentType, length + 1);\n      System.arraycopy((long[]) array, 0, result, 0, length);\n      return result;\n    } else if (newArrayComponentType == short.class) {\n      short[] result = (short[]) Array.newInstance(newArrayComponentType, length + 1);\n      System.arraycopy((short[]) array, 0, result, 0, length);\n      return result;\n    }\n  }\n  return Array.newInstance(newArrayComponentType, 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  if (newArrayComponentType == boolean.class || newArrayComponentType == Boolean.class) {\n    return Array.newInstance(array.getClass().getComponentType(), 0);\n  }\n  if (newArrayComponentType == byte.class || newArrayComponentType == Byte.class) {\n    return Array.newInstance(array.getClass().getComponentType(), 0);\n  }\n  if (newArrayComponentType == char.class || newArrayComponentType == Character.class) {\n    return Array.newInstance(array.getClass().getComponentType(), 0);\n  }\n  if (newArrayComponentType == short.class || newArrayComponentType == Short.class) {\n    return Array.newInstance(array.getClass().getComponentType(), 0);\n  }\n  if (newArrayComponentType == int.class || newArrayComponentType == Integer.class) {\n    return Array.newInstance(array.getClass().getComponentType(), 0);\n  }\n  if (newArrayComponentType == long.class || newArrayComponentType == Long.class) {\n    return Array.newInstance(array.getClass().getComponentType(), 0);\n  }\n  if (newArrayComponentType == float.class || newArrayComponentType == Float.class) {\n    return Array.newInstance(array.getClass().getComponentType(), 0);\n  }\n  if (newArrayComponentType == double.class || newArrayComponentType == Double.class) {\n    return Array.newInstance(array.getClass().getComponentType(), 0);\n  }\n  if (newArrayComponentType == Object.class) {\n    return new Object[0];\n  }\n  return Array.newInstance(array.getClass().getComponentType(), Array.getLength(array));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n  if (array == null) {\n    return null;\n  }\n  if (newArrayComponentType == boolean[].class) {\n    return copyArray((boolean[]) array);\n  }\n  if (newArrayComponentType == byte[].class) {\n    return copyArray((byte[]) array);\n  }\n  if (newArrayComponentType == char[].class) {\n    return copyArray((char[]) array);\n  }\n  if (newArrayComponentType == double[].class) {\n    return copyArray((double[]) array);\n  }\n  if (newArrayComponentType == float[].class) {\n    return copyArray((float[]) array);\n  }\n  if (newArrayComponentType == int[].class) {\n    return copyArray((int[]) array);\n  }\n  if (newArrayComponentType == long[].class) {\n    return copyArray((long[]) array);\n  }\n  if (newArrayComponentType == short[].class) {\n    return copyArray((short[]) array);\n  }\n  throw new IllegalArgumentException(\n      \"Cannot copy non-primitive array of type \" + array.getClass().getComponentType().getName());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n", "method_name": "copyArrayGrow1", "codes": ["private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ Object result = Array.newInstance(newArrayComponentType, array.length); System.arraycopy(array, 0, result, 0, array.length); return result; }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ Object result = Array.newInstance(newArrayComponentType, ((Object[]) array).length); System.arraycopy(((Object[]) array), 0, result, 0, Array.getLength(array)); return result; }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } if (array.getClass().isArray()) { final int length = Array.getLength(array); final Object newArray = Array.newInstance(array.getClass().getComponentType(), length + 1); System.arraycopy(array, 0, newArray, 0, length); return newArray; } return Array.newInstance(array.getClass().getComponentType(), 1); }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ int newLength = Array.getLength(array); if (newLength == 0) { return Array.newInstance(newArrayComponentType, 1); } if (newLength > Array.getLength(array)) { throw new IllegalArgumentException(\"Cannot create an array of length \" + newLength + \" at index \" + newLength + \". The array must have at least one element.\"); } final Object result = Array.newInstance(newArrayComponentType, newLength + 1); System.arraycopy(array, 0, result, 0, Math.min(newLength, Array.getLength(array))); return result; }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } if (array.getClass().isArray()) { final int length = Array.getLength(array); final Object newArray = Array.newInstance(array.getClass().getComponentType(), length + 1); System.arraycopy(array, 0, newArray, 0, length); return newArray; } return Array.newInstance(array.getClass().getComponentType(), 1); }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ final int length = Array.getLength(array); final Object newArray = Array.newInstance(newArrayComponentType, length + 1); System.arraycopy(array, 0, newArray, 0, length); return newArray; }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } if (array.getClass().isArray()) { final int length = Array.getLength(array); final Object newArray = Array.newInstance(newArrayComponentType, length + 1); System.arraycopy(array, 0, newArray, 0, length); return newArray; } return Array.newInstance(newArrayComponentType, 1); }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } if (array.getClass().isArray()) { int length = Array.getLength(array); if (newArrayComponentType == boolean.class) { boolean[] result = (boolean[]) Array.newInstance(newArrayComponentType, length + 1); System.arraycopy((boolean[]) array, 0, result, 0, length); return result; } else if (newArrayComponentType == byte.class) { byte[] result = (byte[]) Array.newInstance(newArrayComponentType, length + 1); System.arraycopy((byte[]) array, 0, result, 0, length); return result; } else if (newArrayComponentType == char.class) { char[] result = (char[]) Array.newInstance(newArrayComponentType, length + 1); System.arraycopy((char[]) array, 0, result, 0, length); return result; } else if (newArrayComponentType == double.class) { double[] result = (double[]) Array.newInstance(newArrayComponentType, length + 1); System.arraycopy((double[]) array, 0, result, 0, length); return result; } else if (newArrayComponentType == float.class) { float[] result = (float[]) Array.newInstance(newArrayComponentType, length + 1); System.arraycopy((float[]) array, 0, result, 0, length); return result; } else if (newArrayComponentType == int.class) { int[] result = (int[]) Array.newInstance(newArrayComponentType, length + 1); System.arraycopy((int[]) array, 0, result, 0, length); return result; } else if (newArrayComponentType == long.class) { long[] result = (long[]) Array.newInstance(newArrayComponentType, length + 1); System.arraycopy((long[]) array, 0, result, 0, length); return result; } else if (newArrayComponentType == short.class) { short[] result = (short[]) Array.newInstance(newArrayComponentType, length + 1); System.arraycopy((short[]) array, 0, result, 0, length); return result; } } return Array.newInstance(newArrayComponentType, 1); }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } if (newArrayComponentType == boolean.class || newArrayComponentType == Boolean.class) { return Array.newInstance(array.getClass().getComponentType(), 0); } if (newArrayComponentType == byte.class || newArrayComponentType == Byte.class) { return Array.newInstance(array.getClass().getComponentType(), 0); } if (newArrayComponentType == char.class || newArrayComponentType == Character.class) { return Array.newInstance(array.getClass().getComponentType(), 0); } if (newArrayComponentType == short.class || newArrayComponentType == Short.class) { return Array.newInstance(array.getClass().getComponentType(), 0); } if (newArrayComponentType == int.class || newArrayComponentType == Integer.class) { return Array.newInstance(array.getClass().getComponentType(), 0); } if (newArrayComponentType == long.class || newArrayComponentType == Long.class) { return Array.newInstance(array.getClass().getComponentType(), 0); } if (newArrayComponentType == float.class || newArrayComponentType == Float.class) { return Array.newInstance(array.getClass().getComponentType(), 0); } if (newArrayComponentType == double.class || newArrayComponentType == Double.class) { return Array.newInstance(array.getClass().getComponentType(), 0); } if (newArrayComponentType == Object.class) { return new Object[0]; } return Array.newInstance(array.getClass().getComponentType(), Array.getLength(array)); }", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){ if (array == null) { return null; } if (newArrayComponentType == boolean[].class) { return copyArray((boolean[]) array); } if (newArrayComponentType == byte[].class) { return copyArray((byte[]) array); } if (newArrayComponentType == char[].class) { return copyArray((char[]) array); } if (newArrayComponentType == double[].class) { return copyArray((double[]) array); } if (newArrayComponentType == float[].class) { return copyArray((float[]) array); } if (newArrayComponentType == int[].class) { return copyArray((int[]) array); } if (newArrayComponentType == long[].class) { return copyArray((long[]) array); } if (newArrayComponentType == short[].class) { return copyArray((short[]) array); } throw new IllegalArgumentException(\"Cannot copy non-primitive array of type \" + array.getClass().getComponentType().getName()); }"], "code_level": "slib_runnable", "_id": "636767031a6d9265ec0178ef", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public static String sessionId() {\n  return sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return (String) s_session.get();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return getSession().getId();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return getRequest().getSession().getId();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return (String) request().getSession().getId();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  HttpSession session = getSession();\n  if (session == null) {\n    return null;\n  }\n  return session.getId();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  if (sessionId == null) {\n    sessionId = ServletActionContext.getRequest().getSession().getId();\n  }\n  return sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return sessionId.get();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return FacesContext.getCurrentInstance()\n      .getExternalContext()\n      .getRequestParameterMap()\n      .get(\"sessionId\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId() {\n  return ServletActionContext.getRequest().getSession().getId();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Session ID. \n */\n", "method_name": "sessionId", "codes": ["public static String sessionId(){ return sessionId; }", "public static String sessionId(){ return (String) s_session.get(); }", "public static String sessionId(){ return getSession().getId(); }", "public static String sessionId(){ return getRequest().getSession().getId(); }", "public static String sessionId(){ return (String) request().getSession().getId(); }", "public static String sessionId(){ HttpSession session = getSession(); if (session == null) { return null; } return session.getId(); }", "public static String sessionId(){ if (sessionId == null) { sessionId = ServletActionContext.getRequest().getSession().getId(); } return sessionId; }", "public static String sessionId(){ return sessionId.get(); }", "public static String sessionId(){ return FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap().get(\"sessionId\"); }", "public static String sessionId(){ return ServletActionContext.getRequest().getSession().getId(); }"], "code_level": "plib_runnable", "_id": "636766fe1a6d9265ec017834", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "public Boolean isPartialContentResponse() {\n  return this.partialContent;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return this.partialContent;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return isPartialContentResponse;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return isPartialContentResponse;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return (getHttpStatus().equals(HttpStatus.PARTIAL_CONTENT));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return this.isPartialContent;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return getBoolean(\"partialContent\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return isPartialContentResponse;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return response.isPartialContent();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse() {\n  return this.get(ResponseField.PARTIAL_CONTENT).isPresent();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if the actual response is a Partial Content (HTTP 206 code)\n * @return is partial content or not\n */\n", "method_name": "isPartialContentResponse", "codes": ["public Boolean isPartialContentResponse(){ return this.partialContent; }", "public Boolean isPartialContentResponse(){ return this.partialContent; }", "public Boolean isPartialContentResponse(){ return isPartialContentResponse; }", "public Boolean isPartialContentResponse(){ return isPartialContentResponse; }", "public Boolean isPartialContentResponse(){ return (getHttpStatus().equals(HttpStatus.PARTIAL_CONTENT)); }", "public Boolean isPartialContentResponse(){ return this.isPartialContent; }", "public Boolean isPartialContentResponse(){ return getBoolean(\"partialContent\"); }", "public Boolean isPartialContentResponse(){ return isPartialContentResponse; }", "public Boolean isPartialContentResponse(){ return response.isPartialContent(); }", "public Boolean isPartialContentResponse(){ return this.get(ResponseField.PARTIAL_CONTENT).isPresent(); }"], "code_level": "plib_runnable", "_id": "636766ae1a6d9265ec0175dc", "project_name": "framework-master"}, {"generate_results": [{"generate_code": "private String buildContentRange() {\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"bytes=\");\n  sb.append(offset);\n  sb.append(\"-\");\n  sb.append(limit);\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  StringBuilder builder = new StringBuilder();\n  builder.append(\"bytes \");\n  builder.append(startOffset);\n  builder.append(\"-\");\n  builder.append(endOffset);\n  builder.append(\"/\");\n  builder.append(fileSize);\n  builder.append(\" \");\n  builder.append(fileName);\n  return builder.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  StringBuilder sb = new StringBuilder(\"bytes \");\n  if (offset >= 0) {\n    sb.append(offset);\n  } else {\n    sb.append(\"-\");\n  }\n  if (limit > 0) {\n    sb.append(limit);\n  } else {\n    sb.append(\"-\");\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  if (this.contentRange == null || this.contentRange.isEmpty()) {\n    return \"\";\n  }\n  StringBuilder contentRange = new StringBuilder(this.contentRange);\n  contentRange.append(\"-\");\n  contentRange.append(this.contentRange.charAt(this.contentRange.length() - 1));\n  contentRange.append(\"/\");\n  contentRange.append(this.contentRange.length());\n  return contentRange.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  int n = content.length;\n  int s = n - 1;\n  if (n <= 1) return \"\";\n  StringBuffer sb = new StringBuffer();\n  sb.append(content[s]);\n  for (int i = s - 1; i >= 0; i--) {\n    sb.append('-');\n    sb.append(content[i]);\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  if (contentRange == null) {\n    return \"\";\n  }\n  StringBuilder sb = new StringBuilder();\n  int start = 0;\n  int end = contentRange.length() - 1;\n  int count = 0;\n  for (int i = 0; i < contentRange.length(); i++) {\n    if (contentRange.charAt(i) == '-') {\n      start = i;\n      count++;\n    }\n    if (contentRange.charAt(i) == '+') {\n      end = i;\n      count++;\n    }\n  }\n  sb.append(contentRange.substring(start, end + 1));\n  if (count != 0) {\n    sb.append(\"-\");\n    sb.append(count);\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  if (offset <= 0) {\n    return \"\";\n  }\n  if (limit >= 0) {\n    return \"bytes=\" + offset + \"-\" + limit;\n  } else {\n    return \"bytes=\" + offset;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  return String.format(\"bytes %d-%d/%d\", start, end, count);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  long offset = getOffset();\n  long limit = getLimit();\n  if (offset == 0) {\n    return \"\";\n  } else if (limit == 0) {\n    return \"[\" + offset + \"]\";\n  } else {\n    return \"[\" + offset + \"-\" + limit + \"]\";\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange() {\n  if (contentRanges.isEmpty()) {\n    return \"\";\n  }\n  StringBuilder range = new StringBuilder();\n  range\n      .append(\"bytes \")\n      .append(contentRanges.get(0).start)\n      .append(\"-\")\n      .append(contentRanges.get(contentRanges.size() - 1).end);\n  if (contentRanges.size() > 1) {\n    range.append(\"/\").append(contentRanges.get(contentRanges.size() - 1).end);\n  }\n  return range.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n", "method_name": "buildContentRange", "codes": ["private String buildContentRange(){ StringBuilder sb = new StringBuilder(); sb.append(\"bytes=\"); sb.append(offset); sb.append(\"-\"); sb.append(limit); return sb.toString(); }", "private String buildContentRange(){ StringBuilder builder = new StringBuilder(); builder.append(\"bytes \"); builder.append(startOffset); builder.append(\"-\"); builder.append(endOffset); builder.append(\"/\"); builder.append(fileSize); builder.append(\" \"); builder.append(fileName); return builder.toString(); }", "private String buildContentRange(){ StringBuilder sb = new StringBuilder(\"bytes \"); if (offset >= 0) { sb.append(offset); } else { sb.append(\"-\"); } if (limit > 0) { sb.append(limit); } else { sb.append(\"-\"); } return sb.toString(); }", "private String buildContentRange(){ if (this.contentRange == null || this.contentRange.isEmpty()) { return \"\"; } StringBuilder contentRange = new StringBuilder(this.contentRange); contentRange.append(\"-\"); contentRange.append(this.contentRange.charAt(this.contentRange.length() - 1)); contentRange.append(\"/\"); contentRange.append(this.contentRange.length()); return contentRange.toString(); }", "private String buildContentRange(){ int n = content.length; int s = n - 1; if (n <= 1) return \"\"; StringBuffer sb = new StringBuffer(); sb.append(content[s]); for (int i = s - 1; i >= 0; i--) { sb.append('-'); sb.append(content[i]); } return sb.toString(); }", "private String buildContentRange(){ if (contentRange == null) { return \"\"; } StringBuilder sb = new StringBuilder(); int start = 0; int end = contentRange.length() - 1; int count = 0; for (int i = 0; i < contentRange.length(); i++) { if (contentRange.charAt(i) == '-') { start = i; count++; } if (contentRange.charAt(i) == '+') { end = i; count++; } } sb.append(contentRange.substring(start, end + 1)); if (count != 0) { sb.append(\"-\"); sb.append(count); } return sb.toString(); }", "private String buildContentRange(){ if (offset <= 0) { return \"\"; } if (limit >= 0) { return \"bytes=\" + offset + \"-\" + limit; } else { return \"bytes=\" + offset; } }", "private String buildContentRange(){ return String.format(\"bytes %d-%d/%d\", start, end, count); }", "private String buildContentRange(){ long offset = getOffset(); long limit = getLimit(); if (offset == 0) { return \"\"; } else if (limit == 0) { return \"[\" + offset + \"]\"; } else { return \"[\" + offset + \"-\" + limit + \"]\"; } }", "private String buildContentRange(){ if (contentRanges.isEmpty()) { return \"\"; } StringBuilder range = new StringBuilder(); range.append(\"bytes \").append(contentRanges.get(0).start).append(\"-\").append(contentRanges.get(contentRanges.size() - 1).end); if (contentRanges.size() > 1) { range.append(\"/\").append(contentRanges.get(contentRanges.size() - 1).end); } return range.toString(); }"], "code_level": "class_runnable", "_id": "636766ae1a6d9265ec0175d8", "project_name": "framework-master"}, {"generate_results": [{"generate_code": "private static String javaCharset(String charset) {\n  if (charset == null) {\n    return null;\n  } else if (charset.equalsIgnoreCase(\"UTF-8\")) {\n    return \"UTF-8\";\n  } else if (charset.equalsIgnoreCase(\"ISO-8859-1\")) {\n    return \"ISO-8859-1\";\n  } else if (charset.equalsIgnoreCase(\"UTF-16BE\")) {\n    return \"UTF-16BE\";\n  } else if (charset.equalsIgnoreCase(\"UTF-16LE\")) {\n    return \"UTF-16LE\";\n  } else if (charset.equalsIgnoreCase(\"UTF-16\")) {\n    return \"UTF-16\";\n  } else {\n    return null;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  String javaCharset = null;\n  if (charset != null && !charset.isEmpty()) {\n    javaCharset = Charset.forName(charset).name();\n  }\n  return javaCharset;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){ if (charset == null) { return null; } String tmp = charset.trim(); if (tmp.length() == 0) { return null; } tmp = tmp.toUpperCase(); if (tmp.startsWith(\"US-ASCII\")) { tmp = tmp.substring(5); } if (tmp.startsWith(\"ISO-8859-1\")) { tmp = tmp.substring(8); } if (tmp.startsWith(\"ISO-8859-2\")) { tmp = tmp.substring(6); } if (tmp.startsWith(\"ISO-8859-3\")) { tmp = tmp.substring(5); } if (tmp.startsWith(\"ISO-8859-4\")) { tmp = tmp.substring(4); } if (tmp.startsWith(\"ISO-8859-5\")) { tmp = tmp.substring(3); } if (tmp.startsWith(\"ISO-8859-6\")) { tmp = tmp.substring(2); } if (tmp.startsWith(\"ISO-8859-7\")) { tmp = tmp.substring(1); } if (tmp.startsWith(\"ISO-8859-8\")) { tmp = tmp.substring(0); } if (tmp.startsWith(\"ISO-8859-9\")) { tmp = tmp.substring(9); } if (tmp.startsWith(\"ISO-8859-10\")) { tmp = tmp.substring(8); } if (tmp.startsWith(\"ISO-8859-11\")) { tmp = tmp.substring(6); } if (tmp.startsWith(\"ISO-8859-12\")) { tmp = tmp.substring(5); } if (tmp.startsWith(\"ISO-8859-13\")) { tmp = tmp.substring(4); } if (tmp.startsWith(\"ISO-8859-14\")) { tmp = tmp.substring(3); } if (tmp.startsWith(\"ISO-8859-15\")) { tmp = tmp.substring(2); } if (tmp.startsWith(\"ISO-8859-16\")) { tmp = tmp.substring(1); } if (tmp.startsWith(\"ISO-8859-17\")) { tmp = tmp.substring(0); } if (tmp.startsWith(\"ISO-8859-18\")) { tmp = tmp.substring(9); } if (tmp.startsWith(\"ISO-8859-19\")) { tmp = tmp.substring(8); } if (tmp.startsWith(\"ISO-8859-20\")) { tmp = tmp.substring(6); } if (tmp.startsWith(\"ISO-8859-21\")) { tmp = tmp.substring(5); } if (tmp.startsWith(\"ISO-8859-22\")) { tmp = tmp.substring(4); } if (tmp.startsWith(\"ISO-8859-23\")) { tmp = tmp.substring(3); } if (tmp.startsWith(\"ISO-8859-24\")) { tmp = tmp.substring(2); } if (tmp.startsWith(\"ISO-8859-25\")) { tmp = tmp.substring(1); } if (tmp.startsWith(\"", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  String retval = null;\n  if (charset != null) {\n    int i = charset.indexOf(\";\");\n    if (i > 0) {\n      retval = charset.substring(0, i);\n    }\n  }\n  return retval;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){ String javaCharset = null; if (charset.equals(\"ISO-8859-1\")) { javaCharset = \"ISO-8859-1\"; } else if (charset.equals(\"UTF-8\")) { javaCharset = \"UTF-8\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  if (charset == null) {\n    return null;\n  }\n  int pos = charset.indexOf(\";\");\n  if (pos < 0) {\n    return charset;\n  }\n  StringBuilder sb = new StringBuilder(charset.length() + 10);\n  sb.append(charset);\n  while (pos >= 0) {\n    pos = charset.indexOf(\";\", pos + 1);\n    if (pos < 0) {\n      break;\n    }\n    sb.append(\";\").append(charset.substring(pos + 1));\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  StringBuilder result = new StringBuilder(\"\");\n  if (charset != null) {\n    int i = 0;\n    while (i < charset.length()) {\n      char ch = charset.charAt(i);\n      if (ch >= 0x20 && ch <= 0x7E) {\n        if (ch == '\"') {\n          result.append(\"\\\\\\\"\");\n        } else if (ch == '\\\\') {\n          result.append(\"\\\\\\\\\");\n        } else if (ch == '/') {\n          result.append(\"\\\\/\");\n        } else if (ch == '\\b') {\n          result.append(\"\\\\b\");\n        } else if (ch == '\\f') {\n          result.append(\"\\\\f\");\n        } else if (ch == '\\n') {\n          result.append(\"\\\\n\");\n        } else if (ch == '\\r') {\n          result.append(\"\\\\r\");\n        } else if (ch == '\\t') {\n          result.append(\"\\\\t\");\n        } else {\n          result.append(\"\\\\x\");\n          result.append(Integer.toHexString(ch));\n        }\n      } else {\n        result.append(ch);\n      }\n      i++;\n    }\n  }\n  return result.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  if (charset == null) return null;\n  String javaCharset = null;\n  try {\n    javaCharset = MimeUtility.javaCharset(charset);\n  } catch (UnsupportedEncodingException e) {\n  }\n  return javaCharset;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  if (charset.startsWith(\"UTF-8\") || charset.startsWith(\"UTF-16\")) {\n    return \"UTF-8\";\n  } else if (charset.startsWith(\"ISO-8859-1\")) {\n    return \"ISO-8859-1\";\n  } else if (charset.startsWith(\"ISO-8859-2\")) {\n    return \"ISO-8859-2\";\n  } else if (charset.startsWith(\"ISO-8859-3\")) {\n    return \"ISO-8859-3\";\n  } else if (charset.startsWith(\"ISO-8859-4\")) {\n    return \"ISO-8859-4\";\n  } else if (charset.startsWith(\"ISO-8859-5\")) {\n    return \"ISO-8859-5\";\n  } else if (charset.startsWith(\"ISO-8859-6\")) {\n    return \"ISO-8859-6\";\n  } else if (charset.startsWith(\"ISO-8859-7\")) {\n    return \"ISO-8859-7\";\n  } else if (charset.startsWith(\"ISO-8859-8\")) {\n    return \"ISO-8859-8\";\n  } else if (charset.startsWith(\"ISO-8859-9\")) {\n    return \"ISO-8859-9\";\n  } else if (charset.startsWith(\"ISO-8859-10\")) {\n    return \"ISO-8859-10\";\n  } else if (charset.startsWith(\"ISO-8859-11\")) {\n    return \"ISO-8859-11\";\n  } else if (charset.startsWith(\"ISO-8859-12\")) {\n    return \"ISO-8859-12\";\n  } else if (charset.startsWith(\"ISO-8859-13\")) {\n    return \"ISO-8859-13\";\n  } else if (charset.startsWith(\"ISO-8859-14\")) {\n    return \"ISO-8859-14\";\n  } else if (charset.startsWith(\"ISO-8859-15\")) {\n    return \"ISO-8859-15\";\n  } else if (charset.startsWith(\"ISO-8859-16\")) {\n    return \"ISO-8859-16\";\n  } else if (charset.startsWith(\"ISO-8859-17\")) {\n    return \"ISO-8859-17\";\n  } else if (charset.startsWith(\"ISO-8859-18\")) {\n    return \"ISO-8859-18\";\n  } else if (charset.startsWith(\"ISO-8859-19\")) {\n    return \"ISO-8859-19\";\n  } else if (charset.startsWith(\"ISO-8859-20\")) {\n    return \"ISO-8859-20\";\n  } else {\n    return charset;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset) {\n  if (charset == null) {\n    return null;\n  }\n  if (charset.startsWith(\"ISO-8859-1\")) {\n    return \"ISO-8859-1\";\n  } else if (charset.startsWith(\"UTF-16\")) {\n    return \"UTF-16\";\n  } else if (charset.startsWith(\"UTF-8\")) {\n    return \"UTF-8\";\n  } else {\n    return charset;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n", "method_name": "javaCharset", "codes": ["private static String javaCharset(String charset){ if (charset == null) { return null; } else if (charset.equalsIgnoreCase(\"UTF-8\")) { return \"UTF-8\"; } else if (charset.equalsIgnoreCase(\"ISO-8859-1\")) { return \"ISO-8859-1\"; } else if (charset.equalsIgnoreCase(\"UTF-16BE\")) { return \"UTF-16BE\"; } else if (charset.equalsIgnoreCase(\"UTF-16LE\")) { return \"UTF-16LE\"; } else if (charset.equalsIgnoreCase(\"UTF-16\")) { return \"UTF-16\"; } else { return null; } }", "private static String javaCharset(String charset){ String javaCharset = null; if (charset != null && !charset.isEmpty()) { javaCharset = Charset.forName(charset).name(); } return javaCharset; }", "private static String javaCharset(String charset){ if (charset == null) { return null; } String tmp = charset.trim(); if (tmp.length() == 0) { return null; } tmp = tmp.toUpperCase(); if (tmp.startsWith(\"US-ASCII\")) { tmp = tmp.substring(5); } if (tmp.startsWith(\"ISO-8859-1\")) { tmp = tmp.substring(8); } if (tmp.startsWith(\"ISO-8859-2\")) { tmp = tmp.substring(6); } if (tmp.startsWith(\"ISO-8859-3\")) { tmp = tmp.substring(5); } if (tmp.startsWith(\"ISO-8859-4\")) { tmp = tmp.substring(4); } if (tmp.startsWith(\"ISO-8859-5\")) { tmp = tmp.substring(3); } if (tmp.startsWith(\"ISO-8859-6\")) { tmp = tmp.substring(2); } if (tmp.startsWith(\"ISO-8859-7\")) { tmp = tmp.substring(1); } if (tmp.startsWith(\"ISO-8859-8\")) { tmp = tmp.substring(0); } if (tmp.startsWith(\"ISO-8859-9\")) { tmp = tmp.substring(9); } if (tmp.startsWith(\"ISO-8859-10\")) { tmp = tmp.substring(8); } if (tmp.startsWith(\"ISO-8859-11\")) { tmp = tmp.substring(6); } if (tmp.startsWith(\"ISO-8859-12\")) { tmp = tmp.substring(5); } if (tmp.startsWith(\"ISO-8859-13\")) { tmp = tmp.substring(4); } if (tmp.startsWith(\"ISO-8859-14\")) { tmp = tmp.substring(3); } if (tmp.startsWith(\"ISO-8859-15\")) { tmp = tmp.substring(2); } if (tmp.startsWith(\"ISO-8859-16\")) { tmp = tmp.substring(1); } if (tmp.startsWith(\"ISO-8859-17\")) { tmp = tmp.substring(0); } if (tmp.startsWith(\"ISO-8859-18\")) { tmp = tmp.substring(9); } if (tmp.startsWith(\"ISO-8859-19\")) { tmp = tmp.substring(8); } if (tmp.startsWith(\"ISO-8859-20\")) { tmp = tmp.substring(6); } if (tmp.startsWith(\"ISO-8859-21\")) { tmp = tmp.substring(5); } if (tmp.startsWith(\"ISO-8859-22\")) { tmp = tmp.substring(4); } if (tmp.startsWith(\"ISO-8859-23\")) { tmp = tmp.substring(3); } if (tmp.startsWith(\"ISO-8859-24\")) { tmp = tmp.substring(2); } if (tmp.startsWith(\"ISO-8859-25\")) { tmp = tmp.substring(1); } if (tmp.startsWith(\"", "private static String javaCharset(String charset){ String retval = null; if (charset != null) { int i = charset.indexOf(\";\"); if (i > 0) { retval = charset.substring(0, i); } } return retval; }", "private static String javaCharset(String charset){ String javaCharset = null; if (charset.equals(\"ISO-8859-1\")) { javaCharset = \"ISO-8859-1\"; } else if (charset.equals(\"UTF-8\")) { javaCharset = \"UTF-8\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-32LE\")) { javaCharset = \"UTF-32LE\"; } else if (charset.equals(\"UTF-32BE\")) { javaCharset = \"UTF-32BE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else if (charset.equals(\"UTF-16LE\")) { javaCharset = \"UTF-16LE\"; } else if (charset.equals(\"UTF-16BE\")) { javaCharset = \"UTF-16BE\"; } else", "private static String javaCharset(String charset){ if (charset == null) { return null; } int pos = charset.indexOf(\";\"); if (pos < 0) { return charset; } StringBuilder sb = new StringBuilder(charset.length() + 10); sb.append(charset); while (pos >= 0) { pos = charset.indexOf(\";\", pos + 1); if (pos < 0) { break; } sb.append(\";\").append(charset.substring(pos + 1)); } return sb.toString(); }", "private static String javaCharset(String charset){ StringBuilder result = new StringBuilder(\"\"); if (charset != null) { int i = 0; while (i < charset.length()) { char ch = charset.charAt(i); if (ch >= 0x20 && ch <= 0x7E) { if (ch == '\"') { result.append(\"\\\\\\\"\"); } else if (ch == '\\\\') { result.append(\"\\\\\\\\\"); } else if (ch == '/') { result.append(\"\\\\/\"); } else if (ch == '\\b') { result.append(\"\\\\b\"); } else if (ch == '\\f') { result.append(\"\\\\f\"); } else if (ch == '\\n') { result.append(\"\\\\n\"); } else if (ch == '\\r') { result.append(\"\\\\r\"); } else if (ch == '\\t') { result.append(\"\\\\t\"); } else { result.append(\"\\\\x\"); result.append(Integer.toHexString(ch)); } } else { result.append(ch); } i++; } } return result.toString(); }", "private static String javaCharset(String charset){ if (charset == null) return null; String javaCharset = null; try { javaCharset = MimeUtility.javaCharset(charset); } catch (UnsupportedEncodingException e) { } return javaCharset; }", "private static String javaCharset(String charset){ if (charset.startsWith(\"UTF-8\") || charset.startsWith(\"UTF-16\")) { return \"UTF-8\"; } else if (charset.startsWith(\"ISO-8859-1\")) { return \"ISO-8859-1\"; } else if (charset.startsWith(\"ISO-8859-2\")) { return \"ISO-8859-2\"; } else if (charset.startsWith(\"ISO-8859-3\")) { return \"ISO-8859-3\"; } else if (charset.startsWith(\"ISO-8859-4\")) { return \"ISO-8859-4\"; } else if (charset.startsWith(\"ISO-8859-5\")) { return \"ISO-8859-5\"; } else if (charset.startsWith(\"ISO-8859-6\")) { return \"ISO-8859-6\"; } else if (charset.startsWith(\"ISO-8859-7\")) { return \"ISO-8859-7\"; } else if (charset.startsWith(\"ISO-8859-8\")) { return \"ISO-8859-8\"; } else if (charset.startsWith(\"ISO-8859-9\")) { return \"ISO-8859-9\"; } else if (charset.startsWith(\"ISO-8859-10\")) { return \"ISO-8859-10\"; } else if (charset.startsWith(\"ISO-8859-11\")) { return \"ISO-8859-11\"; } else if (charset.startsWith(\"ISO-8859-12\")) { return \"ISO-8859-12\"; } else if (charset.startsWith(\"ISO-8859-13\")) { return \"ISO-8859-13\"; } else if (charset.startsWith(\"ISO-8859-14\")) { return \"ISO-8859-14\"; } else if (charset.startsWith(\"ISO-8859-15\")) { return \"ISO-8859-15\"; } else if (charset.startsWith(\"ISO-8859-16\")) { return \"ISO-8859-16\"; } else if (charset.startsWith(\"ISO-8859-17\")) { return \"ISO-8859-17\"; } else if (charset.startsWith(\"ISO-8859-18\")) { return \"ISO-8859-18\"; } else if (charset.startsWith(\"ISO-8859-19\")) { return \"ISO-8859-19\"; } else if (charset.startsWith(\"ISO-8859-20\")) { return \"ISO-8859-20\"; } else { return charset; } }", "private static String javaCharset(String charset){ if (charset == null) { return null; } if (charset.startsWith(\"ISO-8859-1\")) { return \"ISO-8859-1\"; } else if (charset.startsWith(\"UTF-16\")) { return \"UTF-16\"; } else if (charset.startsWith(\"UTF-8\")) { return \"UTF-8\"; } else { return charset; } }"], "code_level": "class_runnable", "_id": "636766f01a6d9265ec01763e", "project_name": "hasor-master"}, {"generate_results": [{"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> right = node.getRight();\n  node.setRight(right.getLeft());\n  right.setLeft(node);\n  node.setHeight(Math.max(getHeight(node.getLeft()), getHeight(node.getRight())) + 1);\n  right.setHeight(Math.max(getHeight(right.getLeft()), getHeight(right.getRight())) + 1);\n  return right;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  node.setRight(rotateLeft(node.getRight()));\n  return rotateRight(node);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> rightNode = node.left;\n  node.left = rightNode.right;\n  rightNode.right = node;\n  node.height = Math.max(height(node.left), height(node.right)) + 1;\n  rightNode.height = Math.max(height(rightNode.left), node.height) + 1;\n  return rightNode;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> leftNode = node.left;\n  node.left = leftNode.right;\n  leftNode.right = node;\n  return leftNode;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> temp = node.left;\n  node.left = temp.right;\n  temp.right = node;\n  temp.height = Math.max(height(node.left), height(node.right)) + 1;\n  temp.size = size(node.left) + size(node.right) + 1;\n  return temp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> left = node.left;\n  node.left = left.right;\n  left.right = node;\n  return left;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  node.left = rotateLeft(node.left);\n  return rotateRight(node);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> right = node.getRight();\n  node.setRight(right.getLeft());\n  right.setLeft(node);\n  return right;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  TreeNode<T> newRoot = node.getLeft();\n  node.setLeft(newRoot.getRight());\n  newRoot.setRight(node);\n  newRoot.setHeight(Math.max(height(node.getLeft()), height(node.getRight())) + 1);\n  return newRoot;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node) {\n  node.setRight(rotateLeft(node.getRight()));\n  return rotateRight(node);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}\n */\n", "method_name": "rotateRight", "codes": ["private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> right = node.getRight(); node.setRight(right.getLeft()); right.setLeft(node); node.setHeight(Math.max(getHeight(node.getLeft()), getHeight(node.getRight())) + 1); right.setHeight(Math.max(getHeight(right.getLeft()), getHeight(right.getRight())) + 1); return right; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ node.setRight(rotateLeft(node.getRight())); return rotateRight(node); }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> rightNode = node.left; node.left = rightNode.right; rightNode.right = node; node.height = Math.max(height(node.left), height(node.right)) + 1; rightNode.height = Math.max(height(rightNode.left), node.height) + 1; return rightNode; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> leftNode = node.left; node.left = leftNode.right; leftNode.right = node; return leftNode; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> temp = node.left; node.left = temp.right; temp.right = node; temp.height = Math.max(height(node.left), height(node.right)) + 1; temp.size = size(node.left) + size(node.right) + 1; return temp; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> left = node.left; node.left = left.right; left.right = node; return left; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ node.left = rotateLeft(node.left); return rotateRight(node); }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> right = node.getRight(); node.setRight(right.getLeft()); right.setLeft(node); return right; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ TreeNode<T> newRoot = node.getLeft(); node.setLeft(newRoot.getRight()); newRoot.setRight(node); newRoot.setHeight(Math.max(height(node.getLeft()), height(node.getRight())) + 1); return newRoot; }", "private TreeNode<T> rotateRight(TreeNode<T> node){ node.setRight(rotateLeft(node.getRight())); return rotateRight(node); }"], "code_level": "file_runnable", "_id": "636767441a6d9265ec017cc1", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void swap(V[] arr, int i, int j) {\n  V temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Swaps the two elements at the specified indices in the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param i the index of the first element\n * @param j the index of the second element\n */\n", "method_name": "swap", "codes": ["public static final <V>void swap(V[] arr,int i,int j){ V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }", "public static final <V>void swap(V[] arr,int i,int j){ V temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }", "public static final <V>void swap(V[] arr,int i,int j){ V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }", "public static final <V>void swap(V[] arr,int i,int j){ V temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }", "public static final <V>void swap(V[] arr,int i,int j){ V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }", "public static final <V>void swap(V[] arr,int i,int j){ V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }", "public static final <V>void swap(V[] arr,int i,int j){ V temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }", "public static final <V>void swap(V[] arr,int i,int j){ V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }", "public static final <V>void swap(V[] arr,int i,int j){ V temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }", "public static final <V>void swap(V[] arr,int i,int j){ V temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }"], "code_level": "self_contained", "_id": "636767551a6d9265ec017f3f", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return (Supplier<String>)\n      () -> {\n        StringBuilder sb = new StringBuilder();\n        for (int i = start; i < start + INT_COUNT; i++) {\n          sb.append(i);\n        }\n        return sb.toString();\n      };\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () -> {\n    StringBuilder sb = new StringBuilder();\n    for (int i = start; i <= start + Integer.toString(i).length(); i++) {\n      sb.append(Integer.toString(i));\n    }\n    return sb.toString();\n  };\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () ->\n      IntStream.rangeClosed(start, start + 1)\n          .mapToObj(i -> \"\" + i)\n          .collect(Collectors.joining(\"\"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return (Supplier<String>)\n      () ->\n          IntStream.range(start, start + 1)\n              .mapToObj(String::valueOf)\n              .collect(Collectors.joining());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () -> new String(new char[start]).replace('\\0', 'a');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return (Supplier<String>)\n      () -> {\n        StringBuilder sb = new StringBuilder();\n        for (int i = start; i <= start + 10; i++) {\n          sb.append(i);\n          sb.append(\" \");\n        }\n        return sb.toString();\n      };\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () ->\n      IntStream.rangeClosed(start, start + 1)\n          .mapToObj(String::valueOf)\n          .collect(Collectors.joining(\"\"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () -> String.valueOf(start);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () -> {\n    StringBuilder sb = new StringBuilder();\n    for (int i = start; i < start + RANDOM.nextInt(MAX_STRING_LENGTH - start); i++) {\n      sb.append(Character.toChars(RANDOM.nextInt(26) + 65));\n    }\n    return sb.toString();\n  };\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static Supplier<String> createStringSupplier(int start) {\n  return () -> {\n    StringBuilder sb = new StringBuilder();\n    for (int i = start; i < 100; i++) {\n      sb.append(\"a\");\n    }\n    return sb.toString();\n  };\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n", "method_name": "createStringSupplier", "codes": ["@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return (Supplier<String>) () -> { StringBuilder sb = new StringBuilder(); for (int i = start; i < start + INT_COUNT; i++) { sb.append(i); } return sb.toString(); }; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> { StringBuilder sb = new StringBuilder(); for (int i = start; i <= start + Integer.toString(i).length(); i++) { sb.append(Integer.toString(i)); } return sb.toString(); }; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> IntStream.rangeClosed(start, start + 1).mapToObj(i -> \"\" + i).collect(Collectors.joining(\"\")); }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return (Supplier<String>) () -> IntStream.range(start, start + 1).mapToObj(String::valueOf).collect(Collectors.joining()); }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> new String(new char[start]).replace('\\0', 'a'); }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return (Supplier<String>) () -> { StringBuilder sb = new StringBuilder(); for (int i = start; i <= start + 10; i++) { sb.append(i); sb.append(\" \"); } return sb.toString(); }; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> IntStream.rangeClosed(start, start + 1).mapToObj(String::valueOf).collect(Collectors.joining(\"\")); }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> String.valueOf(start); }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> { StringBuilder sb = new StringBuilder(); for (int i = start; i < start + RANDOM.nextInt(MAX_STRING_LENGTH - start); i++) { sb.append(Character.toChars(RANDOM.nextInt(26) + 65)); } return sb.toString(); }; }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){ return () -> { StringBuilder sb = new StringBuilder(); for (int i = start; i < 100; i++) { sb.append(\"a\"); } return sb.toString(); }; }"], "code_level": "slib_runnable", "_id": "6367675c1a6d9265ec018058", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  if (previous == null) {\n    throw new NoSuchElementException();\n  }\n  previous = previous.previous;\n  return previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return this.previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  ListNode<E> result = this.previous;\n  this.previous = null;\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previousNode;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic ListNode<E> previousNode() {\n  return previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * {@inheritDoc}\n */\n", "method_name": "previousNode", "codes": ["@Override public ListNode<E> previousNode(){ return null; }", "@Override public ListNode<E> previousNode(){ if (previous == null) { throw new NoSuchElementException(); } previous = previous.previous; return previous; }", "@Override public ListNode<E> previousNode(){ return this.previous; }", "@Override public ListNode<E> previousNode(){ return previous; }", "@Override public ListNode<E> previousNode(){ return previous; }", "@Override public ListNode<E> previousNode(){ ListNode<E> result = this.previous; this.previous = null; return result; }", "@Override public ListNode<E> previousNode(){ return previous; }", "@Override public ListNode<E> previousNode(){ return previousNode; }", "@Override public ListNode<E> previousNode(){ return previous; }", "@Override public ListNode<E> previousNode(){ return previous; }"], "code_level": "class_runnable", "_id": "636767501a6d9265ec017e86", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static long factorial(int n) {\n  long fact = 1;\n  for (int i = 1; i <= n; i++) {\n    fact = fact * i;\n  }\n  return fact;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n == 0 || n == 1) return 1;\n  return n * factorial(n - 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n < 0) {\n    throw new IllegalArgumentException(\"n must be non-negative\");\n  }\n  if (n == 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  long factorial = 1;\n  for (int i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  long fact = 1;\n  for (int i = 1; i <= n; i++) {\n    fact = fact * i;\n  }\n  return fact;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n < 0) {\n    throw new IllegalArgumentException(\"Number must be greater than 0\");\n  }\n  if (n == 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  long factorial = 1;\n  for (int i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n <= 1) return 1;\n  else return n * factorial(n - 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n) {\n  if (n == 0) return 1;\n  else return n * factorial(n - 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Calculate the factorial of $n$.\n * @param n the input number\n * @return the factorial\n */\n", "method_name": "factorial", "codes": ["public static long factorial(int n){ long fact = 1; for (int i = 1; i <= n; i++) { fact = fact * i; } return fact; }", "public static long factorial(int n){ if (n == 0 || n == 1) return 1; return n * factorial(n - 1); }", "public static long factorial(int n){ if (n <= 1) { return 1; } else { return n * factorial(n - 1); } }", "public static long factorial(int n){ if (n < 0) { throw new IllegalArgumentException(\"n must be non-negative\"); } if (n == 0) { return 1; } return n * factorial(n - 1); }", "public static long factorial(int n){ long factorial = 1; for (int i = 1; i <= n; i++) { factorial *= i; } return factorial; }", "public static long factorial(int n){ long fact = 1; for (int i = 1; i <= n; i++) { fact = fact * i; } return fact; }", "public static long factorial(int n){ if (n < 0) { throw new IllegalArgumentException(\"Number must be greater than 0\"); } if (n == 0) { return 1; } return n * factorial(n - 1); }", "public static long factorial(int n){ long factorial = 1; for (int i = 1; i <= n; i++) { factorial *= i; } return factorial; }", "public static long factorial(int n){ if (n <= 1) return 1; else return n * factorial(n - 1); }", "public static long factorial(int n){ if (n == 0) return 1; else return n * factorial(n - 1); }"], "code_level": "self_contained", "_id": "636767581a6d9265ec017fc4", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == null) {\n    return false;\n  }\n  if (node.next == null) {\n    node.prev = null;\n    return true;\n  }\n  ListNodeImpl<E> prev = node.prev;\n  ListNodeImpl<E> next = node.next;\n  prev.next = next;\n  next.prev = prev;\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == null) {\n    return false;\n  }\n  if (node == head) {\n    head = node.next;\n  } else {\n    node.prev.next = node.next;\n  }\n  if (node.next != null) {\n    node.next.prev = node.prev;\n  }\n  node.next = null;\n  node.prev = null;\n  size--;\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == null) {\n    return false;\n  }\n  if (node.next == null) {\n    node.prev.next = null;\n    node.prev = null;\n    head = node.prev;\n    tail = node.next;\n  } else {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n    node.next = null;\n    node.prev = null;\n  }\n  size--;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == tail) {\n    tail = tail.prev;\n    if (tail != null) {\n      tail.next = null;\n    }\n    return true;\n  }\n  if (node == head) {\n    head = head.next;\n    if (head != null) {\n      head.prev = null;\n    }\n    return true;\n  }\n  node.prev.next = node.next;\n  node.next.prev = node.prev;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node.prev == null) {\n    if (node.next != null) {\n      node.next.prev = null;\n    } else {\n      head = node.next;\n      head.prev = null;\n    }\n  } else if (node.next == null) {\n    node.prev.next = null;\n  } else {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n  size--;\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == null || node.prev == null) {\n    return false;\n  }\n  if (node.prev == node.next) {\n    node.next = null;\n    node.prev = null;\n  } else {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n  size--;\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  ListNodeImpl<E> nextNode = node.getNext();\n  if (nextNode == null) {\n    head = nextNode;\n    return true;\n  } else {\n    node.setNext(nextNode.getNext());\n    return true;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  ListNodeImpl<E> prev = node.prev;\n  ListNodeImpl<E> next = node.next;\n  if (prev == null) {\n    if (next == null) {\n      head = null;\n      tail = null;\n    } else {\n      next.prev = null;\n      tail = next;\n    }\n  } else {\n    prev.next = next;\n    node.prev = null;\n  }\n  if (next == null) {\n    tail = prev;\n  } else {\n    next.next = prev;\n    node.next = null;\n  }\n  size--;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == tail) {\n    tail = node.prev;\n    if (tail != null) {\n      tail.next = null;\n    }\n  } else {\n    node.prev.next = node.next;\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node) {\n  if (node == null) return false;\n  node.prev.next = node.next;\n  node.next.prev = node.prev;\n  size--;\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Remove the non null  {@code node} from the list. \n */\n", "method_name": "unlink", "codes": ["private boolean unlink(ListNodeImpl<E> node){ if (node == null) { return false; } if (node.next == null) { node.prev = null; return true; } ListNodeImpl<E> prev = node.prev; ListNodeImpl<E> next = node.next; prev.next = next; next.prev = prev; return true; }", "private boolean unlink(ListNodeImpl<E> node){ if (node == null) { return false; } if (node == head) { head = node.next; } else { node.prev.next = node.next; } if (node.next != null) { node.next.prev = node.prev; } node.next = null; node.prev = null; size--; return true; }", "private boolean unlink(ListNodeImpl<E> node){ if (node == null) { return false; } if (node.next == null) { node.prev.next = null; node.prev = null; head = node.prev; tail = node.next; } else { node.prev.next = node.next; node.next.prev = node.prev; node.next = null; node.prev = null; } size--; return true; }", "private boolean unlink(ListNodeImpl<E> node){ if (node == tail) { tail = tail.prev; if (tail != null) { tail.next = null; } return true; } if (node == head) { head = head.next; if (head != null) { head.prev = null; } return true; } node.prev.next = node.next; node.next.prev = node.prev; return true; }", "private boolean unlink(ListNodeImpl<E> node){ if (node.prev == null) { if (node.next != null) { node.next.prev = null; } else { head = node.next; head.prev = null; } } else if (node.next == null) { node.prev.next = null; } else { node.prev.next = node.next; node.next.prev = node.prev; } size--; return true; }", "private boolean unlink(ListNodeImpl<E> node){ if (node == null || node.prev == null) { return false; } if (node.prev == node.next) { node.next = null; node.prev = null; } else { node.prev.next = node.next; node.next.prev = node.prev; } size--; return true; }", "private boolean unlink(ListNodeImpl<E> node){ ListNodeImpl<E> nextNode = node.getNext(); if (nextNode == null) { head = nextNode; return true; } else { node.setNext(nextNode.getNext()); return true; } }", "private boolean unlink(ListNodeImpl<E> node){ ListNodeImpl<E> prev = node.prev; ListNodeImpl<E> next = node.next; if (prev == null) { if (next == null) { head = null; tail = null; } else { next.prev = null; tail = next; } } else { prev.next = next; node.prev = null; } if (next == null) { tail = prev; } else { next.next = prev; node.next = null; } size--; return true; }", "private boolean unlink(ListNodeImpl<E> node){ if (node == tail) { tail = node.prev; if (tail != null) { tail.next = null; } } else { node.prev.next = node.next; if (node.next != null) { node.next.prev = node.prev; } } return true; }", "private boolean unlink(ListNodeImpl<E> node){ if (node == null) return false; node.prev.next = node.next; node.next.prev = node.prev; size--; return true; }"], "code_level": "class_runnable", "_id": "636767631a6d9265ec018171", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (arr == null || from > to)\n    throw new IllegalArgumentException(\"from must be greater than to\");\n  for (int i = from, j = to; i < j; i++, j--) swap(arr, i, j);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (from >= to) return;\n  if (from < 0) from = 0;\n  if (to >= arr.length) to = arr.length - 1;\n  int i = from;\n  int j = to;\n  while (i < j) {\n    V temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    i++;\n    j--;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (from < to) {\n    for (int i = from, j = to - 1; i < j; i++, j--) {\n      V tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  for (int i = from, j = to - 1; i < j; i++, j--) {\n    V tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (arr == null) throw new IllegalArgumentException(\"arr\");\n  if (from > to) throw new IllegalArgumentException(\"from > to\");\n  int i = from;\n  int j = to - 1;\n  while (i < j) {\n    V temp = arr[i];\n    arr[i++] = arr[j];\n    arr[j--] = temp;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (arr == null) return;\n  int i = from, j = to;\n  V tmp;\n  while (i < j) {\n    tmp = arr[i];\n    arr[i++] = arr[j];\n    arr[j--] = tmp;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  assert from <= to;\n  for (int i = from, j = to - 1; i < j; i++, j--) {\n    V tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (arr == null || from < 0 || to > arr.length || from > to) return;\n  for (int i = from, j = to - 1; i < j; i++, j--) swap(arr, i, j);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (from >= to) {\n    return;\n  }\n  int i = from, j = to;\n  while (i < j) {\n    V t = arr[i];\n    arr[i] = arr[j];\n    arr[j] = t;\n    i++;\n    j--;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V> void reverse(V[] arr, int from, int to) {\n  if (arr == null || arr.length == 0) return;\n  if (from > to) return;\n  if (from == to) return;\n  int mid = (from + to) >>> 1;\n  reverse(arr, from, mid);\n  reverse(arr, mid + 1, to);\n  if (arr[from] == arr[mid]) {\n    if (arr[mid + 1] == arr[mid]) {\n      reverse(arr, from, mid);\n    } else {\n      reverse(arr, mid + 1, to);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Reverses the order of the elements in the specified range within the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param from the index of the first element (inclusive) inside the range to reverse\n * @param to the index of the last element (inclusive) inside the range to reverse\n */\n", "method_name": "reverse", "codes": ["public static final <V>void reverse(V[] arr,int from,int to){ if (arr == null || from > to) throw new IllegalArgumentException(\"from must be greater than to\"); for (int i = from, j = to; i < j; i++, j--) swap(arr, i, j); }", "public static final <V>void reverse(V[] arr,int from,int to){ if (from >= to) return; if (from < 0) from = 0; if (to >= arr.length) to = arr.length - 1; int i = from; int j = to; while (i < j) { V temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; i++; j--; } }", "public static final <V>void reverse(V[] arr,int from,int to){ if (from < to) { for (int i = from, j = to - 1; i < j; i++, j--) { V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } }", "public static final <V>void reverse(V[] arr,int from,int to){ for (int i = from, j = to - 1; i < j; i++, j--) { V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } }", "public static final <V>void reverse(V[] arr,int from,int to){ if (arr == null) throw new IllegalArgumentException(\"arr\"); if (from > to) throw new IllegalArgumentException(\"from > to\"); int i = from; int j = to - 1; while (i < j) { V temp = arr[i]; arr[i++] = arr[j]; arr[j--] = temp; } }", "public static final <V>void reverse(V[] arr,int from,int to){ if (arr == null) return; int i = from, j = to; V tmp; while (i < j) { tmp = arr[i]; arr[i++] = arr[j]; arr[j--] = tmp; } }", "public static final <V>void reverse(V[] arr,int from,int to){ assert from <= to; for (int i = from, j = to - 1; i < j; i++, j--) { V tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } }", "public static final <V>void reverse(V[] arr,int from,int to){ if (arr == null || from < 0 || to > arr.length || from > to) return; for (int i = from, j = to - 1; i < j; i++, j--) swap(arr, i, j); }", "public static final <V>void reverse(V[] arr,int from,int to){ if (from >= to) { return; } int i = from, j = to; while (i < j) { V t = arr[i]; arr[i] = arr[j]; arr[j] = t; i++; j--; } }", "public static final <V>void reverse(V[] arr,int from,int to){ if (arr == null || arr.length == 0) return; if (from > to) return; if (from == to) return; int mid = (from + to) >>> 1; reverse(arr, from, mid); reverse(arr, mid + 1, to); if (arr[from] == arr[mid]) { if (arr[mid + 1] == arr[mid]) { reverse(arr, from, mid); } else { reverse(arr, mid + 1, to); } } }"], "code_level": "class_runnable", "_id": "636767491a6d9265ec017d90", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  for (int i = 0; i < list.size(); i++) {\n    moveListNode(list.getNode(i), list.getNode(i + 1));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  if (list == null) {\n    return;\n  }\n  if (list.next == null) {\n    return;\n  }\n  DoublyLinkedList<E> newList = new DoublyLinkedList<>();\n  DoublyLinkedList<E> newList2 = new DoublyLinkedList<>();\n  while (list.next != null) {\n    newList.addFirst(list.next.data);\n    list.next = list.next.next;\n  }\n  while (newList.next != null) {\n    newList2.addFirst(newList.next.data);\n    newList.next = newList.next.next;\n  }\n  list.data = newList2.data;\n  list.next = null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  DoublyLinkedList<E> tmp = list;\n  while (tmp != null) {\n    tmp.setNext(tmp.getNext().getNext());\n    tmp.setPrevious(tmp.getPrevious().getPrevious());\n    tmp = tmp.getNext();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  if (list.head == null) return;\n  DoublyLinkedNode<E> current = list.head;\n  DoublyLinkedNode<E> prev = null;\n  while (current != null) {\n    DoublyLinkedNode<E> next = current.next;\n    if (prev != null) prev.next = next;\n    else head = next;\n    prev = current;\n    current = next;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  if (head != null) {\n    DoublyLinkedListNode<E> tmp = head;\n    while (tmp != null) {\n      DoublyLinkedListNode<E> temp = tmp.next;\n      tmp.next = temp.previous;\n      temp.previous = tmp;\n      tmp = temp;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  while (!list.isEmpty()) {\n    moveListNode(list.removeHead());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  Node<E> first = list.getFirst();\n  Node<E> last = list.getLast();\n  if (first == null) {\n    return;\n  }\n  if (last == null) {\n    first.setNext(null);\n    last = first;\n  } else {\n    last.setNext(first);\n    first.setPrev(last);\n    last = first;\n  }\n  while (first != null) {\n    Node<E> next = first.getNext();\n    Node<E> prev = first.getPrev();\n    if (next == null) {\n      first.setPrev(null);\n      last = first;\n    } else {\n      first.setNext(null);\n      first.setPrev(last);\n      last.setNext(next);\n      next.setPrev(first);\n    }\n    first = next;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  DoublyLinkedList<E> temp = new DoublyLinkedList<E>();\n  temp.addAll(list);\n  list.clear();\n  list.addAll(temp);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  if (list != null) {\n    Node<E> current = list.getHead();\n    while (current != null) {\n      moveListNodeToNewList(current);\n      current = current.getNext();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list) {\n  DoublyLinkedListNode<E> current = list.getHead();\n  DoublyLinkedListNode<E> prev = null;\n  while (current != null) {\n    DoublyLinkedListNode<E> next = current.getNext();\n    current.setNext(prev);\n    prev = current;\n    current = next;\n  }\n  list.setHead(prev);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.\n */\n", "method_name": "moveAllListNodes", "codes": ["private void moveAllListNodes(DoublyLinkedList<E> list){ for (int i = 0; i < list.size(); i++) { moveListNode(list.getNode(i), list.getNode(i + 1)); } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ if (list == null) { return; } if (list.next == null) { return; } DoublyLinkedList<E> newList = new DoublyLinkedList<>(); DoublyLinkedList<E> newList2 = new DoublyLinkedList<>(); while (list.next != null) { newList.addFirst(list.next.data); list.next = list.next.next; } while (newList.next != null) { newList2.addFirst(newList.next.data); newList.next = newList.next.next; } list.data = newList2.data; list.next = null; }", "private void moveAllListNodes(DoublyLinkedList<E> list){ DoublyLinkedList<E> tmp = list; while (tmp != null) { tmp.setNext(tmp.getNext().getNext()); tmp.setPrevious(tmp.getPrevious().getPrevious()); tmp = tmp.getNext(); } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ if (list.head == null) return; DoublyLinkedNode<E> current = list.head; DoublyLinkedNode<E> prev = null; while (current != null) { DoublyLinkedNode<E> next = current.next; if (prev != null) prev.next = next; else head = next; prev = current; current = next; } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ if (head != null) { DoublyLinkedListNode<E> tmp = head; while (tmp != null) { DoublyLinkedListNode<E> temp = tmp.next; tmp.next = temp.previous; temp.previous = tmp; tmp = temp; } } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ while (!list.isEmpty()) { moveListNode(list.removeHead()); } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ Node<E> first = list.getFirst(); Node<E> last = list.getLast(); if (first == null) { return; } if (last == null) { first.setNext(null); last = first; } else { last.setNext(first); first.setPrev(last); last = first; } while (first != null) { Node<E> next = first.getNext(); Node<E> prev = first.getPrev(); if (next == null) { first.setPrev(null); last = first; } else { first.setNext(null); first.setPrev(last); last.setNext(next); next.setPrev(first); } first = next; } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ DoublyLinkedList<E> temp = new DoublyLinkedList<E>(); temp.addAll(list); list.clear(); list.addAll(temp); }", "private void moveAllListNodes(DoublyLinkedList<E> list){ if (list != null) { Node<E> current = list.getHead(); while (current != null) { moveListNodeToNewList(current); current = current.getNext(); } } }", "private void moveAllListNodes(DoublyLinkedList<E> list){ DoublyLinkedListNode<E> current = list.getHead(); DoublyLinkedListNode<E> prev = null; while (current != null) { DoublyLinkedListNode<E> next = current.getNext(); current.setNext(prev); prev = current; current = next; } list.setHead(prev); }"], "code_level": "class_runnable", "_id": "6367674a1a6d9265ec017da9", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IdentityAutomorphism<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<V, E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph) {\n  return new IsomorphicGraphMapping<>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).\n * @param graph the input graph\n * @param < V > the graph vertex type\n * @param < E > the graph edge type\n * @return a mapping from graph to graph\n */\n", "method_name": "identity", "codes": ["public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IdentityAutomorphism<V, E>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<V, E>(graph); }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){ return new IsomorphicGraphMapping<>(graph); }"], "code_level": "project_runnable", "_id": "6367675f1a6d9265ec0180d3", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (partitions.size() == 0) {\n    return;\n  }\n  Graph<V, E> graph = new Graph<>(target);\n  for (Partition<V, E> partition : partitions) {\n    graph.addEdge(partition.getSrc(), partition.getDest());\n  }\n  for (V source : graph.getVertices()) {\n    resultMap.put(source.toString(), null);\n  }\n  for (Partition<V, E> partition : partitions) {\n    if (partition.getSrc().equals(partition.getDest())) {\n      continue;\n    }\n    V src = partition.getSrc();\n    V dest = partition.getDest();\n    for (E edge : graph.getEdges(src, dest)) {\n      V srcDest = graph.getEdgeSource(edge);\n      V destDest = graph.getEdgeDest(edge);\n      if (!resultMap.containsKey(srcDest)) {\n        resultMap.put(srcDest, partition.getSrc());\n      }\n      if (!resultMap.containsKey(destDest)) {\n        resultMap.put(destDest, partition.getDest());\n      }\n      if (!resultMap.containsKey(partition.getSrc())) {\n        resultMap.put(partition.getSrc(), partition.getDest());\n      }\n      if (!resultMap.containsKey(partition.getDest())) {\n        resultMap.put(partition.getDest(), partition.getSrc());\n      }\n    }\n  }\n  for (V source : graph.getVertices()) {\n    for (E edge : graph.getEdges(source, source)) {\n      V srcDest = graph.getEdgeSource(edge);\n      V destDest = graph.getEdgeDest(edge);\n      if (!resultMap.containsKey(srcDest)) {\n        resultMap.put(srcDest, source);\n      }\n      if (!resultMap.containsKey(destDest)) {\n        resultMap.put(destDest, source);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (!target.isDirected()) {\n    throw new IllegalArgumentException(\"Target graph must be directed\");\n  }\n  String source = null;\n  for (V vertex : target.getVertices()) {\n    if (source == null) {\n      source = vertex.getName();\n    } else {\n      throw new IllegalArgumentException(\"Target graph must have unique vertices\");\n    }\n  }\n  for (V vertex : target.getVertices()) {\n    for (E edge : target.getIncidentEdges(vertex)) {\n      V targetVertex = resultMap.get(edge.getTarget());\n      if (targetVertex == null) {\n        throw new IllegalArgumentException(\"Target vertex must be mapped to a vertex\");\n      }\n      if (!target.containsVertex(targetVertex)) {\n        target.addVertex(targetVertex);\n      }\n    }\n  }\n  for (V vertex : target.getVertices()) {\n    for (E edge : target.getIncidentEdges(vertex)) {\n      V targetVertex = resultMap.get(edge.getTarget());\n      if (targetVertex == null) {\n        throw new IllegalArgumentException(\"Target vertex must be mapped to a vertex\");\n      }\n      if (target.containsVertex(targetVertex)) {\n        target.removeVertex(targetVertex);\n      }\n    }\n  }\n  for (V vertex : target.getVertices()) {\n    for (E edge : target.getIncidentEdges(vertex)) {\n      V targetVertex = resultMap.get(edge.getTarget());\n      if (targetVertex == null) {\n        throw new IllegalArgumentException(\"Target vertex must be mapped to a vertex\");\n      }\n      if (!target.containsVertex(targetVertex)) {\n        target.addVertex(targetVertex);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  Graph<V, E> graph = target;\n  Set<V> vertices = graph.getVertices();\n  Set<String> partitions = new HashSet<String>();\n  for (V v : vertices) {\n    partitions.add(v.toString());\n  }\n  for (String s : partitions) {\n    if (resultMap.containsKey(s)) {\n      V v = resultMap.get(s);\n      graph.removeVertex(v);\n    }\n  }\n  for (V v : vertices) {\n    for (E e : graph.getEdges(v)) {\n      V u = graph.getEdgeTarget(e);\n      if (!partitions.contains(u.toString())) {\n        graph.addVertex(u);\n        graph.addEdge(v, u, e);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  Set<V> allVertices = target.getVertices();\n  if (allVertices.size() == 1) {\n    V v1 = allVertices.iterator().next();\n    this.graph.addVertex(v1);\n  } else {\n    this.graph.addVertex(null);\n  }\n  for (V v : allVertices) {\n    if (!this.graph.containsVertex(v)) {\n      if (this.graph.containsEdge(v, null)) {\n        this.graph.addEdge(v, null);\n      }\n    }\n  }\n  for (V v : allVertices) {\n    for (V v2 : allVertices) {\n      if (v != v2) {\n        if (this.graph.containsEdge(v, v2)) {\n          this.graph.addEdge(v, v2);\n        }\n      }\n    }\n  }\n  for (V v : allVertices) {\n    for (V v2 : allVertices) {\n      if (v != v2) {\n        if (this.graph.containsEdge(v, v2)) {\n          this.graph.addEdge(v, v2);\n        }\n      }\n    }\n  }\n  for (V v : allVertices) {\n    for (V v2 : allVertices) {\n      if (v != v2) {\n        if (this.graph.containsEdge(v, v2)) {\n          this.graph.addEdge(v, v2);\n        }\n      }\n    }\n  }\n  if (this.graph.getVertex(v1) != null) {\n    this.graph.addVertex(v1);\n  }\n  if (this.graph.getVertex(v2) != null) {\n    this.graph.addVertex(v2);\n  }\n  if (this.graph.getVertex(v1) == null) {\n    this.graph.addVertex(null);\n  }\n  if (this.graph.getVertex(v2) == null) {\n    this.graph.addVertex(null);\n  }\n  for (V v : allVertices) {\n    if (v != null) {\n      this.graph.addEdge(v, v1);\n      this.graph.addEdge(v, v2);\n    }\n  }\n  for (V v : allVertices) {\n    if (v != null) {\n      this.graph.addEdge(v, v2);\n    }\n  }\n  for (V v : allVertices) {\n    for (E e : this.graph.getEdges(v)) {\n      V v1 = e.getSource();\n      V v2 = e.getTarget();\n      this.graph.addEdge(v1, v2);\n    }\n  }\n  for (V v : allVertices) {\n    for (E e : this.graph.getEdges(v)) {\n      V v1 = e.getSource();\n      V v2 = e.getTarget();\n      this.graph.addEdge(v2, v1);\n    }\n  }\n  for (V v : allVertices) {\n    for (E e : this.graph.getEdges(v)) {\n      V v1 = e.getSource();\n      V v2 = e.getTarget();\n      this.graph.addEdge(v1, v2);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (target.getNumVertices() == 0) return;\n  String[] partitions = target.getPartitions();\n  if (partitions.length == 0) {\n    resultMap.put(target.getName(), target.getVertex(partitions[0]));\n    return;\n  }\n  List<String> allPartitions = new ArrayList<String>(Arrays.asList(partitions));\n  while (allPartitions.size() > 0) {\n    Graph<V, E> subTarget = new Graph<V, E>(allPartitions.remove(0));\n    target.addVertex(subTarget);\n    subTarget.addVertex(target.getVertex(allPartitions.remove(0)));\n    subTarget.addEdge(\n        target.getVertex(allPartitions.remove(0)), target.getVertex(allPartitions.remove(0)));\n    generateGraph(subTarget, resultMap);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  for (V v : resultMap.keySet()) {\n    if (!target.containsVertex(v)) {\n      target.addVertex(v);\n    }\n  }\n  for (V v : resultMap.keySet()) {\n    for (E e : resultMap.get(v).getEdges()) {\n      Vertex<V, E> v1 = resultMap.get(e.getSource());\n      Vertex<V, E> v2 = resultMap.get(e.getTarget());\n      target.addEdge(v1, v2, e);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (target == null) {\n    return;\n  }\n  this.graph = target.getGraph();\n  this.resultMap = resultMap;\n  this.graph.addVertex(target.getVertex());\n  for (V vertex : target.getVertex().getValues()) {\n    this.graph.addVertex(vertex);\n  }\n  for (E edge : target.getEdges()) {\n    this.graph.addEdge(edge.getSource(), edge.getTarget(), edge);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  Graph<V, E> graph = new SimpleGraph<V, E>(Edge.class);\n  for (E e : target.getEdges()) {\n    if (e instanceof Partition) {\n      Partition p = (Partition) e;\n      String[] s = p.getPartitionIds();\n      for (String ss : s) {\n        V v = resultMap.get(ss);\n        if (v == null) {\n          v = createVertex(p.getPartitionIds()[0], p.getPartitionIds()[1]);\n          resultMap.put(ss, v);\n        }\n        graph.addVertex(v);\n      }\n    } else {\n      graph.addVertex(e);\n    }\n  }\n  for (V v : graph.vertexSet()) {\n    for (E e : graph.getEdges(v)) {\n      if (e instanceof Partition) {\n        Partition p = (Partition) e;\n        String[] s = p.getPartitionIds();\n        for (String ss : s) {\n          V v = resultMap.get(ss);\n          if (v == null) {\n            v = createVertex(p.getPartitionIds()[0], p.getPartitionIds()[1]);\n            resultMap.put(ss, v);\n          }\n          graph.addEdge(v, e);\n        }\n      } else {\n        graph.addEdge(e);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void generateGraph(Graph<V, E> target, Map<String, V> resultMap) {\n  if (resultMap == null || resultMap.size() == 0) {\n    return;\n  }\n  for (String key : resultMap.keySet()) {\n    V value = resultMap.get(key);\n    target.addVertex(value);\n  }\n  for (V vertex : target.vertexSet()) {\n    if (vertex.getEdges() == null || vertex.getEdges().size() == 0) {\n      continue;\n    }\n    for (E edge : vertex.getEdges()) {\n      V source = edge.getSource();\n      V target = edge.getTarget();\n      if (!target.containsVertex(source)) {\n        target.addVertex(source);\n      }\n    }\n  }\n  for (V vertex : target.vertexSet()) {\n    for (E edge : vertex.getEdges()) {\n      V source = edge.getSource();\n      V target = edge.getTarget();\n      if (!source.containsVertex(target)) {\n        source.addVertex(target);\n      }\n    }\n  }\n  for (V vertex : target.vertexSet()) {\n    for (E edge : vertex.getEdges()) {\n      V source = edge.getSource();\n      V target = edge.getTarget();\n      if (!source.containsVertex(target)) {\n        source.addEdge(edge);\n      }\n    }\n  }\n  for (V vertex : target.vertexSet()) {\n    for (E edge : vertex.getEdges()) {\n      V source = edge.getSource();\n      V target = edge.getTarget();\n      if (!source.containsVertex(target)) {\n        source.addEdge(edge);\n      }\n    }\n  }\n  for (V vertex : target.vertexSet()) {\n    for (E edge : vertex.getEdges()) {\n      V source = edge.getSource();\n      V target = edge.getTarget();\n      if (!source.containsVertex(target)) {\n        source.addEdge(edge);\n      }\n    }\n  }\n  for (E edge : target.edgeSet()) {\n    V source = edge.getSource();\n    V target = edge.getTarget();\n    if (!source.containsVertex(target)) {\n      source.addEdge(edge);\n    }\n  }\n  for (E edge : target.edgeSet()) {\n    V source = edge.getSource();\n    V target = edge.getTarget();\n    if (!source.containsVertex(target)) {\n      source.addEdge(edge);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Construct a complete bipartite graph\n */\n", "method_name": "generateGraph", "codes": ["@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (partitions.size() == 0) { return; } Graph<V,E> graph = new Graph<>(target); for (Partition<V,E> partition : partitions) { graph.addEdge(partition.getSrc(), partition.getDest()); } for (V source : graph.getVertices()) { resultMap.put(source.toString(), null); } for (Partition<V,E> partition : partitions) { if (partition.getSrc().equals(partition.getDest())) { continue; } V src = partition.getSrc(); V dest = partition.getDest(); for (E edge : graph.getEdges(src, dest)) { V srcDest = graph.getEdgeSource(edge); V destDest = graph.getEdgeDest(edge); if (!resultMap.containsKey(srcDest)) { resultMap.put(srcDest, partition.getSrc()); } if (!resultMap.containsKey(destDest)) { resultMap.put(destDest, partition.getDest()); } if (!resultMap.containsKey(partition.getSrc())) { resultMap.put(partition.getSrc(), partition.getDest()); } if (!resultMap.containsKey(partition.getDest())) { resultMap.put(partition.getDest(), partition.getSrc()); } } } for (V source : graph.getVertices()) { for (E edge : graph.getEdges(source, source)) { V srcDest = graph.getEdgeSource(edge); V destDest = graph.getEdgeDest(edge); if (!resultMap.containsKey(srcDest)) { resultMap.put(srcDest, source); } if (!resultMap.containsKey(destDest)) { resultMap.put(destDest, source); } } } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (!target.isDirected()) { throw new IllegalArgumentException(\"Target graph must be directed\"); } String source = null; for (V vertex : target.getVertices()) { if (source == null) { source = vertex.getName(); } else { throw new IllegalArgumentException(\"Target graph must have unique vertices\"); } } for (V vertex : target.getVertices()) { for (E edge : target.getIncidentEdges(vertex)) { V targetVertex = resultMap.get(edge.getTarget()); if (targetVertex == null) { throw new IllegalArgumentException(\"Target vertex must be mapped to a vertex\"); } if (!target.containsVertex(targetVertex)) { target.addVertex(targetVertex); } } } for (V vertex : target.getVertices()) { for (E edge : target.getIncidentEdges(vertex)) { V targetVertex = resultMap.get(edge.getTarget()); if (targetVertex == null) { throw new IllegalArgumentException(\"Target vertex must be mapped to a vertex\"); } if (target.containsVertex(targetVertex)) { target.removeVertex(targetVertex); } } } for (V vertex : target.getVertices()) { for (E edge : target.getIncidentEdges(vertex)) { V targetVertex = resultMap.get(edge.getTarget()); if (targetVertex == null) { throw new IllegalArgumentException(\"Target vertex must be mapped to a vertex\"); } if (!target.containsVertex(targetVertex)) { target.addVertex(targetVertex); } } } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ Graph<V,E> graph = target; Set<V> vertices = graph.getVertices(); Set<String> partitions = new HashSet<String>(); for (V v : vertices) { partitions.add(v.toString()); } for (String s : partitions) { if (resultMap.containsKey(s)) { V v = resultMap.get(s); graph.removeVertex(v); } } for (V v : vertices) { for (E e : graph.getEdges(v)) { V u = graph.getEdgeTarget(e); if (!partitions.contains(u.toString())) { graph.addVertex(u); graph.addEdge(v, u, e); } } } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ Set<V> allVertices = target.getVertices(); if (allVertices.size() == 1) { V v1 = allVertices.iterator().next(); this.graph.addVertex(v1); } else { this.graph.addVertex(null); } for (V v : allVertices) { if (!this.graph.containsVertex(v)) { if (this.graph.containsEdge(v, null)) { this.graph.addEdge(v, null); } } } for (V v : allVertices) { for (V v2 : allVertices) { if (v != v2) { if (this.graph.containsEdge(v, v2)) { this.graph.addEdge(v, v2); } } } } for (V v : allVertices) { for (V v2 : allVertices) { if (v != v2) { if (this.graph.containsEdge(v, v2)) { this.graph.addEdge(v, v2); } } } } for (V v : allVertices) { for (V v2 : allVertices) { if (v != v2) { if (this.graph.containsEdge(v, v2)) { this.graph.addEdge(v, v2); } } } } if (this.graph.getVertex(v1) != null) { this.graph.addVertex(v1); } if (this.graph.getVertex(v2) != null) { this.graph.addVertex(v2); } if (this.graph.getVertex(v1) == null) { this.graph.addVertex(null); } if (this.graph.getVertex(v2) == null) { this.graph.addVertex(null); } for (V v : allVertices) { if (v != null) { this.graph.addEdge(v, v1); this.graph.addEdge(v, v2); } } for (V v : allVertices) { if (v != null) { this.graph.addEdge(v, v2); } } for (V v : allVertices) { for (E e : this.graph.getEdges(v)) { V v1 = e.getSource(); V v2 = e.getTarget(); this.graph.addEdge(v1, v2); } } for (V v : allVertices) { for (E e : this.graph.getEdges(v)) { V v1 = e.getSource(); V v2 = e.getTarget(); this.graph.addEdge(v2, v1); } } for (V v : allVertices) { for (E e : this.graph.getEdges(v)) { V v1 = e.getSource(); V v2 = e.getTarget(); this.graph.addEdge(v1, v2); } } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (target.getNumVertices() == 0) return; String[] partitions = target.getPartitions(); if (partitions.length == 0) { resultMap.put(target.getName(), target.getVertex(partitions[0])); return; } List<String> allPartitions = new ArrayList<String>(Arrays.asList(partitions)); while (allPartitions.size() > 0) { Graph<V,E> subTarget = new Graph<V, E>(allPartitions.remove(0)); target.addVertex(subTarget); subTarget.addVertex(target.getVertex(allPartitions.remove(0))); subTarget.addEdge(target.getVertex(allPartitions.remove(0)), target.getVertex(allPartitions.remove(0))); generateGraph(subTarget, resultMap); } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ for (V v : resultMap.keySet()) { if (!target.containsVertex(v)) { target.addVertex(v); } } for (V v : resultMap.keySet()) { for (E e : resultMap.get(v).getEdges()) { Vertex<V, E> v1 = resultMap.get(e.getSource()); Vertex<V, E> v2 = resultMap.get(e.getTarget()); target.addEdge(v1, v2, e); } } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (target == null) { return; } this.graph = target.getGraph(); this.resultMap = resultMap; this.graph.addVertex(target.getVertex()); for (V vertex : target.getVertex().getValues()) { this.graph.addVertex(vertex); } for (E edge : target.getEdges()) { this.graph.addEdge(edge.getSource(), edge.getTarget(), edge); } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ Graph<V,E> graph = new SimpleGraph<V, E>(Edge.class); for (E e : target.getEdges()) { if (e instanceof Partition) { Partition p = (Partition) e; String[] s = p.getPartitionIds(); for (String ss : s) { V v = resultMap.get(ss); if (v == null) { v = createVertex(p.getPartitionIds()[0], p.getPartitionIds()[1]); resultMap.put(ss, v); } graph.addVertex(v); } } else { graph.addVertex(e); } } for (V v : graph.vertexSet()) { for (E e : graph.getEdges(v)) { if (e instanceof Partition) { Partition p = (Partition) e; String[] s = p.getPartitionIds(); for (String ss : s) { V v = resultMap.get(ss); if (v == null) { v = createVertex(p.getPartitionIds()[0], p.getPartitionIds()[1]); resultMap.put(ss, v); } graph.addEdge(v, e); } } else { graph.addEdge(e); } } } }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){ if (resultMap == null || resultMap.size() == 0) { return; } for (String key : resultMap.keySet()) { V value = resultMap.get(key); target.addVertex(value); } for (V vertex : target.vertexSet()) { if (vertex.getEdges() == null || vertex.getEdges().size() == 0) { continue; } for (E edge : vertex.getEdges()) { V source = edge.getSource(); V target = edge.getTarget(); if (!target.containsVertex(source)) { target.addVertex(source); } } } for (V vertex : target.vertexSet()) { for (E edge : vertex.getEdges()) { V source = edge.getSource(); V target = edge.getTarget(); if (!source.containsVertex(target)) { source.addVertex(target); } } } for (V vertex : target.vertexSet()) { for (E edge : vertex.getEdges()) { V source = edge.getSource(); V target = edge.getTarget(); if (!source.containsVertex(target)) { source.addEdge(edge); } } } for (V vertex : target.vertexSet()) { for (E edge : vertex.getEdges()) { V source = edge.getSource(); V target = edge.getTarget(); if (!source.containsVertex(target)) { source.addEdge(edge); } } } for (V vertex : target.vertexSet()) { for (E edge : vertex.getEdges()) { V source = edge.getSource(); V target = edge.getTarget(); if (!source.containsVertex(target)) { source.addEdge(edge); } } } for (E edge : target.edgeSet()) { V source = edge.getSource(); V target = edge.getTarget(); if (!source.containsVertex(target)) { source.addEdge(edge); } } for (E edge : target.edgeSet()) { V source = edge.getSource(); V target = edge.getTarget(); if (!source.containsVertex(target)) { source.addEdge(edge); } } }"], "code_level": "class_runnable", "_id": "636767641a6d9265ec01817d", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket.isEmpty()) {\n    return;\n  }\n  if (head == null) {\n    head = new Node(bucket.getValue());\n    tail = head;\n  } else {\n    Node temp = head;\n    while (temp.getNext() != null) {\n      temp = temp.getNext();\n    }\n    temp.setNext(new Node(bucket.getValue()));\n    tail = temp.getNext();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket.next != null) {\n    insertBefore(bucket.next);\n  } else {\n    bucket.next = this;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void insertBefore(Bucket bucket) {\n  Bucket head = this;\n  while (head != null && !head.equals(bucket)) {\n    head = head.next;\n  }\n  if (head == null) {\n    return;\n  }\n  head.next = bucket.next;\n  bucket.next = head;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket == null) {\n    throw new IllegalArgumentException(\"bucket is null\");\n  }\n  if (this == bucket) {\n    return;\n  }\n  if (bucket.prev == null) {\n    bucket.next = this;\n    this.prev = bucket;\n  } else {\n    bucket.prev.next = bucket.next;\n    bucket.next.prev = bucket.prev;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket == null) {\n    throw new IllegalArgumentException(\"Invalid bucket\");\n  }\n  if (this.prev == null) {\n    this.first = bucket;\n  } else {\n    this.prev.next = bucket;\n  }\n  bucket.prev = this.prev;\n  bucket.next = this;\n  this.prev = bucket;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (bucket.isEmpty()) return;\n  if (this.isEmpty()) {\n    this.bucket = bucket;\n    return;\n  }\n  if (this.bucket.isEmpty()) {\n    this.bucket = bucket;\n    return;\n  }\n  this.bucket.insertBefore(bucket);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (this.next == bucket) {\n    return;\n  }\n  int i = this.next;\n  this.next = bucket.next;\n  bucket.next = i;\n  bucket.prev = this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (this == bucket) {\n    return;\n  }\n  if (bucket.next == null) {\n    throw new IllegalArgumentException(\"The bucket is not in the bucket's list\");\n  }\n  if (next == null) {\n    next = bucket.next;\n  }\n  bucket.next.prev = this;\n  bucket.next = this.next;\n  this.next.prev = bucket;\n  this.next = bucket;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void insertBefore(Bucket bucket) {\n  int i = 0;\n  for (Node n = first; n != null; n = n.next) {\n    if (n == bucket) {\n      break;\n    }\n    i++;\n  }\n  if (i >= numBuckets) {\n    System.out.println(\"Bucket is full\");\n    return;\n  }\n  Node newNode = new Node(bucket.key, bucket.value, bucket.next);\n  if (i == 0) {\n    first = newNode;\n  } else {\n    Node prev = first;\n    while (i > 0) {\n      prev = prev.next;\n      i--;\n    }\n    prev.next = newNode;\n  }\n  numBuckets++;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket) {\n  if (this.data.getKey().equals(bucket.getKey())) {\n    this.data = bucket.getData();\n    return;\n  }\n  Bucket temp = this;\n  while (temp.getNext() != null) {\n    if (temp.getNext().getKey().equals(bucket.getKey())) {\n      temp.setNext(bucket.getNext());\n      bucket.setNext(this);\n      return;\n    }\n    temp = temp.getNext();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Inserts this bucket in the data structure before the  {@code bucket}.\n * @param bucket the bucket, that will be the next to this bucket.\n */\n", "method_name": "insertBefore", "codes": ["void insertBefore(Bucket bucket){ if (bucket.isEmpty()) { return; } if (head == null) { head = new Node(bucket.getValue()); tail = head; } else { Node temp = head; while (temp.getNext() != null) { temp = temp.getNext(); } temp.setNext(new Node(bucket.getValue())); tail = temp.getNext(); } }", "void insertBefore(Bucket bucket){ if (bucket.next != null) { insertBefore(bucket.next); } else { bucket.next = this; } }", "void insertBefore(Bucket bucket){ Bucket head = this; while (head != null && !head.equals(bucket)) { head = head.next; } if (head == null) { return; } head.next = bucket.next; bucket.next = head; }", "void insertBefore(Bucket bucket){ if (bucket == null) { throw new IllegalArgumentException(\"bucket is null\"); } if (this == bucket) { return; } if (bucket.prev == null) { bucket.next = this; this.prev = bucket; } else { bucket.prev.next = bucket.next; bucket.next.prev = bucket.prev; } }", "void insertBefore(Bucket bucket){ if (bucket == null) { throw new IllegalArgumentException(\"Invalid bucket\"); } if (this.prev == null) { this.first = bucket; } else { this.prev.next = bucket; } bucket.prev = this.prev; bucket.next = this; this.prev = bucket; }", "void insertBefore(Bucket bucket){ if (bucket.isEmpty()) return; if (this.isEmpty()) { this.bucket = bucket; return; } if (this.bucket.isEmpty()) { this.bucket = bucket; return; } this.bucket.insertBefore(bucket); }", "void insertBefore(Bucket bucket){ if (this.next == bucket) { return; } int i = this.next; this.next = bucket.next; bucket.next = i; bucket.prev = this; }", "void insertBefore(Bucket bucket){ if (this == bucket) { return; } if (bucket.next == null) { throw new IllegalArgumentException(\"The bucket is not in the bucket's list\"); } if (next == null) { next = bucket.next; } bucket.next.prev = this; bucket.next = this.next; this.next.prev = bucket; this.next = bucket; }", "void insertBefore(Bucket bucket){ int i = 0; for (Node n = first; n != null; n = n.next) { if (n == bucket) { break; } i++; } if (i >= numBuckets) { System.out.println(\"Bucket is full\"); return; } Node newNode = new Node(bucket.key, bucket.value, bucket.next); if (i == 0) { first = newNode; } else { Node prev = first; while (i > 0) { prev = prev.next; i--; } prev.next = newNode; } numBuckets++; }", "void insertBefore(Bucket bucket){ if (this.data.getKey().equals(bucket.getKey())) { this.data = bucket.getData(); return; } Bucket temp = this; while (temp.getNext() != null) { if (temp.getNext().getKey().equals(bucket.getKey())) { temp.setNext(bucket.getNext()); bucket.setNext(this); return; } temp = temp.getNext(); } }"], "code_level": "class_runnable", "_id": "636767531a6d9265ec017efb", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic boolean hasNext() {\n  return !stack.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !vertices.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !visited.contains(current);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !nodes.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !visited.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !this.unVisitedVertices.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  boolean hasNext = false;\n  for (int i = 0; i < vertices.length; i++) {\n    if (!vertices[i].isVisited()) {\n      hasNext = true;\n    }\n  }\n  return hasNext;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !unvisited.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !vtxs.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic boolean hasNext() {\n  return !unvisitedVertices.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Checks whether there exist unvisited vertices.\n * @return true if there exist unvisited vertices.\n */\n", "method_name": "hasNext", "codes": ["@Override public boolean hasNext(){ return !stack.isEmpty(); }", "@Override public boolean hasNext(){ return !vertices.isEmpty(); }", "@Override public boolean hasNext(){ return !visited.contains(current); }", "@Override public boolean hasNext(){ return !nodes.isEmpty(); }", "@Override public boolean hasNext(){ return !visited.isEmpty(); }", "@Override public boolean hasNext(){ return !this.unVisitedVertices.isEmpty(); }", "@Override public boolean hasNext(){ boolean hasNext = false; for (int i = 0; i < vertices.length; i++) { if (!vertices[i].isVisited()) { hasNext = true; } } return hasNext; }", "@Override public boolean hasNext(){ return !unvisited.isEmpty(); }", "@Override public boolean hasNext(){ return !vtxs.isEmpty(); }", "@Override public boolean hasNext(){ return !unvisitedVertices.isEmpty(); }"], "code_level": "class_runnable", "_id": "636767561a6d9265ec017f63", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "void removeSelf() {\n  if (this.prev != null) {\n    this.prev.next = this.next;\n  }\n  if (this.next != null) {\n    this.next.prev = this.prev;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void removeSelf() {\n  if (this.next != null) {\n    this.next = this.next.next;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void removeSelf() {\n  if (this.getNext() != null) {\n    this.setNext(this.getNext().getNext());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  prev.next = next;\n  next.prev = prev;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "void removeSelf() {\n  if (head.next == null) {\n    head = null;\n    return;\n  }\n  if (head.next.next == null) {\n    head.next = null;\n    return;\n  }\n  Node curr = head.next;\n  while (curr.next != null) {\n    if (curr.next.next == null) {\n      curr.next = null;\n      return;\n    }\n    curr = curr.next;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  head = null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "void removeSelf() {\n  if (!isEmpty()) {\n    if (head.getNext() == tail) {\n      head = tail = null;\n    } else {\n      head.getNext().setPrevious(null);\n      head = head.getNext();\n    }\n    size--;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf() {\n  if (head != null) {\n    head = head.next;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "void removeSelf() {\n  if (this.prev != null) {\n    this.prev.next = this.next;\n  }\n  if (this.next != null) {\n    this.next.prev = this.prev;\n  }\n  this.prev = this.next = null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void removeSelf() {\n  if (head != null) {\n    head = head.next;\n  } else {\n    System.out.println(\"Nothing to remove\");\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Removes this bucket from the data structure.\n */\n", "method_name": "removeSelf", "codes": ["void removeSelf(){ if (this.prev != null) { this.prev.next = this.next; } if (this.next != null) { this.next.prev = this.prev; } }", "void removeSelf(){ if (this.next != null) { this.next = this.next.next; } }", "void removeSelf(){ if (this.getNext() != null) { this.setNext(this.getNext().getNext()); } }", "void removeSelf(){ prev.next = next; next.prev = prev; }", "void removeSelf(){ if (head.next == null) { head = null; return; } if (head.next.next == null) { head.next = null; return; } Node curr = head.next; while (curr.next != null) { if (curr.next.next == null) { curr.next = null; return; } curr = curr.next; } }", "void removeSelf(){ head = null; }", "void removeSelf(){ if (!isEmpty()) { if (head.getNext() == tail) { head = tail = null; } else { head.getNext().setPrevious(null); head = head.getNext(); } size--; } }", "void removeSelf(){ if (head != null) { head = head.next; } }", "void removeSelf(){ if (this.prev != null) { this.prev.next = this.next; } if (this.next != null) { this.next.prev = this.prev; } this.prev = this.next = null; }", "void removeSelf(){ if (head != null) { head = head.next; } else { System.out.println(\"Nothing to remove\"); } }"], "code_level": "class_runnable", "_id": "6367675a1a6d9265ec018010", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (Edge<V> edge : edges) {\n    vertices.add(edge.getVertex1());\n    vertices.add(edge.getVertex2());\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> visibleVertices = new HashSet<V>();\n  for (Edge edge : edges) {\n    visibleVertices.add(edge.getV1());\n    visibleVertices.add(edge.getV2());\n  }\n  return visibleVertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> visibleVertices = new HashSet<>();\n  for (V v : getVertices()) {\n    if (v.isVisible()) {\n      visibleVertices.add(v);\n    }\n  }\n  return visibleVertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (V v : this.vertexSet()) {\n    if (!v.isVisited()) {\n      vertices.add(v);\n    }\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> visible = new HashSet<>();\n  for (V v : graph.getVertices()) {\n    if (!graph.isVisible(v)) visible.add(v);\n  }\n  return visible;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (Edge<V> edge : edges) {\n    vertices.add(edge.getV1());\n    vertices.add(edge.getV2());\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> visibleVertices = new HashSet<>();\n  for (E edge : edges()) {\n    visibleVertices.add(edge.getTarget());\n  }\n  return visibleVertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<>();\n  for (E edge : edges) {\n    vertices.add(edge.getTarget());\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  final Set<V> vertices = new HashSet<V>();\n  for (final Edge<V, E> edge : this.edges) {\n    vertices.add(edge.getSource());\n    vertices.add(edge.getTarget());\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices() {\n  Set<V> vertices = new HashSet<V>();\n  for (Edge<V, E> edge : edges) {\n    vertices.add(edge.getVertex1());\n    vertices.add(edge.getVertex2());\n  }\n  return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n", "method_name": "initVisibleVertices", "codes": ["private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (Edge<V> edge : edges) { vertices.add(edge.getVertex1()); vertices.add(edge.getVertex2()); } return vertices; }", "private Set<V> initVisibleVertices(){ Set<V> visibleVertices = new HashSet<V>(); for (Edge edge : edges) { visibleVertices.add(edge.getV1()); visibleVertices.add(edge.getV2()); } return visibleVertices; }", "private Set<V> initVisibleVertices(){ Set<V> visibleVertices = new HashSet<>(); for (V v : getVertices()) { if (v.isVisible()) { visibleVertices.add(v); } } return visibleVertices; }", "private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (V v : this.vertexSet()) { if (!v.isVisited()) { vertices.add(v); } } return vertices; }", "private Set<V> initVisibleVertices(){ Set<V> visible = new HashSet<>(); for (V v : graph.getVertices()) { if (!graph.isVisible(v)) visible.add(v); } return visible; }", "private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (Edge<V> edge : edges) { vertices.add(edge.getV1()); vertices.add(edge.getV2()); } return vertices; }", "private Set<V> initVisibleVertices(){ Set<V> visibleVertices = new HashSet<>(); for (E edge : edges()) { visibleVertices.add(edge.getTarget()); } return visibleVertices; }", "private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<>(); for (E edge : edges) { vertices.add(edge.getTarget()); } return vertices; }", "private Set<V> initVisibleVertices(){ final Set<V> vertices = new HashSet<V>(); for (final Edge<V, E> edge : this.edges) { vertices.add(edge.getSource()); vertices.add(edge.getTarget()); } return vertices; }", "private Set<V> initVisibleVertices(){ Set<V> vertices = new HashSet<V>(); for (Edge<V, E> edge : edges) { vertices.add(edge.getVertex1()); vertices.add(edge.getVertex2()); } return vertices; }"], "code_level": "class_runnable", "_id": "6367674b1a6d9265ec017dc0", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public void removeFromTreeEdgeList() {\n  edgeList.remove(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.edges.size() == 0) return;\n  for (int i = 0; i < this.edges.size(); i++) {\n    if (this.edges.get(i).getHead() == this.getHead()\n        && this.edges.get(i).getTail() == this.getTail()) {\n      this.edges.remove(i);\n      i--;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  this.edgeList.remove(this.getEdgeTo());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (rootEdge != null) {\n    rootEdge.removeFromTreeEdgeList();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  edgeList.remove(edgeList.size() - 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.treeEdgeList != null) {\n    if (this.treeEdgeList.size() > 0) {\n      this.treeEdgeList.clear();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.getFirstEdge().getTarget() == this) {\n    this.setFirstEdge(this.getFirstEdge().getNext());\n  }\n  if (this.getSecondEdge().getTarget() == this) {\n    this.setSecondEdge(this.getSecondEdge().getNext());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.isLeaf()) {\n    return;\n  }\n  if (this.getLeftChild().isLeaf()) {\n    this.setLeftChild(null);\n    this.setLeftChild(null);\n  } else if (this.getRightChild().isLeaf()) {\n    this.setRightChild(null);\n    this.setRightChild(null);\n  } else {\n    this.setLeftChild(this.getRightChild().getLeftChild());\n    this.setRightChild(this.getRightChild().getRightChild());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (this.getParent() == null) {\n    return;\n  }\n  this.setParent(null);\n  this.setChild(null);\n  this.setNeighbor(null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList() {\n  if (root != null) {\n    root.removeFromTreeEdgeList();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes this edge from both doubly linked lists of tree edges.\n */\n", "method_name": "removeFromTreeEdgeList", "codes": ["public void removeFromTreeEdgeList(){ edgeList.remove(this); }", "public void removeFromTreeEdgeList(){ if (this.edges.size() == 0) return; for (int i = 0; i < this.edges.size(); i++) { if (this.edges.get(i).getHead() == this.getHead() && this.edges.get(i).getTail() == this.getTail()) { this.edges.remove(i); i--; } } }", "public void removeFromTreeEdgeList(){ this.edgeList.remove(this.getEdgeTo()); }", "public void removeFromTreeEdgeList(){ if (rootEdge != null) { rootEdge.removeFromTreeEdgeList(); } }", "public void removeFromTreeEdgeList(){ edgeList.remove(edgeList.size() - 1); }", "public void removeFromTreeEdgeList(){ if (this.treeEdgeList != null) { if (this.treeEdgeList.size() > 0) { this.treeEdgeList.clear(); } } }", "public void removeFromTreeEdgeList(){ if (this.getFirstEdge().getTarget() == this) { this.setFirstEdge(this.getFirstEdge().getNext()); } if (this.getSecondEdge().getTarget() == this) { this.setSecondEdge(this.getSecondEdge().getNext()); } }", "public void removeFromTreeEdgeList(){ if (this.isLeaf()) { return; } if (this.getLeftChild().isLeaf()) { this.setLeftChild(null); this.setLeftChild(null); } else if (this.getRightChild().isLeaf()) { this.setRightChild(null); this.setRightChild(null); } else { this.setLeftChild(this.getRightChild().getLeftChild()); this.setRightChild(this.getRightChild().getRightChild()); } }", "public void removeFromTreeEdgeList(){ if (this.getParent() == null) { return; } this.setParent(null); this.setChild(null); this.setNeighbor(null); }", "public void removeFromTreeEdgeList(){ if (root != null) { root.removeFromTreeEdgeList(); } }"], "code_level": "class_runnable", "_id": "6367675c1a6d9265ec01805b", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (!touchingVerticesToEdgeMap.containsKey(sourceVertex)) {\n    if (!touchingVerticesToEdgeMap.containsKey(targetVertex)) {\n      touchingVerticesToEdgeMap.put(sourceVertex, new LinkedHashSet<E>());\n    }\n  }\n  if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) {\n    if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) {\n      touchingVerticesToEdgeMap.get(sourceVertex).add(e);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (sourceVertex.equals(targetVertex)) {\n    return;\n  }\n  if (!isConnected(sourceVertex, targetVertex)) {\n    return;\n  }\n  if (!touchingVerticesToEdgeMap.containsKey(sourceVertex)) {\n    touchingVerticesToEdgeMap.put(sourceVertex, new ArrayList<E>());\n  }\n  if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) {\n    touchingVerticesToEdgeMap.get(sourceVertex).add(e);\n  }\n  if (!touchingVerticesToEdgeMap.containsKey(targetVertex)) {\n    touchingVerticesToEdgeMap.put(targetVertex, new ArrayList<E>());\n  }\n  if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) {\n    touchingVerticesToEdgeMap.get(targetVertex).add(e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (sourceVertex.equals(targetVertex)) return;\n  if (sourceVertex.equals(vertex)) {\n    if (!vertexToEdgeMap.containsKey(sourceVertex)) {\n      vertexToEdgeMap.put(sourceVertex, new HashSet<E>());\n    }\n    vertexToEdgeMap.get(sourceVertex).add(e);\n    return;\n  }\n  if (!vertexToEdgeMap.containsKey(targetVertex)) {\n    vertexToEdgeMap.put(targetVertex, new HashSet<E>());\n  }\n  vertexToEdgeMap.get(targetVertex).add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (sourceVertex.equals(targetVertex)) return;\n  if (!index.containsKey(sourceVertex)) index.put(sourceVertex, new HashSet<>());\n  if (!index.containsKey(targetVertex)) index.put(targetVertex, new HashSet<>());\n  index.get(sourceVertex).add(targetVertex);\n  index.get(targetVertex).add(sourceVertex);\n  index.get(sourceVertex).add(targetVertex);\n  index.get(targetVertex).add(sourceVertex);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (sourceVertex.equals(targetVertex)) {\n    return;\n  }\n  if (e.getSource().equals(sourceVertex)) {\n    e.getSource().addEdge(e);\n  } else {\n    e.getTarget().addEdge(e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  assert sourceVertex != null;\n  assert targetVertex != null;\n  assert e != null;\n  assert sourceVertex.equals(targetVertex);\n  assert !touchingVerticesToEdgeMap.containsKey(sourceVertex);\n  assert !touchingVerticesToEdgeMap.containsKey(targetVertex);\n  if (sourceVertex.equals(targetVertex)) {\n    return;\n  }\n  if (e.isRemoved()) {\n    return;\n  }\n  if (touchingVerticesToEdgeMap.containsKey(sourceVertex)) {\n    if (e.isTouchingVertex()) {\n      if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(targetVertex)) {\n        touchingVerticesToEdgeMap.get(sourceVertex).add(targetVertex);\n      }\n    } else {\n      if (touchingVerticesToEdgeMap.get(sourceVertex).contains(targetVertex)) {\n        if (touchingVerticesToEdgeMap.get(sourceVertex).size() == 1) {\n          touchingVerticesToEdgeMap.remove(sourceVertex);\n        } else {\n          touchingVerticesToEdgeMap.get(sourceVertex).remove(targetVertex);\n        }\n      }\n    }\n  } else {\n    LinkedList<V> vertices = new LinkedList<V>();\n    vertices.add(sourceVertex);\n    vertices.add(targetVertex);\n    touchingVerticesToEdgeMap.put(sourceVertex, vertices);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (index.containsKey(sourceVertex)) {\n    index.get(sourceVertex).add(targetVertex, e);\n  } else {\n    HashSet<V, E> es = new HashSet<V, E>();\n    es.add(targetVertex, e);\n    index.put(sourceVertex, es);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (sourceVertex == null || targetVertex == null) {\n    throw new NullPointerException();\n  }\n  if (e == null) {\n    throw new NullPointerException();\n  }\n  if (!e.isTouchingVertices()) {\n    throw new IllegalArgumentException(\"Edge must be TouchingVertices!\");\n  }\n  if (!touchingVerticesToEdgeMap.containsKey(sourceVertex)) {\n    ArrayList<E> edges = new ArrayList<E>();\n    edges.add(e);\n    touchingVerticesToEdgeMap.put(sourceVertex, edges);\n  } else {\n    ArrayList<E> edges = touchingVerticesToEdgeMap.get(sourceVertex);\n    edges.add(e);\n    touchingVerticesToEdgeMap.put(sourceVertex, edges);\n  }\n  if (!touchingVerticesToEdgeMap.containsKey(targetVertex)) {\n    ArrayList<E> edges = new ArrayList<E>();\n    edges.add(e);\n    touchingVerticesToEdgeMap.put(targetVertex, edges);\n  } else {\n    ArrayList<E> edges = touchingVerticesToEdgeMap.get(targetVertex);\n    edges.add(e);\n    touchingVerticesToEdgeMap.put(targetVertex, edges);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (e.isTouchingVertices()) {\n    if (touchingVerticesToEdgeMap.containsKey(sourceVertex)) {\n      if (touchingVerticesToEdgeMap.get(sourceVertex).containsKey(targetVertex)) {\n        int edgeId = touchingVerticesToEdgeMap.get(sourceVertex).get(targetVertex);\n        e.setId(edgeId);\n      }\n    }\n  } else {\n    if (sourceVertex.equals(targetVertex)) {\n      e.setId(-1);\n    } else {\n      int sourceVertexId = vertices.get(sourceVertex).getId();\n      int targetVertexId = vertices.get(targetVertex).getId();\n      e.setId(sourceVertexId < targetVertexId ? sourceVertexId : targetVertexId);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex, V targetVertex, E e) {\n  if (sourceVertex.equals(targetVertex)) return;\n  if (sourceVertex.equals(sourceVertex)) {\n    sourceVertex = sourceVertex;\n  }\n  if (sourceVertex.equals(targetVertex)) {\n    targetVertex = targetVertex;\n  }\n  if (targetVertex.equals(sourceVertex)) {\n    targetVertex = targetVertex;\n  }\n  if (targetVertex.equals(sourceVertex)) {\n    targetVertex = targetVertex;\n  }\n  if (sourceVertex.equals(targetVertex)) {\n    sourceVertex = sourceVertex;\n  }\n  if (sourceVertex.equals(targetVertex)) {\n    targetVertex = targetVertex;\n  }\n  if (e.equals(e)) {\n    e = e;\n  }\n  if (e.getType() == E.Type.CONNECTION) {\n    if (!edgeToVertex.containsKey(sourceVertex)) {\n      edgeToVertex.put(sourceVertex, new HashSet<V>());\n    }\n    if (!edgeToVertex.get(sourceVertex).contains(targetVertex)) {\n      edgeToVertex.get(sourceVertex).add(targetVertex);\n    }\n    if (!edgeToVertex.containsKey(targetVertex)) {\n      edgeToVertex.put(targetVertex, new HashSet<V>());\n    }\n    if (!edgeToVertex.get(targetVertex).contains(sourceVertex)) {\n      edgeToVertex.get(targetVertex).add(sourceVertex);\n    }\n  } else if (e.getType() == E.Type.EDGE) {\n    if (!edgeToVertex.containsKey(sourceVertex)) {\n      edgeToVertex.put(sourceVertex, new HashSet<V>());\n    }\n    if (!edgeToVertex.get(sourceVertex).contains(targetVertex)) {\n      edgeToVertex.get(sourceVertex).add(targetVertex);\n    }\n    if (!edgeToVertex.containsKey(targetVertex)) {\n      edgeToVertex.put(targetVertex, new HashSet<V>());\n    }\n    if (!edgeToVertex.get(targetVertex).contains(sourceVertex)) {\n      edgeToVertex.get(targetVertex).add(sourceVertex);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n", "method_name": "addToIndex", "codes": ["protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (!touchingVerticesToEdgeMap.containsKey(sourceVertex)) { if (!touchingVerticesToEdgeMap.containsKey(targetVertex)) { touchingVerticesToEdgeMap.put(sourceVertex, new LinkedHashSet<E>()); } } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { touchingVerticesToEdgeMap.get(sourceVertex).add(e); } } }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (sourceVertex.equals(targetVertex)) { return; } if (!isConnected(sourceVertex, targetVertex)) { return; } if (!touchingVerticesToEdgeMap.containsKey(sourceVertex)) { touchingVerticesToEdgeMap.put(sourceVertex, new ArrayList<E>()); } if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(e)) { touchingVerticesToEdgeMap.get(sourceVertex).add(e); } if (!touchingVerticesToEdgeMap.containsKey(targetVertex)) { touchingVerticesToEdgeMap.put(targetVertex, new ArrayList<E>()); } if (!touchingVerticesToEdgeMap.get(targetVertex).contains(e)) { touchingVerticesToEdgeMap.get(targetVertex).add(e); } }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (sourceVertex.equals(targetVertex)) return; if (sourceVertex.equals(vertex)) { if (!vertexToEdgeMap.containsKey(sourceVertex)) { vertexToEdgeMap.put(sourceVertex, new HashSet<E>()); } vertexToEdgeMap.get(sourceVertex).add(e); return; } if (!vertexToEdgeMap.containsKey(targetVertex)) { vertexToEdgeMap.put(targetVertex, new HashSet<E>()); } vertexToEdgeMap.get(targetVertex).add(e); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (sourceVertex.equals(targetVertex)) return; if (!index.containsKey(sourceVertex)) index.put(sourceVertex, new HashSet<>()); if (!index.containsKey(targetVertex)) index.put(targetVertex, new HashSet<>()); index.get(sourceVertex).add(targetVertex); index.get(targetVertex).add(sourceVertex); index.get(sourceVertex).add(targetVertex); index.get(targetVertex).add(sourceVertex); }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (sourceVertex.equals(targetVertex)) { return; } if (e.getSource().equals(sourceVertex)) { e.getSource().addEdge(e); } else { e.getTarget().addEdge(e); } }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ assert sourceVertex != null; assert targetVertex != null; assert e != null; assert sourceVertex.equals(targetVertex); assert !touchingVerticesToEdgeMap.containsKey(sourceVertex); assert !touchingVerticesToEdgeMap.containsKey(targetVertex); if (sourceVertex.equals(targetVertex)) { return; } if (e.isRemoved()) { return; } if (touchingVerticesToEdgeMap.containsKey(sourceVertex)) { if (e.isTouchingVertex()) { if (!touchingVerticesToEdgeMap.get(sourceVertex).contains(targetVertex)) { touchingVerticesToEdgeMap.get(sourceVertex).add(targetVertex); } } else { if (touchingVerticesToEdgeMap.get(sourceVertex).contains(targetVertex)) { if (touchingVerticesToEdgeMap.get(sourceVertex).size() == 1) { touchingVerticesToEdgeMap.remove(sourceVertex); } else { touchingVerticesToEdgeMap.get(sourceVertex).remove(targetVertex); } } } } else { LinkedList<V> vertices = new LinkedList<V>(); vertices.add(sourceVertex); vertices.add(targetVertex); touchingVerticesToEdgeMap.put(sourceVertex, vertices); } }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (index.containsKey(sourceVertex)) { index.get(sourceVertex).add(targetVertex, e); } else { HashSet<V, E> es = new HashSet<V, E>(); es.add(targetVertex, e); index.put(sourceVertex, es); } }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (sourceVertex == null || targetVertex == null) { throw new NullPointerException(); } if (e == null) { throw new NullPointerException(); } if (!e.isTouchingVertices()) { throw new IllegalArgumentException(\"Edge must be TouchingVertices!\"); } if (!touchingVerticesToEdgeMap.containsKey(sourceVertex)) { ArrayList<E> edges = new ArrayList<E>(); edges.add(e); touchingVerticesToEdgeMap.put(sourceVertex, edges); } else { ArrayList<E> edges = touchingVerticesToEdgeMap.get(sourceVertex); edges.add(e); touchingVerticesToEdgeMap.put(sourceVertex, edges); } if (!touchingVerticesToEdgeMap.containsKey(targetVertex)) { ArrayList<E> edges = new ArrayList<E>(); edges.add(e); touchingVerticesToEdgeMap.put(targetVertex, edges); } else { ArrayList<E> edges = touchingVerticesToEdgeMap.get(targetVertex); edges.add(e); touchingVerticesToEdgeMap.put(targetVertex, edges); } }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (e.isTouchingVertices()) { if (touchingVerticesToEdgeMap.containsKey(sourceVertex)) { if (touchingVerticesToEdgeMap.get(sourceVertex).containsKey(targetVertex)) { int edgeId = touchingVerticesToEdgeMap.get(sourceVertex).get(targetVertex); e.setId(edgeId); } } } else { if (sourceVertex.equals(targetVertex)) { e.setId(-1); } else { int sourceVertexId = vertices.get(sourceVertex).getId(); int targetVertexId = vertices.get(targetVertex).getId(); e.setId(sourceVertexId < targetVertexId ? sourceVertexId : targetVertexId); } } }", "protected void addToIndex(V sourceVertex,V targetVertex,E e){ if (sourceVertex.equals(targetVertex)) return; if (sourceVertex.equals(sourceVertex)) { sourceVertex = sourceVertex; } if (sourceVertex.equals(targetVertex)) { targetVertex = targetVertex; } if (targetVertex.equals(sourceVertex)) { targetVertex = targetVertex; } if (targetVertex.equals(sourceVertex)) { targetVertex = targetVertex; } if (sourceVertex.equals(targetVertex)) { sourceVertex = sourceVertex; } if (sourceVertex.equals(targetVertex)) { targetVertex = targetVertex; } if (e.equals(e)) { e = e; } if (e.getType() == E.Type.CONNECTION) { if (!edgeToVertex.containsKey(sourceVertex)) { edgeToVertex.put(sourceVertex, new HashSet<V>()); } if (!edgeToVertex.get(sourceVertex).contains(targetVertex)) { edgeToVertex.get(sourceVertex).add(targetVertex); } if (!edgeToVertex.containsKey(targetVertex)) { edgeToVertex.put(targetVertex, new HashSet<V>()); } if (!edgeToVertex.get(targetVertex).contains(sourceVertex)) { edgeToVertex.get(targetVertex).add(sourceVertex); } } else if (e.getType() == E.Type.EDGE) { if (!edgeToVertex.containsKey(sourceVertex)) { edgeToVertex.put(sourceVertex, new HashSet<V>()); } if (!edgeToVertex.get(sourceVertex).contains(targetVertex)) { edgeToVertex.get(sourceVertex).add(targetVertex); } if (!edgeToVertex.containsKey(targetVertex)) { edgeToVertex.put(targetVertex, new HashSet<V>()); } if (!edgeToVertex.get(targetVertex).contains(sourceVertex)) { edgeToVertex.get(targetVertex).add(sourceVertex); } } }"], "code_level": "class_runnable", "_id": "636767601a6d9265ec0180fd", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.getXmin(), box.getXmax(), box.getYmin(), box.getYmax()); Box2D right = new Box2D(box.getXmin(), box.getXmax(), box.getYmin(), box.getYmax()); Box2D leftMinus = left.clone(); Box2D rightMinus = right.clone(); Box2D leftMaxus = left.clone(); Box2D rightMaxus = right.clone(); Box2D leftMinusMinus = leftMinus.clone(); Box2D rightMinusMinus = rightMinus.clone(); Box2D leftMaxusMinus = leftMaxus.clone(); Box2D rightMaxusMinus = rightMaxus.clone(); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmax()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmax()); leftMinusMinus.set(box.getXmax(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmax()); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmax()); leftMinusMinus.set(box.getXmax(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmin(),", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  if (box.getX().getWidth() == box.getX().getHeight()) {\n    return new Pair<Box2D, Box2D>(box, box.getX());\n  }\n  return new Pair<Box2D, Box2D>(box, box.getX().getWidth() / 2);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left = new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight());\n  Box2D right =\n      new Box2D(box.getX(), box.getY() + box.getHeight(), box.getWidth(), box.getHeight());\n  Box2D top = new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight());\n  Box2D bottom =\n      new Box2D(box.getX(), box.getY() + box.getHeight(), box.getWidth(), box.getHeight());\n  return new Pair<Box2D, Box2D>(left, right);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left = new Box2D(box.getX() - 1, box.getY(), box.getWidth(), box.getHeight());\n  Box2D right = new Box2D(box.getX(), box.getY() + 1, box.getWidth(), box.getHeight());\n  Box2D top = new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight());\n  Box2D bottom = new Box2D(box.getX() + 1, box.getY(), box.getWidth(), box.getHeight());\n  if (!box.contains(left) && !box.contains(right)) {\n    return new Pair<>(left, right);\n  } else if (box.contains(left) && !box.contains(right)) {\n    return new Pair<>(left, bottom);\n  } else if (box.contains(left) && box.contains(right)) {\n    return new Pair<>(left, top);\n  } else if (box.contains(left) && box.contains(top)) {\n    return new Pair<>(left, bottom);\n  } else if (box.contains(left) && box.contains(bottom)) {\n    return new Pair<>(right, bottom);\n  } else if (box.contains(left) && box.contains(top)) {\n    return new Pair<>(right, top);\n  } else if (box.contains(right) && box.contains(bottom)) {\n    return new Pair<>(left, top);\n  } else if (box.contains(right) && box.contains(top)) {\n    return new Pair<>(right, bottom);\n  } else if (box.contains(right) && box.contains(bottom)) {\n    return new Pair<>(left, top);\n  } else if (box.contains(right) && box.contains(top)) {\n    return new Pair<>(left, bottom);\n  } else {\n    return new Pair<>(right, top);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left = new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight());\n  Box2D right =\n      new Box2D(box.getX() + box.getWidth(), box.getY(), box.getWidth(), box.getHeight());\n  return new Pair<Box2D, Box2D>(left, right);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left =\n      new Box2D(box.x - box.width / 2, box.y - box.height / 2, box.width / 2, box.height / 2);\n  Box2D right =\n      new Box2D(box.x + box.width / 2, box.y - box.height / 2, box.width / 2, box.height / 2);\n  Box2D middle = new Box2D(box.x, box.y, box.width, box.height);\n  if (box.x < left.x) {\n    left.x = box.x;\n  }\n  if (box.x > right.x) {\n    right.x = box.x;\n  }\n  if (box.y < left.y) {\n    left.y = box.y;\n  }\n  if (box.y > right.y) {\n    right.y = box.y;\n  }\n  if (box.y > middle.y) {\n    middle.y = box.y;\n  }\n  if (box.x < left.x + middle.width / 2) {\n    left.x = left.x + box.width / 2;\n  } else {\n    right.x = right.x - box.width / 2;\n  }\n  if (box.x > right.x - middle.width / 2) {\n    right.x = right.x - box.width / 2;\n  }\n  return new Pair<Box2D, Box2D>(left, right);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  double y1 = box.getY1();\n  double y2 = box.getY2();\n  double x1 = box.getX1();\n  double x2 = box.getX2();\n  double z1 = box.getZ1();\n  double z2 = box.getZ2();\n  double xm = x2 - x1;\n  double ym = y2 - y1;\n  double zm = z2 - z1;\n  double dx = xm * zm - ym * zm;\n  double dy = zm * ym - xm * ym;\n  double dz = zm * xm - ym * xm;\n  double d = Math.sqrt(dx * dx + dy * dy + dz * dz);\n  double dx1 = dx / d;\n  double dy1 = dy / d;\n  double dz1 = dz / d;\n  double dx2 = dx1 * xm + dx1 * ym + dx1 * zm;\n  double dy2 = dy1 * xm + dy1 * ym + dy1 * zm;\n  double dz2 = dz1 * xm + dz1 * ym + dz1 * zm;\n  return new Pair<Box2D, Box2D>(\n      new Box2D(x1, y1, z1, x2, y2, z2), new Box2D(x2, y2, z2, xm, ym, zm));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left = new Box2D(box.getXmin(), box.getXmax(), box.getYmin(), box.getYmax());\n  Box2D right = new Box2D(box.getXmin(), box.getXmax(), box.getYmax(), box.getYmin());\n  double t = 0;\n  double d =\n      Math.sqrt(\n          Math.pow(left.getXmax() - right.getXmin(), 2)\n              + Math.pow(left.getYmax() - right.getYmin(), 2));\n  while (t <= d) {\n    t += d / 2;\n    Box2D b = new Box2D(t, t, t, t);\n    if (b.getYmin() > box.getYmax()) {\n      break;\n    }\n    if (box.contains(b)) {\n      left = b;\n    } else {\n      right = b;\n    }\n  }\n  t = 0;\n  d =\n      Math.sqrt(\n          Math.pow(left.getXmax() - right.getXmin(), 2)\n              + Math.pow(left.getYmax() - right.getYmin(), 2));\n  while (t <= d) {\n    t += d / 2;\n    Box2D b = new Box2D(t, t, t, t);\n    if (b.getXmin() > box.getXmax()) {\n      break;\n    }\n    if (box.contains(b)) {\n      left = b;\n    } else {\n      right = b;\n    }\n  }\n  t = 0;\n  d =\n      Math.sqrt(\n          Math.pow(left.getXmax() - right.getXmin(), 2)\n              + Math.pow(left.getYmax() - right.getYmin(), 2));\n  while (t <= d) {\n    t += d / 2;\n    Box2D b = new Box2D(t, t, t, t);\n    if (b.getXmax() < box.getXmin()) {\n      break;\n    }\n    if (box.contains(b)) {\n      left = b;\n    } else {\n      right = b;\n    }\n  }\n  t = 0;\n  d =\n      Math.sqrt(\n          Math.pow(left.getXmax() - right.getXmin(), 2)\n              + Math.pow(left.getYmax() - right.getYmin(), 2));\n  while (t <= d) {\n    t += d / 2;\n    Box2D b = new Box2D(t, t, t, t);\n    if (b.getXmin() < box.getXmax()) {\n      break;\n    }\n    if (box.contains(b)) {\n      left = b;\n    } else {\n      right = b;\n    }\n  }\n  return new Pair<Box2D, Box2D>(left, right);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  int x = (int) box.getX();\n  int y = (int) box.getY();\n  Box2D left = new Box2D(x - 1, y, x + 1, y);\n  Box2D right = new Box2D(x, y - 1, x, y + 1);\n  return new Pair<>(left, right);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box) {\n  Box2D left = new Box2D(box.x - box.width / 2, box.y, box.width, box.height);\n  Box2D right = new Box2D(box.x + box.width / 2, box.y, box.width, box.height);\n  return new Pair<Box2D, Box2D>(left, right);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split a box along the x axis into two equal boxes.\n * @param box the box to split\n * @return a pair with the two resulting boxes\n */\n", "method_name": "splitAlongXAxis", "codes": ["public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.getXmin(), box.getXmax(), box.getYmin(), box.getYmax()); Box2D right = new Box2D(box.getXmin(), box.getXmax(), box.getYmin(), box.getYmax()); Box2D leftMinus = left.clone(); Box2D rightMinus = right.clone(); Box2D leftMaxus = left.clone(); Box2D rightMaxus = right.clone(); Box2D leftMinusMinus = leftMinus.clone(); Box2D rightMinusMinus = rightMinus.clone(); Box2D leftMaxusMinus = leftMaxus.clone(); Box2D rightMaxusMinus = rightMaxus.clone(); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmax()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmax()); leftMinusMinus.set(box.getXmax(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmax()); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmax()); leftMinusMinus.set(box.getXmax(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmin(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmin(), box.getYmax(), box.getXmin()); leftMinusMinus.set(box.getXmax(), box.getYmin(),", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ if (box.getX().getWidth() == box.getX().getHeight()) { return new Pair<Box2D, Box2D>(box, box.getX()); } return new Pair<Box2D, Box2D>(box, box.getX().getWidth() / 2); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight()); Box2D right = new Box2D(box.getX(), box.getY() + box.getHeight(), box.getWidth(), box.getHeight()); Box2D top = new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight()); Box2D bottom = new Box2D(box.getX(), box.getY() + box.getHeight(), box.getWidth(), box.getHeight()); return new Pair<Box2D, Box2D>(left, right); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.getX() - 1, box.getY(), box.getWidth(), box.getHeight()); Box2D right = new Box2D(box.getX(), box.getY() + 1, box.getWidth(), box.getHeight()); Box2D top = new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight()); Box2D bottom = new Box2D(box.getX() + 1, box.getY(), box.getWidth(), box.getHeight()); if (!box.contains(left) && !box.contains(right)) { return new Pair<>(left, right); } else if (box.contains(left) && !box.contains(right)) { return new Pair<>(left, bottom); } else if (box.contains(left) && box.contains(right)) { return new Pair<>(left, top); } else if (box.contains(left) && box.contains(top)) { return new Pair<>(left, bottom); } else if (box.contains(left) && box.contains(bottom)) { return new Pair<>(right, bottom); } else if (box.contains(left) && box.contains(top)) { return new Pair<>(right, top); } else if (box.contains(right) && box.contains(bottom)) { return new Pair<>(left, top); } else if (box.contains(right) && box.contains(top)) { return new Pair<>(right, bottom); } else if (box.contains(right) && box.contains(bottom)) { return new Pair<>(left, top); } else if (box.contains(right) && box.contains(top)) { return new Pair<>(left, bottom); } else { return new Pair<>(right, top); } }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.getX(), box.getY(), box.getWidth(), box.getHeight()); Box2D right = new Box2D(box.getX() + box.getWidth(), box.getY(), box.getWidth(), box.getHeight()); return new Pair<Box2D, Box2D>(left, right); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.x - box.width / 2, box.y - box.height / 2, box.width / 2, box.height / 2); Box2D right = new Box2D(box.x + box.width / 2, box.y - box.height / 2, box.width / 2, box.height / 2); Box2D middle = new Box2D(box.x, box.y, box.width, box.height); if (box.x < left.x) { left.x = box.x; } if (box.x > right.x) { right.x = box.x; } if (box.y < left.y) { left.y = box.y; } if (box.y > right.y) { right.y = box.y; } if (box.y > middle.y) { middle.y = box.y; } if (box.x < left.x + middle.width / 2) { left.x = left.x + box.width / 2; } else { right.x = right.x - box.width / 2; } if (box.x > right.x - middle.width / 2) { right.x = right.x - box.width / 2; } return new Pair<Box2D, Box2D>(left, right); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ double y1 = box.getY1(); double y2 = box.getY2(); double x1 = box.getX1(); double x2 = box.getX2(); double z1 = box.getZ1(); double z2 = box.getZ2(); double xm = x2 - x1; double ym = y2 - y1; double zm = z2 - z1; double dx = xm * zm - ym * zm; double dy = zm * ym - xm * ym; double dz = zm * xm - ym * xm; double d = Math.sqrt(dx * dx + dy * dy + dz * dz); double dx1 = dx / d; double dy1 = dy / d; double dz1 = dz / d; double dx2 = dx1 * xm + dx1 * ym + dx1 * zm; double dy2 = dy1 * xm + dy1 * ym + dy1 * zm; double dz2 = dz1 * xm + dz1 * ym + dz1 * zm; return new Pair<Box2D, Box2D>(new Box2D(x1, y1, z1, x2, y2, z2), new Box2D(x2, y2, z2, xm, ym, zm)); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.getXmin(), box.getXmax(), box.getYmin(), box.getYmax()); Box2D right = new Box2D(box.getXmin(), box.getXmax(), box.getYmax(), box.getYmin()); double t = 0; double d = Math.sqrt(Math.pow(left.getXmax() - right.getXmin(), 2) + Math.pow(left.getYmax() - right.getYmin(), 2)); while (t <= d) { t += d / 2; Box2D b = new Box2D(t, t, t, t); if (b.getYmin() > box.getYmax()) { break; } if (box.contains(b)) { left = b; } else { right = b; } } t = 0; d = Math.sqrt(Math.pow(left.getXmax() - right.getXmin(), 2) + Math.pow(left.getYmax() - right.getYmin(), 2)); while (t <= d) { t += d / 2; Box2D b = new Box2D(t, t, t, t); if (b.getXmin() > box.getXmax()) { break; } if (box.contains(b)) { left = b; } else { right = b; } } t = 0; d = Math.sqrt(Math.pow(left.getXmax() - right.getXmin(), 2) + Math.pow(left.getYmax() - right.getYmin(), 2)); while (t <= d) { t += d / 2; Box2D b = new Box2D(t, t, t, t); if (b.getXmax() < box.getXmin()) { break; } if (box.contains(b)) { left = b; } else { right = b; } } t = 0; d = Math.sqrt(Math.pow(left.getXmax() - right.getXmin(), 2) + Math.pow(left.getYmax() - right.getYmin(), 2)); while (t <= d) { t += d / 2; Box2D b = new Box2D(t, t, t, t); if (b.getXmin() < box.getXmax()) { break; } if (box.contains(b)) { left = b; } else { right = b; } } return new Pair<Box2D, Box2D>(left, right); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ int x = (int) box.getX(); int y = (int) box.getY(); Box2D left = new Box2D(x - 1, y, x + 1, y); Box2D right = new Box2D(x, y - 1, x, y + 1); return new Pair<>(left, right); }", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){ Box2D left = new Box2D(box.x - box.width / 2, box.y, box.width, box.height); Box2D right = new Box2D(box.x + box.width / 2, box.y, box.width, box.height); return new Pair<Box2D, Box2D>(left, right); }"], "code_level": "project_runnable", "_id": "636767521a6d9265ec017ecc", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  if (p1.getX() == p2.getX() && p1.getY() == p2.getY()) return true;\n  else return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  if (p1 == null && p2 == null) return true;\n  if (p1 == null || p2 == null) return false;\n  return p1.equals(p2);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return p1.distance(p2) < TOLERANCE_DOUBLE_COMPARATOR.distance(p1, p2);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return (p1.getX() == p2.getX() && p1.getY() == p2.getY());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  if (p1 == null || p2 == null) return false;\n  return p1.x == p2.x && p1.y == p2.y;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return (p1.getX() == p2.getX()) && (p1.getY() == p2.getY());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  if (p1 == null || p2 == null) {\n    return false;\n  }\n  return p1.equals(p2);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  double deltaX = p2.getX() - p1.getX();\n  double deltaY = p2.getY() - p1.getY();\n  if (deltaX == 0 && deltaY == 0) return true;\n  else return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  double dx = p1.getX() - p2.getX();\n  double dy = p1.getY() - p2.getY();\n  return Math.abs(dx) < TOLERANCE_DOUBLE_COMPARATOR && Math.abs(dy) < TOLERANCE_DOUBLE_COMPARATOR;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1, Point2D p2) {\n  return Math.abs(p1.getX() - p2.getX()) < TOLERANCE_DOUBLE_COMPARATOR\n      && Math.abs(p1.getY() - p2.getY()) < TOLERANCE_DOUBLE_COMPARATOR;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compare two points for equality using tolerance 1e-9.\n * @param p1 the first point\n * @param p2 the second point\n * @return whether the two points are equal or not\n */\n", "method_name": "equals", "codes": ["public static boolean equals(Point2D p1,Point2D p2){ if (p1.getX() == p2.getX() && p1.getY() == p2.getY()) return true; else return false; }", "public static boolean equals(Point2D p1,Point2D p2){ if (p1 == null && p2 == null) return true; if (p1 == null || p2 == null) return false; return p1.equals(p2); }", "public static boolean equals(Point2D p1,Point2D p2){ return p1.distance(p2) < TOLERANCE_DOUBLE_COMPARATOR.distance(p1, p2); }", "public static boolean equals(Point2D p1,Point2D p2){ return (p1.getX() == p2.getX() && p1.getY() == p2.getY()); }", "public static boolean equals(Point2D p1,Point2D p2){ if (p1 == null || p2 == null) return false; return p1.x == p2.x && p1.y == p2.y; }", "public static boolean equals(Point2D p1,Point2D p2){ return (p1.getX() == p2.getX()) && (p1.getY() == p2.getY()); }", "public static boolean equals(Point2D p1,Point2D p2){ if (p1 == null || p2 == null) { return false; } return p1.equals(p2); }", "public static boolean equals(Point2D p1,Point2D p2){ double deltaX = p2.getX() - p1.getX(); double deltaY = p2.getY() - p1.getY(); if (deltaX == 0 && deltaY == 0) return true; else return false; }", "public static boolean equals(Point2D p1,Point2D p2){ double dx = p1.getX() - p2.getX(); double dy = p1.getY() - p2.getY(); return Math.abs(dx) < TOLERANCE_DOUBLE_COMPARATOR && Math.abs(dy) < TOLERANCE_DOUBLE_COMPARATOR; }", "public static boolean equals(Point2D p1,Point2D p2){ return Math.abs(p1.getX() - p2.getX()) < TOLERANCE_DOUBLE_COMPARATOR && Math.abs(p1.getY() - p2.getY()) < TOLERANCE_DOUBLE_COMPARATOR; }"], "code_level": "project_runnable", "_id": "636767531a6d9265ec017ef1", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  if (o1 < epsilon && o2 < epsilon) {\n    return 0;\n  } else if (o1 < epsilon) {\n    return -1;\n  } else if (o2 < epsilon) {\n    return 1;\n  }\n  return 0;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  if (o1 == o2) return 0;\n  if (o1 < o2) return -1;\n  return 1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  if (o1 < o2) return -1;\n  else if (o1 > o2) return 1;\n  else return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return Double.compare(o1, o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  if (o1 < o2) return -1;\n  else if (o1 > o2) return 1;\n  else return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return Double.compare(o2, o1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  if (o1 == null && o2 == null) {\n    return 0;\n  }\n  if (o1 == null) {\n    return -1;\n  }\n  if (o2 == null) {\n    return 1;\n  }\n  return Double.compare(o1, o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return (int) (o2 - o1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return (int) (Math.abs(o1 - o2) - epsilon);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\npublic int compare(Double o1, Double o2) {\n  return o1.compareTo(o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares two floating point values. Returns 0 if they are equal, -1 if  {@literal o1 < o2}, 1 otherwise\n * @param o1 the first value\n * @param o2 the second value\n * @return 0 if they are equal, -1 if {@literal o1 < o2}, 1 otherwise\n */\n", "method_name": "compare", "codes": ["@Override public int compare(Double o1,Double o2){ if (o1 < epsilon && o2 < epsilon) { return 0; } else if (o1 < epsilon) { return -1; } else if (o2 < epsilon) { return 1; } return 0; }", "@Override public int compare(Double o1,Double o2){ if (o1 == o2) return 0; if (o1 < o2) return -1; return 1; }", "@Override public int compare(Double o1,Double o2){ if (o1 < o2) return -1; else if (o1 > o2) return 1; else return 0; }", "@Override public int compare(Double o1,Double o2){ return Double.compare(o1, o2); }", "@Override public int compare(Double o1,Double o2){ if (o1 < o2) return -1; else if (o1 > o2) return 1; else return 0; }", "@Override public int compare(Double o1,Double o2){ return Double.compare(o2, o1); }", "@Override public int compare(Double o1,Double o2){ if (o1 == null && o2 == null) { return 0; } if (o1 == null) { return -1; } if (o2 == null) { return 1; } return Double.compare(o1, o2); }", "@Override public int compare(Double o1,Double o2){ return (int) (o2 - o1); }", "@Override public int compare(Double o1,Double o2){ return (int) (Math.abs(o1 - o2) - epsilon); }", "@Override public int compare(Double o1,Double o2){ return o1.compareTo(o2); }"], "code_level": "slib_runnable", "_id": "6367674a1a6d9265ec017dab", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public String toString() {\n  return Arrays.toString(values);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  StringBuffer sb = new StringBuffer(\"[\");\n  for (int i = 0; i < n; i++) {\n    sb.append(get(i) + \",\");\n  }\n  sb.deleteCharAt(sb.length() - 1);\n  sb.append(\"]\");\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  String ret = \"\";\n  for (int i = 0; i < value.length; i++) {\n    ret = ret + value[i] + \" \";\n  }\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  return String.format(\"%s:%s\", this.name, this.value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  String s = \"[\";\n  for (int i = 0; i < size(); i++) {\n    s += get(i) + \" \";\n  }\n  s += \"]\";\n  return s;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  String output = \"\";\n  for (int i = 0; i < this.values.length; i++) {\n    output = output + this.values[i] + \", \";\n  }\n  return output;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  String output = \"\";\n  for (int i = 0; i < size(); i++) {\n    output += get(i) + \" \";\n  }\n  return output;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  if (this.size() == 0) {\n    return \"\";\n  }\n  String str = \"[\";\n  for (int i = 0; i < this.size(); i++) {\n    str += this.get(i);\n    if (i < this.size() - 1) {\n      str += \",\";\n    }\n  }\n  return str + \"]\";\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  String res = \"\";\n  for (int i = 0; i < size; i++) {\n    res += arr[i] + \" \";\n  }\n  return res;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString() {\n  String ret = \"\";\n  if (this.isArray) {\n    ret += \"[\";\n    for (int i = 0; i < this.values.length; i++) {\n      ret += this.values[i];\n      if (i != this.values.length - 1) {\n        ret += \",\";\n      }\n    }\n    ret += \"]\";\n  } else {\n    ret += this.value;\n  }\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a textual representation of the queue.\n * @return a textual representation of the queue.\n */\n", "method_name": "toString", "codes": ["public String toString(){ return Arrays.toString(values); }", "public String toString(){ StringBuffer sb = new StringBuffer(\"[\"); for (int i = 0; i < n; i++) { sb.append(get(i) + \",\"); } sb.deleteCharAt(sb.length() - 1); sb.append(\"]\"); return sb.toString(); }", "public String toString(){ String ret = \"\"; for (int i = 0; i < value.length; i++) { ret = ret + value[i] + \" \"; } return ret; }", "public String toString(){ return String.format(\"%s:%s\", this.name, this.value); }", "public String toString(){ String s = \"[\"; for (int i = 0; i < size(); i++) { s += get(i) + \" \"; } s += \"]\"; return s; }", "public String toString(){ String output = \"\"; for (int i = 0; i < this.values.length; i++) { output = output + this.values[i] + \", \"; } return output; }", "public String toString(){ String output = \"\"; for (int i = 0; i < size(); i++) { output += get(i) + \" \"; } return output; }", "public String toString(){ if (this.size() == 0) { return \"\"; } String str = \"[\"; for (int i = 0; i < this.size(); i++) { str += this.get(i); if (i < this.size() - 1) { str += \",\"; } } return str + \"]\"; }", "public String toString(){ String res = \"\"; for (int i = 0; i < size; i++) { res += arr[i] + \" \"; } return res; }", "public String toString(){ String ret = \"\"; if (this.isArray) { ret += \"[\"; for (int i = 0; i < this.values.length; i++) { ret += this.values[i]; if (i != this.values.length - 1) { ret += \",\"; } } ret += \"]\"; } else { ret += this.value; } return ret; }"], "code_level": "class_runnable", "_id": "6367674f1a6d9265ec017e74", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private int computeBinaryLog(int n) {\n  if (n <= 0) {\n    throw new IllegalArgumentException(\"Number must be positive: \" + n);\n  }\n  if (n < 2) {\n    return n;\n  }\n  int log = 1;\n  int i = 2;\n  while (i <= n) {\n    log = log * 2;\n    i++;\n  }\n  return log;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private int computeBinaryLog(int n) {\n  int floor = 1;\n  while (n > 0) {\n    floor *= 2;\n    n -= 1;\n  }\n  return floor;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private int computeBinaryLog(int n) {\n  int i;\n  int j;\n  if (n < 0) {\n    n = -n;\n    i = -1;\n  } else {\n    i = 1;\n  }\n  j = 0;\n  while ((i << 1) <= n) {\n    j++;\n  }\n  return j;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n) {\n  int retVal = 0;\n  while (n > 0) {\n    retVal += n % 2;\n    n /= 2;\n  }\n  return retVal;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n) {\n  int f = 0;\n  while (n > 0) {\n    f = f * 2 + n % 2;\n    n = n / 2;\n  }\n  return f;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private int computeBinaryLog(int n) {\n  int i = 0;\n  while (n > 0) {\n    i++;\n    n /= 2;\n  }\n  return i;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private int computeBinaryLog(int n) {\n  int res = 0;\n  while (n > 0) {\n    res = res + (n & 1);\n    n >>= 1;\n  }\n  return res;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n) {\n  int log = 0;\n  while (n != 0) {\n    n /= 2;\n    log++;\n  }\n  return log;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private int computeBinaryLog(int n) {\n  int binaryLog = 0;\n  while (n != 0) {\n    binaryLog = (binaryLog * 10) + (n % 10);\n    n /= 10;\n  }\n  return binaryLog;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n) {\n  if (n == 1) {\n    return 1;\n  }\n  return computeBinaryLog(n / 2) + n % 2;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n", "method_name": "computeBinaryLog", "codes": ["private int computeBinaryLog(int n){ if (n <= 0) { throw new IllegalArgumentException(\"Number must be positive: \" + n); } if (n < 2) { return n; } int log = 1; int i = 2; while (i <= n) { log = log * 2; i++; } return log; }", "private int computeBinaryLog(int n){ int floor = 1; while (n > 0) { floor *= 2; n -= 1; } return floor; }", "private int computeBinaryLog(int n){ int i; int j; if (n < 0) { n = -n; i = -1; } else { i = 1; } j = 0; while ((i << 1) <= n) { j++; } return j; }", "private int computeBinaryLog(int n){ int retVal = 0; while (n > 0) { retVal += n % 2; n /= 2; } return retVal; }", "private int computeBinaryLog(int n){ int f = 0; while (n > 0) { f = f * 2 + n % 2; n = n / 2; } return f; }", "private int computeBinaryLog(int n){ int i = 0; while (n > 0) { i++; n /= 2; } return i; }", "private int computeBinaryLog(int n){ int res = 0; while (n > 0) { res = res + (n & 1); n >>= 1; } return res; }", "private int computeBinaryLog(int n){ int log = 0; while (n != 0) { n /= 2; log++; } return log; }", "private int computeBinaryLog(int n){ int binaryLog = 0; while (n != 0) { binaryLog = (binaryLog * 10) + (n % 10); n /= 10; } return binaryLog; }", "private int computeBinaryLog(int n){ if (n == 1) { return 1; } return computeBinaryLog(n / 2) + n % 2; }"], "code_level": "self_contained", "_id": "636767431a6d9265ec017c8d", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0.0;\n  for (V e : v) {\n    sum += weight(e);\n  }\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double weight = 0;\n  for (V v1 : v) {\n    weight += weights.get(v1).get(v1);\n  }\n  return weight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double weight = 0;\n  for (V u : v) {\n    weight += this.getWeight(u, v);\n  }\n  return weight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0;\n  for (V vv : v) sum += vertexWeight(vv);\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double weight = 0;\n  for (V k : v) {\n    weight += this.weights.get(k);\n  }\n  return weight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double weight = 0;\n  for (V v1 : v) weight += this.getWeight(v1);\n  return weight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double sum = 0;\n  for (V vv : v) sum += weight(vv);\n  return sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double w = 0;\n  for (V elem : v) w += this.weight(elem);\n  return w;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double weight = 0;\n  for (V e : v) {\n    weight += edgeWeight(e);\n  }\n  return weight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v) {\n  double totalWeight = 0;\n  for (V v1 : v) {\n    totalWeight += weights.get(v1);\n  }\n  return totalWeight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compute the sum of the weights entering a vertex\n * @param v the vertex\n * @return the sum of the weights entering a vertex\n */\n", "method_name": "vertexWeight", "codes": ["public double vertexWeight(Set<V> v){ double sum = 0.0; for (V e : v) { sum += weight(e); } return sum; }", "public double vertexWeight(Set<V> v){ double weight = 0; for (V v1 : v) { weight += weights.get(v1).get(v1); } return weight; }", "public double vertexWeight(Set<V> v){ double weight = 0; for (V u : v) { weight += this.getWeight(u, v); } return weight; }", "public double vertexWeight(Set<V> v){ double sum = 0; for (V vv : v) sum += vertexWeight(vv); return sum; }", "public double vertexWeight(Set<V> v){ double weight = 0; for (V k : v) { weight += this.weights.get(k); } return weight; }", "public double vertexWeight(Set<V> v){ double weight = 0; for (V v1 : v) weight += this.getWeight(v1); return weight; }", "public double vertexWeight(Set<V> v){ double sum = 0; for (V vv : v) sum += weight(vv); return sum; }", "public double vertexWeight(Set<V> v){ double w = 0; for (V elem : v) w += this.weight(elem); return w; }", "public double vertexWeight(Set<V> v){ double weight = 0; for (V e : v) { weight += edgeWeight(e); } return weight; }", "public double vertexWeight(Set<V> v){ double totalWeight = 0; for (V v1 : v) { totalWeight += weights.get(v1); } return totalWeight; }"], "code_level": "class_runnable", "_id": "636767611a6d9265ec018106", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>();\n  for (V v : set1) {\n    if (set2.contains(v)) {\n      intersection.add(v);\n    }\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>();\n  for (V v : set1) {\n    if (set2.contains(v)) intersection.add(v);\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>();\n  for (V v : set1) {\n    if (set2.contains(v)) {\n      intersection.add(v);\n    }\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>();\n  for (V v : set1) {\n    if (set2.contains(v)) {\n      intersection.add(v);\n    }\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<>();\n  for (V v : set1) {\n    if (set2.contains(v)) intersection.add(v);\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> result = new HashSet<>();\n  for (V v : set1) {\n    if (set2.contains(v)) {\n      result.add(v);\n    }\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> result = new HashSet<>();\n  for (V v : set1) {\n    if (set2.contains(v)) result.add(v);\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> intersection = new HashSet<V>();\n  for (V v : set1) {\n    if (set2.contains(v)) intersection.add(v);\n  }\n  return intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> result = new HashSet<V>(set1);\n  for (V v : set2) {\n    if (set1.contains(v)) {\n      result.remove(v);\n    }\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Set<V> intersection(Set<V> set1, Set<V> set2) {\n  Set<V> result = new HashSet<>(set1);\n  result.retainAll(set2);\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n", "method_name": "intersection", "codes": ["private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(); for (V v : set1) { if (set2.contains(v)) { intersection.add(v); } } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(); for (V v : set1) { if (set2.contains(v)) intersection.add(v); } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(); for (V v : set1) { if (set2.contains(v)) { intersection.add(v); } } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(); for (V v : set1) { if (set2.contains(v)) { intersection.add(v); } } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<>(); for (V v : set1) { if (set2.contains(v)) intersection.add(v); } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> result = new HashSet<>(); for (V v : set1) { if (set2.contains(v)) { result.add(v); } } return result; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> result = new HashSet<>(); for (V v : set1) { if (set2.contains(v)) result.add(v); } return result; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> intersection = new HashSet<V>(); for (V v : set1) { if (set2.contains(v)) intersection.add(v); } return intersection; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> result = new HashSet<V>(set1); for (V v : set2) { if (set1.contains(v)) { result.remove(v); } } return result; }", "private Set<V> intersection(Set<V> set1,Set<V> set2){ Set<V> result = new HashSet<>(set1); result.retainAll(set2); return result; }"], "code_level": "slib_runnable", "_id": "636767611a6d9265ec018116", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  ArrayList<Node> neighbors = new ArrayList<>();\n  neighbors.add(start);\n  neighbors.add(stop);\n  for (Node n : neighbors) {\n    if (n.equals(start)) {\n      continue;\n    }\n    if (n.equals(stop)) {\n      continue;\n    }\n    if (n.isOuterFace()) {\n      continue;\n    }\n    if (predicate.test(n)) {\n      return new OuterFaceCirculator(n, dir);\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  OuterFaceCirculator found = null;\n  for (int i = 0; i < outerFaces.size(); i++) {\n    if (outerFaces.get(i).isSelected()) {\n      if (found == null) {\n        found = outerFaces.get(i);\n      } else {\n        if (predicate.test(start)) {\n          if (!predicate.test(stop)) {\n            if (!predicate.test(found.getOuterFace())) {\n              found = outerFaces.get(i);\n            }\n          }\n        }\n      }\n    }\n  }\n  return found;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  outerFaceCirculator = null;\n  outerFaceCirculator = new OuterFaceCirculator();\n  outerFaceCirculator.setStart(start);\n  outerFaceCirculator.setStop(stop);\n  outerFaceCirculator.setDir(dir);\n  outerFaceCirculator.setPredicate(predicate);\n  outerFaceCirculator.setVisible(true);\n  outerFaceCirculator.setSize(new Dimension(500, 500));\n  outerFaceCirculator.setCirculator(selectOnOuterFace(outerFaceCirculator));\n  return outerFaceCirculator;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  int[] indices = new int[2];\n  indices[0] = (dir == 0) ? 0 : 1;\n  indices[1] = (dir == 0) ? 1 : 0;\n  int i = 0;\n  while (i < indices.length) {\n    int j = indices[i];\n    if (j != 0) {\n      if (predicate.test(start.getNode(j))) {\n        return new OuterFaceCirculator(start.getNode(j), stop.getNode(j));\n      }\n    }\n    i++;\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  OuterFaceCirculator selected = null;\n  if (predicate.test(start)) {\n    selected = new OuterFaceCirculator(start, stop, dir);\n  } else if (predicate.test(stop)) {\n    selected = new OuterFaceCirculator(stop, start, dir);\n  } else {\n    for (Node node : getNodes(start, stop)) {\n      selected = new OuterFaceCirculator(node, stop, dir);\n      if (predicate.test(node)) {\n        selected = new OuterFaceCirculator(node, stop, dir);\n        break;\n      }\n    }\n  }\n  return selected;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  if (!predicate.test(start)) {\n    throw new IllegalArgumentException(\"Start node does not match start node\");\n  }\n  if (!predicate.test(stop)) {\n    throw new IllegalArgumentException(\"Stop node does not match stop node\");\n  }\n  Node prev = null;\n  outer:\n  while (true) {\n    for (Node node : getNodes(start, stop)) {\n      if (prev == null) {\n        prev = node;\n        continue;\n      }\n      if (prev.getDegree() == dir) {\n        if (prev.getOuterFace() == null || prev.getOuterFace().getState() != Node.State.OUTER) {\n          prev = node;\n          continue outer;\n        }\n      } else {\n        if (prev.getOuterFace() == null\n            || prev.getOuterFace().getState() != Node.State.OUTER_FACE) {\n          prev = node;\n          continue outer;\n        }\n      }\n    }\n    break;\n  }\n  return prev.getOuterFace();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  if (start == null || stop == null) {\n    return null;\n  }\n  OuterFaceCirculator outerFace = null;\n  if (start.equals(stop)) {\n    outerFace = start.getOuterFace();\n  } else {\n    if (dir == 0) {\n      outerFace = start.getOuterFace().getNeighbor(predicate);\n    } else {\n      outerFace = start.getOuterFace().getNeighbor(predicate.negate());\n    }\n  }\n  return outerFace;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  if (start == null || stop == null) return null;\n  OuterFaceCirculator outerFace = null;\n  if (dir == 0) outerFace = getOuterFace(start, stop);\n  else if (dir == 1) outerFace = getOuterFace(stop, start);\n  else if (dir == 2) outerFace = getOuterFace(start, stop);\n  if (outerFace == null) return null;\n  if (predicate.test(start) && predicate.test(stop)) return outerFace;\n  if (predicate.test(start) || predicate.test(stop)) return null;\n  if (predicate.test(start) && predicate.test(stop)) return outerFace;\n  if (predicate.test(start) && predicate.test(stop)) return outerFace;\n  if (predicate.test(start) && predicate.test(stop)) return outerFace;\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  for (Node node : start.getOuterFaces()) {\n    if (node.getOuterFace().getPredicate().equals(predicate)) {\n      if (node.getOuterFace().getDirection() == dir) {\n        return (OuterFaceCirculator) node.getOuterFace();\n      }\n    }\n  }\n  for (Node node : stop.getOuterFaces()) {\n    if (node.getOuterFace().getPredicate().equals(predicate)) {\n      if (node.getOuterFace().getDirection() == dir) {\n        return (OuterFaceCirculator) node.getOuterFace();\n      }\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(\n    Predicate<Node> predicate, Node start, Node stop, int dir) {\n  OuterFaceCirculator outerFaceCirculator = new OuterFaceCirculator();\n  outerFaceCirculator.predicate = predicate;\n  outerFaceCirculator.start = start;\n  outerFaceCirculator.stop = stop;\n  outerFaceCirculator.dir = dir;\n  if (start.equals(stop)) {\n    outerFaceCirculator.direction = OuterFaceCirculator.Direction.FRONT;\n    return outerFaceCirculator;\n  }\n  if (start.equals(stop.previous())) {\n    outerFaceCirculator.direction = OuterFaceCirculator.Direction.BACK;\n  } else {\n    Node n = stop.previous();\n    if (n.equals(start)) {\n      outerFaceCirculator.direction = OuterFaceCirculator.Direction.LEFT;\n    } else if (n.equals(stop)) {\n      outerFaceCirculator.direction = OuterFaceCirculator.Direction.RIGHT;\n    } else {\n      outerFaceCirculator.direction = OuterFaceCirculator.Direction.FRONT;\n    }\n  }\n  return outerFaceCirculator;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.\n * @param predicate the condition the desired node should satisfy\n * @param start the node to start the search from\n * @param stop the node to end the search with\n * @param dir the direction to start the traversal in\n * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node\n */\n", "method_name": "selectOnOuterFace", "codes": ["private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ ArrayList<Node> neighbors = new ArrayList<>(); neighbors.add(start); neighbors.add(stop); for (Node n : neighbors) { if (n.equals(start)) { continue; } if (n.equals(stop)) { continue; } if (n.isOuterFace()) { continue; } if (predicate.test(n)) { return new OuterFaceCirculator(n, dir); } } return null; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ OuterFaceCirculator found = null; for (int i = 0; i < outerFaces.size(); i++) { if (outerFaces.get(i).isSelected()) { if (found == null) { found = outerFaces.get(i); } else { if (predicate.test(start)) { if (!predicate.test(stop)) { if (!predicate.test(found.getOuterFace())) { found = outerFaces.get(i); } } } } } } return found; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ outerFaceCirculator = null; outerFaceCirculator = new OuterFaceCirculator(); outerFaceCirculator.setStart(start); outerFaceCirculator.setStop(stop); outerFaceCirculator.setDir(dir); outerFaceCirculator.setPredicate(predicate); outerFaceCirculator.setVisible(true); outerFaceCirculator.setSize(new Dimension(500, 500)); outerFaceCirculator.setCirculator(selectOnOuterFace(outerFaceCirculator)); return outerFaceCirculator; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ int[] indices = new int[2]; indices[0] = (dir == 0) ? 0 : 1; indices[1] = (dir == 0) ? 1 : 0; int i = 0; while (i < indices.length) { int j = indices[i]; if (j != 0) { if (predicate.test(start.getNode(j))) { return new OuterFaceCirculator(start.getNode(j), stop.getNode(j)); } } i++; } return null; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ OuterFaceCirculator selected = null; if (predicate.test(start)) { selected = new OuterFaceCirculator(start, stop, dir); } else if (predicate.test(stop)) { selected = new OuterFaceCirculator(stop, start, dir); } else { for (Node node : getNodes(start, stop)) { selected = new OuterFaceCirculator(node, stop, dir); if (predicate.test(node)) { selected = new OuterFaceCirculator(node, stop, dir); break; } } } return selected; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (!predicate.test(start)) { throw new IllegalArgumentException(\"Start node does not match start node\"); } if (!predicate.test(stop)) { throw new IllegalArgumentException(\"Stop node does not match stop node\"); } Node prev = null; outer: while (true) { for (Node node : getNodes(start, stop)) { if (prev == null) { prev = node; continue; } if (prev.getDegree() == dir) { if (prev.getOuterFace() == null || prev.getOuterFace().getState() != Node.State.OUTER) { prev = node; continue outer; } } else { if (prev.getOuterFace() == null || prev.getOuterFace().getState() != Node.State.OUTER_FACE) { prev = node; continue outer; } } } break; } return prev.getOuterFace(); }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (start == null || stop == null) { return null; } OuterFaceCirculator outerFace = null; if (start.equals(stop)) { outerFace = start.getOuterFace(); } else { if (dir == 0) { outerFace = start.getOuterFace().getNeighbor(predicate); } else { outerFace = start.getOuterFace().getNeighbor(predicate.negate()); } } return outerFace; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ if (start == null || stop == null) return null; OuterFaceCirculator outerFace = null; if (dir == 0) outerFace = getOuterFace(start, stop); else if (dir == 1) outerFace = getOuterFace(stop, start); else if (dir == 2) outerFace = getOuterFace(start, stop); if (outerFace == null) return null; if (predicate.test(start) && predicate.test(stop)) return outerFace; if (predicate.test(start) || predicate.test(stop)) return null; if (predicate.test(start) && predicate.test(stop)) return outerFace; if (predicate.test(start) && predicate.test(stop)) return outerFace; if (predicate.test(start) && predicate.test(stop)) return outerFace; return null; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ for (Node node : start.getOuterFaces()) { if (node.getOuterFace().getPredicate().equals(predicate)) { if (node.getOuterFace().getDirection() == dir) { return (OuterFaceCirculator) node.getOuterFace(); } } } for (Node node : stop.getOuterFaces()) { if (node.getOuterFace().getPredicate().equals(predicate)) { if (node.getOuterFace().getDirection() == dir) { return (OuterFaceCirculator) node.getOuterFace(); } } } return null; }", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){ OuterFaceCirculator outerFaceCirculator = new OuterFaceCirculator(); outerFaceCirculator.predicate = predicate; outerFaceCirculator.start = start; outerFaceCirculator.stop = stop; outerFaceCirculator.dir = dir; if (start.equals(stop)) { outerFaceCirculator.direction = OuterFaceCirculator.Direction.FRONT; return outerFaceCirculator; } if (start.equals(stop.previous())) { outerFaceCirculator.direction = OuterFaceCirculator.Direction.BACK; } else { Node n = stop.previous(); if (n.equals(start)) { outerFaceCirculator.direction = OuterFaceCirculator.Direction.LEFT; } else if (n.equals(stop)) { outerFaceCirculator.direction = OuterFaceCirculator.Direction.RIGHT; } else { outerFaceCirculator.direction = OuterFaceCirculator.Direction.FRONT; } } return outerFaceCirculator; }"], "code_level": "class_runnable", "_id": "636767511a6d9265ec017eb6", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "Edge edgeToNext() {\n  return next;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return edgeToNext;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  if (node == null) return null;\n  if (node == node.parent.left) return node.parent.right;\n  else return node.parent.left;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return edgeToNext;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return edgeToNext;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return new Edge(current.getId(), next.getId());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return edgeToNext;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return this.edgeToNext;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  return this.edgeToNext;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext() {\n  Edge e = next;\n  if (e != null) {\n    return e;\n  }\n  if (!isReversed) {\n    e = prev;\n    if (e != null) {\n      return e;\n    }\n  }\n  e = next;\n  if (e != null) {\n    return e;\n  }\n  e = prev;\n  if (e != null) {\n    return e;\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n", "method_name": "edgeToNext", "codes": ["Edge edgeToNext(){ return next; }", "Edge edgeToNext(){ return edgeToNext; }", "Edge edgeToNext(){ if (node == null) return null; if (node == node.parent.left) return node.parent.right; else return node.parent.left; }", "Edge edgeToNext(){ return edgeToNext; }", "Edge edgeToNext(){ return edgeToNext; }", "Edge edgeToNext(){ return new Edge(current.getId(), next.getId()); }", "Edge edgeToNext(){ return edgeToNext; }", "Edge edgeToNext(){ return this.edgeToNext; }", "Edge edgeToNext(){ return this.edgeToNext; }", "Edge edgeToNext(){ Edge e = next; if (e != null) { return e; } if (!isReversed) { e = prev; if (e != null) { return e; } } e = next; if (e != null) { return e; } e = prev; if (e != null) { return e; } return null; }"], "code_level": "class_runnable", "_id": "6367675d1a6d9265ec018082", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  List<V> vertices = graph.getVertices();\n  List<E> edges = graph.getEdges();\n  GraphPath<V, E> path = new GraphPath<V, E>();\n  path.setVertices(vertices);\n  path.setEdges(edges);\n  for (E e : tour) {\n    path.addVertex(e.getFrom());\n    path.addVertex(e.getTo());\n  }\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  if (tour.isEmpty()) {\n    return new GraphPath<V, E>(graph);\n  }\n  GraphPath<V, E> path = new GraphPath<V, E>(graph);\n  if (tour.size() == 1) {\n    path.addEdge(tour.iterator().next());\n  } else {\n    for (E e : tour) {\n      path.addEdge(e, graph.getEdgeTarget(e));\n    }\n  }\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  GraphPath<V, E> path = new GraphPath<V, E>();\n  for (E edge : tour) {\n    path.addEdge(graph.getEdgeSource(edge), graph.getEdgeTarget(edge), edge);\n  }\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  if (tour == null) {\n    return null;\n  }\n  GraphPath<V, E> path = new GraphPath<V, E>(graph);\n  for (E edge : tour) {\n    path.addEdge(edge);\n  }\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  GraphPath<V, E> path = new GraphPath<V, E>(graph);\n  path.addAll(tour);\n  return path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  Set<V> vertices = graph.vertices();\n  Set<V> verticesToRemove = new HashSet<V>();\n  for (V vertex : vertices) {\n    if (!tour.contains(vertex)) verticesToRemove.add(vertex);\n  }\n  vertices.removeAll(verticesToRemove);\n  Set<V> verticesToAdd = new HashSet<V>();\n  for (V vertex : vertices) {\n    verticesToAdd.add(vertex);\n  }\n  vertices.addAll(verticesToAdd);\n  Set<E> edges = graph.edges();\n  Set<E> edgesToRemove = new HashSet<E>();\n  for (E edge : edges) {\n    if (!tour.contains(edge)) edgesToRemove.add(edge);\n  }\n  edges.removeAll(edgesToRemove);\n  Set<E> edgesToAdd = new HashSet<E>();\n  for (E edge : edges) {\n    edgesToAdd.add(edge);\n  }\n  edges.addAll(edgesToAdd);\n  GraphPath<V, E> gp = new GraphPath<V, E>(vertices, edges);\n  return gp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  GraphPath<V, E> ret = new GraphPath<V, E>(graph);\n  for (E edge : tour) ret.addEdge(edge);\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  return new GraphPath<V, E>(tour);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph) {\n  List<GraphPath<V, E>> paths = new LinkedList<GraphPath<V, E>>();\n  GraphPath<V, E> path = null;\n  for (E edge : tour) {\n    V source = edge.getSource();\n    V dest = edge.getDestination();\n    V weight = edge.getWeight();\n    if (path == null) {\n      path = new GraphPath<V, E>(graph, source, dest, weight);\n    } else {\n      path.addEdge(source, dest, weight);\n    }\n  }\n  paths.add(path);\n  return paths.get(0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n", "method_name": "edgeSetToTour", "codes": ["protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ List<V> vertices = graph.getVertices(); List<E> edges = graph.getEdges(); GraphPath<V,E> path = new GraphPath<V, E>(); path.setVertices(vertices); path.setEdges(edges); for (E e : tour) { path.addVertex(e.getFrom()); path.addVertex(e.getTo()); } return path; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ if (tour.isEmpty()) { return new GraphPath<V,E>(graph); } GraphPath<V,E> path = new GraphPath<V,E>(graph); if (tour.size() == 1) { path.addEdge(tour.iterator().next()); } else { for (E e : tour) { path.addEdge(e, graph.getEdgeTarget(e)); } } return path; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ return null; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ GraphPath<V,E> path = new GraphPath<V, E>(); for (E edge : tour) { path.addEdge(graph.getEdgeSource(edge), graph.getEdgeTarget(edge), edge); } return path; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ if (tour == null) { return null; } GraphPath<V,E> path = new GraphPath<V, E>(graph); for (E edge : tour) { path.addEdge(edge); } return path; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ GraphPath<V,E> path = new GraphPath<V, E>(graph); path.addAll(tour); return path; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ Set<V> vertices = graph.vertices(); Set<V> verticesToRemove = new HashSet<V>(); for (V vertex : vertices) { if (!tour.contains(vertex)) verticesToRemove.add(vertex); } vertices.removeAll(verticesToRemove); Set<V> verticesToAdd = new HashSet<V>(); for (V vertex : vertices) { verticesToAdd.add(vertex); } vertices.addAll(verticesToAdd); Set<E> edges = graph.edges(); Set<E> edgesToRemove = new HashSet<E>(); for (E edge : edges) { if (!tour.contains(edge)) edgesToRemove.add(edge); } edges.removeAll(edgesToRemove); Set<E> edgesToAdd = new HashSet<E>(); for (E edge : edges) { edgesToAdd.add(edge); } edges.addAll(edgesToAdd); GraphPath<V,E> gp = new GraphPath<V, E>(vertices, edges); return gp; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ GraphPath<V,E> ret = new GraphPath<V, E>(graph); for (E edge : tour) ret.addEdge(edge); return ret; }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ return new GraphPath<V,E>(tour); }", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){ List<GraphPath<V,E>> paths = new LinkedList<GraphPath<V,E>>(); GraphPath<V,E> path = null; for (E edge : tour) { V source = edge.getSource(); V dest = edge.getDestination(); V weight = edge.getWeight(); if (path == null) { path = new GraphPath<V,E>(graph, source, dest, weight); } else { path.addEdge(source, dest, weight); } } paths.add(path); return paths.get(0); }"], "code_level": "class_runnable", "_id": "636767561a6d9265ec017f7c", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (Set<Integer> bucket : bucketsByLabel) {\n    bucket.clear();\n    for (Integer label : labels) {\n      bucket.add(label);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  if (labels.size() == 0) {\n    return;\n  }\n  if (minLabel == 0) {\n    for (int i = 0; i < bucketsByLabel.size(); i++) {\n      bucketsByLabel.get(i).clear();\n    }\n    return;\n  }\n  Set<Integer> bucket = bucketsByLabel.get(minLabel);\n  if (bucket == null) {\n    bucket = new HashSet<>();\n    bucketsByLabel.set(minLabel, bucket);\n  }\n  bucket.clear();\n  for (int i = 0; i < labels.size(); i++) {\n    bucket.add(labels.get(i));\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = 0; i < labels.size(); i++) {\n    int label = labels.get(i);\n    if (label > minLabel) {\n      bucketsByLabel.get(label).remove(i);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = 0; i < bucketsByLabel.size(); i++) {\n    if (bucketsByLabel.get(i).size() == 0) {\n      bucketsByLabel.remove(i);\n      i--;\n    }\n  }\n  for (int label : labels) {\n    if (bucketsByLabel.get(label).size() == 0) {\n      bucketsByLabel.remove(label);\n      labels.remove(label);\n    }\n  }\n  for (int i = 0; i < labels.size(); i++) {\n    int label = labels.get(i);\n    if (bucketsByLabel.get(label).size() > 0 && bucketsByLabel.get(label).size() <= minLabel) {\n      bucketsByLabel.get(label).remove(0);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  if (labels.size() == 0) return;\n  int minLabelIndex = 0;\n  for (int i = 0; i < labels.size(); i++) {\n    if (labels.get(i) < minLabel) {\n      minLabelIndex = i;\n      minLabel = labels.get(i);\n    }\n  }\n  bucketsByLabel.get(minLabelIndex).remove(labels.get(0));\n  labels.remove(0);\n  reload(bucketsByLabel, labels, minLabelIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  Set<Integer> bucket = bucketsByLabel.get(minLabel);\n  labels.removeAll(bucket);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (Set<Integer> bucket : bucketsByLabel) {\n    bucket.clear();\n  }\n  for (int label : labels) {\n    if (label < minLabel) {\n      bucketsByLabel.get(minLabel).add(label);\n    } else {\n      bucketsByLabel.get(label).add(minLabel);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int i = labels.size() - 1; i >= 0; i--) {\n    int label = labels.get(i);\n    if (bucketsByLabel.get(label).size() == 0) {\n      labels.remove(i);\n    } else {\n      labels.set(i, minLabel);\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int label : labels) {\n    if (!bucketsByLabel.get(label).isEmpty()) {\n      for (Set<Integer> bucket : bucketsByLabel.get(label)) {\n        if (bucket.size() == minLabel) {\n          bucket.remove(label);\n        }\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel) {\n  for (int label : labels) {\n    bucketsByLabel.get(label).remove(minLabel);\n  }\n  labels.clear();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Moves all vertices from the bucket with label  {@code minLabel} to the bucket with label 0.Clears the bucket with label  {@code minLabel}. Updates the labeling accordingly.\n * @param bucketsByLabel the buckets vertices are stored in\n * @param labels the labels of the vertices\n * @param minLabel the minimum value of the non-empty bucket\n */\n", "method_name": "reload", "codes": ["private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (Set<Integer> bucket : bucketsByLabel) { bucket.clear(); for (Integer label : labels) { bucket.add(label); } } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ if (labels.size() == 0) { return; } if (minLabel == 0) { for (int i = 0; i < bucketsByLabel.size(); i++) { bucketsByLabel.get(i).clear(); } return; } Set<Integer> bucket = bucketsByLabel.get(minLabel); if (bucket == null) { bucket = new HashSet<>(); bucketsByLabel.set(minLabel, bucket); } bucket.clear(); for (int i = 0; i < labels.size(); i++) { bucket.add(labels.get(i)); } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = 0; i < labels.size(); i++) { int label = labels.get(i); if (label > minLabel) { bucketsByLabel.get(label).remove(i); } } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = 0; i < bucketsByLabel.size(); i++) { if (bucketsByLabel.get(i).size() == 0) { bucketsByLabel.remove(i); i--; } } for (int label : labels) { if (bucketsByLabel.get(label).size() == 0) { bucketsByLabel.remove(label); labels.remove(label); } } for (int i = 0; i < labels.size(); i++) { int label = labels.get(i); if (bucketsByLabel.get(label).size() > 0 && bucketsByLabel.get(label).size() <= minLabel) { bucketsByLabel.get(label).remove(0); } } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ if (labels.size() == 0) return; int minLabelIndex = 0; for (int i = 0; i < labels.size(); i++) { if (labels.get(i) < minLabel) { minLabelIndex = i; minLabel = labels.get(i); } } bucketsByLabel.get(minLabelIndex).remove(labels.get(0)); labels.remove(0); reload(bucketsByLabel, labels, minLabelIndex); }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ Set<Integer> bucket = bucketsByLabel.get(minLabel); labels.removeAll(bucket); }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (Set<Integer> bucket : bucketsByLabel) { bucket.clear(); } for (int label : labels) { if (label < minLabel) { bucketsByLabel.get(minLabel).add(label); } else { bucketsByLabel.get(label).add(minLabel); } } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int i = labels.size() - 1; i >= 0; i--) { int label = labels.get(i); if (bucketsByLabel.get(label).size() == 0) { labels.remove(i); } else { labels.set(i, minLabel); } } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int label : labels) { if (!bucketsByLabel.get(label).isEmpty()) { for (Set<Integer> bucket : bucketsByLabel.get(label)) { if (bucket.size() == minLabel) { bucket.remove(label); } } } } }", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){ for (int label : labels) { bucketsByLabel.get(label).remove(minLabel); } labels.clear(); }"], "code_level": "self_contained", "_id": "636767641a6d9265ec018190", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "@Override\nprotected V provideNextVertex() {\n  while (!vertices.isEmpty()) {\n    if (vertices.peek().getVertexIndex() <= currentVertex) {\n      return vertices.poll();\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  return currentVertex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  if (!this.vertices.hasNext()) return null;\n  return this.vertices.next();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  if (iter.hasNext()) {\n    return iter.next();\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  while (this.hasNextVertex()) {\n    V vertex = this.nextVertex();\n    if (this.isVertexIncluded(vertex)) {\n      return vertex;\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  V vertex = null;\n  if (vertexIterator.hasNext()) {\n    vertex = vertexIterator.next();\n  } else {\n    vertex = null;\n  }\n  return vertex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  if (!hasNext()) {\n    throw new NoSuchElementException(\"Graph is empty\");\n  }\n  V v = currentVertex.getValue();\n  currentVertex = currentVertex.getNext();\n  return v;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  return graph.getVertex(vertexId++);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\nprotected V provideNextVertex() {\n  V vertex = null;\n  while (vertex == null) {\n    vertex = graph.getNextVertex();\n  }\n  return vertex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * {@inheritDoc}\n */\n", "method_name": "provideNextVertex", "codes": ["@Override protected V provideNextVertex(){ while (!vertices.isEmpty()) { if (vertices.peek().getVertexIndex() <= currentVertex) { return vertices.poll(); } } return null; }", "@Override protected V provideNextVertex(){ return null; }", "@Override protected V provideNextVertex(){ return currentVertex; }", "@Override protected V provideNextVertex(){ if (!this.vertices.hasNext()) return null; return this.vertices.next(); }", "@Override protected V provideNextVertex(){ if (iter.hasNext()) { return iter.next(); } else { return null; } }", "@Override protected V provideNextVertex(){ while (this.hasNextVertex()) { V vertex = this.nextVertex(); if (this.isVertexIncluded(vertex)) { return vertex; } } return null; }", "@Override protected V provideNextVertex(){ V vertex = null; if (vertexIterator.hasNext()) { vertex = vertexIterator.next(); } else { vertex = null; } return vertex; }", "@Override protected V provideNextVertex(){ if (!hasNext()) { throw new NoSuchElementException(\"Graph is empty\"); } V v = currentVertex.getValue(); currentVertex = currentVertex.getNext(); return v; }", "@Override protected V provideNextVertex(){ return graph.getVertex(vertexId++); }", "@Override protected V provideNextVertex(){ V vertex = null; while (vertex == null) { vertex = graph.getNextVertex(); } return vertex; }"], "code_level": "class_runnable", "_id": "636767611a6d9265ec018112", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> result = new ArrayList<>();\n  List<Pair<List<Pair<Integer, Integer>>, E>> allSeparators = new ArrayList<>();\n  for (List<Pair<Integer, Integer>> separatorList : this.globalSeparators) {\n    allSeparators.addAll(separatorList);\n  }\n  for (E edge : this.edges) {\n    int edgeIndex = edge.getIndex();\n    List<Pair<List<Pair<Integer, Integer>>, E>> separatorList = new ArrayList<>();\n    for (int i = 0; i < allSeparators.size(); i++) {\n      if (allSeparators.get(i).getFirst().contains(edgeIndex)) {\n        separatorList.add(allSeparators.get(i));\n      }\n    }\n    result.add(new Pair<>(separatorList, edge));\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> sepList =\n      new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n  for (int i = 0; i < graph.getEdgeCount(); i++) {\n    int v1 = graph.getEdgeSource(i);\n    int v2 = graph.getEdgeTarget(i);\n    if (!graph.getEdgeSource(i).equals(graph.getEdgeTarget(i))) {\n      sepList.add(\n          new Pair<List<Pair<Integer, Integer>>, E>(\n              graph.getNeighborList(v1), graph.getEdge(v1, v2)));\n    }\n  }\n  return sepList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> sepList =\n      new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n  for (E edge : this.graph.getEdges()) {\n    if (edge instanceof CircleE) {\n      CircleE circleE = (CircleE) edge;\n      for (Pair<List<Pair<Integer, Integer>>, E> pair : circleE.getSeparators()) {\n        if (!pair.getKey().isEmpty()) {\n          sepList.add(pair);\n        }\n      }\n    }\n  }\n  return sepList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> returnList = new ArrayList<>();\n  for (E e : this.getEdges()) {\n    if (!this.isEdgeCircle(e)) {\n      returnList.add(new Pair<>(this.getSeparatorList(e), e));\n    }\n  }\n  return returnList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> edgeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> nodeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> nodeSeparatorList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> edgeSeparatorList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> edgeSeparatorNodeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> nodeSeparatorNodeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> edgeSeparatorEdgeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); for (E edge : graph.edgeSet()) { if (graph.containsEdge(edge, source)) { edgeList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Integer>>(), edge)); } } for (E edge : graph.edgeSet()) { if (graph.containsEdge(edge, sink)) { edgeList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Integer>>(), edge)); } } for (Pair<List<Pair<Integer,Integer>>,E> pair : edgeList) { pair.getFirst().add(pair.getSecond()); } nodeList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Integer>>(), source)); nodeList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Integer>>(), sink)); for (Pair<List<Pair<Integer,Integer>>,E> pair : edgeList) { if (pair.getFirst().size() > 1) { nodeSeparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Int", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> result =\n      new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n  List<E> edges = graph.getEdges();\n  for (E edge : edges) {\n    if (edge instanceof CircleEdge) {\n      List<Pair<List<Pair<Integer, Integer>>, E>> list =\n          new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n      list.add(\n          new Pair<List<Pair<Integer, Integer>>, E>(\n              new ArrayList<Pair<Integer, Integer>>(), edge));\n      result.add(list);\n    } else {\n      List<Pair<List<Pair<Integer, Integer>>, E>> list = computeSeparatorList(edge);\n      result.add(list);\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> finalList =\n      new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n  for (E edge : this.graph.getEdges()) {\n    if (!(edge instanceof Circle)) {\n      Pair<List<Pair<Integer, Integer>>, E> pair = computeEdgeSeparatorList(edge);\n      if (!pair.getLeft().isEmpty()) {\n        finalList.add(pair);\n      }\n    }\n  }\n  return finalList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  if (isEdgeCircle()) {\n    return this.globalSeparatorList;\n  }\n  List<Pair<List<Pair<Integer, Integer>>, E>> result =\n      new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n  List<E> edges = this.edges;\n  for (int i = 0; i < edges.size(); i++) {\n    E edge = edges.get(i);\n    if (this.globalSeparatorList.size() < 2) {\n      result.add(new Pair<List<Pair<Integer, Integer>>, E>(this.globalSeparatorList, edge));\n    } else {\n      boolean foundSeparator = false;\n      for (int j = 1; j < this.globalSeparatorList.size(); j++) {\n        if (this.globalSeparatorList.get(j).getFirst().size()\n            > this.globalSeparatorList.get(j - 1).getFirst().size()) {\n          foundSeparator = true;\n          break;\n        }\n      }\n      if (foundSeparator) {\n        result.add(new Pair<List<Pair<Integer, Integer>>, E>(this.globalSeparatorList, edge));\n      } else {\n        for (int j = this.globalSeparatorList.size() - 2; j >= 0; j--) {\n          if (this.globalSeparatorList.get(j).getFirst().size()\n              > this.globalSeparatorList.get(j + 1).getFirst().size()) {\n            foundSeparator = true;\n            break;\n          }\n        }\n        if (foundSeparator) {\n          result.add(new Pair<List<Pair<Integer, Integer>>, E>(this.globalSeparatorList, edge));\n        }\n      }\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> finalList =\n      new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n  List<Pair<List<Pair<Integer, Integer>>, E>> edgeList =\n      new ArrayList<Pair<List<Pair<Integer, Integer>>, E>>();\n  for (E edge : this.graph.getEdges()) {\n    if (edge.getNeighbors().size() == 0) {\n      edgeList.add(\n          new Pair<List<Pair<Integer, Integer>>, E>(\n              new ArrayList<Pair<Integer, Integer>>(), edge));\n    } else {\n      for (Pair<Integer, Integer> pair : edge.getNeighbors()) {\n        if (!this.separators.containsKey(pair.getFirst())) {\n          this.separators.put(pair.getFirst(), new ArrayList<Integer>());\n        }\n        this.separators.get(pair.getFirst()).add(pair.getSecond());\n      }\n    }\n  }\n  for (Pair<List<Pair<Integer, Integer>>, E> pair : edgeList) {\n    finalList.add(pair);\n  }\n  return finalList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList() {\n  List<Pair<List<Pair<Integer, Integer>>, E>> globalSeparatorList = new ArrayList<>();\n  for (int i = 0; i < graph.getVertices().size(); i++) {\n    for (int j = i + 1; j < graph.getVertices().size(); j++) {\n      if (!graph.getVertices().get(i).isCircle() && !graph.getVertices().get(j).isCircle()) {\n        List<Pair<List<Pair<Integer, Integer>>, E>> temp = new ArrayList<>();\n        temp.add(\n            new Pair<>(\n                graph.getVertices().get(i).getSeparators(),\n                new Edge(graph.getVertices().get(i), graph.getVertices().get(j))));\n        temp.add(\n            new Pair<>(\n                graph.getVertices().get(j).getSeparators(),\n                new Edge(graph.getVertices().get(j), graph.getVertices().get(i))));\n        globalSeparatorList.add(temp);\n      }\n    }\n  }\n  return globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates\n * @return the list of minimal separators of every edge $e$ in the inspected graph\n */\n", "method_name": "computeGlobalSeparatorList", "codes": ["private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> result = new ArrayList<>(); List<Pair<List<Pair<Integer,Integer>>,E>> allSeparators = new ArrayList<>(); for (List<Pair<Integer, Integer>> separatorList : this.globalSeparators) { allSeparators.addAll(separatorList); } for (E edge : this.edges) { int edgeIndex = edge.getIndex(); List<Pair<List<Pair<Integer,Integer>>,E>> separatorList = new ArrayList<>(); for (int i = 0; i < allSeparators.size(); i++) { if (allSeparators.get(i).getFirst().contains(edgeIndex)) { separatorList.add(allSeparators.get(i)); } } result.add(new Pair<>(separatorList, edge)); } return result; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> sepList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); for (int i = 0; i < graph.getEdgeCount(); i++) { int v1 = graph.getEdgeSource(i); int v2 = graph.getEdgeTarget(i); if (!graph.getEdgeSource(i).equals(graph.getEdgeTarget(i))) { sepList.add(new Pair<List<Pair<Integer,Integer>>,E>(graph.getNeighborList(v1), graph.getEdge(v1, v2))); } } return sepList; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> sepList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); for (E edge : this.graph.getEdges()) { if (edge instanceof CircleE) { CircleE circleE = (CircleE) edge; for (Pair<List<Pair<Integer,Integer>>,E> pair : circleE.getSeparators()) { if (!pair.getKey().isEmpty()) { sepList.add(pair); } } } } return sepList; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> returnList = new ArrayList<>(); for (E e : this.getEdges()) { if (!this.isEdgeCircle(e)) { returnList.add(new Pair<>(this.getSeparatorList(e), e)); } } return returnList; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> edgeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> nodeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> nodeSeparatorList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> edgeSeparatorList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> edgeSeparatorNodeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> nodeSeparatorNodeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> edgeSeparatorEdgeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); for (E edge : graph.edgeSet()) { if (graph.containsEdge(edge, source)) { edgeList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Integer>>(), edge)); } } for (E edge : graph.edgeSet()) { if (graph.containsEdge(edge, sink)) { edgeList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Integer>>(), edge)); } } for (Pair<List<Pair<Integer,Integer>>,E> pair : edgeList) { pair.getFirst().add(pair.getSecond()); } nodeList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Integer>>(), source)); nodeList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Integer>>(), sink)); for (Pair<List<Pair<Integer,Integer>>,E> pair : edgeList) { if (pair.getFirst().size() > 1) { nodeSeparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Int", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> result = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<E> edges = graph.getEdges(); for (E edge : edges) { if (edge instanceof CircleEdge) { List<Pair<List<Pair<Integer,Integer>>,E>> list = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); list.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Integer>>(), edge)); result.add(list); } else { List<Pair<List<Pair<Integer,Integer>>,E>> list = computeSeparatorList(edge); result.add(list); } } return result; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> finalList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); for (E edge : this.graph.getEdges()) { if (!(edge instanceof Circle)) { Pair<List<Pair<Integer,Integer>>,E> pair = computeEdgeSeparatorList(edge); if (!pair.getLeft().isEmpty()) { finalList.add(pair); } } } return finalList; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ if (isEdgeCircle()) { return this.globalSeparatorList; } List<Pair<List<Pair<Integer,Integer>>,E>> result = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<E> edges = this.edges; for (int i = 0; i < edges.size(); i++) { E edge = edges.get(i); if (this.globalSeparatorList.size() < 2) { result.add(new Pair<List<Pair<Integer,Integer>>,E>(this.globalSeparatorList, edge)); } else { boolean foundSeparator = false; for (int j = 1; j < this.globalSeparatorList.size(); j++) { if (this.globalSeparatorList.get(j).getFirst().size() > this.globalSeparatorList.get(j - 1).getFirst().size()) { foundSeparator = true; break; } } if (foundSeparator) { result.add(new Pair<List<Pair<Integer,Integer>>,E>(this.globalSeparatorList, edge)); } else { for (int j = this.globalSeparatorList.size() - 2; j >= 0; j--) { if (this.globalSeparatorList.get(j).getFirst().size() > this.globalSeparatorList.get(j + 1).getFirst().size()) { foundSeparator = true; break; } } if (foundSeparator) { result.add(new Pair<List<Pair<Integer,Integer>>,E>(this.globalSeparatorList, edge)); } } } } return result; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> finalList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); List<Pair<List<Pair<Integer,Integer>>,E>> edgeList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>(); for (E edge : this.graph.getEdges()) { if (edge.getNeighbors().size() == 0) { edgeList.add(new Pair<List<Pair<Integer,Integer>>,E>(new ArrayList<Pair<Integer,Integer>>(), edge)); } else { for (Pair<Integer, Integer> pair : edge.getNeighbors()) { if (!this.separators.containsKey(pair.getFirst())) { this.separators.put(pair.getFirst(), new ArrayList<Integer>()); } this.separators.get(pair.getFirst()).add(pair.getSecond()); } } } for (Pair<List<Pair<Integer,Integer>>,E> pair : edgeList) { finalList.add(pair); } return finalList; }", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){ List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<>(); for (int i = 0; i < graph.getVertices().size(); i++) { for (int j = i + 1; j < graph.getVertices().size(); j++) { if (!graph.getVertices().get(i).isCircle() && !graph.getVertices().get(j).isCircle()) { List<Pair<List<Pair<Integer,Integer>>,E>> temp = new ArrayList<>(); temp.add(new Pair<>(graph.getVertices().get(i).getSeparators(), new Edge(graph.getVertices().get(i), graph.getVertices().get(j)))); temp.add(new Pair<>(graph.getVertices().get(j).getSeparators(), new Edge(graph.getVertices().get(j), graph.getVertices().get(i)))); globalSeparatorList.add(temp); } } } return globalSeparatorList; }"], "code_level": "class_runnable", "_id": "636767601a6d9265ec0180e2", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  long sum = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    sum += bounds.get(i);\n  }\n  List<Integer> suffixSum = new ArrayList<>();\n  for (int i = bounds.size() - 1; i >= 0; i--) {\n    suffixSum.add(bounds.get(i) + sum);\n  }\n  return Pair.of(suffixSum, sum);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  long sum = 0;\n  List<Integer> suffixSum = new ArrayList<>();\n  for (int i = 0; i < bounds.size() - 1; i++) {\n    int left = bounds.get(i);\n    int right = bounds.get(i + 1);\n    for (int j = i + 2; j < bounds.size(); j++) {\n      int k = bounds.get(j);\n      if (left + k > right) {\n        break;\n      }\n      sum += k - left;\n      suffixSum.add(left + k);\n    }\n  }\n  return new Pair<>(suffixSum, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  List<Integer> suffixSum = new ArrayList<Integer>();\n  long sum = 0;\n  for (int i = 0; i < bounds.size() - 1; i++) {\n    sum += bounds.get(i + 1);\n    suffixSum.add((int) sum);\n  }\n  suffixSum.add(bounds.get(bounds.size() - 1));\n  return new Pair<List<Integer>, Long>(suffixSum, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  long sum = 0;\n  for (Integer i : bounds) {\n    sum += i;\n  }\n  return Pair.of(bounds, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  List<Integer> suffixSum = new ArrayList<>();\n  long sum = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    suffixSum.add(bounds.get(i));\n    sum += bounds.get(i);\n  }\n  suffixSum.add(bounds.get(bounds.size() - 1));\n  return new Pair<>(suffixSum, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  List<Integer> suffixSum = new ArrayList<>();\n  long sum = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    sum += bounds.get(i);\n    suffixSum.add(i, sum);\n  }\n  return new Pair<>(suffixSum, sum);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  long sum = 0;\n  List<Integer> suffixSum = new ArrayList<>();\n  for (int i = bounds.size() - 1; i >= 0; i--) {\n    sum += bounds.get(i);\n    suffixSum.add(i, (int) sum);\n  }\n  return new Pair<>(suffixSum, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  List<Integer> suffixSum = new ArrayList<>();\n  long sum = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    int j = bounds.get(i);\n    if (j == bounds.get(i) - 1) {\n      suffixSum.add(j);\n    } else {\n      suffixSum.add(j - 1);\n    }\n    sum += j;\n  }\n  return new Pair<>(suffixSum, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  List<Integer> suffixSum = new ArrayList<>();\n  long sum = 0;\n  for (int i = 0; i < bounds.size(); i++) {\n    int j = i + 1;\n    while (j < bounds.size() && bounds.get(i) == bounds.get(j)) {\n      j++;\n    }\n    suffixSum.add(j - i);\n    sum += bounds.get(i) - bounds.get(j);\n  }\n  suffixSum.add(bounds.size() - 1);\n  return new Pair<>(suffixSum, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds) {\n  List<Integer> suffixSum = new ArrayList<>();\n  long sum = 0;\n  for (int i = bounds.size() - 1; i >= 0; i--) {\n    suffixSum.add(bounds.get(i));\n    sum += bounds.get(i);\n  }\n  return new Pair<>(suffixSum, sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.\n * @param bounds list of integers.\n * @return computed pair of suffix sum list and a sum of all elements.\n */\n", "method_name": "computeSuffixSum", "codes": ["private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ long sum = 0; for (int i = 0; i < bounds.size(); i++) { sum += bounds.get(i); } List<Integer> suffixSum = new ArrayList<>(); for (int i = bounds.size() - 1; i >= 0; i--) { suffixSum.add(bounds.get(i) + sum); } return Pair.of(suffixSum, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ long sum = 0; List<Integer> suffixSum = new ArrayList<>(); for (int i = 0; i < bounds.size() - 1; i++) { int left = bounds.get(i); int right = bounds.get(i + 1); for (int j = i + 2; j < bounds.size(); j++) { int k = bounds.get(j); if (left + k > right) { break; } sum += k - left; suffixSum.add(left + k); } } return new Pair<>(suffixSum, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ List<Integer> suffixSum = new ArrayList<Integer>(); long sum = 0; for (int i = 0; i < bounds.size() - 1; i++) { sum += bounds.get(i + 1); suffixSum.add((int) sum); } suffixSum.add(bounds.get(bounds.size() - 1)); return new Pair<List<Integer>, Long>(suffixSum, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ long sum = 0; for (Integer i : bounds) { sum += i; } return Pair.of(bounds, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ List<Integer> suffixSum = new ArrayList<>(); long sum = 0; for (int i = 0; i < bounds.size(); i++) { suffixSum.add(bounds.get(i)); sum += bounds.get(i); } suffixSum.add(bounds.get(bounds.size() - 1)); return new Pair<>(suffixSum, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ List<Integer> suffixSum = new ArrayList<>(); long sum = 0; for (int i = 0; i < bounds.size(); i++) { sum += bounds.get(i); suffixSum.add(i, sum); } return new Pair<>(suffixSum, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ long sum = 0; List<Integer> suffixSum = new ArrayList<>(); for (int i = bounds.size() - 1; i >= 0; i--) { sum += bounds.get(i); suffixSum.add(i, (int) sum); } return new Pair<>(suffixSum, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ List<Integer> suffixSum = new ArrayList<>(); long sum = 0; for (int i = 0; i < bounds.size(); i++) { int j = bounds.get(i); if (j == bounds.get(i) - 1) { suffixSum.add(j); } else { suffixSum.add(j - 1); } sum += j; } return new Pair<>(suffixSum, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ List<Integer> suffixSum = new ArrayList<>(); long sum = 0; for (int i = 0; i < bounds.size(); i++) { int j = i + 1; while (j < bounds.size() && bounds.get(i) == bounds.get(j)) { j++; } suffixSum.add(j - i); sum += bounds.get(i) - bounds.get(j); } suffixSum.add(bounds.size() - 1); return new Pair<>(suffixSum, sum); }", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){ List<Integer> suffixSum = new ArrayList<>(); long sum = 0; for (int i = bounds.size() - 1; i >= 0; i--) { suffixSum.add(bounds.get(i)); sum += bounds.get(i); } return new Pair<>(suffixSum, sum); }"], "code_level": "project_runnable", "_id": "636767461a6d9265ec017d0e", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  for (K key : keys) {\n    lowerBounds.add(computeLowerBound(key));\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<Integer>();\n  for (K key : keys) {\n    int lowerBound = 0;\n    for (int i = 0; i < keys.size(); i++) {\n      if (key.compareTo(keys.get(i)) > 0) {\n        lowerBound++;\n      }\n    }\n    lowerBounds.add(lowerBound);\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  for (int i = 0; i < keys.size(); i++) {\n    int lowerBound = Math.max(0, i - keyLength);\n    lowerBounds.add(lowerBound);\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  for (int i = 0; i < keys.size(); i++) {\n    int max = Integer.MIN_VALUE;\n    for (int j = 0; j < keys.size(); j++) {\n      if (j != i) {\n        if (keys.get(j).compareTo(keys.get(i)) > 0) {\n          max = Math.max(max, keys.get(j).compareTo(keys.get(i)));\n        }\n      }\n    }\n    lowerBounds.add(max);\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  if (keys.size() == 0) {\n    return lowerBounds;\n  }\n  int currentKey = keys.get(0);\n  for (int i = 1; i < keys.size(); i++) {\n    if (keys.get(i).compareTo(currentKey) < 0) {\n      currentKey = keys.get(i);\n    }\n  }\n  lowerBounds.add(currentKey);\n  for (int i = 1; i < keys.size(); i++) {\n    int currentKeyInList = keys.get(i);\n    if (currentKeyInList > currentKey) {\n      lowerBounds.add(currentKeyInList);\n    }\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  for (K key : keys) {\n    lowerBounds.add(computeLowerBound(key));\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> result = new ArrayList<>();\n  for (int i = 0; i < keys.size(); i++) {\n    int min = Integer.MAX_VALUE;\n    for (int j = i; j < keys.size(); j++) {\n      if (keys.get(j).compareTo(keys.get(i)) < 0) {\n        min =\n            keys.get(j).compareTo(keys.get(i)) < 0\n                ? keys.get(j).compareTo(keys.get(i))\n                : keys.get(i).compareTo(keys.get(j));\n      }\n    }\n    result.add(min);\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<>();\n  int i = 0;\n  while (i < keys.size()) {\n    int key = keys.get(i).getKey();\n    if (i + 1 < keys.size() && keys.get(i + 1).getKey() <= key) {\n      int nextKey = keys.get(i + 1).getKey();\n      lowerBounds.add(Math.max(key, nextKey));\n      i += 2;\n    } else {\n      lowerBounds.add(key);\n      i++;\n    }\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<Integer>(keys.size());\n  for (int i = 0; i < keys.size(); i++) {\n    lowerBounds.add(i);\n  }\n  return lowerBounds;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys) {\n  List<Integer> lowerBounds = new ArrayList<Integer>();\n  for (K key : keys) {\n    Integer lowerBound = getLowerBound(key);\n    if (lowerBound != null) {\n      lowerBounds.add(lowerBound);\n    }\n  }\n  return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n", "method_name": "computeLowerBounds", "codes": ["private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); for (K key : keys) { lowerBounds.add(computeLowerBound(key)); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<Integer>(); for (K key : keys) { int lowerBound = 0; for (int i = 0; i < keys.size(); i++) { if (key.compareTo(keys.get(i)) > 0) { lowerBound++; } } lowerBounds.add(lowerBound); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); for (int i = 0; i < keys.size(); i++) { int lowerBound = Math.max(0, i - keyLength); lowerBounds.add(lowerBound); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); for (int i = 0; i < keys.size(); i++) { int max = Integer.MIN_VALUE; for (int j = 0; j < keys.size(); j++) { if (j != i) { if (keys.get(j).compareTo(keys.get(i)) > 0) { max = Math.max(max, keys.get(j).compareTo(keys.get(i))); } } } lowerBounds.add(max); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); if (keys.size() == 0) { return lowerBounds; } int currentKey = keys.get(0); for (int i = 1; i < keys.size(); i++) { if (keys.get(i).compareTo(currentKey) < 0) { currentKey = keys.get(i); } } lowerBounds.add(currentKey); for (int i = 1; i < keys.size(); i++) { int currentKeyInList = keys.get(i); if (currentKeyInList > currentKey) { lowerBounds.add(currentKeyInList); } } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); for (K key : keys) { lowerBounds.add(computeLowerBound(key)); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> result = new ArrayList<>(); for (int i = 0; i < keys.size(); i++) { int min = Integer.MAX_VALUE; for (int j = i; j < keys.size(); j++) { if (keys.get(j).compareTo(keys.get(i)) < 0) { min = keys.get(j).compareTo(keys.get(i)) < 0 ? keys.get(j).compareTo(keys.get(i)) : keys.get(i).compareTo(keys.get(j)); } } result.add(min); } return result; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<>(); int i = 0; while (i < keys.size()) { int key = keys.get(i).getKey(); if (i + 1 < keys.size() && keys.get(i + 1).getKey() <= key) { int nextKey = keys.get(i + 1).getKey(); lowerBounds.add(Math.max(key, nextKey)); i += 2; } else { lowerBounds.add(key); i++; } } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<Integer>(keys.size()); for (int i = 0; i < keys.size(); i++) { lowerBounds.add(i); } return lowerBounds; }", "private List<Integer> computeLowerBounds(List<K> keys){ List<Integer> lowerBounds = new ArrayList<Integer>(); for (K key : keys) { Integer lowerBound = getLowerBound(key); if (lowerBound != null) { lowerBounds.add(lowerBound); } } return lowerBounds; }"], "code_level": "class_runnable", "_id": "636767431a6d9265ec017c88", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<Integer>();\n  for (int i = 0; i < keys.size(); i++) {\n    upperBounds.add(i);\n  }\n  Collections.sort(\n      upperBounds,\n      new Comparator<Integer>() {\n        @Override\n        public int compare(Integer o1, Integer o2) {\n          int l = o2 - o1;\n          if (l == 0) {\n            return 0;\n          } else if (l < 0) {\n            return -1;\n          } else {\n            return 1;\n          }\n        }\n      });\n  return upperBounds;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>();\n  for (K key : keys) {\n    upperBounds.add(computeUpperBound(key));\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>();\n  for (K key : keys) {\n    int upperBound = this.computeUpperBound(key);\n    upperBounds.add(upperBound);\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>();\n  int min = Integer.MAX_VALUE;\n  for (K key : keys) {\n    min = Math.min(min, key.getKey());\n    upperBounds.add(min);\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>();\n  for (int i = 0; i < keys.size(); i++) {\n    int upperBound = 0;\n    for (int j = i + 1; j < keys.size(); j++) {\n      upperBound += keys.get(j).getKey() - keys.get(i).getKey();\n    }\n    upperBounds.add(upperBound);\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<Integer>();\n  for (int i = 0; i < keys.size(); i++) {\n    upperBounds.add(Integer.MAX_VALUE);\n  }\n  for (int i = 0; i < keys.size(); i++) {\n    for (int j = 0; j < keys.size(); j++) {\n      if (j != i && keys.get(i).compareTo(keys.get(j)) == 1) {\n        upperBounds.set(i, Math.min(upperBounds.get(i), upperBounds.get(j)));\n      }\n    }\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>();\n  for (int i = 0; i < keys.size(); i++) {\n    int upperBound = i + 1;\n    for (int j = i + 1; j < keys.size(); j++) {\n      upperBounds.add(upperBound);\n    }\n  }\n  return upperBounds;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>();\n  for (K key : keys) {\n    upperBounds.add(key.getUpperBound());\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>();\n  for (K key : keys) {\n    upperBounds.add(calculateUpperBound(key));\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys) {\n  List<Integer> upperBounds = new ArrayList<>();\n  for (K key : keys) {\n    upperBounds.add(key.getLowerBound());\n  }\n  return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n", "method_name": "computeUpperBounds", "codes": ["private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<Integer>(); for (int i = 0; i < keys.size(); i++) { upperBounds.add(i); } Collections.sort(upperBounds, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { int l = o2 - o1; if (l == 0) { return 0; } else if (l < 0) { return -1; } else { return 1; } } }); return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(); for (K key : keys) { upperBounds.add(computeUpperBound(key)); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(); for (K key : keys) { int upperBound = this.computeUpperBound(key); upperBounds.add(upperBound); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(); int min = Integer.MAX_VALUE; for (K key : keys) { min = Math.min(min, key.getKey()); upperBounds.add(min); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(); for (int i = 0; i < keys.size(); i++) { int upperBound = 0; for (int j = i + 1; j < keys.size(); j++) { upperBound += keys.get(j).getKey() - keys.get(i).getKey(); } upperBounds.add(upperBound); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<Integer>(); for (int i = 0; i < keys.size(); i++) { upperBounds.add(Integer.MAX_VALUE); } for (int i = 0; i < keys.size(); i++) { for (int j = 0; j < keys.size(); j++) { if (j != i && keys.get(i).compareTo(keys.get(j)) == 1) { upperBounds.set(i, Math.min(upperBounds.get(i), upperBounds.get(j))); } } } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(); for (int i = 0; i < keys.size(); i++) { int upperBound = i + 1; for (int j = i + 1; j < keys.size(); j++) { upperBounds.add(upperBound); } } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(); for (K key : keys) { upperBounds.add(key.getUpperBound()); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(); for (K key : keys) { upperBounds.add(calculateUpperBound(key)); } return upperBounds; }", "private List<Integer> computeUpperBounds(List<K> keys){ List<Integer> upperBounds = new ArrayList<>(); for (K key : keys) { upperBounds.add(key.getLowerBound()); } return upperBounds; }"], "code_level": "class_runnable", "_id": "636767581a6d9265ec017fb4", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (graph == null || vertices == null) return false;\n  for (V v : vertices) {\n    if (!graph.containsVertex(v)) return false;\n  }\n  if (graph.size() != vertices.size()) return false;\n  return isClique(graph.getVertices(), vertices);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  boolean[][] adjacencyMatrix =\n      new boolean[graph.getVertices().size()][graph.getVertices().size()];\n  for (V vertex : vertices) {\n    adjacencyMatrix[vertex.intValue()][vertex.intValue()] = true;\n    adjacencyMatrix[vertex.intValue()][vertex.intValue()] = true;\n  }\n  Set<V> vertexSet = new HashSet<V>(vertices);\n  for (V vertex : vertexSet) {\n    for (V vertex2 : vertexSet) {\n      if (adjacencyMatrix[vertex.intValue()][vertex2.intValue()]\n          && adjacencyMatrix[vertex2.intValue()][vertex.intValue()]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (vertices.size() == 1) {\n    return true;\n  }\n  if (vertices.size() == 2) {\n    return graph.getEdge(vertices.iterator().next(), vertices.iterator().next()).isDirected();\n  }\n  Set<V> vertices1 = new HashSet<>();\n  for (V v : vertices) {\n    vertices1.add(v);\n  }\n  boolean[] visited = new boolean[vertices.size()];\n  for (int i = 0; i < visited.length; i++) {\n    visited[i] = false;\n  }\n  for (V v : vertices) {\n    if (!visited[v.id()]) {\n      if (isClique(graph, vertices1, v)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (graph.vertexSet().size() == 0) {\n    return true;\n  }\n  if (graph.vertexSet().size() != vertices.size()) {\n    return false;\n  }\n  Map<V, Set<V>> adjList = graph.adjacencyListOf(vertices);\n  for (V vertex : vertices) {\n    if (adjList.get(vertex).size() == 0) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  Set<V> verticesClique = new HashSet<>();\n  for (V vertex : vertices) {\n    if (!graph.hasEdge(vertex, null)) {\n      return false;\n    }\n    verticesClique.add(vertex);\n  }\n  return verticesClique.size() == graph.getVertexCount();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (graph == null || graph.getVertices().size() == 0) return false;\n  boolean[] visited = new boolean[graph.getVertices().size()];\n  boolean[] processed = new boolean[graph.getVertices().size()];\n  Arrays.fill(visited, false);\n  Arrays.fill(processed, false);\n  for (V v : vertices) {\n    if (!processed[v.hashCode()]) {\n      if (!dfs(graph, visited, processed, v)) return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (vertices.size() < 2) {\n    return false;\n  }\n  if (vertices.size() == 2) {\n    return graph.getEdges().size() == 1\n        && graph.getEdges().iterator().next().getLabel().equals(\"v\");\n  }\n  Set<V> visited = new HashSet<>();\n  Set<V> processed = new HashSet<>();\n  for (V v : vertices) {\n    if (!visited.contains(v)) {\n      if (!processed.contains(v)) {\n        boolean isClique = isClique(graph, v, visited, processed);\n        if (isClique) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (vertices.size() == 0) return true;\n  Set<V> verticesToAdd = new HashSet<>(vertices);\n  for (V vertex : vertices) {\n    if (verticesToAdd.contains(vertex)) continue;\n    if (graph.vertices().contains(vertex)) {\n      for (E edge : graph.edgesOf(vertex)) {\n        if (graph.outgoingEdgesOf(edge.to()).isEmpty()) return false;\n      }\n    }\n    verticesToAdd.remove(vertex);\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  Set<V> visited = new HashSet<>();\n  if (vertices.size() == graph.vertices().size()) {\n    return true;\n  }\n  if (vertices.size() == 1) {\n    return false;\n  }\n  if (graph.vertices().containsAll(vertices)) {\n    return true;\n  }\n  Queue<V> queue = new LinkedList<>(vertices);\n  while (!queue.isEmpty()) {\n    V v = queue.poll();\n    if (visited.contains(v)) {\n      continue;\n    }\n    visited.add(v);\n    for (V w : graph.adj(v)) {\n      if (!visited.contains(w)) {\n        queue.offer(w);\n      }\n    }\n  }\n  return queue.isEmpty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices) {\n  if (vertices.isEmpty()) return false;\n  if (vertices.size() == 1) return true;\n  if (graph.getNumVertices() == 1) return false;\n  for (V v : vertices) {\n    if (!graph.isVisited(v)) {\n      if (!isClique(graph.getIncidentEdges(v), vertices)) return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n", "method_name": "isClique", "codes": ["private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (graph == null || vertices == null) return false; for (V v : vertices) { if (!graph.containsVertex(v)) return false; } if (graph.size() != vertices.size()) return false; return isClique(graph.getVertices(), vertices); }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ boolean[][] adjacencyMatrix = new boolean[graph.getVertices().size()][graph.getVertices().size()]; for (V vertex : vertices) { adjacencyMatrix[vertex.intValue()][vertex.intValue()] = true; adjacencyMatrix[vertex.intValue()][vertex.intValue()] = true; } Set<V> vertexSet = new HashSet<V>(vertices); for (V vertex : vertexSet) { for (V vertex2 : vertexSet) { if (adjacencyMatrix[vertex.intValue()][vertex2.intValue()] && adjacencyMatrix[vertex2.intValue()][vertex.intValue()]) { return false; } } } return true; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (vertices.size() == 1) { return true; } if (vertices.size() == 2) { return graph.getEdge(vertices.iterator().next(), vertices.iterator().next()).isDirected(); } Set<V> vertices1 = new HashSet<>(); for (V v : vertices) { vertices1.add(v); } boolean[] visited = new boolean[vertices.size()]; for (int i = 0; i < visited.length; i++) { visited[i] = false; } for (V v : vertices) { if (!visited[v.id()]) { if (isClique(graph, vertices1, v)) { return true; } } } return false; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (graph.vertexSet().size() == 0) { return true; } if (graph.vertexSet().size() != vertices.size()) { return false; } Map<V, Set<V>> adjList = graph.adjacencyListOf(vertices); for (V vertex : vertices) { if (adjList.get(vertex).size() == 0) { return false; } } return true; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ Set<V> verticesClique = new HashSet<>(); for (V vertex : vertices) { if (!graph.hasEdge(vertex, null)) { return false; } verticesClique.add(vertex); } return verticesClique.size() == graph.getVertexCount(); }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (graph == null || graph.getVertices().size() == 0) return false; boolean[] visited = new boolean[graph.getVertices().size()]; boolean[] processed = new boolean[graph.getVertices().size()]; Arrays.fill(visited, false); Arrays.fill(processed, false); for (V v : vertices) { if (!processed[v.hashCode()]) { if (!dfs(graph, visited, processed, v)) return false; } } return true; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (vertices.size() < 2) { return false; } if (vertices.size() == 2) { return graph.getEdges().size() == 1 && graph.getEdges().iterator().next().getLabel().equals(\"v\"); } Set<V> visited = new HashSet<>(); Set<V> processed = new HashSet<>(); for (V v : vertices) { if (!visited.contains(v)) { if (!processed.contains(v)) { boolean isClique = isClique(graph, v, visited, processed); if (isClique) { return true; } } } } return false; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (vertices.size() == 0) return true; Set<V> verticesToAdd = new HashSet<>(vertices); for (V vertex : vertices) { if (verticesToAdd.contains(vertex)) continue; if (graph.vertices().contains(vertex)) { for (E edge : graph.edgesOf(vertex)) { if (graph.outgoingEdgesOf(edge.to()).isEmpty()) return false; } } verticesToAdd.remove(vertex); } return true; }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ Set<V> visited = new HashSet<>(); if (vertices.size() == graph.vertices().size()) { return true; } if (vertices.size() == 1) { return false; } if (graph.vertices().containsAll(vertices)) { return true; } Queue<V> queue = new LinkedList<>(vertices); while (!queue.isEmpty()) { V v = queue.poll(); if (visited.contains(v)) { continue; } visited.add(v); for (V w : graph.adj(v)) { if (!visited.contains(w)) { queue.offer(w); } } } return queue.isEmpty(); }", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){ if (vertices.isEmpty()) return false; if (vertices.size() == 1) return true; if (graph.getNumVertices() == 1) return false; for (V v : vertices) { if (!graph.isVisited(v)) { if (!isClique(graph.getIncidentEdges(v), vertices)) return false; } } return true; }"], "code_level": "class_runnable", "_id": "6367675f1a6d9265ec0180cf", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "public int nonZeros(int row) {\n  int n = 0;\n  for (int j = 0; j < this.columns; j++) {\n    if (this.matrix[row][j] != 0) n++;\n  }\n  return n;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int count = 0;\n  for (int i = 0; i < size; i++) {\n    if (matrix[row][i] != 0) count++;\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  return nonZeros[row];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int count = 0;\n  for (int i = 0; i < numRows; i++) {\n    if (matrix[row][i] != 0) count++;\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int num = 0;\n  for (int i = 0; i < n; i++) {\n    if (rows[row][i] == 0) num++;\n  }\n  return num;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  return m_rows[row].nonZeros();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int n = 0;\n  for (int i = 0; i < nRows; i++) {\n    if (((bits[i] >> row) & 1) == 1) {\n      n++;\n    }\n  }\n  return n;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  if (row < 0 || row >= rows) {\n    throw new IllegalArgumentException(\"row \" + row + \" is not in range [0,\" + rows + \")\");\n  }\n  int count = 0;\n  for (int col = 0; col < columns; col++) {\n    if (!isZero(row, col)) {\n      count++;\n    }\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int cnt = 0;\n  for (int j = 0; j < N; j++) {\n    if (data[row][j] != 0) cnt++;\n  }\n  return cnt;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row) {\n  int count = 0;\n  for (int col = 0; col < columns; col++) {\n    if (data[row][col] == 0) {\n      count++;\n    }\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Get the number of non-zero entries of a row.\n * @param row the row\n * @return the number of non-zero entries of a row\n */\n", "method_name": "nonZeros", "codes": ["public int nonZeros(int row){ int n = 0; for (int j = 0; j < this.columns; j++) { if (this.matrix[row][j] != 0) n++; } return n; }", "public int nonZeros(int row){ int count = 0; for (int i = 0; i < size; i++) { if (matrix[row][i] != 0) count++; } return count; }", "public int nonZeros(int row){ return nonZeros[row]; }", "public int nonZeros(int row){ int count = 0; for (int i = 0; i < numRows; i++) { if (matrix[row][i] != 0) count++; } return count; }", "public int nonZeros(int row){ int num = 0; for (int i = 0; i < n; i++) { if (rows[row][i] == 0) num++; } return num; }", "public int nonZeros(int row){ return m_rows[row].nonZeros(); }", "public int nonZeros(int row){ int n = 0; for (int i = 0; i < nRows; i++) { if (((bits[i] >> row) & 1) == 1) { n++; } } return n; }", "public int nonZeros(int row){ if (row < 0 || row >= rows) { throw new IllegalArgumentException(\"row \" + row + \" is not in range [0,\" + rows + \")\"); } int count = 0; for (int col = 0; col < columns; col++) { if (!isZero(row, col)) { count++; } } return count; }", "public int nonZeros(int row){ int cnt = 0; for (int j = 0; j < N; j++) { if (data[row][j] != 0) cnt++; } return cnt; }", "public int nonZeros(int row){ int count = 0; for (int col = 0; col < columns; col++) { if (data[row][col] == 0) { count++; } } return count; }"], "code_level": "class_runnable", "_id": "636767511a6d9265ec017eb0", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private String unescapeId(String input) {\n  return input.replace('.', '_').replace('-', '_');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  return input.replace(\".\", \"\").replace(\":\", \"\").replace(\"\\\\\", \"\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  if (input == null) {\n    return null;\n  }\n  if (input.indexOf('.') < 0) {\n    return input;\n  }\n  StringBuffer result = new StringBuffer();\n  char[] chars = input.toCharArray();\n  int i = 0;\n  int length = chars.length;\n  while (i < length) {\n    char c = chars[i];\n    if (c == '.') {\n      if (i + 1 < length && chars[i + 1] == '.') {\n        result.append('.');\n        i++;\n      } else {\n        result.append('.');\n      }\n    } else {\n      result.append(c);\n      i++;\n    }\n  }\n  return result.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  int index = 0;\n  int length = input.length();\n  StringBuffer output = new StringBuffer(length);\n  while (index < length) {\n    int c = input.charAt(index);\n    if (c == '.') {\n      output.append('.');\n      index++;\n    } else if (c == '_') {\n      output.append('_');\n      index++;\n    } else if (c == ':') {\n      output.append(':');\n      index++;\n    } else if (c == '-') {\n      output.append('-');\n      index++;\n    } else if (c == '+') {\n      output.append('+');\n      index++;\n    } else {\n      output.append(c);\n      index++;\n    }\n  }\n  return output.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  StringBuffer output = new StringBuffer();\n  for (int i = 0; i < input.length(); i++) {\n    char c = input.charAt(i);\n    if (c == '.') {\n      output.append('\\\\');\n    }\n    output.append(c);\n  }\n  return output.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  StringBuffer sb = new StringBuffer();\n  char[] chars = input.toCharArray();\n  int i = 0;\n  while (i < chars.length) {\n    char c = chars[i];\n    if (c == '.') {\n      sb.append('.');\n      i++;\n    } else if (c == '-') {\n      sb.append('-');\n      i++;\n    } else if (c == '_') {\n      sb.append('_');\n      i++;\n    } else {\n      sb.append(c);\n      i++;\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  if (input == null || input.length() == 0) {\n    return null;\n  }\n  StringBuilder sb = new StringBuilder();\n  int len = input.length();\n  for (int i = 0; i < len; i++) {\n    char c = input.charAt(i);\n    if (c == '.') {\n      sb.append('.');\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  if (input.indexOf('.') == -1) return input;\n  StringBuilder result = new StringBuilder();\n  int start = 0;\n  int idx = -1;\n  while ((idx = input.indexOf('.', start)) != -1) {\n    if (idx == 0) {\n      result.append(input.substring(start, idx));\n      start = idx + 1;\n    } else if (idx == 1) {\n      result.append(input.substring(start, idx));\n      start = idx + 1;\n    } else if (idx == 2) {\n      result.append(input.substring(start, idx));\n      start = idx + 1;\n    } else if (idx == 3) {\n      result.append(input.substring(start, idx));\n      start = idx + 1;\n    }\n  }\n  result.append(input.substring(start, idx));\n  return result.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  if (input.equals(\"_\")) {\n    return input;\n  } else {\n    return \"_\" + input;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input) {\n  int pos = input.indexOf('.');\n  if (pos == -1) {\n    return input;\n  } else {\n    StringBuffer sb = new StringBuffer();\n    int len = input.length();\n    for (int i = 0; i < len; i++) {\n      char c = input.charAt(i);\n      if (c == '.') {\n        if (i + 1 < len && input.charAt(i + 1) == '.') {\n          sb.append('.');\n          i++;\n        } else {\n          sb.append(c);\n        }\n      } else {\n        sb.append(c);\n      }\n    }\n    return sb.toString();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n", "method_name": "unescapeId", "codes": ["private String unescapeId(String input){ return input.replace('.', '_').replace('-', '_'); }", "private String unescapeId(String input){ return input.replace(\".\", \"\").replace(\":\", \"\").replace(\"\\\\\", \"\"); }", "private String unescapeId(String input){ if (input == null) { return null; } if (input.indexOf('.') < 0) { return input; } StringBuffer result = new StringBuffer(); char[] chars = input.toCharArray(); int i = 0; int length = chars.length; while (i < length) { char c = chars[i]; if (c == '.') { if (i + 1 < length && chars[i + 1] == '.') { result.append('.'); i++; } else { result.append('.'); } } else { result.append(c); i++; } } return result.toString(); }", "private String unescapeId(String input){ int index = 0; int length = input.length(); StringBuffer output = new StringBuffer(length); while (index < length) { int c = input.charAt(index); if (c == '.') { output.append('.'); index++; } else if (c == '_') { output.append('_'); index++; } else if (c == ':') { output.append(':'); index++; } else if (c == '-') { output.append('-'); index++; } else if (c == '+') { output.append('+'); index++; } else { output.append(c); index++; } } return output.toString(); }", "private String unescapeId(String input){ StringBuffer output = new StringBuffer(); for (int i = 0; i < input.length(); i++) { char c = input.charAt(i); if (c == '.') { output.append('\\\\'); } output.append(c); } return output.toString(); }", "private String unescapeId(String input){ StringBuffer sb = new StringBuffer(); char[] chars = input.toCharArray(); int i = 0; while (i < chars.length) { char c = chars[i]; if (c == '.') { sb.append('.'); i++; } else if (c == '-') { sb.append('-'); i++; } else if (c == '_') { sb.append('_'); i++; } else { sb.append(c); i++; } } return sb.toString(); }", "private String unescapeId(String input){ if (input == null || input.length() == 0) { return null; } StringBuilder sb = new StringBuilder(); int len = input.length(); for (int i = 0; i < len; i++) { char c = input.charAt(i); if (c == '.') { sb.append('.'); } else { sb.append(c); } } return sb.toString(); }", "private String unescapeId(String input){ if (input.indexOf('.') == -1) return input; StringBuilder result = new StringBuilder(); int start = 0; int idx = -1; while ((idx = input.indexOf('.', start)) != -1) { if (idx == 0) { result.append(input.substring(start, idx)); start = idx + 1; } else if (idx == 1) { result.append(input.substring(start, idx)); start = idx + 1; } else if (idx == 2) { result.append(input.substring(start, idx)); start = idx + 1; } else if (idx == 3) { result.append(input.substring(start, idx)); start = idx + 1; } } result.append(input.substring(start, idx)); return result.toString(); }", "private String unescapeId(String input){ if (input.equals(\"_\")) { return input; } else { return \"_\" + input; } }", "private String unescapeId(String input){ int pos = input.indexOf('.'); if (pos == -1) { return input; } else { StringBuffer sb = new StringBuffer(); int len = input.length(); for (int i = 0; i < len; i++) { char c = input.charAt(i); if (c == '.') { if (i + 1 < len && input.charAt(i + 1) == '.') { sb.append('.'); i++; } else { sb.append(c); } } else { sb.append(c); } } return sb.toString(); } }"], "code_level": "class_runnable", "_id": "636767461a6d9265ec017d17", "project_name": "jgrapht-master"}, {"generate_results": [{"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  if (i == 0) {\n    return i;\n  }\n  int b = bb.get(i - 1);\n  if (b < 0x80) {\n    sb.append((char) b);\n    i--;\n    return decodeOctets(i, bb, sb);\n  }\n  if (i == bb.limit()) {\n    return i;\n  }\n  if (i == bb.position()) {\n    return i;\n  }\n  sb.append((char) (((b & 0x7f) << 6) | (bb.get(i) & 0x3f)));\n  i++;\n  return decodeOctets(i, bb, sb);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ byte c = bb.get(); if (c == 0) { sb.append(' '); return i; } if (c == '\\n') { sb.append('\\n'); return i; } if (c == '\\r') { sb.append('\\r'); return i; } if (c == '\\t') { sb.append('\\t'); return i; } if (c == '\\f') { sb.append('\\f'); return i; } if (c == '\\b') { sb.append('\\b'); return i; } if (c == '\\\\') { sb.append('\\\\'); return i; } if (c == '\\\"') { sb.append('\"'); return i; } if (c == '/') { sb.append('/'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int byteChars = bb.remaining(); if (byteChars == 0) { sb.append((char) i); return i; } int chars = i; int chars2 = 0; int chars3 = 0; chars2 = bb.get() & 0xFF; chars3 = bb.get() & 0xFF; if (chars2 == -1 && chars3 == -1) { sb.append((char) i); return i; } chars3 = chars3 << 8; chars2 = chars2 << 8; chars2 = chars2 | chars3; chars2 = bb.get() & 0xFF; if (chars2 == -1) { sb.append((char) i); chars3 = chars3 + 1; chars2 = chars2 + 1; } if (chars2 > 0) { sb.append((char) i); chars3 = chars3 + 1; chars2 = chars2 + 1; } if (chars2 == 0 && chars3 == 0) { sb.append((char) i); return i; } chars3 = chars3 << 8; chars2 = chars2 << 8; chars2 = chars2 | chars3; chars2 = bb.get() & 0xFF; if (chars2 == -1) { sb.append((char) i); chars3 = chars3 + 2; chars2 = chars2 + 2; } if (chars2 > 0) { sb.append((char) i); chars3 = chars3 + 2; chars2 = chars2 + 2; } if (chars2 == 0 && chars3 == 0) { sb.append((char) i); return i; } chars3 = chars3 << 8; chars2 = chars2 << 8; chars2 = chars2 | chars3; chars2 = bb.get() & 0xFF; if (chars2 == -1) { sb.append((char) i); chars3 = chars3 + 3; chars2 = chars2 + 3; } if (chars2 > 0) { sb.append((char) i); chars3 = chars3 + 3; chars2 = chars2 + 3; } if (chars2 == 0 && chars3 == 0) { sb.append((char) i); return i; } chars3 = chars3 << 8; chars2 = chars2 << 8; chars2 = chars2 | chars3; chars2 = bb.get() & 0xFF; if (chars2 == -1) { sb.append((char) i); chars3 = chars3 + 4; chars2 = chars2 + 4; } if (chars2 > 0) { sb.append((char) i); chars3 = chars3 + 4; chars2 = chars2 + 4; } if (chars2 == 0 && chars3 == 0) { sb.append((char) i); return i; } chars3 = chars3 <<", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  int j = bb.position();\n  bb.position(i + 1);\n  if (bb.remaining() >= 2) {\n    char c = (char) (bb.get() & 0xFF);\n    sb.append(c);\n  }\n  if (bb.remaining() >= 1) {\n    char c = (char) (bb.get() & 0xFF);\n    sb.append(c);\n  }\n  bb.position(j);\n  return i + 2;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  int octet = bb.get(i);\n  while ((octet & 0x80) != 0) {\n    sb.append((char) octet);\n    octet = bb.get(++i);\n  }\n  sb.append((char) octet);\n  return i + 1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  if (i == -1) {\n    i = bb.remaining();\n  }\n  if (i == 0) {\n    return i;\n  }\n  int octet = bb.get() & 0xFF;\n  if (i > bb.remaining()) {\n    return -1;\n  }\n  sb.append((char) octet);\n  i--;\n  return i;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  int charIndex = 0;\n  if (i < 0) {\n    i = i + 256;\n  }\n  byte byteValue = (byte) i;\n  sb.append((char) byteValue);\n  if (byteValue >= 0 && byteValue <= 9) {\n    sb.append((char) (byteValue + '0'));\n  } else if (byteValue >= 10 && byteValue <= 15) {\n    sb.append((char) (byteValue - 10 + 'a'));\n  } else if (byteValue >= 16 && byteValue <= 26) {\n    sb.append((char) (byteValue - 16 + 'A'));\n  } else {\n    sb.append('.');\n  }\n  charIndex = sb.length();\n  return charIndex;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  if (bb.hasArray()) {\n    byte[] ba = bb.array();\n    if (bb.hasArrayOffset()) {\n      int offset = bb.arrayOffset();\n      int pos = bb.position();\n      sb.append(new String(ba, offset + pos, bb.remaining(), UTF8));\n      bb.position(offset + pos + ba.length);\n      return i;\n    }\n    sb.append(new String(ba, 0, bb.remaining(), UTF8));\n    bb.position(bb.position() + bb.remaining());\n    return i;\n  }\n  byte[] ba = new byte[bb.remaining()];\n  bb.get(ba);\n  sb.append(new String(ba, 0, ba.length, UTF8));\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int v = bb.get() & 0xFF; if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0x", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n  int j = i;\n  while (bb.hasRemaining()) {\n    int ch = bb.get() & 0xFF;\n    if (ch >= 0x80) {\n      sb.append((char) ch);\n    } else if (ch == '\\\\') {\n      sb.append('\\\\');\n      sb.append('\\\\');\n    } else if (ch <= 0x7F) {\n      sb.append((char) ch);\n    } else {\n      sb.append('\\\\');\n      sb.append('u');\n      sb.append(toHex((ch >> 12) & 0xF));\n      sb.append(toHex((ch >> 8) & 0xF));\n      sb.append(toHex((ch >> 4) & 0xF));\n      sb.append(toHex(ch & 0xF));\n    }\n  }\n  return j;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n", "method_name": "decodeOctets", "codes": ["private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ if (i == 0) { return i; } int b = bb.get(i - 1); if (b < 0x80) { sb.append((char) b); i--; return decodeOctets(i, bb, sb); } if (i == bb.limit()) { return i; } if (i == bb.position()) { return i; } sb.append((char) (((b & 0x7f) << 6) | (bb.get(i) & 0x3f))); i++; return decodeOctets(i, bb, sb); }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ byte c = bb.get(); if (c == 0) { sb.append(' '); return i; } if (c == '\\n') { sb.append('\\n'); return i; } if (c == '\\r') { sb.append('\\r'); return i; } if (c == '\\t') { sb.append('\\t'); return i; } if (c == '\\f') { sb.append('\\f'); return i; } if (c == '\\b') { sb.append('\\b'); return i; } if (c == '\\\\') { sb.append('\\\\'); return i; } if (c == '\\\"') { sb.append('\"'); return i; } if (c == '/') { sb.append('/'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '\\u2028') { sb.append('\\u2028'); return i; } if (c == '\\u2029') { sb.append('\\u2029'); return i; } if (c == '\\u0085') { sb.append('\\u0085'); return i; } if (c == '", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int byteChars = bb.remaining(); if (byteChars == 0) { sb.append((char) i); return i; } int chars = i; int chars2 = 0; int chars3 = 0; chars2 = bb.get() & 0xFF; chars3 = bb.get() & 0xFF; if (chars2 == -1 && chars3 == -1) { sb.append((char) i); return i; } chars3 = chars3 << 8; chars2 = chars2 << 8; chars2 = chars2 | chars3; chars2 = bb.get() & 0xFF; if (chars2 == -1) { sb.append((char) i); chars3 = chars3 + 1; chars2 = chars2 + 1; } if (chars2 > 0) { sb.append((char) i); chars3 = chars3 + 1; chars2 = chars2 + 1; } if (chars2 == 0 && chars3 == 0) { sb.append((char) i); return i; } chars3 = chars3 << 8; chars2 = chars2 << 8; chars2 = chars2 | chars3; chars2 = bb.get() & 0xFF; if (chars2 == -1) { sb.append((char) i); chars3 = chars3 + 2; chars2 = chars2 + 2; } if (chars2 > 0) { sb.append((char) i); chars3 = chars3 + 2; chars2 = chars2 + 2; } if (chars2 == 0 && chars3 == 0) { sb.append((char) i); return i; } chars3 = chars3 << 8; chars2 = chars2 << 8; chars2 = chars2 | chars3; chars2 = bb.get() & 0xFF; if (chars2 == -1) { sb.append((char) i); chars3 = chars3 + 3; chars2 = chars2 + 3; } if (chars2 > 0) { sb.append((char) i); chars3 = chars3 + 3; chars2 = chars2 + 3; } if (chars2 == 0 && chars3 == 0) { sb.append((char) i); return i; } chars3 = chars3 << 8; chars2 = chars2 << 8; chars2 = chars2 | chars3; chars2 = bb.get() & 0xFF; if (chars2 == -1) { sb.append((char) i); chars3 = chars3 + 4; chars2 = chars2 + 4; } if (chars2 > 0) { sb.append((char) i); chars3 = chars3 + 4; chars2 = chars2 + 4; } if (chars2 == 0 && chars3 == 0) { sb.append((char) i); return i; } chars3 = chars3 <<", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int j = bb.position(); bb.position(i + 1); if (bb.remaining() >= 2) { char c = (char) (bb.get() & 0xFF); sb.append(c); } if (bb.remaining() >= 1) { char c = (char) (bb.get() & 0xFF); sb.append(c); } bb.position(j); return i + 2; }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int octet = bb.get(i); while ((octet & 0x80) != 0) { sb.append((char) octet); octet = bb.get(++i); } sb.append((char) octet); return i + 1; }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ if (i == -1) { i = bb.remaining(); } if (i == 0) { return i; } int octet = bb.get() & 0xFF; if (i > bb.remaining()) { return -1; } sb.append((char) octet); i--; return i; }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int charIndex = 0; if (i < 0) { i = i + 256; } byte byteValue = (byte) i; sb.append((char) byteValue); if (byteValue >= 0 && byteValue <= 9) { sb.append((char) (byteValue + '0')); } else if (byteValue >= 10 && byteValue <= 15) { sb.append((char) (byteValue - 10 + 'a')); } else if (byteValue >= 16 && byteValue <= 26) { sb.append((char) (byteValue - 16 + 'A')); } else { sb.append('.'); } charIndex = sb.length(); return charIndex; }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ if (bb.hasArray()) { byte[] ba = bb.array(); if (bb.hasArrayOffset()) { int offset = bb.arrayOffset(); int pos = bb.position(); sb.append(new String(ba, offset + pos, bb.remaining(), UTF8)); bb.position(offset + pos + ba.length); return i; } sb.append(new String(ba, 0, bb.remaining(), UTF8)); bb.position(bb.position() + bb.remaining()); return i; } byte[] ba = new byte[bb.remaining()]; bb.get(ba); sb.append(new String(ba, 0, ba.length, UTF8)); return i; }", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int v = bb.get() & 0xFF; if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0xFF) << 24; } sb.append((char) v); if ((v & 0x80) == 0x80) { v |= (bb.get() & 0xFF) << 8; } else { v |= (bb.get() & 0xFF) << 8 | (bb.get() & 0xFF) << 16 | (bb.get() & 0x", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){ int j = i; while (bb.hasRemaining()) { int ch = bb.get() & 0xFF; if (ch >= 0x80) { sb.append((char) ch); } else if (ch == '\\\\') { sb.append('\\\\'); sb.append('\\\\'); } else if (ch <= 0x7F) { sb.append((char) ch); } else { sb.append('\\\\'); sb.append('u'); sb.append(toHex((ch >> 12) & 0xF)); sb.append(toHex((ch >> 8) & 0xF)); sb.append(toHex((ch >> 4) & 0xF)); sb.append(toHex(ch & 0xF)); } } return j; }"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec017457", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  String s = u.getPath();\n  if (s == null) {\n    return Collections.emptyList();\n  }\n  List<PathSegmentImpl> segments = new ArrayList<PathSegmentImpl>();\n  int pos = 0;\n  int end = s.length();\n  while (pos < end) {\n    int slash = s.indexOf('/', pos);\n    if (slash < 0) {\n      slash = end;\n    }\n    int dot = s.indexOf('.', pos);\n    if (dot < 0) {\n      dot = end;\n    }\n    if (dot < slash) {\n      throw new IllegalArgumentException(\"Invalid path: \" + s);\n    }\n    int start = pos;\n    if (s.regionMatches(pos, \"/./\", 0, 3)) {\n      pos += 3;\n    } else if (s.regionMatches(pos, \"/../\", 0, 3)) {\n      pos += 3;\n    } else {\n      throw new IllegalArgumentException(\"Invalid path: \" + s);\n    }\n    int endIndex = s.indexOf('/', start);\n    if (endIndex < 0) {\n      endIndex = end;\n    }\n    String segment = s.substring(start, endIndex);\n    String base = u.getSchemeSpecificPart();\n    if (segment.startsWith(\"/..\")) {\n      throw new IllegalArgumentException(\n          \"Path segment '\" + segment + \"' is a reserved segment: \" + base);\n    }\n    if (segment.equals(\"..\")) {\n      throw new IllegalArgumentException(\n          \"Path segment '\" + segment + \"' is a reserved segment: \" + base);\n    }\n    if (segment.equals(\".\") && !base.endsWith(\"/\")) {\n      base += \"/\";\n    }\n    if (base.length() > 0) {\n      PathSegmentImpl seg = new PathSegmentImpl(segment, base, decode);\n      segments.add(seg);\n    }\n    pos = endIndex + 1;\n  }\n  return segments;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  return decodePath(u, decode, DEFAULT_PATH_SEGMENT_DECODER);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>();\n  if (u == null) {\n    return result;\n  }\n  String path = u.getPath();\n  if (path == null) {\n    return result;\n  }\n  int index = 0;\n  int segmentIndex = 0;\n  int pathIndex = 0;\n  int pathEndIndex = path.length();\n  int segmentEndIndex = 0;\n  while (index < pathEndIndex) {\n    char c = path.charAt(index);\n    if (c == '?') {\n      if (pathIndex != pathEndIndex) {\n        result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex)));\n      } else {\n        result.add(new PathSegmentImpl(path.substring(pathIndex)));\n      }\n    } else if (c == '#') {\n      if (pathIndex != pathEndIndex) {\n        result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex)));\n      } else {\n        result.add(new PathSegmentImpl(path.substring(pathIndex)));\n      }\n    } else if (c == '%') {\n      if (pathIndex != pathEndIndex) {\n        result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex)));\n      } else {\n        result.add(new PathSegmentImpl(path.substring(pathIndex)));\n      }\n    } else if (c == '/') {\n      if (pathIndex != pathEndIndex) {\n        result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex)));\n      } else {\n        result.add(new PathSegmentImpl(path.substring(pathIndex)));\n      }\n    } else {\n      if (decode) {\n        c = path.charAt(pathIndex++);\n      }\n      if (c < '0' || c > '9') {\n        throw new IllegalArgumentException(\n            \"Invalid path segment char '\" + c + \"' at index \" + index);\n      }\n      int value = (c - '0') * 10 + path.charAt(pathIndex++) - '0';\n      if (pathIndex == pathEndIndex) {\n        result.add(new PathSegmentImpl(Integer.toString(value)));\n      } else {\n        result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex)));\n      }\n    }\n    index++;\n  }\n  if (pathIndex != pathEndIndex) {\n    result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex)));\n  } else {\n    result.add(new PathSegmentImpl(path.substring(pathIndex)));\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> path = new ArrayList<PathSegmentImpl>(); if (u == null) { return path; } String pathStr = u.getPath(); int index = pathStr.indexOf(';'); if (index == -1) { path.add(new PathSegmentImpl(pathStr, false)); return path; } String[] parts = pathStr.substring(0, index).split(\";\"); for (int i = 0; i < parts.length; i++) { String part = parts[i]; if (part.length() == 0) { continue; } String[] segments = part.split(\":\"); if (segments.length == 0) { continue; } String s = segments[0]; if (s.length() == 0) { continue; } if (s.equals(\"/\")) { continue; } if (s.equals(\"#\")) { continue; } if (s.equals(\".\")) { continue; } if (s.equals(\"..\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"../\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"..\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"../\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"..\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"../\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"/\")) { continue; } if (s.equals(\"#\")) { continue; } if (s.equals(\".\")) { continue; } if (s.equals(\"../\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new Path", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  if (u == null) {\n    return null;\n  }\n  List<PathSegmentImpl> segments = new ArrayList<PathSegmentImpl>();\n  String path = u.getPath();\n  int pos = 0;\n  while (pos < path.length()) {\n    pos = path.indexOf('/', pos);\n    if (pos == -1) {\n      pos = path.length();\n    }\n    if (pos == 0) {\n      throw new IllegalArgumentException(\"Invalid path: \" + path);\n    }\n    String segment = path.substring(pos);\n    if (segment.length() > 0) {\n      if (segment.charAt(0) == '/') {\n        throw new IllegalArgumentException(\"Invalid path: \" + path);\n      }\n      if (segment.equals(\"/.\")) {\n        continue;\n      }\n      if (segment.equals(\"..\")) {\n        if (segments.size() > 0) {\n          segments.remove(segments.size() - 1);\n        }\n      } else {\n        if (decode) {\n          segment = URLDecoder.decode(segment, \"UTF-8\");\n        }\n        segments.add(new PathSegmentImpl(segment, false));\n      }\n    }\n  }\n  return segments;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>();\n  if (u != null) {\n    String path = u.getRawPath();\n    if (path != null) {\n      String[] segments = path.split(\"/\");\n      for (String s : segments) {\n        if (decode) {\n          result.add(decodePathSegment(s, decode));\n        } else {\n          result.add(decodePathSegment(s));\n        }\n      }\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  String path = u.getRawPath();\n  if (path == null) {\n    return null;\n  }\n  if (decode) {\n    path = path.replaceAll(\"%2F\", \"/\");\n  }\n  return decodePath(path);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  if (u == null) {\n    return null;\n  }\n  if (u.getScheme() == null) {\n    return null;\n  }\n  if (u.getScheme().equals(\"file\")) {\n    return decodePath(u.getPath(), decode);\n  }\n  if (u.getScheme().equals(\"http\")) {\n    return decodePath(u.getPath(), decode);\n  }\n  if (u.getScheme().equals(\"https\")) {\n    return decodePath(u.getPath(), decode);\n  }\n  throw new IllegalArgumentException(\"Invalid scheme: \" + u.getScheme());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>();\n  String path = u.getRawPath();\n  if (path == null || path.length() == 0) {\n    return result;\n  }\n  String[] segments = path.split(\"/\");\n  for (int i = 0; i < segments.length; i++) {\n    String segment = segments[i];\n    if (segment == null || segment.length() == 0) {\n      continue;\n    }\n    if (decode) {\n      segment = decodePathSegment(segment);\n    }\n    result.add(new PathSegmentImpl(segment));\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n  if (u == null) return null;\n  List<PathSegmentImpl> list = new ArrayList<PathSegmentImpl>();\n  String scheme = u.getScheme();\n  if (scheme != null) {\n    for (String pathSegment : u.getPath().split(\"/\")) {\n      if (pathSegment.length() > 0) {\n        list.add(new PathSegmentImpl(pathSegment, scheme, decode));\n      }\n    }\n  }\n  return list;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decode the path component of a URI as path segments.\n * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.\n * @param decode true if the path segments of the path componentshould be in decoded form.\n * @return the list of path segments.\n */\n", "method_name": "decodePath", "codes": ["public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ String s = u.getPath(); if (s == null) { return Collections.emptyList(); } List<PathSegmentImpl> segments = new ArrayList<PathSegmentImpl>(); int pos = 0; int end = s.length(); while (pos < end) { int slash = s.indexOf('/', pos); if (slash < 0) { slash = end; } int dot = s.indexOf('.', pos); if (dot < 0) { dot = end; } if (dot < slash) { throw new IllegalArgumentException(\"Invalid path: \" + s); } int start = pos; if (s.regionMatches(pos, \"/./\", 0, 3)) { pos += 3; } else if (s.regionMatches(pos, \"/../\", 0, 3)) { pos += 3; } else { throw new IllegalArgumentException(\"Invalid path: \" + s); } int endIndex = s.indexOf('/', start); if (endIndex < 0) { endIndex = end; } String segment = s.substring(start, endIndex); String base = u.getSchemeSpecificPart(); if (segment.startsWith(\"/..\")) { throw new IllegalArgumentException(\"Path segment '\" + segment + \"' is a reserved segment: \" + base); } if (segment.equals(\"..\")) { throw new IllegalArgumentException(\"Path segment '\" + segment + \"' is a reserved segment: \" + base); } if (segment.equals(\".\") && !base.endsWith(\"/\")) { base += \"/\"; } if (base.length() > 0) { PathSegmentImpl seg = new PathSegmentImpl(segment, base, decode); segments.add(seg); } pos = endIndex + 1; } return segments; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ return decodePath(u, decode, DEFAULT_PATH_SEGMENT_DECODER); }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>(); if (u == null) { return result; } String path = u.getPath(); if (path == null) { return result; } int index = 0; int segmentIndex = 0; int pathIndex = 0; int pathEndIndex = path.length(); int segmentEndIndex = 0; while (index < pathEndIndex) { char c = path.charAt(index); if (c == '?') { if (pathIndex != pathEndIndex) { result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex))); } else { result.add(new PathSegmentImpl(path.substring(pathIndex))); } } else if (c == '#') { if (pathIndex != pathEndIndex) { result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex))); } else { result.add(new PathSegmentImpl(path.substring(pathIndex))); } } else if (c == '%') { if (pathIndex != pathEndIndex) { result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex))); } else { result.add(new PathSegmentImpl(path.substring(pathIndex))); } } else if (c == '/') { if (pathIndex != pathEndIndex) { result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex))); } else { result.add(new PathSegmentImpl(path.substring(pathIndex))); } } else { if (decode) { c = path.charAt(pathIndex++); } if (c < '0' || c > '9') { throw new IllegalArgumentException(\"Invalid path segment char '\" + c + \"' at index \" + index); } int value = (c - '0') * 10 + path.charAt(pathIndex++) - '0'; if (pathIndex == pathEndIndex) { result.add(new PathSegmentImpl(Integer.toString(value))); } else { result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex))); } } index++; } if (pathIndex != pathEndIndex) { result.add(new PathSegmentImpl(path.substring(pathIndex, pathEndIndex))); } else { result.add(new PathSegmentImpl(path.substring(pathIndex))); } return result; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> path = new ArrayList<PathSegmentImpl>(); if (u == null) { return path; } String pathStr = u.getPath(); int index = pathStr.indexOf(';'); if (index == -1) { path.add(new PathSegmentImpl(pathStr, false)); return path; } String[] parts = pathStr.substring(0, index).split(\";\"); for (int i = 0; i < parts.length; i++) { String part = parts[i]; if (part.length() == 0) { continue; } String[] segments = part.split(\":\"); if (segments.length == 0) { continue; } String s = segments[0]; if (s.length() == 0) { continue; } if (s.equals(\"/\")) { continue; } if (s.equals(\"#\")) { continue; } if (s.equals(\".\")) { continue; } if (s.equals(\"..\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"../\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"..\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"../\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"..\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"../\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new PathSegmentImpl(segments[1], true)); } } continue; } if (s.equals(\"/\")) { continue; } if (s.equals(\"#\")) { continue; } if (s.equals(\".\")) { continue; } if (s.equals(\"../\")) { if (i > 0) { if (segments.length == 2) { path.add(new PathSegmentImpl(segments[1], false)); } else { path.add(new Path", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ if (u == null) { return null; } List<PathSegmentImpl> segments = new ArrayList<PathSegmentImpl>(); String path = u.getPath(); int pos = 0; while (pos < path.length()) { pos = path.indexOf('/', pos); if (pos == -1) { pos = path.length(); } if (pos == 0) { throw new IllegalArgumentException(\"Invalid path: \" + path); } String segment = path.substring(pos); if (segment.length() > 0) { if (segment.charAt(0) == '/') { throw new IllegalArgumentException(\"Invalid path: \" + path); } if (segment.equals(\"/.\")) { continue; } if (segment.equals(\"..\")) { if (segments.size() > 0) { segments.remove(segments.size() - 1); } } else { if (decode) { segment = URLDecoder.decode(segment, \"UTF-8\"); } segments.add(new PathSegmentImpl(segment, false)); } } } return segments; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>(); if (u != null) { String path = u.getRawPath(); if (path != null) { String[] segments = path.split(\"/\"); for (String s : segments) { if (decode) { result.add(decodePathSegment(s, decode)); } else { result.add(decodePathSegment(s)); } } } } return result; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ String path = u.getRawPath(); if (path == null) { return null; } if (decode) { path = path.replaceAll(\"%2F\", \"/\"); } return decodePath(path); }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ if (u == null) { return null; } if (u.getScheme() == null) { return null; } if (u.getScheme().equals(\"file\")) { return decodePath(u.getPath(), decode); } if (u.getScheme().equals(\"http\")) { return decodePath(u.getPath(), decode); } if (u.getScheme().equals(\"https\")) { return decodePath(u.getPath(), decode); } throw new IllegalArgumentException(\"Invalid scheme: \" + u.getScheme()); }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>(); String path = u.getRawPath(); if (path == null || path.length() == 0) { return result; } String[] segments = path.split(\"/\"); for (int i = 0; i < segments.length; i++) { String segment = segments[i]; if (segment == null || segment.length() == 0) { continue; } if (decode) { segment = decodePathSegment(segment); } result.add(new PathSegmentImpl(segment)); } return result; }", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){ if (u == null) return null; List<PathSegmentImpl> list = new ArrayList<PathSegmentImpl>(); String scheme = u.getScheme(); if (scheme != null) { for (String pathSegment : u.getPath().split(\"/\")) { if (pathSegment.length() > 0) { list.add(new PathSegmentImpl(pathSegment, scheme, decode)); } } } return list; }"], "code_level": "slib_runnable", "_id": "6367667f1a6d9265ec01745d", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public final MatchResult match(CharSequence uri) {\n  return match(uri, 0, uri.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  MatchResult result = null;\n  if (urlPattern.matcher(uri).matches()) {\n    result = new MatchResult(uri.toString(), urlPattern.pattern());\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  if (uri == null) {\n    return null;\n  }\n  if (uri.length() == 0) {\n    return MatchResult.EMPTY;\n  }\n  final int uriStart = 0;\n  final int uriEnd = uri.length();\n  if (!hasPattern()) {\n    return null;\n  }\n  final int uriEndMatch = uriEnd - 1;\n  final boolean uriMatch = uri.regionMatches(uriStart, pattern, 0, pattern.length());\n  if (uriMatch && uriEndMatch == uriEnd) {\n    return MatchResult.create(uriStart, uriEndMatch, this);\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  return match(uri, 0, uri.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  if (this.isMatch(uri)) {\n    return MatchResult.MATCH;\n  } else {\n    if (this.url.isPrefixOf(uri)) {\n      return MatchResult.NOMATCH;\n    } else {\n      return MatchResult.NOMATCH_AND_PREFIX;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  if (uri == null) {\n    return null;\n  }\n  if (uri.length() == 0) {\n    return null;\n  }\n  final String pattern = mPattern;\n  if (pattern == null) {\n    return null;\n  }\n  final int patternLength = pattern.length();\n  final int uriLength = uri.length();\n  int i = 0;\n  int j = 0;\n  while (i < uriLength && j < patternLength) {\n    if (pattern.charAt(j) == uri.charAt(i)) {\n      i++;\n      j++;\n    } else {\n      if (j == 0) {\n        i++;\n      } else {\n        j = mMatchParams[j - 1];\n      }\n    }\n  }\n  if (j == patternLength) {\n    return new MatchResult(i - j, i);\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  if (uri == null) {\n    return null;\n  }\n  MatchResult result = new MatchResult();\n  int i = 0;\n  int n = uri.length();\n  while (i < n) {\n    char c = uri.charAt(i);\n    if (c == '*') {\n      if (i + 1 < n && uri.charAt(i + 1) == '*') {\n        result.start = i;\n        result.end = i + 2;\n        i += 2;\n      } else {\n        result.start = i;\n        result.end = i + 1;\n        i++;\n      }\n    } else if (c == '?') {\n      result.start = i;\n      result.end = i + 1;\n      i++;\n    } else {\n      if (c == '/') {\n        if (i + 1 < n && uri.charAt(i + 1) == '/') {\n          result.start = i;\n          result.end = i + 2;\n          i += 2;\n        } else {\n          result.start = i;\n          result.end = i + 1;\n          i++;\n        }\n      } else {\n        if (!Character.isJavaIdentifierStart(c)) {\n          if (c == '.') {\n            result.start = i;\n            result.end = i + 1;\n            i++;\n          } else {\n            result.start = i;\n            result.end = i + 1;\n            i++;\n          }\n        } else {\n          i++;\n        }\n      }\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  if (uri == null || uri.length() == 0) {\n    return null;\n  }\n  return match(uri.toString());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  if (uri.length() == 0) {\n    return null;\n  }\n  final MatchResult result = new MatchResult();\n  final String url = uri.toString();\n  if (url.length() > 0 && url.charAt(0) == '/') {\n    if (url.length() > 1) {\n      result.url = url.substring(1);\n    }\n  } else {\n    if (url.length() > 0 && url.charAt(0) == ':') {\n      result.url = url.substring(1);\n    }\n  }\n  if (url.length() > 0 && url.charAt(0) == '/' && !result.url.endsWith(\"/\")) {\n    result.url += \"/\";\n  }\n  if (url.length() > 0 && url.charAt(0) == '/' && result.url.endsWith(\"/\")) {\n    result.url += url.substring(1);\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri) {\n  return mPattern.match(uri);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Match a URI against the pattern.\n * @param uri the uri to match against the template.\n * @return the match result, otherwise null if no match occurs.\n */\n", "method_name": "match", "codes": ["public final MatchResult match(CharSequence uri){ return match(uri, 0, uri.length()); }", "public final MatchResult match(CharSequence uri){ MatchResult result = null; if (urlPattern.matcher(uri).matches()) { result = new MatchResult(uri.toString(), urlPattern.pattern()); } return result; }", "public final MatchResult match(CharSequence uri){ if (uri == null) { return null; } if (uri.length() == 0) { return MatchResult.EMPTY; } final int uriStart = 0; final int uriEnd = uri.length(); if (!hasPattern()) { return null; } final int uriEndMatch = uriEnd - 1; final boolean uriMatch = uri.regionMatches(uriStart, pattern, 0, pattern.length()); if (uriMatch && uriEndMatch == uriEnd) { return MatchResult.create(uriStart, uriEndMatch, this); } return null; }", "public final MatchResult match(CharSequence uri){ return match(uri, 0, uri.length()); }", "public final MatchResult match(CharSequence uri){ if (this.isMatch(uri)) { return MatchResult.MATCH; } else { if (this.url.isPrefixOf(uri)) { return MatchResult.NOMATCH; } else { return MatchResult.NOMATCH_AND_PREFIX; } } }", "public final MatchResult match(CharSequence uri){ if (uri == null) { return null; } if (uri.length() == 0) { return null; } final String pattern = mPattern; if (pattern == null) { return null; } final int patternLength = pattern.length(); final int uriLength = uri.length(); int i = 0; int j = 0; while (i < uriLength && j < patternLength) { if (pattern.charAt(j) == uri.charAt(i)) { i++; j++; } else { if (j == 0) { i++; } else { j = mMatchParams[j - 1]; } } } if (j == patternLength) { return new MatchResult(i - j, i); } else { return null; } }", "public final MatchResult match(CharSequence uri){ if (uri == null) { return null; } MatchResult result = new MatchResult(); int i = 0; int n = uri.length(); while (i < n) { char c = uri.charAt(i); if (c == '*') { if (i + 1 < n && uri.charAt(i + 1) == '*') { result.start = i; result.end = i + 2; i += 2; } else { result.start = i; result.end = i + 1; i++; } } else if (c == '?') { result.start = i; result.end = i + 1; i++; } else { if (c == '/') { if (i + 1 < n && uri.charAt(i + 1) == '/') { result.start = i; result.end = i + 2; i += 2; } else { result.start = i; result.end = i + 1; i++; } } else { if (!Character.isJavaIdentifierStart(c)) { if (c == '.') { result.start = i; result.end = i + 1; i++; } else { result.start = i; result.end = i + 1; i++; } } else { i++; } } } } return result; }", "public final MatchResult match(CharSequence uri){ if (uri == null || uri.length() == 0) { return null; } return match(uri.toString()); }", "public final MatchResult match(CharSequence uri){ if (uri.length() == 0) { return null; } final MatchResult result = new MatchResult(); final String url = uri.toString(); if (url.length() > 0 && url.charAt(0) == '/') { if (url.length() > 1) { result.url = url.substring(1); } } else { if (url.length() > 0 && url.charAt(0) == ':') { result.url = url.substring(1); } } if (url.length() > 0 && url.charAt(0) == '/' && !result.url.endsWith(\"/\")) { result.url += \"/\"; } if (url.length() > 0 && url.charAt(0) == '/' && result.url.endsWith(\"/\")) { result.url += url.substring(1); } return result; }", "public final MatchResult match(CharSequence uri){ return mPattern.match(uri); }"], "code_level": "project_runnable", "_id": "636766861a6d9265ec01755a", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return getTemplateVariable(name) != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return (templateVariables != null) && (templateVariables.containsKey(name));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  if (this.name.equals(name)) {\n    return true;\n  }\n  if (this.isTemplateVariable()) {\n    return this.getTemplateVariable().isTemplateVariablePresent(name);\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  for (int i = 0; i < this.getNumTemplateVars(); i++) {\n    if (name.equals(this.getTemplateVar(i).getName())) return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return _templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name) {\n  return (templateVariables.containsKey(name));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Ascertain if a template variable is a member of this template.\n * @param name name The template variable.\n * @return true if the template variable is a member of the template, otherwisefalse.\n */\n", "method_name": "isTemplateVariablePresent", "codes": ["public final boolean isTemplateVariablePresent(String name){ return this.templateVariables.containsKey(name); }", "public final boolean isTemplateVariablePresent(String name){ return this.templateVariables.containsKey(name); }", "public final boolean isTemplateVariablePresent(String name){ return getTemplateVariable(name) != null; }", "public final boolean isTemplateVariablePresent(String name){ return templateVariables.containsKey(name); }", "public final boolean isTemplateVariablePresent(String name){ return (templateVariables != null) && (templateVariables.containsKey(name)); }", "public final boolean isTemplateVariablePresent(String name){ if (this.name.equals(name)) { return true; } if (this.isTemplateVariable()) { return this.getTemplateVariable().isTemplateVariablePresent(name); } return false; }", "public final boolean isTemplateVariablePresent(String name){ for (int i = 0; i < this.getNumTemplateVars(); i++) { if (name.equals(this.getTemplateVar(i).getName())) return true; } return false; }", "public final boolean isTemplateVariablePresent(String name){ return templateVariables.containsKey(name); }", "public final boolean isTemplateVariablePresent(String name){ return _templateVariables.containsKey(name); }", "public final boolean isTemplateVariablePresent(String name){ return (templateVariables.containsKey(name)); }"], "code_level": "class_runnable", "_id": "636766861a6d9265ec017553", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String encodeTemplateNames(String s) {\n  return encodeTemplateNames(s, '{', '}');\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  s = s.replace(\"{\", \"\");\n  s = s.replace(\"}\", \"\");\n  s = s.replace(\"\\\\\", \"\");\n  String[] split = s.split(\",\");\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < split.length; i++) {\n    sb.append(encodeTemplateName(split[i]));\n    if (i < split.length - 1) {\n      sb.append(\",\");\n    }\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  StringBuilder sb = new StringBuilder();\n  char c;\n  for (int i = 0; i < s.length(); i++) {\n    c = s.charAt(i);\n    if (c == '{' || c == '}') {\n      sb.append('{');\n      sb.append(c);\n      sb.append('}');\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  return encodeTemplateNames(s, '{', '}');\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  if (s == null) return null;\n  char[] chars = s.toCharArray();\n  StringBuilder sb = new StringBuilder();\n  for (char c : chars) {\n    if (c == '{') {\n      sb.append(\"&lt;\");\n    } else if (c == '}') {\n      sb.append(\"&gt;\");\n    } else if (c == '&') {\n      sb.append(\"&amp;\");\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  if (s == null) {\n    return null;\n  }\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    if (c == '{' || c == '}') {\n      sb.append('{');\n      sb.append(c);\n      sb.append('}');\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  if (s == null) {\n    return null;\n  }\n  StringBuilder sb = new StringBuilder(s.length());\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    if (c == '{' || c == '}') {\n      if (c == '}') {\n        if (i + 1 < s.length() && s.charAt(i + 1) == '{') {\n          sb.append(\"{}\");\n          i++;\n        } else {\n          sb.append(\"{}\");\n        }\n      } else {\n        sb.append(\"{}\");\n      }\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  String[] names = s.split(\",\");\n  StringBuffer sb = new StringBuffer();\n  for (String name : names) {\n    name = name.replace(\"{\", \"\");\n    name = name.replace(\"}\", \"\");\n    sb.append(\"{\" + name.charAt(0) + \"}\");\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  StringBuilder result = new StringBuilder(s.length());\n  boolean inQuote = false;\n  for (char c : s.toCharArray()) {\n    if (inQuote) {\n      result.append(\"\\\\\");\n    } else if (c == '{') {\n      inQuote = true;\n    } else if (c == '}') {\n      inQuote = false;\n      result.append('\\\\');\n    } else {\n      result.append(c);\n    }\n  }\n  return result.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s) {\n  StringBuffer sb = new StringBuffer();\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    if (c == '{' || c == '}') {\n      sb.append('%').append(Integer.toHexString((int) c));\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Encodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-encoded.\n * @param s the string with zero or more template parameters names\n * @return the string with encoded template parameters names.\n */\n", "method_name": "encodeTemplateNames", "codes": ["public static String encodeTemplateNames(String s){ return encodeTemplateNames(s, '{', '}'); }", "public static String encodeTemplateNames(String s){ s = s.replace(\"{\", \"\"); s = s.replace(\"}\", \"\"); s = s.replace(\"\\\\\", \"\"); String[] split = s.split(\",\"); StringBuilder sb = new StringBuilder(); for (int i = 0; i < split.length; i++) { sb.append(encodeTemplateName(split[i])); if (i < split.length - 1) { sb.append(\",\"); } } return sb.toString(); }", "public static String encodeTemplateNames(String s){ StringBuilder sb = new StringBuilder(); char c; for (int i = 0; i < s.length(); i++) { c = s.charAt(i); if (c == '{' || c == '}') { sb.append('{'); sb.append(c); sb.append('}'); } else { sb.append(c); } } return sb.toString(); }", "public static String encodeTemplateNames(String s){ return encodeTemplateNames(s, '{', '}'); }", "public static String encodeTemplateNames(String s){ if (s == null) return null; char[] chars = s.toCharArray(); StringBuilder sb = new StringBuilder(); for (char c : chars) { if (c == '{') { sb.append(\"&lt;\"); } else if (c == '}') { sb.append(\"&gt;\"); } else if (c == '&') { sb.append(\"&amp;\"); } else { sb.append(c); } } return sb.toString(); }", "public static String encodeTemplateNames(String s){ if (s == null) { return null; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c == '{' || c == '}') { sb.append('{'); sb.append(c); sb.append('}'); } else { sb.append(c); } } return sb.toString(); }", "public static String encodeTemplateNames(String s){ if (s == null) { return null; } StringBuilder sb = new StringBuilder(s.length()); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c == '{' || c == '}') { if (c == '}') { if (i + 1 < s.length() && s.charAt(i + 1) == '{') { sb.append(\"{}\"); i++; } else { sb.append(\"{}\"); } } else { sb.append(\"{}\"); } } else { sb.append(c); } } return sb.toString(); }", "public static String encodeTemplateNames(String s){ String[] names = s.split(\",\"); StringBuffer sb = new StringBuffer(); for (String name : names) { name = name.replace(\"{\", \"\"); name = name.replace(\"}\", \"\"); sb.append(\"{\" + name.charAt(0) + \"}\"); } return sb.toString(); }", "public static String encodeTemplateNames(String s){ StringBuilder result = new StringBuilder(s.length()); boolean inQuote = false; for (char c : s.toCharArray()) { if (inQuote) { result.append(\"\\\\\"); } else if (c == '{') { inQuote = true; } else if (c == '}') { inQuote = false; result.append('\\\\'); } else { result.append(c); } } return result.toString(); }", "public static String encodeTemplateNames(String s){ StringBuffer sb = new StringBuffer(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c == '{' || c == '}') { sb.append('%').append(Integer.toHexString((int) c)); } else { sb.append(c); } } return sb.toString(); }"], "code_level": "self_contained", "_id": "636766801a6d9265ec017487", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  URL url = null;\n  try {\n    url = new File(dir).toURL();\n  } catch (MalformedURLException e) {\n    throw new RuntimeException(e);\n  }\n  cpV.addElement(url);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  String slash = System.getProperty(\"file.separator\");\n  String jarPath = dir + slash + \"lib\";\n  try {\n    Enumeration<URL> e = ClassLoader.getSystemResources(jarPath);\n    while (e.hasMoreElements()) {\n      URL url = e.nextElement();\n      cpV.add(url);\n    }\n  } catch (Exception e) {\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  File dirF = new File(dir);\n  if (!dirF.exists()) {\n    throw new RuntimeException(\"Could not locate directory: \" + dir);\n  }\n  File[] files = dirF.listFiles();\n  for (int i = 0; i < files.length; i++) {\n    if (files[i].isDirectory()) {\n      addToClassPath(cpV, files[i].getAbsolutePath());\n    } else {\n      try {\n        cpV.addElement(new URL(\"file://\" + files[i].getAbsolutePath()));\n      } catch (MalformedURLException e) {\n        throw new RuntimeException(\n            \"Could not create a URL from a file: \" + files[i].getAbsolutePath(), e);\n      }\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  try {\n    String[] dirs = dir.split(\";\");\n    for (String dirEntry : dirs) {\n      if (dirEntry.length() == 0) continue;\n      File dirEntryFile = new File(dirEntry);\n      if (!dirEntryFile.exists()) continue;\n      String[] filenames = dirEntryFile.list();\n      for (String filename : filenames) {\n        File entryFile = new File(dirEntry, filename);\n        if (entryFile.isDirectory()) continue;\n        URL entryURL = dirEntryFile.toURI().toURL();\n        cpV.add(entryURL);\n      }\n    }\n  } catch (MalformedURLException e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  File file = new File(dir);\n  if (!file.isDirectory()) {\n    return;\n  }\n  for (File f : file.listFiles()) {\n    if (f.isDirectory()) {\n      addToClassPath(cpV, f.getAbsolutePath());\n    } else {\n      try {\n        cpV.addElement(new URL(\"file://\" + f.getAbsolutePath()));\n      } catch (MalformedURLException e) {\n      }\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  try {\n    Enumeration<URL> e = ClassLoader.getSystemResources(dir);\n    while (e.hasMoreElements()) {\n      cpV.add(e.nextElement());\n    }\n  } catch (IOException ioe) {\n    System.err.println(\"IOException in addToClassPath: \" + ioe.getMessage());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  try {\n    Enumeration<URL> dirs = ClassLoader.getSystemResources(dir);\n    while (dirs.hasMoreElements()) {\n      URL url = dirs.nextElement();\n      cpV.add(url);\n    }\n  } catch (IOException e) {\n    System.err.println(\"Cannot add to classpath: \" + dir);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  try {\n    Enumeration<URL> e = Thread.currentThread().getContextClassLoader().getResources(dir);\n    while (e.hasMoreElements()) {\n      cpV.add(e.nextElement());\n    }\n  } catch (IOException e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  File f = new File(dir);\n  File[] files = f.listFiles();\n  for (int i = 0; i < files.length; i++) {\n    if (files[i].isDirectory()) {\n      addToClassPath(cpV, files[i].getAbsolutePath());\n    } else {\n      try {\n        cpV.add(new URL(\"file:\" + files[i].getAbsolutePath()));\n      } catch (MalformedURLException e) {\n      }\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic static void addToClassPath(Vector<URL> cpV, String dir) {\n  File dirFile = new File(dir);\n  if (!dirFile.exists()) {\n    return;\n  }\n  String[] dirList = dirFile.list();\n  if (dirList == null) {\n    return;\n  }\n  for (int i = 0; i < dirList.length; i++) {\n    if (dirList[i].endsWith(\".jar\")) {\n      String jarFileName = dirList[i];\n      URL jarURL = null;\n      try {\n        jarURL = dirFile.toURI().toURL();\n      } catch (MalformedURLException e) {\n        e.printStackTrace();\n      }\n      if (!cpV.contains(jarURL)) {\n        cpV.addElement(jarURL);\n      }\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n", "method_name": "addToClassPath", "codes": ["@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ URL url = null; try { url = new File(dir).toURL(); } catch (MalformedURLException e) { throw new RuntimeException(e); } cpV.addElement(url); }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ String slash = System.getProperty(\"file.separator\"); String jarPath = dir + slash + \"lib\"; try { Enumeration<URL> e = ClassLoader.getSystemResources(jarPath); while (e.hasMoreElements()) { URL url = e.nextElement(); cpV.add(url); } } catch (Exception e) { } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ File dirF = new File(dir); if (!dirF.exists()) { throw new RuntimeException(\"Could not locate directory: \" + dir); } File[] files = dirF.listFiles(); for (int i = 0; i < files.length; i++) { if (files[i].isDirectory()) { addToClassPath(cpV, files[i].getAbsolutePath()); } else { try { cpV.addElement(new URL(\"file://\" + files[i].getAbsolutePath())); } catch (MalformedURLException e) { throw new RuntimeException(\"Could not create a URL from a file: \" + files[i].getAbsolutePath(), e); } } } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ try { String[] dirs = dir.split(\";\"); for (String dirEntry : dirs) { if (dirEntry.length() == 0) continue; File dirEntryFile = new File(dirEntry); if (!dirEntryFile.exists()) continue; String[] filenames = dirEntryFile.list(); for (String filename : filenames) { File entryFile = new File(dirEntry, filename); if (entryFile.isDirectory()) continue; URL entryURL = dirEntryFile.toURI().toURL(); cpV.add(entryURL); } } } catch (MalformedURLException e) { e.printStackTrace(); } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ File file = new File(dir); if (!file.isDirectory()) { return; } for (File f : file.listFiles()) { if (f.isDirectory()) { addToClassPath(cpV, f.getAbsolutePath()); } else { try { cpV.addElement(new URL(\"file://\" + f.getAbsolutePath())); } catch (MalformedURLException e) { } } } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ try { Enumeration<URL> e = ClassLoader.getSystemResources(dir); while (e.hasMoreElements()) { cpV.add(e.nextElement()); } } catch (IOException ioe) { System.err.println(\"IOException in addToClassPath: \" + ioe.getMessage()); } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ try { Enumeration<URL> dirs = ClassLoader.getSystemResources(dir); while (dirs.hasMoreElements()) { URL url = dirs.nextElement(); cpV.add(url); } } catch (IOException e) { System.err.println(\"Cannot add to classpath: \" + dir); } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ try { Enumeration<URL> e = Thread.currentThread().getContextClassLoader().getResources(dir); while (e.hasMoreElements()) { cpV.add(e.nextElement()); } } catch (IOException e) { e.printStackTrace(); } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ File f = new File(dir); File[] files = f.listFiles(); for (int i = 0; i < files.length; i++) { if (files[i].isDirectory()) { addToClassPath(cpV, files[i].getAbsolutePath()); } else { try { cpV.add(new URL(\"file:\" + files[i].getAbsolutePath())); } catch (MalformedURLException e) { } } } }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){ File dirFile = new File(dir); if (!dirFile.exists()) { return; } String[] dirList = dirFile.list(); if (dirList == null) { return; } for (int i = 0; i < dirList.length; i++) { if (dirList[i].endsWith(\".jar\")) { String jarFileName = dirList[i]; URL jarURL = null; try { jarURL = dirFile.toURI().toURL(); } catch (MalformedURLException e) { e.printStackTrace(); } if (!cpV.contains(jarURL)) { cpV.addElement(jarURL); } } } }"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec01745c", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String capitalize(String name) {\n  char[] nameArray = name.toCharArray();\n  nameArray[0] = Character.toUpperCase(nameArray[0]);\n  return new String(nameArray);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name) {\n  String capitalizedName = \"\";\n  for (int i = 0; i < name.length(); i++) {\n    char currentChar = name.charAt(i);\n    if (Character.isUpperCase(currentChar)) {\n      capitalizedName += currentChar;\n    } else {\n      capitalizedName += Character.toUpperCase(currentChar);\n    }\n  }\n  return capitalizedName;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name) {\n  return name.substring(0, 1).toUpperCase() + name.substring(1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name) {\n  if (name.length() == 0) {\n    return name;\n  } else {\n    return Character.toUpperCase(name.charAt(0)) + name.substring(1);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name) {\n  if (name == null || name.length() == 0) return name;\n  char[] chars = name.toCharArray();\n  chars[0] = Character.toUpperCase(chars[0]);\n  return new String(chars);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String capitalize(String name) {\n  char[] chars = name.toCharArray();\n  chars[0] -= 32;\n  return String.valueOf(chars);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name) {\n  if (name == null || name.length() == 0) {\n    return name;\n  }\n  return name.substring(0, 1).toUpperCase() + name.substring(1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String capitalize(String name) {\n  name = name.toLowerCase();\n  if (name.length() > 1) {\n    name = name.substring(0, 1).toUpperCase() + name.substring(1);\n  }\n  return name;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name) {\n  char[] chars = name.toCharArray();\n  chars[0] -= 32;\n  return String.valueOf(chars);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name) {\n  if (name == null || name.length() == 0) return name;\n  char[] chars = name.toCharArray();\n  chars[0] = Character.toUpperCase(chars[0]);\n  return new String(chars);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Reverse of Introspector.decapitalize\n */\n", "method_name": "capitalize", "codes": ["public static String capitalize(String name){ char[] nameArray = name.toCharArray(); nameArray[0] = Character.toUpperCase(nameArray[0]); return new String(nameArray); }", "public static String capitalize(String name){ String capitalizedName = \"\"; for (int i = 0; i < name.length(); i++) { char currentChar = name.charAt(i); if (Character.isUpperCase(currentChar)) { capitalizedName += currentChar; } else { capitalizedName += Character.toUpperCase(currentChar); } } return capitalizedName; }", "public static String capitalize(String name){ return name.substring(0, 1).toUpperCase() + name.substring(1); }", "public static String capitalize(String name){ if (name.length() == 0) { return name; } else { return Character.toUpperCase(name.charAt(0)) + name.substring(1); } }", "public static String capitalize(String name){ if (name == null || name.length() == 0) return name; char[] chars = name.toCharArray(); chars[0] = Character.toUpperCase(chars[0]); return new String(chars); }", "public static String capitalize(String name){ char[] chars = name.toCharArray(); chars[0] -= 32; return String.valueOf(chars); }", "public static String capitalize(String name){ if (name == null || name.length() == 0) { return name; } return name.substring(0, 1).toUpperCase() + name.substring(1); }", "public static String capitalize(String name){ name = name.toLowerCase(); if (name.length() > 1) { name = name.substring(0, 1).toUpperCase() + name.substring(1); } return name; }", "public static String capitalize(String name){ char[] chars = name.toCharArray(); chars[0] -= 32; return String.valueOf(chars); }", "public static String capitalize(String name){ if (name == null || name.length() == 0) return name; char[] chars = name.toCharArray(); chars[0] = Character.toUpperCase(chars[0]); return new String(chars); }"], "code_level": "slib_runnable", "_id": "636766821a6d9265ec0174bf", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String unescapeJava(String str) throws Exception {\n  return unescapeJava(str, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  return StringEscapeUtils.unescapeJava(str);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  str = str.replaceAll(\"\\\\\\\\\", \"\");\n  StringWriter sw = new StringWriter();\n  int i = 0;\n  char c;\n  while (i < str.length()) {\n    c = str.charAt(i);\n    if (c == '\\\\') {\n      i++;\n      if (i < str.length()) {\n        c = str.charAt(i);\n        switch (c) {\n          case 'u':\n            sw.write(unescapeUnicode(str.substring(i + 1, i + 6), false));\n            i += 6;\n            break;\n          case 't':\n            sw.write(unescapeUnicode(str.substring(i + 1, i + 3), true));\n            i += 3;\n            break;\n          default:\n            throw new Exception(\"Invalid escape character: \" + c);\n        }\n      } else {\n        sw.write(\"\\\\t\");\n        i++;\n      }\n    } else {\n      sw.write(c);\n      i++;\n    }\n  }\n  return sw.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  StringBuffer buf = new StringBuffer();\n  int i = 0;\n  while (i < str.length()) {\n    int ch = str.charAt(i);\n    if (ch == '\\\\') {\n      i++;\n      ch = str.charAt(i);\n      if (ch == 'n' || ch == 'r' || ch == 't' || ch == 'b') {\n        buf.append('\\\\');\n      } else {\n        buf.append('\\\\');\n      }\n    } else {\n      buf.append((char) ch);\n    }\n    i++;\n  }\n  return buf.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  StringBuffer buf = new StringBuffer();\n  int len = str.length();\n  int i = 0;\n  while (i < len) {\n    char c = str.charAt(i);\n    if (c == '\\\\') {\n      i++;\n      if (i >= len) {\n        throw new Exception(\"Invalid escape sequence: \" + str);\n      }\n      c = str.charAt(i);\n      switch (c) {\n        case 'n':\n          buf.append('\\n');\n          break;\n        case 'r':\n          buf.append('\\r');\n          break;\n        case 't':\n          buf.append('\\t');\n          break;\n        case 'b':\n          buf.append('\\b');\n          break;\n        case 'f':\n          buf.append('\\f');\n          break;\n        case '\\'':\n          buf.append('\\'');\n          break;\n        case '\\\"':\n          buf.append('\\\"');\n          break;\n        case '\\\\':\n          buf.append('\\\\');\n          break;\n        case 'u':\n          {\n            int j = i + 1;\n            int k = -1;\n            if (j < len && str.charAt(j) == 'u') {\n              k = 2;\n            } else {\n              k = i + 2;\n            }\n            int v = Integer.parseInt(str.substring(i + 1, j), 16);\n            i = j + 1;\n            if (k >= 0 && k < 8) {\n              buf.append((char) ((v >>> (k * 8)) & 0xff));\n            } else {\n              throw new Exception(\"Invalid escape sequence: \" + str);\n            }\n          }\n          break;\n        default:\n          throw new Exception(\"Invalid escape sequence: \" + str);\n      }\n    } else {\n      buf.append(c);\n      i++;\n    }\n  }\n  return buf.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  int sz = str.length();\n  StringBuffer buf = new StringBuffer(sz);\n  for (int i = 0; i < sz; i++) {\n    char ch = str.charAt(i);\n    if (ch == '\\\\') {\n      if (++i < sz) {\n        switch (str.charAt(i)) {\n          case 'b':\n            buf.append('\\b');\n            break;\n          case 't':\n            buf.append('\\t');\n            break;\n          case 'n':\n            buf.append('\\n');\n            break;\n          case 'f':\n            buf.append('\\f');\n            break;\n          case 'r':\n            buf.append('\\r');\n            break;\n          case '\"':\n            buf.append('\"');\n            break;\n          case '\\'':\n            buf.append('\\'');\n            break;\n          case '\\\\':\n            buf.append('\\\\');\n            break;\n          default:\n            if (ch > 0xf) {\n              throw new Exception(\"Illegal escape sequence '\" + ch + \"'\");\n            }\n            buf.append(ch);\n            break;\n        }\n      }\n    } else {\n      buf.append(ch);\n    }\n  }\n  return buf.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  return unescapeJava(str, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  StringBuffer buf = new StringBuffer();\n  int i = 0;\n  int len = str.length();\n  while (i < len) {\n    char c = str.charAt(i);\n    if (c == '\\\\') {\n      char c2 = str.charAt(++i);\n      if (c2 == 'u') {\n        int u = Character.digit(str.charAt(++i), 16);\n        int l = Character.digit(str.charAt(++i), 16);\n        buf.append((char) ((u << 4) + l));\n      } else {\n        throw new Exception(\"Invalid escape sequence \\\\\" + str.charAt(i));\n      }\n    } else {\n      buf.append(c);\n    }\n    i++;\n  }\n  return buf.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  int len = str.length();\n  StringBuilder buf = new StringBuilder(len);\n  for (int i = 0; i < len; i++) {\n    char ch = str.charAt(i);\n    if (ch == '\\\\') {\n      if (++i < len) {\n        ch = str.charAt(i);\n        switch (ch) {\n          case 'b':\n            buf.append('\\b');\n            break;\n          case 'f':\n            buf.append('\\f');\n            break;\n          case 'n':\n            buf.append('\\n');\n            break;\n          case 'r':\n            buf.append('\\r');\n            break;\n          case 't':\n            buf.append('\\t');\n            break;\n          case 'u':\n            char[] hex = new char[4];\n            for (int j = 0; j < 4; j++) {\n              char h = str.charAt(++i);\n              int v = Character.digit(h, 16);\n              hex[j] = (char) v;\n            }\n            buf.append(new String(hex));\n            break;\n          default:\n            buf.append(ch);\n        }\n      } else {\n        throw new Exception(\"Invalid escape sequence\");\n      }\n    } else {\n      buf.append(ch);\n    }\n  }\n  return buf.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n  return unescapeJava(str, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code> into a newline character, unless the <code>'\\'</code> is preceded by another <code>'\\'</code>.</p>\n * @param str the <code>String</code> to unescape, may be null\n * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n */\n", "method_name": "unescapeJava", "codes": ["public static String unescapeJava(String str) throws Exception { return unescapeJava(str, true); }", "public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } return StringEscapeUtils.unescapeJava(str); }", "public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } str = str.replaceAll(\"\\\\\\\\\", \"\"); StringWriter sw = new StringWriter(); int i = 0; char c; while (i < str.length()) { c = str.charAt(i); if (c == '\\\\') { i++; if (i < str.length()) { c = str.charAt(i); switch(c) { case 'u': sw.write(unescapeUnicode(str.substring(i + 1, i + 6), false)); i += 6; break; case 't': sw.write(unescapeUnicode(str.substring(i + 1, i + 3), true)); i += 3; break; default: throw new Exception(\"Invalid escape character: \" + c); } } else { sw.write(\"\\\\t\"); i++; } } else { sw.write(c); i++; } } return sw.toString(); }", "public static String unescapeJava(String str) throws Exception { StringBuffer buf = new StringBuffer(); int i = 0; while (i < str.length()) { int ch = str.charAt(i); if (ch == '\\\\') { i++; ch = str.charAt(i); if (ch == 'n' || ch == 'r' || ch == 't' || ch == 'b') { buf.append('\\\\'); } else { buf.append('\\\\'); } } else { buf.append((char) ch); } i++; } return buf.toString(); }", "public static String unescapeJava(String str) throws Exception { StringBuffer buf = new StringBuffer(); int len = str.length(); int i = 0; while (i < len) { char c = str.charAt(i); if (c == '\\\\') { i++; if (i >= len) { throw new Exception(\"Invalid escape sequence: \" + str); } c = str.charAt(i); switch(c) { case 'n': buf.append('\\n'); break; case 'r': buf.append('\\r'); break; case 't': buf.append('\\t'); break; case 'b': buf.append('\\b'); break; case 'f': buf.append('\\f'); break; case '\\'': buf.append('\\''); break; case '\\\"': buf.append('\\\"'); break; case '\\\\': buf.append('\\\\'); break; case 'u': { int j = i + 1; int k = -1; if (j < len && str.charAt(j) == 'u') { k = 2; } else { k = i + 2; } int v = Integer.parseInt(str.substring(i + 1, j), 16); i = j + 1; if (k >= 0 && k < 8) { buf.append((char) ((v >>> (k * 8)) & 0xff)); } else { throw new Exception(\"Invalid escape sequence: \" + str); } } break; default: throw new Exception(\"Invalid escape sequence: \" + str); } } else { buf.append(c); i++; } } return buf.toString(); }", "public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } int sz = str.length(); StringBuffer buf = new StringBuffer(sz); for (int i = 0; i < sz; i++) { char ch = str.charAt(i); if (ch == '\\\\') { if (++i < sz) { switch(str.charAt(i)) { case 'b': buf.append('\\b'); break; case 't': buf.append('\\t'); break; case 'n': buf.append('\\n'); break; case 'f': buf.append('\\f'); break; case 'r': buf.append('\\r'); break; case '\"': buf.append('\"'); break; case '\\'': buf.append('\\''); break; case '\\\\': buf.append('\\\\'); break; default: if (ch > 0xf) { throw new Exception(\"Illegal escape sequence '\" + ch + \"'\"); } buf.append(ch); break; } } } else { buf.append(ch); } } return buf.toString(); }", "public static String unescapeJava(String str) throws Exception { return unescapeJava(str, true); }", "public static String unescapeJava(String str) throws Exception { StringBuffer buf = new StringBuffer(); int i = 0; int len = str.length(); while (i < len) { char c = str.charAt(i); if (c == '\\\\') { char c2 = str.charAt(++i); if (c2 == 'u') { int u = Character.digit(str.charAt(++i), 16); int l = Character.digit(str.charAt(++i), 16); buf.append((char) ((u << 4) + l)); } else { throw new Exception(\"Invalid escape sequence \\\\\" + str.charAt(i)); } } else { buf.append(c); } i++; } return buf.toString(); }", "public static String unescapeJava(String str) throws Exception { if (str == null) { return null; } int len = str.length(); StringBuilder buf = new StringBuilder(len); for (int i = 0; i < len; i++) { char ch = str.charAt(i); if (ch == '\\\\') { if (++i < len) { ch = str.charAt(i); switch(ch) { case 'b': buf.append('\\b'); break; case 'f': buf.append('\\f'); break; case 'n': buf.append('\\n'); break; case 'r': buf.append('\\r'); break; case 't': buf.append('\\t'); break; case 'u': char[] hex = new char[4]; for (int j = 0; j < 4; j++) { char h = str.charAt(++i); int v = Character.digit(h, 16); hex[j] = (char) v; } buf.append(new String(hex)); break; default: buf.append(ch); } } else { throw new Exception(\"Invalid escape sequence\"); } } else { buf.append(ch); } } return buf.toString(); }", "public static String unescapeJava(String str) throws Exception { return unescapeJava(str, null); }"], "code_level": "slib_runnable", "_id": "6367667d1a6d9265ec017401", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private static char decodeHexNibble(final char c) {\n  return (char) (((c - '0') * 10) + '0');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if ('0' <= c && c <= '9') {\n    return (char) (c - '0');\n  } else if ('a' <= c && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  } else if ('A' <= c && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  } else {\n    return c;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  switch (c) {\n    case '0':\n      return '0';\n    case '1':\n      return '1';\n    case '2':\n      return '2';\n    case '3':\n      return '3';\n    case '4':\n      return '4';\n    case '5':\n      return '5';\n    case '6':\n      return '6';\n    case '7':\n      return '7';\n    case '8':\n      return '8';\n    case '9':\n      return '9';\n    case 'a':\n      return 'A';\n    case 'b':\n      return 'B';\n    case 'c':\n      return 'C';\n    case 'd':\n      return 'D';\n    case 'e':\n      return 'E';\n    case 'f':\n      return 'F';\n    default:\n      throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if ('0' <= c && c <= '9') {\n    return (char) (c - '0');\n  }\n  if ('a' <= c && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  }\n  if ('A' <= c && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  }\n  throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if ((c >= '0') && (c <= '9')) {\n    return (char) ((c - '0') + ('A' - 'a'));\n  } else if ((c >= 'A') && (c <= 'F')) {\n    return (char) ((c - 'A') + ('0' - 'a'));\n  } else if ((c >= 'a') && (c <= 'f')) {\n    return (char) ((c - 'a') + ('0' - 'a'));\n  } else {\n    return ' ';\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c;\n  } else if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  } else {\n    throw new IllegalArgumentException(\"Invalid hexadecimal digit: \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return (char) (c - '0');\n  }\n  if (c >= 'a' && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  }\n  if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  }\n  throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c;\n  } else if (c >= 'a' && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  } else if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  } else {\n    throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  if (c >= '0' && c <= '9') {\n    return (char) (c - '0');\n  } else if (c >= 'A' && c <= 'F') {\n    return (char) (c - 'A' + 10);\n  } else if (c >= 'a' && c <= 'f') {\n    return (char) (c - 'a' + 10);\n  } else {\n    throw new IllegalArgumentException(\"Invalid hex digit: \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c) {\n  return (char) (c <= 'F' ? ((c & 0xF0) >> 4) | 0xF : (c & 0x0F) | 0x10);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}.\n * @return The hexadecimal value represented in the ASCII charactergiven, or  {@link Character#MAX_VALUE} if the character is invalid.\n */\n", "method_name": "decodeHexNibble", "codes": ["private static char decodeHexNibble(final char c){ return (char) (((c - '0') * 10) + '0'); }", "private static char decodeHexNibble(final char c){ if ('0' <= c && c <= '9') { return (char) (c - '0'); } else if ('a' <= c && c <= 'f') { return (char) (c - 'a' + 10); } else if ('A' <= c && c <= 'F') { return (char) (c - 'A' + 10); } else { return c; } }", "private static char decodeHexNibble(final char c){ switch(c) { case '0': return '0'; case '1': return '1'; case '2': return '2'; case '3': return '3'; case '4': return '4'; case '5': return '5'; case '6': return '6'; case '7': return '7'; case '8': return '8'; case '9': return '9'; case 'a': return 'A'; case 'b': return 'B'; case 'c': return 'C'; case 'd': return 'D'; case 'e': return 'E'; case 'f': return 'F'; default: throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c); } }", "private static char decodeHexNibble(final char c){ if ('0' <= c && c <= '9') { return (char) (c - '0'); } if ('a' <= c && c <= 'f') { return (char) (c - 'a' + 10); } if ('A' <= c && c <= 'F') { return (char) (c - 'A' + 10); } throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c); }", "private static char decodeHexNibble(final char c){ if ((c >= '0') && (c <= '9')) { return (char) ((c - '0') + ('A' - 'a')); } else if ((c >= 'A') && (c <= 'F')) { return (char) ((c - 'A') + ('0' - 'a')); } else if ((c >= 'a') && (c <= 'f')) { return (char) ((c - 'a') + ('0' - 'a')); } else { return ' '; } }", "private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return c; } else if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } else { throw new IllegalArgumentException(\"Invalid hexadecimal digit: \" + c); } }", "private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return (char) (c - '0'); } if (c >= 'a' && c <= 'f') { return (char) (c - 'a' + 10); } if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c); }", "private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return c; } else if (c >= 'a' && c <= 'f') { return (char) (c - 'a' + 10); } else if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } else { throw new IllegalArgumentException(\"Invalid hexadecimal number: \" + c); } }", "private static char decodeHexNibble(final char c){ if (c >= '0' && c <= '9') { return (char) (c - '0'); } else if (c >= 'A' && c <= 'F') { return (char) (c - 'A' + 10); } else if (c >= 'a' && c <= 'f') { return (char) (c - 'a' + 10); } else { throw new IllegalArgumentException(\"Invalid hex digit: \" + c); } }", "private static char decodeHexNibble(final char c){ return (char) (c <= 'F' ? ((c & 0xF0) >> 4) | 0xF : (c & 0x0F) | 0x10); }"], "code_level": "slib_runnable", "_id": "636766851a6d9265ec01751b", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Type[] typeArguments = parameterizedType.getActualTypeArguments();\n    Class<?>[] arguments = new Class<?>[typeArguments.length];\n    for (int i = 0; i < arguments.length; i++) {\n      Type typeArgument = typeArguments[i];\n      if (typeArgument instanceof Class) {\n        arguments[i] = (Class<?>) typeArgument;\n      } else if (typeArgument instanceof ParameterizedType) {\n        arguments[i] = (Class<?>) ((ParameterizedType) typeArgument).getRawType();\n      } else if (typeArgument instanceof GenericArrayType) {\n        Type componentType = ((GenericArrayType) typeArgument).getGenericComponentType();\n        if (componentType instanceof Class) {\n          arguments[i] = (Class<?>) componentType;\n        } else {\n          arguments[i] = resolveArguments(componentType, targetType);\n        }\n      } else if (typeArgument instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) typeArgument;\n        Class<?> clazz = resolveClass(targetType, typeVariable.getName());\n        if (clazz != null) {\n          arguments[i] = clazz;\n        }\n      } else {\n        throw new IllegalArgumentException(\"Unsupported type argument: \" + typeArgument);\n      }\n    }\n    return arguments;\n  } else if (genericType instanceof GenericArrayType) {\n    GenericArrayType arrayType = (GenericArrayType) genericType;\n    Type componentType = arrayType.getGenericComponentType();\n    Class<?> componentClass = resolveClass(targetType, componentType.toString());\n    if (componentClass != null) {\n      return new Class<?>[] {componentClass};\n    }\n  } else if (genericType instanceof TypeVariable) {\n    TypeVariable<?> typeVariable = (TypeVariable<?>) genericType;\n    Class<?> clazz = resolveClass(targetType, typeVariable.getName());\n    if (clazz != null) {\n      return new Class<?>[] {clazz};\n    }\n  } else if (genericType instanceof WildcardType) {\n    WildcardType wildcardType = (WildcardType) genericType;\n    return new Class<?>[] {resolveClass(targetType, wildcardType.getUpperBounds()[0].toString())};\n  } else {\n    return null;\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    Class<?>[] actualArguments = new Class[actualTypeArguments.length];\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n      actualArguments[i] = resolveType(actualTypeArguments[i], targetType);\n    }\n    return actualArguments;\n  } else if (genericType instanceof Class<?>) {\n    return new Class<?>[] {resolveType(genericType, targetType)};\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    Class<?>[] result = new Class<?>[actualTypeArguments.length];\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n      result[i] = resolveType(actualTypeArguments[i], targetType);\n    }\n    return result;\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof TypeVariable) {\n    TypeVariable<?> typeVariable = (TypeVariable<?>) genericType;\n    genericType = targetType.getTypeParameters()[typeVariable.getIndex()];\n  } else if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Type rawType = parameterizedType.getRawType();\n    genericType = rawType instanceof Class ? (Class<?>) rawType : null;\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    if (actualTypeArguments.length != 1) {\n      return null;\n    }\n    Type actualTypeArgument = actualTypeArguments[0];\n    Class<?> actualTypeArgumentClass =\n        actualTypeArgument instanceof Class ? (Class<?>) actualTypeArgument : null;\n    if (actualTypeArgumentClass != null && targetType.isAssignableFrom(actualTypeArgumentClass)) {\n      return resolveArguments(actualTypeArgument, targetType);\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Type[] arguments = parameterizedType.getActualTypeArguments();\n    Class<?>[] resolvedArguments = new Class[arguments.length];\n    for (int i = 0; i < arguments.length; i++) {\n      resolvedArguments[i] = resolveType(arguments[i], targetType);\n    }\n    return resolvedArguments;\n  } else if (genericType instanceof TypeVariable) {\n    TypeVariable<?> typeVariable = (TypeVariable<?>) genericType;\n    Type[] bounds = targetType.getTypeParameters()[0].getBounds();\n    Class<?> resolvedType = resolveType(bounds[0], targetType);\n    if (resolvedType != null) {\n      return new Class[] {resolvedType};\n    }\n  } else if (genericType instanceof WildcardType) {\n    WildcardType wildcardType = (WildcardType) genericType;\n    Type[] upperBounds = wildcardType.getUpperBounds();\n    if (upperBounds.length != 1) {\n      throw new IllegalArgumentException(\n          \"Type variable \" + genericType + \" is not a wildcard type\");\n    }\n    Class<?> resolvedType = resolveType(upperBounds[0], targetType);\n    if (resolvedType != null) {\n      return new Class[] {resolvedType};\n    }\n    Type[] lowerBounds = wildcardType.getLowerBounds();\n    if (lowerBounds.length != 1) {\n      throw new IllegalArgumentException(\n          \"Type variable \" + genericType + \" is not a wildcard type\");\n    }\n    resolvedType = resolveType(lowerBounds[0], targetType);\n    if (resolvedType != null) {\n      return new Class[] {resolvedType};\n    }\n  } else {\n    throw new IllegalArgumentException(\"Cannot resolve generic type \" + genericType);\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  Type[] arguments = resolveArguments(genericType, targetType);\n  if (arguments == null) {\n    return null;\n  }\n  return Arrays.stream(arguments).map(argument -> (Class<?>) argument).toArray(Class<?>[]::new);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    return resolveArguments((ParameterizedType) genericType, targetType);\n  } else if (genericType instanceof Class<?>) {\n    return resolveArguments((Class<?>) genericType, targetType);\n  }\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    if (actualTypeArguments != null && actualTypeArguments.length == 1) {\n      Type actualTypeArgument = actualTypeArguments[0];\n      if (actualTypeArgument instanceof Class) {\n        Class<?> argumentType = (Class<?>) actualTypeArgument;\n        if (argumentType.isArray()) {\n          Class<?>[] arguments = new Class<?>[actualTypeArguments.length - 1];\n          for (int i = 1; i < actualTypeArguments.length; i++) {\n            arguments[i - 1] = (Class<?>) actualTypeArguments[i];\n          }\n          return arguments;\n        }\n      }\n    }\n  } else if (genericType instanceof GenericArrayType) {\n    Type componentType = ((GenericArrayType) genericType).getGenericComponentType();\n    if (componentType instanceof Class) {\n      Class<?> componentTypeClass = (Class<?>) componentType;\n      if (componentTypeClass.isArray()) {\n        Class<?>[] arguments = new Class<?>[actualTypeArguments.length - 1];\n        for (int i = 1; i < actualTypeArguments.length; i++) {\n          arguments[i - 1] = (Class<?>) actualTypeArguments[i];\n        }\n        return arguments;\n      }\n    }\n  } else if (genericType instanceof TypeVariable) {\n    TypeVariable<?> typeVariable = (TypeVariable<?>) genericType;\n    Type[] bounds = typeVariable.getBounds();\n    if (bounds.length == 1) {\n      return new Class<?>[] {bounds[0]};\n    }\n  } else if (genericType instanceof WildcardType) {\n    WildcardType wildcardType = (WildcardType) genericType;\n    return new Class<?>[] {wildcardType.getUpperBounds()[0]};\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  return resolveArguments(genericType, targetType, new Class[0]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n  if (genericType == null) {\n    return null;\n  }\n  if (genericType instanceof Class) {\n    return resolveArguments((Class<?>) genericType, targetType);\n  }\n  if (genericType instanceof ParameterizedType) {\n    return resolveArguments((ParameterizedType) genericType, targetType);\n  }\n  if (genericType instanceof GenericArrayType) {\n    GenericArrayType arrayType = (GenericArrayType) genericType;\n    Class<?> componentType = resolveArguments(arrayType.getGenericComponentType(), targetType);\n    return new Class<?>[] {componentType};\n  }\n  if (genericType instanceof TypeVariable) {\n    TypeVariable<?> typeVariable = (TypeVariable<?>) genericType;\n    Type[] bounds = targetType.getTypeParameters();\n    for (int i = 0; i < bounds.length; i++) {\n      if (typeVariable.getName().equals(bounds[i].getTypeName())) {\n        return resolveArguments(bounds[i], targetType);\n      }\n    }\n  }\n  if (genericType instanceof WildcardType) {\n    WildcardType wildcardType = (WildcardType) genericType;\n    Type[] upperBounds = wildcardType.getUpperBounds();\n    if (upperBounds.length == 0) {\n      return null;\n    }\n    Class<?>[] types = new Class<?>[upperBounds.length];\n    for (int i = 0; i < upperBounds.length; i++) {\n      types[i] = resolveArguments(upperBounds[i], targetType);\n    }\n    return types;\n  }\n  throw new IllegalArgumentException(\"Could not resolve type parameter: \" + genericType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.\n */\n", "method_name": "resolveArguments", "codes": ["public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Type[] typeArguments = parameterizedType.getActualTypeArguments(); Class<?>[] arguments = new Class<?>[typeArguments.length]; for (int i = 0; i < arguments.length; i++) { Type typeArgument = typeArguments[i]; if (typeArgument instanceof Class) { arguments[i] = (Class<?>) typeArgument; } else if (typeArgument instanceof ParameterizedType) { arguments[i] = (Class<?>) ((ParameterizedType) typeArgument).getRawType(); } else if (typeArgument instanceof GenericArrayType) { Type componentType = ((GenericArrayType) typeArgument).getGenericComponentType(); if (componentType instanceof Class) { arguments[i] = (Class<?>) componentType; } else { arguments[i] = resolveArguments(componentType, targetType); } } else if (typeArgument instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) typeArgument; Class<?> clazz = resolveClass(targetType, typeVariable.getName()); if (clazz != null) { arguments[i] = clazz; } } else { throw new IllegalArgumentException(\"Unsupported type argument: \" + typeArgument); } } return arguments; } else if (genericType instanceof GenericArrayType) { GenericArrayType arrayType = (GenericArrayType) genericType; Type componentType = arrayType.getGenericComponentType(); Class<?> componentClass = resolveClass(targetType, componentType.toString()); if (componentClass != null) { return new Class<?>[] { componentClass }; } } else if (genericType instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) genericType; Class<?> clazz = resolveClass(targetType, typeVariable.getName()); if (clazz != null) { return new Class<?>[] { clazz }; } } else if (genericType instanceof WildcardType) { WildcardType wildcardType = (WildcardType) genericType; return new Class<?>[] { resolveClass(targetType, wildcardType.getUpperBounds()[0].toString()) }; } else { return null; } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); Class<?>[] actualArguments = new Class[actualTypeArguments.length]; for (int i = 0; i < actualTypeArguments.length; i++) { actualArguments[i] = resolveType(actualTypeArguments[i], targetType); } return actualArguments; } else if (genericType instanceof Class<?>) { return new Class<?>[] { resolveType(genericType, targetType) }; } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); Class<?>[] result = new Class<?>[actualTypeArguments.length]; for (int i = 0; i < actualTypeArguments.length; i++) { result[i] = resolveType(actualTypeArguments[i], targetType); } return result; } else { return null; } }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) genericType; genericType = targetType.getTypeParameters()[typeVariable.getIndex()]; } else if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Type rawType = parameterizedType.getRawType(); genericType = rawType instanceof Class ? (Class<?>) rawType : null; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments.length != 1) { return null; } Type actualTypeArgument = actualTypeArguments[0]; Class<?> actualTypeArgumentClass = actualTypeArgument instanceof Class ? (Class<?>) actualTypeArgument : null; if (actualTypeArgumentClass != null && targetType.isAssignableFrom(actualTypeArgumentClass)) { return resolveArguments(actualTypeArgument, targetType); } } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Type[] arguments = parameterizedType.getActualTypeArguments(); Class<?>[] resolvedArguments = new Class[arguments.length]; for (int i = 0; i < arguments.length; i++) { resolvedArguments[i] = resolveType(arguments[i], targetType); } return resolvedArguments; } else if (genericType instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) genericType; Type[] bounds = targetType.getTypeParameters()[0].getBounds(); Class<?> resolvedType = resolveType(bounds[0], targetType); if (resolvedType != null) { return new Class[] { resolvedType }; } } else if (genericType instanceof WildcardType) { WildcardType wildcardType = (WildcardType) genericType; Type[] upperBounds = wildcardType.getUpperBounds(); if (upperBounds.length != 1) { throw new IllegalArgumentException(\"Type variable \" + genericType + \" is not a wildcard type\"); } Class<?> resolvedType = resolveType(upperBounds[0], targetType); if (resolvedType != null) { return new Class[] { resolvedType }; } Type[] lowerBounds = wildcardType.getLowerBounds(); if (lowerBounds.length != 1) { throw new IllegalArgumentException(\"Type variable \" + genericType + \" is not a wildcard type\"); } resolvedType = resolveType(lowerBounds[0], targetType); if (resolvedType != null) { return new Class[] { resolvedType }; } } else { throw new IllegalArgumentException(\"Cannot resolve generic type \" + genericType); } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ Type[] arguments = resolveArguments(genericType, targetType); if (arguments == null) { return null; } return Arrays.stream(arguments).map(argument -> (Class<?>) argument).toArray(Class<?>[]::new); }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { return resolveArguments((ParameterizedType) genericType, targetType); } else if (genericType instanceof Class<?>) { return resolveArguments((Class<?>) genericType, targetType); } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) genericType; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments != null && actualTypeArguments.length == 1) { Type actualTypeArgument = actualTypeArguments[0]; if (actualTypeArgument instanceof Class) { Class<?> argumentType = (Class<?>) actualTypeArgument; if (argumentType.isArray()) { Class<?>[] arguments = new Class<?>[actualTypeArguments.length - 1]; for (int i = 1; i < actualTypeArguments.length; i++) { arguments[i - 1] = (Class<?>) actualTypeArguments[i]; } return arguments; } } } } else if (genericType instanceof GenericArrayType) { Type componentType = ((GenericArrayType) genericType).getGenericComponentType(); if (componentType instanceof Class) { Class<?> componentTypeClass = (Class<?>) componentType; if (componentTypeClass.isArray()) { Class<?>[] arguments = new Class<?>[actualTypeArguments.length - 1]; for (int i = 1; i < actualTypeArguments.length; i++) { arguments[i - 1] = (Class<?>) actualTypeArguments[i]; } return arguments; } } } else if (genericType instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) genericType; Type[] bounds = typeVariable.getBounds(); if (bounds.length == 1) { return new Class<?>[] { bounds[0] }; } } else if (genericType instanceof WildcardType) { WildcardType wildcardType = (WildcardType) genericType; return new Class<?>[] { wildcardType.getUpperBounds()[0] }; } return null; }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ return resolveArguments(genericType, targetType, new Class[0]); }", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){ if (genericType == null) { return null; } if (genericType instanceof Class) { return resolveArguments((Class<?>) genericType, targetType); } if (genericType instanceof ParameterizedType) { return resolveArguments((ParameterizedType) genericType, targetType); } if (genericType instanceof GenericArrayType) { GenericArrayType arrayType = (GenericArrayType) genericType; Class<?> componentType = resolveArguments(arrayType.getGenericComponentType(), targetType); return new Class<?>[] { componentType }; } if (genericType instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) genericType; Type[] bounds = targetType.getTypeParameters(); for (int i = 0; i < bounds.length; i++) { if (typeVariable.getName().equals(bounds[i].getTypeName())) { return resolveArguments(bounds[i], targetType); } } } if (genericType instanceof WildcardType) { WildcardType wildcardType = (WildcardType) genericType; Type[] upperBounds = wildcardType.getUpperBounds(); if (upperBounds.length == 0) { return null; } Class<?>[] types = new Class<?>[upperBounds.length]; for (int i = 0; i < upperBounds.length; i++) { types[i] = resolveArguments(upperBounds[i], targetType); } return types; } throw new IllegalArgumentException(\"Could not resolve type parameter: \" + genericType); }"], "code_level": "class_runnable", "_id": "636766821a6d9265ec0174b6", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  if (typeVariable.getBounds().length == 0) {\n    return Unknown.class;\n  }\n  return resolveBound(typeVariable.getBounds()[0]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  if (typeVariable.getBounds().length == 0) {\n    return Unknown.class;\n  }\n  return resolveBound(typeVariable.getBounds()[0]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  if (typeVariable.getBounds().length == 1) {\n    return resolveBound(typeVariable.getBounds()[0]);\n  }\n  return Unknown.class;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  Type type = typeVariable.getBounds()[0];\n  if (type instanceof Class) {\n    return resolveBound((Class) type);\n  }\n  return type;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  if (typeVariable.getBounds().length == 0) {\n    return Unknown.class;\n  }\n  return resolveBound(typeVariable.getBounds()[0]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  Type type = typeVariable.getBounds()[0];\n  while (type instanceof Class) {\n    type = ((Class) type).getGenericSuperclass();\n  }\n  return type;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  Type type = typeVariable.getBounds()[0];\n  while (type instanceof TypeVariable) {\n    type = ((TypeVariable<?>) type).getBounds()[0];\n  }\n  return type;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  return resolveBound(typeVariable, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  return resolveBound(typeVariable, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable) {\n  return resolveBound(typeVariable, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Resolves the first bound for the  {@code typeVariable}, returning  {@code Unknown.class} if nonecan be resolved.\n */\n", "method_name": "resolveBound", "codes": ["public static Type resolveBound(TypeVariable<?> typeVariable){ if (typeVariable.getBounds().length == 0) { return Unknown.class; } return resolveBound(typeVariable.getBounds()[0]); }", "public static Type resolveBound(TypeVariable<?> typeVariable){ if (typeVariable.getBounds().length == 0) { return Unknown.class; } return resolveBound(typeVariable.getBounds()[0]); }", "public static Type resolveBound(TypeVariable<?> typeVariable){ if (typeVariable.getBounds().length == 1) { return resolveBound(typeVariable.getBounds()[0]); } return Unknown.class; }", "public static Type resolveBound(TypeVariable<?> typeVariable){ Type type = typeVariable.getBounds()[0]; if (type instanceof Class) { return resolveBound((Class) type); } return type; }", "public static Type resolveBound(TypeVariable<?> typeVariable){ if (typeVariable.getBounds().length == 0) { return Unknown.class; } return resolveBound(typeVariable.getBounds()[0]); }", "public static Type resolveBound(TypeVariable<?> typeVariable){ Type type = typeVariable.getBounds()[0]; while (type instanceof Class) { type = ((Class) type).getGenericSuperclass(); } return type; }", "public static Type resolveBound(TypeVariable<?> typeVariable){ Type type = typeVariable.getBounds()[0]; while (type instanceof TypeVariable) { type = ((TypeVariable<?>) type).getBounds()[0]; } return type; }", "public static Type resolveBound(TypeVariable<?> typeVariable){ return resolveBound(typeVariable, null); }", "public static Type resolveBound(TypeVariable<?> typeVariable){ return resolveBound(typeVariable, null); }", "public static Type resolveBound(TypeVariable<?> typeVariable){ return resolveBound(typeVariable, null); }"], "code_level": "slib_runnable", "_id": "6367667d1a6d9265ec01741d", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequest(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  if (request == null) {\n    return null;\n  }\n  AtmosphereRequestWrapper w = new AtmosphereRequestWrapper(request);\n  w.request = request;\n  w.request.setAttribute(\n      FrameworkConfig.class.getName(),\n      new ServletConfig() {\n        @Override\n        public String getServletName() {\n          return w.getServletName();\n        }\n\n        @Override\n        public ServletContext getServletContext() {\n          return w.getServletContext();\n        }\n\n        @Override\n        public String getInitParameter(String name) {\n          return w.getInitParameter(name);\n        }\n\n        @Override\n        public Enumeration<String> getInitParameterNames() {\n          return w.getInitParameterNames();\n        }\n      });\n  return w;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  if (request instanceof AtmosphereRequest) {\n    return (AtmosphereRequest) request;\n  } else {\n    return new AtmosphereRequestImpl(request);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  if (request instanceof AtmosphereRequest) {\n    return (AtmosphereRequest) request;\n  }\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  if (request instanceof AtmosphereRequest) {\n    return (AtmosphereRequest) request;\n  } else {\n    return new AtmosphereRequestImpl(request);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(\n      request,\n      new AtmosphereRequestImpl.Builder(\n              request,\n              new AtmosphereResponseImpl.Builder(\n                      request, new AtmosphereResponseImpl.Builder().build())\n                  .build())\n          .build());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequest(\n      request,\n      new AtmosphereResponse(\n          new ServletRequestWrapper(request), new ServletResponseWrapper(request)));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequest(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request) {\n  return new AtmosphereRequestImpl(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Wrap an  {@link HttpServletRequest}.\n * @param request {@link HttpServletRequest}\n * @return an {@link AtmosphereRequest}\n */\n", "method_name": "wrap", "codes": ["public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequest(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ if (request == null) { return null; } AtmosphereRequestWrapper w = new AtmosphereRequestWrapper(request); w.request = request; w.request.setAttribute(FrameworkConfig.class.getName(), new ServletConfig() { @Override public String getServletName() { return w.getServletName(); } @Override public ServletContext getServletContext() { return w.getServletContext(); } @Override public String getInitParameter(String name) { return w.getInitParameter(name); } @Override public Enumeration<String> getInitParameterNames() { return w.getInitParameterNames(); } }); return w; }", "public static AtmosphereRequest wrap(HttpServletRequest request){ if (request instanceof AtmosphereRequest) { return (AtmosphereRequest) request; } else { return new AtmosphereRequestImpl(request); } }", "public static AtmosphereRequest wrap(HttpServletRequest request){ if (request instanceof AtmosphereRequest) { return (AtmosphereRequest) request; } return new AtmosphereRequestImpl(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ if (request instanceof AtmosphereRequest) { return (AtmosphereRequest) request; } else { return new AtmosphereRequestImpl(request); } }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request, new AtmosphereRequestImpl.Builder(request, new AtmosphereResponseImpl.Builder(request, new AtmosphereResponseImpl.Builder().build()).build()).build()); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequest(request, new AtmosphereResponse(new ServletRequestWrapper(request), new ServletResponseWrapper(request))); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequest(request); }", "public static AtmosphereRequest wrap(HttpServletRequest request){ return new AtmosphereRequestImpl(request); }"], "code_level": "class_runnable", "_id": "636766821a6d9265ec0174d2", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){ if (mapping == null) return this; AtmosphereHandler handler = atmosphereHandlers.remove(mapping); if (handler != null) { if (log.isDebugEnabled()) log.debug(\"Removing AtmosphereHandler \" + mapping + \" for AtmosphereResource {\" + getID() + \"}\"); if (!isInit) { try { if (isInit = handler.getClass().getMethod(\"initialize\", new Class[0]).invoke(handler, new Object[0])) { if (isInit) { if (!isInitialized()) { if (!isInitializing()) { if (!isInitialized()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) {", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  return (AtmosphereFramework) framework.removeAtmosphereHandler(mapping);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  synchronized (atmosphereHandlersLock) {\n    AtmosphereHandler handler = atmosphereHandlers.remove(mapping);\n    if (handler != null) {\n      broadcaster.removeAtmosphereHandler(handler);\n      if (AtmosphereInterceptorFactory.class.isAssignableFrom(handler.getClass())) {\n        for (AtmosphereInterceptor interceptor :\n            ((AtmosphereInterceptorFactory) handler).interceptors()) {\n          broadcaster.addAtmosphereHandler(interceptor.getClass().getName(), interceptor);\n        }\n      }\n    }\n    return this;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  return (AtmosphereFramework) broadcaster.removeAtmosphereHandler(mapping);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  if (mapping == null) {\n    return this;\n  }\n  AtmosphereHandlerWrapper w = (AtmosphereHandlerWrapper) atmosphereHandlers.remove(mapping);\n  if (w != null) {\n    w.atmosphereHandler.destroy();\n  }\n  return this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  AtmosphereHandler h = (AtmosphereHandler) atmosphereHandlers.remove(mapping);\n  if (h != null) {\n    h.destroy();\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  if (mapping == null) return this;\n  if (mapping.startsWith(\"/\")) {\n    mapping = mapping.substring(1);\n  }\n  if (mapping.endsWith(\"/\")) {\n    mapping = mapping.substring(0, mapping.length() - 1);\n  }\n  if (mapping.equals(\"*\")) {\n    broadcaster.removeAtmosphereHandler(\"*\");\n  } else if (mapping.equals(\"/*\")) {\n    broadcaster.removeAtmosphereHandler(\"/*\");\n  } else {\n    synchronized (atmosphereHandlers) {\n      AtmosphereHandler a = broadcaster.removeAtmosphereHandler(mapping);\n      if (a != null) {\n        if (a.getClass().getName().equals(mapping)) {\n          broadcaster.addAtmosphereHandler(mapping, a);\n        } else {\n          logger.warn(\"Removed invalid mapping: {}\", mapping);\n        }\n      }\n    }\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  return (AtmosphereFramework) broadcaster.removeAtmosphereHandler(mapping);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  if (mapping == null) return this;\n  AtmosphereHandlerWrapper h = (AtmosphereHandlerWrapper) atmosphereHandlers.remove(mapping);\n  if (h != null) {\n    h.removeAtmosphereHandler();\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n  return (AtmosphereFramework) framework.remove(mapping);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Remove an  {@link AtmosphereHandler}.\n * @param mapping the mapping used when invoking {@link #addAtmosphereHandler(String,AtmosphereHandler)};\n * @return true if removed\n */\n", "method_name": "removeAtmosphereHandler", "codes": ["public AtmosphereFramework removeAtmosphereHandler(String mapping){ if (mapping == null) return this; AtmosphereHandler handler = atmosphereHandlers.remove(mapping); if (handler != null) { if (log.isDebugEnabled()) log.debug(\"Removing AtmosphereHandler \" + mapping + \" for AtmosphereResource {\" + getID() + \"}\"); if (!isInit) { try { if (isInit = handler.getClass().getMethod(\"initialize\", new Class[0]).invoke(handler, new Object[0])) { if (isInit) { if (!isInitialized()) { if (!isInitializing()) { if (!isInitialized()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) { if (!isInitializing()) {", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ return (AtmosphereFramework) framework.removeAtmosphereHandler(mapping); }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ synchronized (atmosphereHandlersLock) { AtmosphereHandler handler = atmosphereHandlers.remove(mapping); if (handler != null) { broadcaster.removeAtmosphereHandler(handler); if (AtmosphereInterceptorFactory.class.isAssignableFrom(handler.getClass())) { for (AtmosphereInterceptor interceptor : ((AtmosphereInterceptorFactory) handler).interceptors()) { broadcaster.addAtmosphereHandler(interceptor.getClass().getName(), interceptor); } } } return this; } }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ return (AtmosphereFramework) broadcaster.removeAtmosphereHandler(mapping); }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ if (mapping == null) { return this; } AtmosphereHandlerWrapper w = (AtmosphereHandlerWrapper) atmosphereHandlers.remove(mapping); if (w != null) { w.atmosphereHandler.destroy(); } return this; }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ AtmosphereHandler h = (AtmosphereHandler) atmosphereHandlers.remove(mapping); if (h != null) { h.destroy(); } return this; }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ if (mapping == null) return this; if (mapping.startsWith(\"/\")) { mapping = mapping.substring(1); } if (mapping.endsWith(\"/\")) { mapping = mapping.substring(0, mapping.length() - 1); } if (mapping.equals(\"*\")) { broadcaster.removeAtmosphereHandler(\"*\"); } else if (mapping.equals(\"/*\")) { broadcaster.removeAtmosphereHandler(\"/*\"); } else { synchronized (atmosphereHandlers) { AtmosphereHandler a = broadcaster.removeAtmosphereHandler(mapping); if (a != null) { if (a.getClass().getName().equals(mapping)) { broadcaster.addAtmosphereHandler(mapping, a); } else { logger.warn(\"Removed invalid mapping: {}\", mapping); } } } } return this; }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ return (AtmosphereFramework) broadcaster.removeAtmosphereHandler(mapping); }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ if (mapping == null) return this; AtmosphereHandlerWrapper h = (AtmosphereHandlerWrapper) atmosphereHandlers.remove(mapping); if (h != null) { h.removeAtmosphereHandler(); } return this; }", "public AtmosphereFramework removeAtmosphereHandler(String mapping){ return (AtmosphereFramework) framework.remove(mapping); }"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec017458", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "protected Object filter(Object msg) {\n  if (msg == null) {\n    return null;\n  }\n  String action = msg.getClass().getSimpleName();\n  if (action.equals(BroadcastAction.class.getSimpleName())) {\n    return msg;\n  } else {\n    return null;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg != null && msg instanceof ActionMessage) {\n    ActionMessage actionMessage = (ActionMessage) msg;\n    if (actionMessage.getAction().equals(Action.Broadcast)) {\n      if (!broadcastRequest.isEmpty()) {\n        return broadcastRequest.remove(0);\n      }\n    }\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg == null) {\n    return null;\n  }\n  if (msg instanceof BroadcastAction) {\n    return filter((BroadcastAction) msg);\n  } else if (msg instanceof Object[]) {\n    return filter((Object[]) msg);\n  }\n  return msg;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg == null) {\n    return null;\n  }\n  if (msg instanceof BroadcastAction) {\n    return filter((BroadcastAction) msg);\n  } else {\n    return msg;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Object filter(Object msg) {\n  return null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg == null) return null;\n  if (msg instanceof BroadcastAction) {\n    BroadcastAction action = (BroadcastAction) msg;\n    if (action.getActionMessage() == null) return null;\n    return action.getActionMessage();\n  }\n  if (msg instanceof Message) {\n    Message message = (Message) msg;\n    if (message.getActionMessage() == null) return null;\n    return message.getActionMessage();\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg instanceof BroadcastAction) {\n    BroadcastAction m = (BroadcastAction) msg;\n    if (m.getAction() == null) {\n      return null;\n    }\n    if (m.getAction().equals(BroadcastAction.BROADCAST_ACTION_TYPE_ACTION)) {\n      return m.getActionMessage();\n    } else if (m.getAction().equals(BroadcastAction.BROADCAST_ACTION_TYPE_ERROR)) {\n      return \"An error occured while executing the action: \" + m.getActionMessage();\n    }\n  }\n  return msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg == null) {\n    return null;\n  }\n  if (msg instanceof BroadcastAction) {\n    return msg;\n  }\n  return getActionMessage(msg);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg) {\n  return msg;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Object filter(Object msg) {\n  if (msg instanceof BroadcastAction) {\n    BroadcastAction a = (BroadcastAction) msg;\n    if (a.getAction().equals(Action.NULL)) {\n      msg = null;\n    }\n  }\n  if (msg == null) {\n    return null;\n  }\n  if (msg instanceof Message) {\n    Message m = (Message) msg;\n    if (m.getMessageType().equals(MessageType.BROADCAST)) {\n      return null;\n    }\n  }\n  return msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Invoke the  {@link BroadcastFilter}\n * @param msg\n * @return\n */\n", "method_name": "filter", "codes": ["protected Object filter(Object msg){ if (msg == null) { return null; } String action = msg.getClass().getSimpleName(); if (action.equals(BroadcastAction.class.getSimpleName())) { return msg; } else { return null; } }", "protected Object filter(Object msg){ if (msg != null && msg instanceof ActionMessage) { ActionMessage actionMessage = (ActionMessage) msg; if (actionMessage.getAction().equals(Action.Broadcast)) { if (!broadcastRequest.isEmpty()) { return broadcastRequest.remove(0); } } } return null; }", "protected Object filter(Object msg){ if (msg == null) { return null; } if (msg instanceof BroadcastAction) { return filter((BroadcastAction) msg); } else if (msg instanceof Object[]) { return filter((Object[]) msg); } return msg; }", "protected Object filter(Object msg){ if (msg == null) { return null; } if (msg instanceof BroadcastAction) { return filter((BroadcastAction) msg); } else { return msg; } }", "protected Object filter(Object msg){ return null; }", "protected Object filter(Object msg){ if (msg == null) return null; if (msg instanceof BroadcastAction) { BroadcastAction action = (BroadcastAction) msg; if (action.getActionMessage() == null) return null; return action.getActionMessage(); } if (msg instanceof Message) { Message message = (Message) msg; if (message.getActionMessage() == null) return null; return message.getActionMessage(); } return null; }", "protected Object filter(Object msg){ if (msg instanceof BroadcastAction) { BroadcastAction m = (BroadcastAction) msg; if (m.getAction() == null) { return null; } if (m.getAction().equals(BroadcastAction.BROADCAST_ACTION_TYPE_ACTION)) { return m.getActionMessage(); } else if (m.getAction().equals(BroadcastAction.BROADCAST_ACTION_TYPE_ERROR)) { return \"An error occured while executing the action: \" + m.getActionMessage(); } } return msg; }", "protected Object filter(Object msg){ if (msg == null) { return null; } if (msg instanceof BroadcastAction) { return msg; } return getActionMessage(msg); }", "protected Object filter(Object msg){ return msg; }", "protected Object filter(Object msg){ if (msg instanceof BroadcastAction) { BroadcastAction a = (BroadcastAction) msg; if (a.getAction().equals(Action.NULL)) { msg = null; } } if (msg == null) { return null; } if (msg instanceof Message) { Message m = (Message) msg; if (m.getMessageType().equals(MessageType.BROADCAST)) { return null; } } return msg; }"], "code_level": "project_runnable", "_id": "636766821a6d9265ec0174b3", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  boolean result = false;\n  for (final AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().equals(c)) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor i : interceptorList) {\n    if (i.getClass() == c) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().equals(c)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().equals(c)) return true;\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  if (interceptorList.size() < 1) return false;\n  boolean found = false;\n  for (AtmosphereInterceptor i : interceptorList) {\n    if (i.getClass().equals(c)) {\n      found = true;\n      break;\n    }\n  }\n  return found;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().equals(c)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  boolean duplicate = false;\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().equals(c)) {\n      duplicate = true;\n      break;\n    }\n  }\n  return duplicate;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().isAssignableFrom(c)) return true;\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().equals(c)) return true;\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(\n    final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n  for (AtmosphereInterceptor a : interceptorList) {\n    if (a.getClass().getName().equals(c.getName())) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor} implementation class.</p>\n * @param interceptorList the interceptors\n * @param c               the interceptor class\n * @return {@code false} if an instance of the class already exists in the list, {@code true} otherwise\n */\n", "method_name": "checkDuplicate", "codes": ["private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ boolean result = false; for (final AtmosphereInterceptor a : interceptorList) { if (a.getClass().equals(c)) { result = true; break; } } return result; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor i : interceptorList) { if (i.getClass() == c) { return true; } } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().equals(c)) { return true; } } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().equals(c)) return true; } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ if (interceptorList.size() < 1) return false; boolean found = false; for (AtmosphereInterceptor i : interceptorList) { if (i.getClass().equals(c)) { found = true; break; } } return found; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().equals(c)) { return true; } } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ boolean duplicate = false; for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().equals(c)) { duplicate = true; break; } } return duplicate; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().isAssignableFrom(c)) return true; } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().equals(c)) return true; } return false; }", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){ for (AtmosphereInterceptor a : interceptorList) { if (a.getClass().getName().equals(c.getName())) { return true; } } return false; }"], "code_level": "project_runnable", "_id": "636766811a6d9265ec017499", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public boolean hasBytes() {\n  return dataBytes != null && dataBytes.length > 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes() {\n  return (bytes != null && bytes.length > 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  if (bytes == null) return false;\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return (dataBytes != null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes() {\n  return ((bitField0_ & 0x00000002) == 0x00000002);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return ((bitField0_ & 0x00000002) == 0x00000002);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasBytes() {\n  return (this.dataBytes != null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes() {\n  return (dataBytes != null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes() {\n  if (dataBytes == null) return false;\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes() {\n  if (dataBytes == null) return false;\n  else return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * True is the body is a byte array\n * @return True is the body is a byte array\n */\n", "method_name": "hasBytes", "codes": ["public boolean hasBytes(){ return dataBytes != null && dataBytes.length > 0; }", "public boolean hasBytes(){ return (bytes != null && bytes.length > 0); }", "public boolean hasBytes(){ if (bytes == null) return false; return true; }", "public boolean hasBytes(){ return (dataBytes != null); }", "public boolean hasBytes(){ return ((bitField0_ & 0x00000002) == 0x00000002); }", "public boolean hasBytes(){ return ((bitField0_ & 0x00000002) == 0x00000002); }", "public boolean hasBytes(){ return (this.dataBytes != null); }", "public boolean hasBytes(){ return (dataBytes != null); }", "public boolean hasBytes(){ if (dataBytes == null) return false; return true; }", "public boolean hasBytes(){ if (dataBytes == null) return false; else return true; }"], "code_level": "class_runnable", "_id": "6367667c1a6d9265ec0173f7", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  Meteor m = null;\n  if (r.getParameter(\"id\") != null) {\n    m = new Meteor(r.getParameter(\"id\"));\n  }\n  if (r.getParameter(\"name\") != null) {\n    m.setName(r.getParameter(\"name\"));\n  }\n  if (r.getParameter(\"description\") != null) {\n    m.setDescription(r.getParameter(\"description\"));\n  }\n  if (r.getParameter(\"url\") != null) {\n    m.setUrl(r.getParameter(\"url\"));\n  }\n  if (r.getParameter(\"thumbnail\") != null) {\n    m.setThumbnail(r.getParameter(\"thumbnail\"));\n  }\n  if (r.getParameter(\"image\") != null) {\n    m.setImage(r.getParameter(\"image\"));\n  }\n  if (r.getParameter(\"url\") != null) {\n    m.setUrl(r.getParameter(\"url\"));\n  }\n  if (r.getParameter(\"thumbnail\") != null) {\n    m.setThumbnail(r.getParameter(\"thumbnail\"));\n  }\n  if (r.getParameter(\"image\") != null) {\n    m.setImage(r.getParameter(\"image\"));\n  }\n  if (r.getParameter(\"url\") != null) {\n    m.setUrl(r.getParameter(\"url\"));\n  }\n  if (r.getParameter(\"thumbnail\") != null) {\n    m.setThumbnail(r.getParameter(\"thumbnail\"));\n  }\n  if (r.getParameter(\"image\") != null) {\n    m.setImage(r.getParameter(\"image\"));\n  }\n  if (r.getParameter(\"url\") != null) {\n    m.setUrl(r.getParameter(\"url\"));\n  }\n  if (r.getParameter(\"thumbnail\") != null) {\n    m.setThumbnail(r.getParameter(\"thumbnail\"));\n  }\n  if (r.getParameter(\"image\") != null) {\n    m.setImage(r.getParameter(\"image\"));\n  }\n  return m;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String id = r.getParameter(\"id\");\n  if (id == null) return null;\n  Meteor m = Meteor.find(Long.valueOf(id));\n  return m;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  Meteor m = null;\n  try {\n    m =\n        new Meteor(\n            r.getIntParameter(\"meteor_id\"),\n            r.getStringParameter(\"meteor_name\"),\n            r.getStringParameter(\"meteor_description\"));\n  } catch (Exception e) {\n  }\n  return m;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String uri = r.getRequestURI();\n  String contextPath = r.getContextPath();\n  if (contextPath == null || contextPath.length() == 0) {\n    contextPath = \"/\";\n  }\n  String relativePath = uri.substring(contextPath.length());\n  if (relativePath.startsWith(\"/\")) {\n    relativePath = relativePath.substring(1);\n  }\n  if (relativePath.indexOf(\"//\") >= 0) {\n    relativePath = relativePath.substring(0, relativePath.indexOf(\"//\"));\n  }\n  String name = null;\n  String src = null;\n  String dst = null;\n  String md5 = null;\n  boolean isDirectory = false;\n  int slash = relativePath.lastIndexOf('/');\n  if (slash > 0) {\n    name = relativePath.substring(slash + 1);\n    src = relativePath.substring(0, slash);\n    dst = relativePath.substring(slash + 1);\n    md5 = MD5.getMD5(relativePath);\n  } else {\n    name = relativePath;\n    src = \"\";\n    dst = \"\";\n    md5 = \"\";\n  }\n  if (name.length() == 0) {\n    name = \"\";\n  }\n  String m = \"/\" + name;\n  if (!isDirectory && !md5.equals(m)) {\n    return null;\n  }\n  String path = src + \"/\" + dst;\n  String lcPath = path.toLowerCase();\n  if (!lcPath.endsWith(\"/\")) {\n    lcPath += \"/\";\n  }\n  if (!lcPath.startsWith(\"/\")) {\n    lcPath += \"/\";\n  }\n  StringBuffer sb = new StringBuffer();\n  sb.append(\"/\" + md5 + \"/\" + lcPath);\n  sb.append(src);\n  sb.append(\"/\" + dst);\n  return new Meteor(sb.toString(), isDirectory, md5);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String m = r.getParameter(\"meteor\");\n  Meteor mt = null;\n  if (m != null) {\n    mt = (Meteor) r.getSession().getAttribute(m);\n  }\n  return mt;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  Meteor m = null;\n  if (r != null) {\n    String s = r.getParameter(\"id\");\n    if (s != null) {\n      m = Meteor.get(Integer.parseInt(s));\n    }\n  }\n  return m;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  Meteor m = new Meteor();\n  m.setId(Integer.parseInt(r.getParameter(\"id\")));\n  m.setName(r.getParameter(\"name\"));\n  m.setDate(r.getParameter(\"date\"));\n  m.setCreated(r.getParameter(\"created\"));\n  m.setUpdated(r.getParameter(\"updated\"));\n  return m;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  String s = r.getParameter(\"meteor\");\n  if (s != null) {\n    Meteor m = (Meteor) MemCache.get(s);\n    if (m != null) {\n      return m;\n    } else {\n      m = new Meteor(s);\n      MemCache.put(s, m);\n      return m;\n    }\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r) {\n  return (Meteor) r.getAttribute(METEOROBJECT_ATTRIBUTE);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){ String m = r.getParameter(\"meteor_name\"); String d = r.getParameter(\"meteor_description\"); String t = r.getParameter(\"meteor_type\"); String s = r.getParameter(\"meteor_state\"); String a = r.getParameter(\"meteor_area\"); String p = r.getParameter(\"meteor_price\"); String c = r.getParameter(\"meteor_image_url\"); String i = r.getParameter(\"meteor_difficulty\"); String f = r.getParameter(\"meteor_difficulty_level\"); String df = r.getParameter(\"meteor_difficulty_level_description\"); String e = r.getParameter(\"meteor_difficulty_level_int\"); String rt = r.getParameter(\"meteor_rewards\"); String rt_d = r.getParameter(\"meteor_rewards_desc\"); String rt_int = r.getParameter(\"meteor_rewards_int\"); String rt_diff = r.getParameter(\"meteor_rewards_difficulty\"); String rt_diff_level = r.getParameter(\"meteor_rewards_difficulty_level\"); String rt_diff_level_description = r.getParameter(\"meteor_rewards_difficulty_level_description\"); String rt_diff_level_int = r.getParameter(\"meteor_rewards_difficulty_level_int\"); String rt_rewards = r.getParameter(\"meteor_rewards_desc\"); String rt_rewards_desc = r.getParameter(\"meteor_rewards_desc\"); String rt_rewards_int = r.getParameter(\"meteor_rewards_int\"); String rt_rewards_diff = r.getParameter(\"meteor_rewards_difficulty\"); String rt_rewards_diff_level = r.getParameter(\"meteor_rewards_difficulty_level\"); String rt_rewards_diff_level_description = r.getParameter(\"meteor_rewards_difficulty_level_description\"); String rt_rewards_diff_level_int = r.getParameter(\"meteor_rewards_difficulty_level_int\"); String rt_rewards_diff_level_diff = r.getParameter(\"meteor_rewards_difficulty_level_diff\"); String rt_rewards_diff_level_diff_description = r.getParameter(\"meteor_rewards_difficulty_level_diff_description\"); String rt_rewards_diff_level_diff_int = r.getParameter(\"meteor_rewards_difficulty_level_diff_int\"); String rt_diff = r.getParameter(\"meteor_difficulty\"); String rt_diff_level = r.getParameter(\"meteor_difficulty_level\"); String rt_diff_level_description = r.getParameter", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Retrieve an instance of  {@link Meteor} based on the {@link HttpServletRequest}.\n * @param r {@link HttpServletRequest}\n * @return a {@link Meteor} or null if not found\n */\n", "method_name": "lookup", "codes": ["public static Meteor lookup(HttpServletRequest r){ Meteor m = null; if (r.getParameter(\"id\") != null) { m = new Meteor(r.getParameter(\"id\")); } if (r.getParameter(\"name\") != null) { m.setName(r.getParameter(\"name\")); } if (r.getParameter(\"description\") != null) { m.setDescription(r.getParameter(\"description\")); } if (r.getParameter(\"url\") != null) { m.setUrl(r.getParameter(\"url\")); } if (r.getParameter(\"thumbnail\") != null) { m.setThumbnail(r.getParameter(\"thumbnail\")); } if (r.getParameter(\"image\") != null) { m.setImage(r.getParameter(\"image\")); } if (r.getParameter(\"url\") != null) { m.setUrl(r.getParameter(\"url\")); } if (r.getParameter(\"thumbnail\") != null) { m.setThumbnail(r.getParameter(\"thumbnail\")); } if (r.getParameter(\"image\") != null) { m.setImage(r.getParameter(\"image\")); } if (r.getParameter(\"url\") != null) { m.setUrl(r.getParameter(\"url\")); } if (r.getParameter(\"thumbnail\") != null) { m.setThumbnail(r.getParameter(\"thumbnail\")); } if (r.getParameter(\"image\") != null) { m.setImage(r.getParameter(\"image\")); } if (r.getParameter(\"url\") != null) { m.setUrl(r.getParameter(\"url\")); } if (r.getParameter(\"thumbnail\") != null) { m.setThumbnail(r.getParameter(\"thumbnail\")); } if (r.getParameter(\"image\") != null) { m.setImage(r.getParameter(\"image\")); } return m; }", "public static Meteor lookup(HttpServletRequest r){ String id = r.getParameter(\"id\"); if (id == null) return null; Meteor m = Meteor.find(Long.valueOf(id)); return m; }", "public static Meteor lookup(HttpServletRequest r){ Meteor m = null; try { m = new Meteor(r.getIntParameter(\"meteor_id\"), r.getStringParameter(\"meteor_name\"), r.getStringParameter(\"meteor_description\")); } catch (Exception e) { } return m; }", "public static Meteor lookup(HttpServletRequest r){ String uri = r.getRequestURI(); String contextPath = r.getContextPath(); if (contextPath == null || contextPath.length() == 0) { contextPath = \"/\"; } String relativePath = uri.substring(contextPath.length()); if (relativePath.startsWith(\"/\")) { relativePath = relativePath.substring(1); } if (relativePath.indexOf(\"//\") >= 0) { relativePath = relativePath.substring(0, relativePath.indexOf(\"//\")); } String name = null; String src = null; String dst = null; String md5 = null; boolean isDirectory = false; int slash = relativePath.lastIndexOf('/'); if (slash > 0) { name = relativePath.substring(slash + 1); src = relativePath.substring(0, slash); dst = relativePath.substring(slash + 1); md5 = MD5.getMD5(relativePath); } else { name = relativePath; src = \"\"; dst = \"\"; md5 = \"\"; } if (name.length() == 0) { name = \"\"; } String m = \"/\" + name; if (!isDirectory && !md5.equals(m)) { return null; } String path = src + \"/\" + dst; String lcPath = path.toLowerCase(); if (!lcPath.endsWith(\"/\")) { lcPath += \"/\"; } if (!lcPath.startsWith(\"/\")) { lcPath += \"/\"; } StringBuffer sb = new StringBuffer(); sb.append(\"/\" + md5 + \"/\" + lcPath); sb.append(src); sb.append(\"/\" + dst); return new Meteor(sb.toString(), isDirectory, md5); }", "public static Meteor lookup(HttpServletRequest r){ String m = r.getParameter(\"meteor\"); Meteor mt = null; if (m != null) { mt = (Meteor) r.getSession().getAttribute(m); } return mt; }", "public static Meteor lookup(HttpServletRequest r){ Meteor m = null; if (r != null) { String s = r.getParameter(\"id\"); if (s != null) { m = Meteor.get(Integer.parseInt(s)); } } return m; }", "public static Meteor lookup(HttpServletRequest r){ Meteor m = new Meteor(); m.setId(Integer.parseInt(r.getParameter(\"id\"))); m.setName(r.getParameter(\"name\")); m.setDate(r.getParameter(\"date\")); m.setCreated(r.getParameter(\"created\")); m.setUpdated(r.getParameter(\"updated\")); return m; }", "public static Meteor lookup(HttpServletRequest r){ String s = r.getParameter(\"meteor\"); if (s != null) { Meteor m = (Meteor) MemCache.get(s); if (m != null) { return m; } else { m = new Meteor(s); MemCache.put(s, m); return m; } } else { return null; } }", "public static Meteor lookup(HttpServletRequest r){ return (Meteor) r.getAttribute(METEOROBJECT_ATTRIBUTE); }", "public static Meteor lookup(HttpServletRequest r){ String m = r.getParameter(\"meteor_name\"); String d = r.getParameter(\"meteor_description\"); String t = r.getParameter(\"meteor_type\"); String s = r.getParameter(\"meteor_state\"); String a = r.getParameter(\"meteor_area\"); String p = r.getParameter(\"meteor_price\"); String c = r.getParameter(\"meteor_image_url\"); String i = r.getParameter(\"meteor_difficulty\"); String f = r.getParameter(\"meteor_difficulty_level\"); String df = r.getParameter(\"meteor_difficulty_level_description\"); String e = r.getParameter(\"meteor_difficulty_level_int\"); String rt = r.getParameter(\"meteor_rewards\"); String rt_d = r.getParameter(\"meteor_rewards_desc\"); String rt_int = r.getParameter(\"meteor_rewards_int\"); String rt_diff = r.getParameter(\"meteor_rewards_difficulty\"); String rt_diff_level = r.getParameter(\"meteor_rewards_difficulty_level\"); String rt_diff_level_description = r.getParameter(\"meteor_rewards_difficulty_level_description\"); String rt_diff_level_int = r.getParameter(\"meteor_rewards_difficulty_level_int\"); String rt_rewards = r.getParameter(\"meteor_rewards_desc\"); String rt_rewards_desc = r.getParameter(\"meteor_rewards_desc\"); String rt_rewards_int = r.getParameter(\"meteor_rewards_int\"); String rt_rewards_diff = r.getParameter(\"meteor_rewards_difficulty\"); String rt_rewards_diff_level = r.getParameter(\"meteor_rewards_difficulty_level\"); String rt_rewards_diff_level_description = r.getParameter(\"meteor_rewards_difficulty_level_description\"); String rt_rewards_diff_level_int = r.getParameter(\"meteor_rewards_difficulty_level_int\"); String rt_rewards_diff_level_diff = r.getParameter(\"meteor_rewards_difficulty_level_diff\"); String rt_rewards_diff_level_diff_description = r.getParameter(\"meteor_rewards_difficulty_level_diff_description\"); String rt_rewards_diff_level_diff_int = r.getParameter(\"meteor_rewards_difficulty_level_diff_int\"); String rt_diff = r.getParameter(\"meteor_difficulty\"); String rt_diff_level = r.getParameter(\"meteor_difficulty_level\"); String rt_diff_level_description = r.getParameter"], "code_level": "class_runnable", "_id": "6367667d1a6d9265ec0173ff", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (e == null) return null;\n  if (resource != null) {\n    resource.addEventListener(e);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (!eventListeners.contains(e)) {\n    eventListeners.add(e);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  return this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (eventListeners.contains(e)) {\n    return null;\n  }\n  eventListeners.add(e);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  logger.trace(\"{}\", e);\n  if (e instanceof AtmosphereResourceEventListenerWrapper) {\n    AtmosphereResourceEventListenerWrapper aw = (AtmosphereResourceEventListenerWrapper) e;\n    if (aw.getAtmosphereResourceEventListener() == null) {\n      aw.setAtmosphereResourceEventListener(this);\n    }\n  }\n  if (!eventListeners.contains(e)) {\n    logger.trace(\"{}\", e);\n    eventListeners.add(e);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  logger.info(\"Calling AtmosphereResource.addEventListener()\");\n  logger.info(\"EventListener = \" + e.getClass().getName());\n  logger.info(\"List = \" + e.getListeners());\n  logger.info(\"Resource = \" + e.getResource());\n  logger.info(\"\");\n  return super.addEventListener(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (e instanceof AtmosphereResourceEventListenerAdapter) {\n    e = ((AtmosphereResourceEventListenerAdapter) e).getAtmosphereResourceEventListener();\n  }\n  if (e instanceof AtmosphereResourceEventListener) {\n    e = (AtmosphereResourceEventListener) e;\n  }\n  if (e instanceof AtmosphereResourceEventListener) {\n    if (eventListeners == null) {\n      eventListeners = new LinkedList<AtmosphereResourceEventListener>();\n    }\n    eventListeners.add(e);\n  } else {\n    if (eventListeners == null) {\n      eventListeners = new LinkedList<AtmosphereResourceEventListener>();\n    }\n    eventListeners.add(e);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (!eventListeners.contains(e)) {\n    eventListeners.add(e);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e) {\n  if (!eventListeners.contains(e)) {\n    eventListeners.add(e);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a  {@link AtmosphereResourceEventListener}.\n * @param e an instance of AtmosphereResourceEventListener\n */\n", "method_name": "addEventListener", "codes": ["@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (e == null) return null; if (resource != null) { resource.addEventListener(e); } return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (!eventListeners.contains(e)) { eventListeners.add(e); } return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (eventListeners.contains(e)) { return null; } eventListeners.add(e); return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if (e.getClass() == AtmosphereResourceEventImpl.class) { AtmosphereResourceEventImpl ev = (AtmosphereResourceEventImpl) e; ev.setListener(this); } if", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ logger.trace(\"{}\", e); if (e instanceof AtmosphereResourceEventListenerWrapper) { AtmosphereResourceEventListenerWrapper aw = (AtmosphereResourceEventListenerWrapper) e; if (aw.getAtmosphereResourceEventListener() == null) { aw.setAtmosphereResourceEventListener(this); } } if (!eventListeners.contains(e)) { logger.trace(\"{}\", e); eventListeners.add(e); } return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ logger.info(\"Calling AtmosphereResource.addEventListener()\"); logger.info(\"EventListener = \" + e.getClass().getName()); logger.info(\"List = \" + e.getListeners()); logger.info(\"Resource = \" + e.getResource()); logger.info(\"\"); return super.addEventListener(e); }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (e instanceof AtmosphereResourceEventListenerAdapter) { e = ((AtmosphereResourceEventListenerAdapter) e).getAtmosphereResourceEventListener(); } if (e instanceof AtmosphereResourceEventListener) { e = (AtmosphereResourceEventListener) e; } if (e instanceof AtmosphereResourceEventListener) { if (eventListeners == null) { eventListeners = new LinkedList<AtmosphereResourceEventListener>(); } eventListeners.add(e); } else { if (eventListeners == null) { eventListeners = new LinkedList<AtmosphereResourceEventListener>(); } eventListeners.add(e); } return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (!eventListeners.contains(e)) { eventListeners.add(e); } return this; }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ if (!eventListeners.contains(e)) { eventListeners.add(e); } return this; }"], "code_level": "project_runnable", "_id": "6367667c1a6d9265ec0173fb", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public InputStream next() throws IOException {\n  if (!stack.isEmpty()) {\n    return stack.pop();\n  }\n  return null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) {\n    throw new NoSuchElementException();\n  }\n  return new ByteArrayInputStream((byte[]) this.iterator.next());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!stack.isEmpty()) {\n    return stack.pop();\n  } else {\n    return null;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) {\n    return null;\n  } else {\n    String nextElement = s.next();\n    return new ByteArrayInputStream(nextElement.getBytes(\"UTF-8\"));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) {\n    throw new IOException(\"No more elements to read\");\n  }\n  int value = m_buffer.get();\n  if (value == m_last) {\n    m_last = m_buffer.get();\n    if (m_last == m_last) {\n      return null;\n    }\n  }\n  m_buffer.position(m_buffer.position() + 1);\n  return new ByteArrayInputStream(new byte[] {(byte) value});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!this.hasNext()) {\n    return null;\n  }\n  if (this.lastElement == null) {\n    this.lastElement = this.stack.pop();\n  } else {\n    this.lastElement = this.stack.peek();\n  }\n  return this.lastElement;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) {\n    return null;\n  }\n  ByteArrayOutputStream bos = new ByteArrayOutputStream();\n  while (true) {\n    byte[] buffer = new byte[BUFFER_SIZE];\n    int read = in.read(buffer);\n    if (read == -1) {\n      break;\n    }\n    bos.write(buffer, 0, read);\n  }\n  return new ByteArrayInputStream(bos.toByteArray());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) {\n    throw new NoSuchElementException();\n  }\n  if (current == null) {\n    current = new ByteArrayInputStream(buffer);\n  } else {\n    current = new ByteArrayInputStream(buffer, current.read(), current.read() + 1);\n  }\n  return current;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) {\n    return null;\n  } else {\n    return new FileInputStream(new File(\"/home/gavin/Downloads/files/\" + getNextFile()));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n  if (!hasNext()) return null;\n  String nextLine = br.readLine();\n  if (nextLine == null) {\n    br.close();\n    return null;\n  }\n  String[] tokens = nextLine.split(\"\\\\s+\");\n  if (tokens.length < 3) return null;\n  String name = tokens[0];\n  int age = Integer.parseInt(tokens[1]);\n  String gender = tokens[2];\n  return new FileInputStream(\n      new File(\"C:\\\\Users\\\\Freddy\\\\IdeaProjects\\\\Test\\\\src\\\\test\\\\resources\\\\\" + name + \".txt\"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Return the next  {@link java.io.File} object or {@code null} if no more files areavailable.\n */\n", "method_name": "next", "codes": ["public InputStream next() throws IOException { if (!stack.isEmpty()) { return stack.pop(); } return null; }", "public InputStream next() throws IOException { if (!hasNext()) { throw new NoSuchElementException(); } return new ByteArrayInputStream((byte[]) this.iterator.next()); }", "public InputStream next() throws IOException { if (!stack.isEmpty()) { return stack.pop(); } else { return null; } }", "public InputStream next() throws IOException { if (!hasNext()) { return null; } else { String nextElement = s.next(); return new ByteArrayInputStream(nextElement.getBytes(\"UTF-8\")); } }", "public InputStream next() throws IOException { if (!hasNext()) { throw new IOException(\"No more elements to read\"); } int value = m_buffer.get(); if (value == m_last) { m_last = m_buffer.get(); if (m_last == m_last) { return null; } } m_buffer.position(m_buffer.position() + 1); return new ByteArrayInputStream(new byte[] { (byte) value }); }", "public InputStream next() throws IOException { if (!this.hasNext()) { return null; } if (this.lastElement == null) { this.lastElement = this.stack.pop(); } else { this.lastElement = this.stack.peek(); } return this.lastElement; }", "public InputStream next() throws IOException { if (!hasNext()) { return null; } ByteArrayOutputStream bos = new ByteArrayOutputStream(); while (true) { byte[] buffer = new byte[BUFFER_SIZE]; int read = in.read(buffer); if (read == -1) { break; } bos.write(buffer, 0, read); } return new ByteArrayInputStream(bos.toByteArray()); }", "public InputStream next() throws IOException { if (!hasNext()) { throw new NoSuchElementException(); } if (current == null) { current = new ByteArrayInputStream(buffer); } else { current = new ByteArrayInputStream(buffer, current.read(), current.read() + 1); } return current; }", "public InputStream next() throws IOException { if (!hasNext()) { return null; } else { return new FileInputStream(new File(\"/home/gavin/Downloads/files/\" + getNextFile())); } }", "public InputStream next() throws IOException { if (!hasNext()) return null; String nextLine = br.readLine(); if (nextLine == null) { br.close(); return null; } String[] tokens = nextLine.split(\"\\\\s+\"); if (tokens.length < 3) return null; String name = tokens[0]; int age = Integer.parseInt(tokens[1]); String gender = tokens[2]; return new FileInputStream(new File(\"C:\\\\Users\\\\Freddy\\\\IdeaProjects\\\\Test\\\\src\\\\test\\\\resources\\\\\" + name + \".txt\")); }"], "code_level": "class_runnable", "_id": "636766811a6d9265ec017496", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private static File[] classPath() {\n  File file = new File(\"\");\n  String[] fileNames = file.list();\n  File[] fileArray = new File[fileNames.length];\n  for (int i = 0; i < fileNames.length; i++) {\n    fileArray[i] = new File(file, fileNames[i]);\n  }\n  return fileArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  File[] files = new File[6];\n  try {\n    String[] classPath = System.getProperty(\"java.class.path\").split(File.pathSeparator);\n    for (int i = 0; i < classPath.length; i++) {\n      File file = new File(classPath[i]);\n      if (file.isDirectory()) {\n        files[i] = file;\n      } else {\n        files[i] = new File(file.getPath().replace(\"\\\\\", \"/\"));\n      }\n    }\n  } catch (Exception e) {\n  }\n  return files;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  File file = new File(\".\");\n  String[] fileNames = file.list();\n  File[] files = new File[fileNames.length];\n  for (int i = 0; i < fileNames.length; i++) {\n    files[i] = new File(file, fileNames[i]);\n  }\n  return files;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  File file = new File(\"C:/Users/User/Desktop/Test/\");\n  File[] fileList = file.listFiles();\n  return fileList;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  File folder = new File(System.getProperty(\"user.dir\"));\n  File[] listOfFiles = folder.listFiles();\n  ArrayList<File> list = new ArrayList<File>();\n  for (int i = 0; i < listOfFiles.length; i++) {\n    if (listOfFiles[i].isFile() && listOfFiles[i].getName().endsWith(\".class\")) {\n      list.add(listOfFiles[i]);\n    }\n  }\n  File[] ret = new File[list.size()];\n  list.toArray(ret);\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  String classPath = System.getProperty(\"java.class.path\");\n  return classPath.split(File.pathSeparator);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  File[] file = null;\n  try {\n    file = new File(System.getProperty(\"java.class.path\")).listFiles();\n  } catch (Exception e) {\n  }\n  return file;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  String path = System.getProperty(\"java.class.path\");\n  if (path.contains(\";\")) {\n    path = path.replace(\";\", \"\\n\");\n  }\n  return path.split(\";\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  return (File[])\n      Arrays.asList(\n              java.class.getProtectionDomain().getCodeSource().getLocation().getPath().split(\";\"))\n          .stream()\n          .map(path -> new File(path))\n          .filter(file -> file.isFile() && file.getName().endsWith(\".class\"))\n          .toArray(File[]::new);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath() {\n  File[] fileArray = new File[classPathFiles.size()];\n  int i = 0;\n  for (File file : classPathFiles) {\n    fileArray[i] = file;\n    i++;\n  }\n  return fileArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the class path of the current JVM instance as an array of  {@link File} objects.\n */\n", "method_name": "classPath", "codes": ["private static File[] classPath(){ File file = new File(\"\"); String[] fileNames = file.list(); File[] fileArray = new File[fileNames.length]; for (int i = 0; i < fileNames.length; i++) { fileArray[i] = new File(file, fileNames[i]); } return fileArray; }", "private static File[] classPath(){ File[] files = new File[6]; try { String[] classPath = System.getProperty(\"java.class.path\").split(File.pathSeparator); for (int i = 0; i < classPath.length; i++) { File file = new File(classPath[i]); if (file.isDirectory()) { files[i] = file; } else { files[i] = new File(file.getPath().replace(\"\\\\\", \"/\")); } } } catch (Exception e) { } return files; }", "private static File[] classPath(){ File file = new File(\".\"); String[] fileNames = file.list(); File[] files = new File[fileNames.length]; for (int i = 0; i < fileNames.length; i++) { files[i] = new File(file, fileNames[i]); } return files; }", "private static File[] classPath(){ File file = new File(\"C:/Users/User/Desktop/Test/\"); File[] fileList = file.listFiles(); return fileList; }", "private static File[] classPath(){ File folder = new File(System.getProperty(\"user.dir\")); File[] listOfFiles = folder.listFiles(); ArrayList<File> list = new ArrayList<File>(); for (int i = 0; i < listOfFiles.length; i++) { if (listOfFiles[i].isFile() && listOfFiles[i].getName().endsWith(\".class\")) { list.add(listOfFiles[i]); } } File[] ret = new File[list.size()]; list.toArray(ret); return ret; }", "private static File[] classPath(){ String classPath = System.getProperty(\"java.class.path\"); return classPath.split(File.pathSeparator); }", "private static File[] classPath(){ File[] file = null; try { file = new File(System.getProperty(\"java.class.path\")).listFiles(); } catch (Exception e) { } return file; }", "private static File[] classPath(){ String path = System.getProperty(\"java.class.path\"); if (path.contains(\";\")) { path = path.replace(\";\", \"\\n\"); } return path.split(\";\"); }", "private static File[] classPath(){ return (File[]) Arrays.asList(java.class.getProtectionDomain().getCodeSource().getLocation().getPath().split(\";\")).stream().map(path -> new File(path)).filter(file -> file.isFile() && file.getName().endsWith(\".class\")).toArray(File[]::new); }", "private static File[] classPath(){ File[] fileArray = new File[classPathFiles.size()]; int i = 0; for (File file : classPathFiles) { fileArray[i] = file; i++; } return fileArray; }"], "code_level": "slib_runnable", "_id": "636766821a6d9265ec0174c9", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  final byte[] buffer = new byte[BUFFER_SIZE];\n  int nRead;\n  while ((nRead = in.read(buffer)) != -1) {\n    final String str = new String(buffer, 0, nRead);\n    if (!str.isEmpty()) {\n      if (str.startsWith(\"\\n\")) {\n        if (!str.endsWith(\"\\n\")) {\n          str = str + \"\\n\";\n        }\n      } else if (str.startsWith(\"\\r\")) {\n        if (!str.endsWith(\"\\r\")) {\n          str = str + \"\\r\";\n        }\n      } else {\n        if (!str.equals(\"\")) {\n          this.data.add(str);\n        }\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  final byte[] buffer = new byte[4096];\n  int bytesRead;\n  while ((bytesRead = in.read(buffer)) != -1) {\n    final byte[] tmpBuffer = new byte[bytesRead];\n    System.arraycopy(buffer, 0, tmpBuffer, 0, bytesRead);\n    buffer = tmpBuffer;\n  }\n  final String content = new String(buffer, \"UTF-8\");\n  if (content.equals(\"\")) {\n    return;\n  }\n  final String[] lines = content.split(\"\\n\");\n  for (final String line : lines) {\n    final String[] parts = line.split(\"\\t\");\n    if (parts.length != 2) {\n      throw new IOException(\"Invalid line in file \" + getName() + \": \" + line);\n    }\n    final String key = parts[0];\n    final String value = parts[1];\n    if (!key.equals(\"__key__\")) {\n      throw new IOException(\"Invalid key in file \" + getName() + \": \" + key);\n    }\n    if (!value.equals(\"\")) {\n      throw new IOException(\"Invalid value in file \" + getName() + \": \" + value);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  final byte[] buf = new byte[BUF_SIZE];\n  int len;\n  while ((len = in.read(buf)) != -1) {\n    m_buffer.write(buf, 0, len);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  final DataInputStream data = new DataInputStream(in);\n  try {\n    m_ID = data.readInt();\n    m_Type = data.readInt();\n    m_Data = data.readInt();\n  } finally {\n    data.close();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  final byte[] buffer = new byte[8192];\n  int read = 0;\n  while ((read = in.read(buffer)) >= 0) {\n    System.arraycopy(buffer, 0, m_buffer, m_pos, read);\n    m_pos += read;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  final byte[] buffer = new byte[BUFFER_SIZE];\n  int bytesRead = 0;\n  while ((bytesRead = in.read(buffer)) > 0) {\n    final int length = bytesRead;\n    if (length > 0) {\n      System.arraycopy(buffer, 0, buffer, 0, length);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  final DataInputStream din = new DataInputStream(in);\n  this._name = din.readUTF();\n  this._host = din.readUTF();\n  this._port = din.readInt();\n  this._data = din.readInt();\n  this._size = din.readInt();\n  this._buffer = new byte[this._size];\n  final int len = din.read(this._buffer);\n  if (len != this._size) {\n    throw new IOException(\"Wrong size in \" + this._name + \": \" + len);\n  }\n  this._buffer = null;\n  this._current = 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  final int size = in.read();\n  if (size == -1) {\n    throw new EOFException();\n  }\n  if (size == '\\n') {\n    throw new EOFException();\n  }\n  if (size == '\\r') {\n    throw new EOFException();\n  }\n  if (size == '\\t') {\n    if (in.read() != '\\t') {\n      throw new EOFException();\n    }\n  }\n  if (size != '\\n' && size != '\\r' && size != '\\t') {\n    throw new EOFException();\n  }\n  if (size == '\\n') {\n    readLine();\n  } else if (size == '\\r') {\n    readLine();\n  } else {\n    throw new IOException(\"Unexpected character at position \" + in.available());\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  in.read(buffer, 0, buffer.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n  if (in == null) {\n    throw new NullPointerException(\"in\");\n  }\n  int size = (int) Math.min(in.available(), maxBufferSize);\n  byte[] buffer = new byte[size];\n  in.read(buffer);\n  in.close();\n  setBuffer(buffer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Clear and fill the buffer of this  {@code ClassFileBuffer} with thesupplied byte stream. The read pointer is reset to the start of the byte array.\n */\n", "method_name": "readFrom", "codes": ["public void readFrom(final InputStream in) throws IOException { final byte[] buffer = new byte[BUFFER_SIZE]; int nRead; while ((nRead = in.read(buffer)) != -1) { final String str = new String(buffer, 0, nRead); if (!str.isEmpty()) { if (str.startsWith(\"\\n\")) { if (!str.endsWith(\"\\n\")) { str = str + \"\\n\"; } } else if (str.startsWith(\"\\r\")) { if (!str.endsWith(\"\\r\")) { str = str + \"\\r\"; } } else { if (!str.equals(\"\")) { this.data.add(str); } } } } }", "public void readFrom(final InputStream in) throws IOException { final byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = in.read(buffer)) != -1) { final byte[] tmpBuffer = new byte[bytesRead]; System.arraycopy(buffer, 0, tmpBuffer, 0, bytesRead); buffer = tmpBuffer; } final String content = new String(buffer, \"UTF-8\"); if (content.equals(\"\")) { return; } final String[] lines = content.split(\"\\n\"); for (final String line : lines) { final String[] parts = line.split(\"\\t\"); if (parts.length != 2) { throw new IOException(\"Invalid line in file \" + getName() + \": \" + line); } final String key = parts[0]; final String value = parts[1]; if (!key.equals(\"__key__\")) { throw new IOException(\"Invalid key in file \" + getName() + \": \" + key); } if (!value.equals(\"\")) { throw new IOException(\"Invalid value in file \" + getName() + \": \" + value); } } }", "public void readFrom(final InputStream in) throws IOException { final byte[] buf = new byte[BUF_SIZE]; int len; while ((len = in.read(buf)) != -1) { m_buffer.write(buf, 0, len); } }", "public void readFrom(final InputStream in) throws IOException { final DataInputStream data = new DataInputStream(in); try { m_ID = data.readInt(); m_Type = data.readInt(); m_Data = data.readInt(); } finally { data.close(); } }", "public void readFrom(final InputStream in) throws IOException { final byte[] buffer = new byte[8192]; int read = 0; while ((read = in.read(buffer)) >= 0) { System.arraycopy(buffer, 0, m_buffer, m_pos, read); m_pos += read; } }", "public void readFrom(final InputStream in) throws IOException { final byte[] buffer = new byte[BUFFER_SIZE]; int bytesRead = 0; while ((bytesRead = in.read(buffer)) > 0) { final int length = bytesRead; if (length > 0) { System.arraycopy(buffer, 0, buffer, 0, length); } } }", "public void readFrom(final InputStream in) throws IOException { final DataInputStream din = new DataInputStream(in); this._name = din.readUTF(); this._host = din.readUTF(); this._port = din.readInt(); this._data = din.readInt(); this._size = din.readInt(); this._buffer = new byte[this._size]; final int len = din.read(this._buffer); if (len != this._size) { throw new IOException(\"Wrong size in \" + this._name + \": \" + len); } this._buffer = null; this._current = 0; }", "public void readFrom(final InputStream in) throws IOException { final int size = in.read(); if (size == -1) { throw new EOFException(); } if (size == '\\n') { throw new EOFException(); } if (size == '\\r') { throw new EOFException(); } if (size == '\\t') { if (in.read() != '\\t') { throw new EOFException(); } } if (size != '\\n' && size != '\\r' && size != '\\t') { throw new EOFException(); } if (size == '\\n') { readLine(); } else if (size == '\\r') { readLine(); } else { throw new IOException(\"Unexpected character at position \" + in.available()); } }", "public void readFrom(final InputStream in) throws IOException { in.read(buffer, 0, buffer.length); }", "public void readFrom(final InputStream in) throws IOException { if (in == null) { throw new NullPointerException(\"in\"); } int size = (int) Math.min(in.available(), maxBufferSize); byte[] buffer = new byte[size]; in.read(buffer); in.close(); setBuffer(buffer); }"], "code_level": "class_runnable", "_id": "636766801a6d9265ec017482", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    addReverse(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  if (files.length > 0) {\n    if (files.length == 1) {\n      addFile(files[0]);\n      return;\n    }\n    final InputStream[] reversed = new InputStream[files.length];\n    for (int i = 0; i < files.length; i++) {\n      reversed[i] = files[files.length - i - 1];\n    }\n    addReverse(reversed);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    add(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    final InputStream file = files[i];\n    addFile(file);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  final Stack<InputStream> stack = new Stack<InputStream>();\n  for (final InputStream is : files) {\n    stack.push(is);\n  }\n  Collections.reverse(stack);\n  for (final InputStream is : stack) {\n    if (is instanceof File) {\n      final File file = (File) is;\n      final File parent = file.getParentFile();\n      if (parent != null) {\n        addReverse(parent.listFiles());\n      }\n      addReverse(file.listFiles());\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  final List<String> filesList = new ArrayList<String>();\n  for (final InputStream f : files) {\n    filesList.add(f.toString());\n  }\n  Collections.sort(filesList);\n  for (final String fileName : filesList) {\n    final InputStream is = new FileInputStream(fileName);\n    try {\n      final byte[] data = new byte[is.available()];\n      is.read(data);\n      if (data.length > 0) {\n        final StringBuilder sb = new StringBuilder();\n        for (final byte b : data) {\n          sb.append(String.format(\"%02x\", b));\n        }\n        final String file = sb.toString();\n        if (!files.contains(file)) {\n          files.add(file);\n        }\n      }\n    } catch (final Exception e) {\n      e.printStackTrace();\n    } finally {\n      try {\n        is.close();\n      } catch (final IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    addReverse(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    addReverse(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    final File file = new File(files[i].getPath());\n    if (file.isFile()) {\n      if (!file.getName().equals(\"classes.dex\")\n          && !file.getName().equals(\"classes.jar\")\n          && !file.getName().equals(\"libraries.jar\")\n          && !file.getName().equals(\"libraries.zip\")) {\n        final String fileName = file.getName();\n        final String filePath = file.getPath();\n        final String[] filesName = fileName.split(\"\\\\.\");\n        final String fileExtension = filesName[filesName.length - 1];\n        if (fileExtension.equals(\"jar\")) {\n          addJar(filePath, files[i], \"reverse\");\n        } else if (fileExtension.equals(\"zip\")) {\n          addZip(filePath, files[i], \"reverse\");\n        }\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files) {\n  for (final InputStream file : files) {\n    if (file != null) {\n      stack.push(file);\n    }\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Add the specified files in reverse order.\n */\n", "method_name": "addReverse", "codes": ["private void addReverse(final InputStream[] files){ for (int i = files.length - 1; i >= 0; i--) { addReverse(files[i]); } }", "private void addReverse(final InputStream[] files){ if (files.length > 0) { if (files.length == 1) { addFile(files[0]); return; } final InputStream[] reversed = new InputStream[files.length]; for (int i = 0; i < files.length; i++) { reversed[i] = files[files.length - i - 1]; } addReverse(reversed); } }", "private void addReverse(final InputStream[] files){ for (int i = files.length - 1; i >= 0; i--) { add(files[i]); } }", "private void addReverse(final InputStream[] files){ for (int i = files.length - 1; i >= 0; i--) { final InputStream file = files[i]; addFile(file); } }", "private void addReverse(final InputStream[] files){ final Stack<InputStream> stack = new Stack<InputStream>(); for (final InputStream is : files) { stack.push(is); } Collections.reverse(stack); for (final InputStream is : stack) { if (is instanceof File) { final File file = (File) is; final File parent = file.getParentFile(); if (parent != null) { addReverse(parent.listFiles()); } addReverse(file.listFiles()); } } }", "private void addReverse(final InputStream[] files){ final List<String> filesList = new ArrayList<String>(); for (final InputStream f : files) { filesList.add(f.toString()); } Collections.sort(filesList); for (final String fileName : filesList) { final InputStream is = new FileInputStream(fileName); try { final byte[] data = new byte[is.available()]; is.read(data); if (data.length > 0) { final StringBuilder sb = new StringBuilder(); for (final byte b : data) { sb.append(String.format(\"%02x\", b)); } final String file = sb.toString(); if (!files.contains(file)) { files.add(file); } } } catch (final Exception e) { e.printStackTrace(); } finally { try { is.close(); } catch (final IOException e) { e.printStackTrace(); } } } }", "private void addReverse(final InputStream[] files){ for (int i = files.length - 1; i >= 0; i--) { addReverse(files[i]); } }", "private void addReverse(final InputStream[] files){ for (int i = files.length - 1; i >= 0; i--) { addReverse(files[i]); } }", "private void addReverse(final InputStream[] files){ for (int i = files.length - 1; i >= 0; i--) { final File file = new File(files[i].getPath()); if (file.isFile()) { if (!file.getName().equals(\"classes.dex\") && !file.getName().equals(\"classes.jar\") && !file.getName().equals(\"libraries.jar\") && !file.getName().equals(\"libraries.zip\")) { final String fileName = file.getName(); final String filePath = file.getPath(); final String[] filesName = fileName.split(\"\\\\.\"); final String fileExtension = filesName[filesName.length - 1]; if (fileExtension.equals(\"jar\")) { addJar(filePath, files[i], \"reverse\"); } else if (fileExtension.equals(\"zip\")) { addZip(filePath, files[i], \"reverse\"); } } } } }", "private void addReverse(final InputStream[] files){ for (final InputStream file : files) { if (file != null) { stack.push(file); } } }"], "code_level": "class_runnable", "_id": "636766801a6d9265ec017477", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "private void addReverse(final File[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    addReverse(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  final File[] temp = new File[files.length];\n  int i = files.length - 1;\n  for (final File file : files) {\n    temp[i] = file;\n    i--;\n  }\n  files = temp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  if (files == null) {\n    return;\n  }\n  if (files.length <= 1) {\n    return;\n  }\n  final File last = files[files.length - 1];\n  final File[] newFiles = new File[files.length - 1];\n  for (int i = 0; i < files.length - 1; i++) {\n    newFiles[i] = files[i];\n  }\n  newFiles[files.length - 1] = last;\n  addReverse(newFiles);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (int i = 0; i < files.length; i++) {\n    final File file = files[i];\n    final String filename = file.getName();\n    final int index = filename.lastIndexOf('.');\n    if (index != -1) {\n      filename = filename.substring(0, index);\n    }\n    final String extension = filename.substring(index + 1);\n    add(file);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (File file : files) {\n    add(file);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (int i = files.length - 1; i >= 0; i--) {\n    this.add(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (File file : files) {\n    addReverse(file);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  for (int i = 0; i < files.length; i++) {\n    if (files[i].isDirectory()) {\n      addReverse(files[i].listFiles());\n    } else {\n      stack.push(files[i]);\n    }\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private void addReverse(final File[] files) {\n  for (int i = 0; i < files.length; i++) {\n    this.add(files[i]);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files) {\n  if (files == null) {\n    return;\n  }\n  for (int i = files.length - 1; i >= 0; --i) {\n    final File file = files[i];\n    if (file.isDirectory()) {\n      addReverse(file.listFiles());\n    } else {\n      if (!file.getName().toLowerCase().endsWith(\".dat\")) {\n        filesStack.push(file);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add the specified files in reverse order.\n */\n", "method_name": "addReverse", "codes": ["private void addReverse(final File[] files){ for (int i = files.length - 1; i >= 0; i--) { addReverse(files[i]); } }", "private void addReverse(final File[] files){ final File[] temp = new File[files.length]; int i = files.length - 1; for (final File file : files) { temp[i] = file; i--; } files = temp; }", "private void addReverse(final File[] files){ if (files == null) { return; } if (files.length <= 1) { return; } final File last = files[files.length - 1]; final File[] newFiles = new File[files.length - 1]; for (int i = 0; i < files.length - 1; i++) { newFiles[i] = files[i]; } newFiles[files.length - 1] = last; addReverse(newFiles); }", "private void addReverse(final File[] files){ for (int i = 0; i < files.length; i++) { final File file = files[i]; final String filename = file.getName(); final int index = filename.lastIndexOf('.'); if (index != -1) { filename = filename.substring(0, index); } final String extension = filename.substring(index + 1); add(file); } }", "private void addReverse(final File[] files){ for (File file : files) { add(file); } }", "private void addReverse(final File[] files){ for (int i = files.length - 1; i >= 0; i--) { this.add(files[i]); } }", "private void addReverse(final File[] files){ for (File file : files) { addReverse(file); } }", "private void addReverse(final File[] files){ for (int i = 0; i < files.length; i++) { if (files[i].isDirectory()) { addReverse(files[i].listFiles()); } else { stack.push(files[i]); } } }", "private void addReverse(final File[] files){ for (int i = 0; i < files.length; i++) { this.add(files[i]); } }", "private void addReverse(final File[] files){ if (files == null) { return; } for (int i = files.length - 1; i >= 0; --i) { final File file = files[i]; if (file.isDirectory()) { addReverse(file.listFiles()); } else { if (!file.getName().toLowerCase().endsWith(\".dat\")) { filesStack.push(file); } } } }"], "code_level": "class_runnable", "_id": "636766831a6d9265ec0174eb", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  if (lastWriteTimeStampInMilliseconds != null) return lastWriteTimeStampInMilliseconds;\n  lastWriteTimeStampInMilliseconds = System.currentTimeMillis();\n  return lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  if (lastWriteTimeStamp == -1) {\n    return System.currentTimeMillis();\n  } else {\n    return lastWriteTimeStamp;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStampInMilliseconds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStampInMilliseconds(false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  return lastWriteTimeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds() {\n  if (lastWriteTimeStamp == null) {\n    synchronized (this) {\n      if (lastWriteTimeStamp == null) {\n        lastWriteTimeStamp = System.currentTimeMillis();\n      }\n    }\n  }\n  return lastWriteTimeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * The last time, in milliseconds, a write operation occurred.\n * @return this\n */\n", "method_name": "lastWriteTimeStampInMilliseconds", "codes": ["public long lastWriteTimeStampInMilliseconds(){ if (lastWriteTimeStampInMilliseconds != null) return lastWriteTimeStampInMilliseconds; lastWriteTimeStampInMilliseconds = System.currentTimeMillis(); return lastWriteTimeStampInMilliseconds; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStampInMilliseconds; }", "public long lastWriteTimeStampInMilliseconds(){ if (lastWriteTimeStamp == -1) { return System.currentTimeMillis(); } else { return lastWriteTimeStamp; } }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStampInMilliseconds; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStampInMilliseconds; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStampInMilliseconds; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStampInMilliseconds; }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStampInMilliseconds(false); }", "public long lastWriteTimeStampInMilliseconds(){ return lastWriteTimeStamp; }", "public long lastWriteTimeStampInMilliseconds(){ if (lastWriteTimeStamp == null) { synchronized (this) { if (lastWriteTimeStamp == null) { lastWriteTimeStamp = System.currentTimeMillis(); } } } return lastWriteTimeStamp; }"], "code_level": "class_runnable", "_id": "6367667e1a6d9265ec01743a", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (r.isResumed()) {\n    if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) {\n      if (r.uuid() != null) {\n        if (r.uuid().equals(\"0\")) {\n          r.getResponse().setContentType(\"text/html\");\n          r.getResponse().setStatus(200);\n          return Action.CONTINUE;\n        }\n      }\n    }\n  }\n  return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) {\n    return Action.CONTINUE;\n  } else {\n    return Action.SKIP_AND_CONTINUE;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  r.getRequest().setAttribute(TRANSPORT, r.transport());\n  return Action.CONTINUE;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (r.getRequest().getAttribute(ATMOSPHERE_RESOURCE) == null) {\n    r.getRequest().setAttribute(ATMOSPHERE_RESOURCE, r);\n  }\n  return Action.CONTINUE;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  if (r.getRequest().getAttribute(TRANSPORT.getName()) != null) {\n    logger.debug(\n        \"AtmosphereResource is in transport {}\",\n        r.getRequest().getAttribute(TRANSPORT.getName()));\n    r.suspend();\n    return Action.CONTINUE;\n  } else {\n    r.getResponse().setContentType(\"text/html\");\n    return Action.CANCEL;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override\npublic Action inspect(AtmosphereResource r) {\n  AtmosphereRequest req = r.getRequest();\n  if (req.getAttribute(TRANSPORT) != null) {\n    AtmosphereResponse resp = r.getResponse();\n    resp.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    resp.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE\");\n    resp.setHeader(\"Access-Control-Max-Age\", \"3600\");\n    resp.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With, Content-Type, Accept\");\n    return Action.CONTINUE;\n  } else {\n    return Action.CONTINUE;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Automatically suspend the  {@link AtmosphereResource} based on {@link AtmosphereResource.TRANSPORT} value.\n * @param r a {@link AtmosphereResource}\n * @return {@link Action#CONTINUE}\n */\n", "method_name": "inspect", "codes": ["@Override public Action inspect(AtmosphereResource r){ return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ if (r.isResumed()) { if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) { if (r.uuid() != null) { if (r.uuid().equals(\"0\")) { r.getResponse().setContentType(\"text/html\"); r.getResponse().setStatus(200); return Action.CONTINUE; } } } } return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET) { return Action.CONTINUE; } else { return Action.SKIP_AND_CONTINUE; } }", "@Override public Action inspect(AtmosphereResource r){ return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ r.getRequest().setAttribute(TRANSPORT, r.transport()); return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ if (r.getRequest().getAttribute(ATMOSPHERE_RESOURCE) == null) { r.getRequest().setAttribute(ATMOSPHERE_RESOURCE, r); } return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ if (r.getRequest().getAttribute(TRANSPORT.getName()) != null) { logger.debug(\"AtmosphereResource is in transport {}\", r.getRequest().getAttribute(TRANSPORT.getName())); r.suspend(); return Action.CONTINUE; } else { r.getResponse().setContentType(\"text/html\"); return Action.CANCEL; } }", "@Override public Action inspect(AtmosphereResource r){ return Action.CONTINUE; }", "@Override public Action inspect(AtmosphereResource r){ AtmosphereRequest req = r.getRequest(); if (req.getAttribute(TRANSPORT) != null) { AtmosphereResponse resp = r.getResponse(); resp.setHeader(\"Access-Control-Allow-Origin\", \"*\"); resp.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE\"); resp.setHeader(\"Access-Control-Max-Age\", \"3600\"); resp.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With, Content-Type, Accept\"); return Action.CONTINUE; } else { return Action.CONTINUE; } }"], "code_level": "project_runnable", "_id": "636766851a6d9265ec017515", "project_name": "atmosphere-atmosphere-2.7.x"}, {"generate_results": [{"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (ObjectUtils.isEmpty(array)) {\n    return array;\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (isEmpty(array)) {\n    return array;\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (array == null) {\n    return null;\n  }\n  int length = array.length;\n  for (int i = 0; i < length; i++) {\n    String element = array[i];\n    array[i] = element.trim();\n  }\n  return array;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (array == null || array.length == 0) {\n    return array;\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (ObjectUtils.isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (ObjectUtils.isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (ObjectUtils.isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (ObjectUtils.isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array) {\n  if (array == null || array.length == 0) {\n    return array;\n  }\n  String[] result = new String[array.length];\n  for (int i = 0; i < array.length; i++) {\n    String element = array[i];\n    result[i] = (element != null ? element.trim() : null);\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.\n * @param array the original String array\n * @return the resulting array (of the same size) with trimmed elements\n */\n", "method_name": "trimArrayElements", "codes": ["public static String[] trimArrayElements(String[] array){ if (isEmpty(array)) { return new String[0]; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (ObjectUtils.isEmpty(array)) { return array; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (isEmpty(array)) { return array; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (array == null) { return null; } int length = array.length; for (int i = 0; i < length; i++) { String element = array[i]; array[i] = element.trim(); } return array; }", "public static String[] trimArrayElements(String[] array){ if (array == null || array.length == 0) { return array; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (ObjectUtils.isEmpty(array)) { return new String[0]; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (ObjectUtils.isEmpty(array)) { return new String[0]; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (ObjectUtils.isEmpty(array)) { return new String[0]; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (ObjectUtils.isEmpty(array)) { return new String[0]; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }", "public static String[] trimArrayElements(String[] array){ if (array == null || array.length == 0) { return array; } String[] result = new String[array.length]; for (int i = 0; i < array.length; i++) { String element = array[i]; result[i] = (element != null ? element.trim() : null); } return result; }"], "code_level": "self_contained", "_id": "6367676d1a6d9265ec018229", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + Long.hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + Long.hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  int arraySize = array.length;\n  for (int i = 0; i < arraySize; i++) {\n    hash = MULTIPLIER * hash + nullSafeHashCode(array[i]);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  int arraySize = array.length;\n  for (int i = 0; i < arraySize; i++) {\n    hash = MULTIPLIER * hash + hashCode(array[i]);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  int arraySize = array.length;\n  for (int i = 0; i < arraySize; i++) {\n    hash = MULTIPLIER * hash + nullSafeHashCode(array[i]);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array) {\n  if (array == null) {\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  int arraySize = array.length;\n  for (long element : array) {\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.\n * @param array the long array to obtain a hashcode\n * @return the long array's hashcode, which could be 0 if the array is null.\n */\n", "method_name": "nullSafeHashCode", "codes": ["public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + Long.hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + Long.hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; int arraySize = array.length; for (int i = 0; i < arraySize; i++) { hash = MULTIPLIER * hash + nullSafeHashCode(array[i]); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; int arraySize = array.length; for (int i = 0; i < arraySize; i++) { hash = MULTIPLIER * hash + hashCode(array[i]); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; int arraySize = array.length; for (int i = 0; i < arraySize; i++) { hash = MULTIPLIER * hash + nullSafeHashCode(array[i]); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }", "public static int nullSafeHashCode(long[] array){ if (array == null) { return 0; } int hash = INITIAL_HASH; int arraySize = array.length; for (long element : array) { hash = MULTIPLIER * hash + hashCode(element); } return hash; }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181aa", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.startsWith(prefix)) {\n    return true;\n  }\n  if (str.length() < prefix.length()) {\n    return false;\n  }\n  String lcStr = str.substring(0, prefix.length()).toLowerCase();\n  String lcPrefix = prefix.toLowerCase();\n  return lcStr.equals(lcPrefix);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWith(str, prefix, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.length() < prefix.length()) {\n    return false;\n  }\n  return str.regionMatches(true, str.length() - prefix.length(), prefix, 0, prefix.length());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWithIgnoreCase(str, prefix, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.length() < prefix.length()) {\n    return false;\n  }\n  return str.regionMatches(true, str.length() - prefix.length(), prefix, 0, prefix.length());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.length() < prefix.length()) {\n    return false;\n  }\n  return str.regionMatches(true, str.length() - prefix.length(), prefix, 0, prefix.length());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWith(str, prefix, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.startsWith(prefix)) {\n    return true;\n  }\n  if (str.length() < prefix.length()) {\n    return false;\n  }\n  String lcStr = str.substring(0, prefix.length()).toLowerCase();\n  String lcPrefix = prefix.toLowerCase();\n  return lcStr.equals(lcPrefix);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.length() < prefix.length()) {\n    return false;\n  }\n  return str.regionMatches(true, str.length() - prefix.length(), prefix, 0, prefix.length());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n  return startsWithIgnoreCase(str, prefix, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @param str the String to check\n * @param prefix the prefix to look for\n * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @see java.lang.String#startsWith\n */\n", "method_name": "startsWithIgnoreCase", "codes": ["public static boolean startsWithIgnoreCase(String str,String prefix){ if (str == null || prefix == null) { return false; } if (str.startsWith(prefix)) { return true; } if (str.length() < prefix.length()) { return false; } String lcStr = str.substring(0, prefix.length()).toLowerCase(); String lcPrefix = prefix.toLowerCase(); return lcStr.equals(lcPrefix); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWith(str, prefix, false); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ if (str == null || prefix == null) { return false; } if (str.length() < prefix.length()) { return false; } return str.regionMatches(true, str.length() - prefix.length(), prefix, 0, prefix.length()); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWithIgnoreCase(str, prefix, false); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ if (str == null || prefix == null) { return false; } if (str.length() < prefix.length()) { return false; } return str.regionMatches(true, str.length() - prefix.length(), prefix, 0, prefix.length()); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ if (str == null || prefix == null) { return false; } if (str.length() < prefix.length()) { return false; } return str.regionMatches(true, str.length() - prefix.length(), prefix, 0, prefix.length()); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWith(str, prefix, true); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ if (str == null || prefix == null) { return false; } if (str.startsWith(prefix)) { return true; } if (str.length() < prefix.length()) { return false; } String lcStr = str.substring(0, prefix.length()).toLowerCase(); String lcPrefix = prefix.toLowerCase(); return lcStr.equals(lcPrefix); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ if (str == null || prefix == null) { return false; } if (str.length() < prefix.length()) { return false; } return str.regionMatches(true, str.length() - prefix.length(), prefix, 0, prefix.length()); }", "public static boolean startsWithIgnoreCase(String str,String prefix){ return startsWithIgnoreCase(str, prefix, false); }"], "code_level": "self_contained", "_id": "6367676b1a6d9265ec0181df", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (candidates.isEmpty()) return null;\n  int i = 0;\n  Object result = null;\n  for (Iterator it = candidates.iterator(); it.hasNext(); ) {\n    Object candidate = it.next();\n    if (source.contains(candidate)) {\n      if (result != null) {\n        return result;\n      }\n      result = candidate;\n      i++;\n    }\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  Object result = null;\n  for (Object candidate : candidates) {\n    if (source.contains(candidate)) {\n      if (result == null) {\n        result = candidate;\n      } else {\n        throw new IllegalArgumentException(\n            \"Candidates must not contain more than one element: \" + candidates);\n      }\n    }\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (candidates == null) return null;\n  if (candidates.size() == 0) return null;\n  if (source == null) return null;\n  Object obj = source.iterator().next();\n  if (obj == null) return null;\n  if (!candidates.contains(obj)) return null;\n  return obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (source == null || candidates == null) {\n    return null;\n  }\n  for (Iterator iter = candidates.iterator(); iter.hasNext(); ) {\n    Object candidate = iter.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  Iterator iter = source.iterator();\n  while (iter.hasNext()) {\n    Object candidate = iter.next();\n    if (candidates.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  return findFirstMatch(source.iterator(), candidates.iterator());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  Iterator it = candidates.iterator();\n  while (it.hasNext()) {\n    Object candidate = it.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (candidates.size() == 0) {\n    return null;\n  }\n  Object result = null;\n  Object candidate = null;\n  int index = 0;\n  for (Iterator iter = candidates.iterator(); iter.hasNext(); ) {\n    candidate = iter.next();\n    if (source.contains(candidate)) {\n      if (result == null) {\n        result = candidate;\n      } else {\n        index++;\n        if (index == candidates.size()) {\n          result = candidate;\n        }\n      }\n    }\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  if (source == null || candidates == null || candidates.size() == 0) {\n    return null;\n  }\n  Iterator it = candidates.iterator();\n  while (it.hasNext()) {\n    Object candidate = it.next();\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Object findFirstMatch(Collection source, Collection candidates) {\n  Object first = null;\n  if (source != null) {\n    first = findFirstMatch(source.iterator(), candidates);\n  }\n  return first;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.\n * @param source the source Collection\n * @param candidates the candidates to search for\n * @return the first present object, or <code>null</code> if not found\n */\n", "method_name": "findFirstMatch", "codes": ["public static Object findFirstMatch(Collection source,Collection candidates){ if (candidates.isEmpty()) return null; int i = 0; Object result = null; for (Iterator it = candidates.iterator(); it.hasNext(); ) { Object candidate = it.next(); if (source.contains(candidate)) { if (result != null) { return result; } result = candidate; i++; } } return result; }", "public static Object findFirstMatch(Collection source,Collection candidates){ Object result = null; for (Object candidate : candidates) { if (source.contains(candidate)) { if (result == null) { result = candidate; } else { throw new IllegalArgumentException(\"Candidates must not contain more than one element: \" + candidates); } } } return result; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (candidates == null) return null; if (candidates.size() == 0) return null; if (source == null) return null; Object obj = source.iterator().next(); if (obj == null) return null; if (!candidates.contains(obj)) return null; return obj; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (source == null || candidates == null) { return null; } for (Iterator iter = candidates.iterator(); iter.hasNext(); ) { Object candidate = iter.next(); if (source.contains(candidate)) { return candidate; } } return null; }", "public static Object findFirstMatch(Collection source,Collection candidates){ Iterator iter = source.iterator(); while (iter.hasNext()) { Object candidate = iter.next(); if (candidates.contains(candidate)) { return candidate; } } return null; }", "public static Object findFirstMatch(Collection source,Collection candidates){ return findFirstMatch(source.iterator(), candidates.iterator()); }", "public static Object findFirstMatch(Collection source,Collection candidates){ Iterator it = candidates.iterator(); while (it.hasNext()) { Object candidate = it.next(); if (source.contains(candidate)) { return candidate; } } return null; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (candidates.size() == 0) { return null; } Object result = null; Object candidate = null; int index = 0; for (Iterator iter = candidates.iterator(); iter.hasNext(); ) { candidate = iter.next(); if (source.contains(candidate)) { if (result == null) { result = candidate; } else { index++; if (index == candidates.size()) { result = candidate; } } } } return result; }", "public static Object findFirstMatch(Collection source,Collection candidates){ if (source == null || candidates == null || candidates.size() == 0) { return null; } Iterator it = candidates.iterator(); while (it.hasNext()) { Object candidate = it.next(); if (source.contains(candidate)) { return candidate; } } return null; }", "public static Object findFirstMatch(Collection source,Collection candidates){ Object first = null; if (source != null) { first = findFirstMatch(source.iterator(), candidates); } return first; }"], "code_level": "class_runnable", "_id": "6367676b1a6d9265ec0181e2", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Trim trailing whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "method_name": "trimTrailingWhitespace", "codes": ["public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }", "public static String trimTrailingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }"], "code_level": "class_runnable", "_id": "6367676b1a6d9265ec0181ee", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    obj = \"'\" + obj + \"'\";\n  }\n  return obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) return obj;\n  else return quote(obj);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return \"\\\"\" + obj.toString() + \"\\\"\";\n  }\n  return obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return quoteIfString((String) obj);\n  } else {\n    return obj;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    String s = (String) obj;\n    return s.replace(\"\\\"\", \"\\\\\\\"\");\n  }\n  return obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return quote((String) obj);\n  }\n  return obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return obj;\n  } else {\n    return quoteIfNumber(obj);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return obj;\n  } else if (obj instanceof Character) {\n    return quote((Character) obj);\n  } else if (obj instanceof Number) {\n    return quote((Number) obj);\n  } else if (obj instanceof Boolean) {\n    return quote((Boolean) obj);\n  } else if (obj instanceof Date) {\n    return quote((Date) obj);\n  } else if (obj instanceof JSONArray) {\n    return quote((JSONArray) obj);\n  } else if (obj instanceof JSONObject) {\n    return quote((JSONObject) obj);\n  } else if (obj instanceof Map) {\n    return quote((Map) obj);\n  } else if (obj instanceof Collection) {\n    return quote((Collection) obj);\n  } else if (obj instanceof Object[]) {\n    return quote((Object[]) obj);\n  } else {\n    return obj;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return obj;\n  }\n  if (obj instanceof Number) {\n    return obj;\n  }\n  if (obj instanceof Boolean) {\n    return obj;\n  }\n  if (obj instanceof Character) {\n    return obj;\n  }\n  if (obj instanceof Character[]) {\n    return quoteArray((Character[]) obj);\n  }\n  if (obj instanceof Character[][]) {\n    return quoteArray((Character[][]) obj);\n  }\n  if (obj instanceof Character[][][]) {\n    return quoteArray((Character[][][]) obj);\n  }\n  if (obj instanceof Object[]) {\n    return quoteArray((Object[]) obj);\n  }\n  return quote(obj);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj) {\n  if (obj instanceof String) {\n    return obj;\n  } else {\n    return quote(obj);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.\n * @param obj the input Object (e.g. \"myString\")\n * @return the quoted String (e.g. \"'myString'\"),or the input object as-is if not a String\n */\n", "method_name": "quoteIfString", "codes": ["public static Object quoteIfString(Object obj){ if (obj instanceof String) { obj = \"'\" + obj + \"'\"; } return obj; }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) return obj; else return quote(obj); }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return \"\\\"\" + obj.toString() + \"\\\"\"; } return obj; }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return quoteIfString((String) obj); } else { return obj; } }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { String s = (String) obj; return s.replace(\"\\\"\", \"\\\\\\\"\"); } return obj; }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return quote((String) obj); } return obj; }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return obj; } else { return quoteIfNumber(obj); } }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return obj; } else if (obj instanceof Character) { return quote((Character) obj); } else if (obj instanceof Number) { return quote((Number) obj); } else if (obj instanceof Boolean) { return quote((Boolean) obj); } else if (obj instanceof Date) { return quote((Date) obj); } else if (obj instanceof JSONArray) { return quote((JSONArray) obj); } else if (obj instanceof JSONObject) { return quote((JSONObject) obj); } else if (obj instanceof Map) { return quote((Map) obj); } else if (obj instanceof Collection) { return quote((Collection) obj); } else if (obj instanceof Object[]) { return quote((Object[]) obj); } else { return obj; } }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return obj; } if (obj instanceof Number) { return obj; } if (obj instanceof Boolean) { return obj; } if (obj instanceof Character) { return obj; } if (obj instanceof Character[]) { return quoteArray((Character[]) obj); } if (obj instanceof Character[][]) { return quoteArray((Character[][]) obj); } if (obj instanceof Character[][][]) { return quoteArray((Character[][][]) obj); } if (obj instanceof Object[]) { return quoteArray((Object[]) obj); } return quote(obj); }", "public static Object quoteIfString(Object obj){ if (obj instanceof String) { return obj; } else { return quote(obj); } }"], "code_level": "class_runnable", "_id": "6367676a1a6d9265ec0181bf", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Trim leading whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "method_name": "trimLeadingWhitespace", "codes": ["public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingWhitespace(String str){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) { sb.deleteCharAt(0); } return sb.toString(); }"], "code_level": "class_runnable", "_id": "6367676a1a6d9265ec0181cd", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  Vector<String> result = new Vector<String>();\n  while (enumeration.hasMoreElements()) {\n    result.add(enumeration.nextElement());\n  }\n  return result.toArray(new String[result.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  Vector<String> vector = new Vector<String>();\n  while (enumeration.hasMoreElements()) vector.add(enumeration.nextElement());\n  return vector.toArray(new String[vector.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  Vector<String> vector = new Vector<String>();\n  while (enumeration.hasMoreElements()) {\n    vector.add(enumeration.nextElement());\n  }\n  return (String[]) vector.toArray(new String[0]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  Vector<String> list = new Vector<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  List<String> list = new ArrayList<String>();\n  while (enumeration.hasMoreElements()) {\n    list.add(enumeration.nextElement());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  Vector<String> vector = new Vector<String>();\n  while (enumeration.hasMoreElements()) {\n    vector.add(enumeration.nextElement());\n  }\n  return vector.toArray(new String[vector.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  String[] array = new String[enumeration.count()];\n  int i = 0;\n  while (enumeration.hasMoreElements()) {\n    array[i++] = enumeration.nextElement();\n  }\n  return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration) {\n  if (enumeration == null) {\n    return null;\n  }\n  Vector<String> result = new Vector<String>();\n  while (enumeration.hasMoreElements()) {\n    result.add(enumeration.nextElement());\n  }\n  return (String[]) result.toArray(new String[result.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Copy the given Enumeration into a String array. The Enumeration must contain String elements only.\n * @param enumeration the Enumeration to copy\n * @return the String array (<code>null</code> if the passed-inEnumeration was <code>null</code>)\n */\n", "method_name": "toStringArray", "codes": ["public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } Vector<String> result = new Vector<String>(); while (enumeration.hasMoreElements()) { result.add(enumeration.nextElement()); } return result.toArray(new String[result.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ Vector<String> vector = new Vector<String>(); while (enumeration.hasMoreElements()) vector.add(enumeration.nextElement()); return vector.toArray(new String[vector.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } Vector<String> vector = new Vector<String>(); while (enumeration.hasMoreElements()) { vector.add(enumeration.nextElement()); } return (String[]) vector.toArray(new String[0]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ Vector<String> list = new Vector<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } List<String> list = new ArrayList<String>(); while (enumeration.hasMoreElements()) { list.add(enumeration.nextElement()); } return list.toArray(new String[list.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } Vector<String> vector = new Vector<String>(); while (enumeration.hasMoreElements()) { vector.add(enumeration.nextElement()); } return vector.toArray(new String[vector.size()]); }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } String[] array = new String[enumeration.count()]; int i = 0; while (enumeration.hasMoreElements()) { array[i++] = enumeration.nextElement(); } return array; }", "public static String[] toStringArray(Enumeration<String> enumeration){ if (enumeration == null) { return null; } Vector<String> result = new Vector<String>(); while (enumeration.hasMoreElements()) { result.add(enumeration.nextElement()); } return (String[]) result.toArray(new String[result.size()]); }"], "code_level": "slib_runnable", "_id": "636767691a6d9265ec0181ae", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString == null) {\n    return null;\n  }\n  if (charsToDelete == null) {\n    return inString;\n  }\n  int pos = 0;\n  int pos2 = 0;\n  int pos3 = 0;\n  int pos4 = 0;\n  int pos5 = 0;\n  int pos6 = 0;\n  int pos7 = 0;\n  while ((pos = inString.indexOf(charsToDelete, pos)) >= 0) {\n    pos2 = pos + charsToDelete.length();\n    pos3 = pos2 + 1;\n    pos4 = pos3 + 1;\n    pos5 = pos4 + 1;\n    pos6 = pos5 + 1;\n    pos7 = pos6 + 1;\n  }\n  return inString.substring(0, pos7);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString == null || inString.length() == 0) {\n    return inString;\n  }\n  if (charsToDelete == null) {\n    return inString;\n  }\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (charsToDelete == null) {\n    return inString;\n  }\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString == null || charsToDelete == null) {\n    return null;\n  }\n  StringBuffer outBuffer = new StringBuffer();\n  for (int i = 0; i < inString.length(); i++) {\n    if (!charsToDelete.contains(inString.charAt(i) + \"\")) {\n      outBuffer.append(inString.charAt(i));\n    }\n  }\n  return outBuffer.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString.length() == 0) {\n    return \"\";\n  }\n  if (charsToDelete.length() == 0) {\n    return inString;\n  }\n  char[] charArray = inString.toCharArray();\n  int charsToDeleteCount = 0;\n  int inStringIndex = 0;\n  while (charsToDeleteCount < charsToDelete.length()) {\n    char currentChar = charArray[inStringIndex];\n    if (charsToDelete.indexOf(currentChar) >= 0) {\n      inStringIndex++;\n      charsToDeleteCount++;\n    } else {\n      charArray[inStringIndex] = currentChar;\n      inStringIndex++;\n      charsToDeleteCount++;\n    }\n  }\n  return new String(charArray, 0, inStringIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString == null || charsToDelete == null) {\n    return inString;\n  }\n  StringBuilder out = new StringBuilder(inString);\n  for (char c : charsToDelete.toCharArray()) {\n    if (out.indexOf(c) == -1) {\n      out.deleteCharAt(out.indexOf(c));\n    }\n  }\n  return out.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString == null || charsToDelete == null) {\n    return null;\n  }\n  if (inString.length() == 0 || charsToDelete.length() == 0) {\n    return inString;\n  }\n  StringBuilder out = new StringBuilder();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      out.append(c);\n    }\n  }\n  return out.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString == null || charsToDelete == null) {\n    return null;\n  }\n  StringBuffer outString = new StringBuffer();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      outString.append(c);\n    }\n  }\n  return outString.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (isEmpty(inString) || isEmpty(charsToDelete)) {\n    return inString;\n  }\n  StringBuilder out = new StringBuilder();\n  int pos = 0;\n  while ((pos = inString.indexOf(charsToDelete, pos)) != -1) {\n    out.append(inString.substring(pos));\n    out.append(\" \");\n    pos += charsToDelete.length();\n  }\n  out.append(inString.substring(pos));\n  return out.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String deleteAny(String inString, String charsToDelete) {\n  if (inString == null || charsToDelete == null) {\n    return null;\n  }\n  StringBuffer out = new StringBuffer();\n  for (int i = 0; i < inString.length(); i++) {\n    char c = inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      out.append(c);\n    }\n  }\n  return out.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Delete any character in a given String.\n * @param inString the original String\n * @param charsToDelete a set of characters to delete.E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n * @return the resulting String\n */\n", "method_name": "deleteAny", "codes": ["public static String deleteAny(String inString,String charsToDelete){ if (inString == null) { return null; } if (charsToDelete == null) { return inString; } int pos = 0; int pos2 = 0; int pos3 = 0; int pos4 = 0; int pos5 = 0; int pos6 = 0; int pos7 = 0; while ((pos = inString.indexOf(charsToDelete, pos)) >= 0) { pos2 = pos + charsToDelete.length(); pos3 = pos2 + 1; pos4 = pos3 + 1; pos5 = pos4 + 1; pos6 = pos5 + 1; pos7 = pos6 + 1; } return inString.substring(0, pos7); }", "public static String deleteAny(String inString,String charsToDelete){ if (inString == null || inString.length() == 0) { return inString; } if (charsToDelete == null) { return inString; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { sb.append(c); } } return sb.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (charsToDelete == null) { return inString; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { sb.append(c); } } return sb.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (inString == null || charsToDelete == null) { return null; } StringBuffer outBuffer = new StringBuffer(); for (int i = 0; i < inString.length(); i++) { if (!charsToDelete.contains(inString.charAt(i) + \"\")) { outBuffer.append(inString.charAt(i)); } } return outBuffer.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (inString.length() == 0) { return \"\"; } if (charsToDelete.length() == 0) { return inString; } char[] charArray = inString.toCharArray(); int charsToDeleteCount = 0; int inStringIndex = 0; while (charsToDeleteCount < charsToDelete.length()) { char currentChar = charArray[inStringIndex]; if (charsToDelete.indexOf(currentChar) >= 0) { inStringIndex++; charsToDeleteCount++; } else { charArray[inStringIndex] = currentChar; inStringIndex++; charsToDeleteCount++; } } return new String(charArray, 0, inStringIndex); }", "public static String deleteAny(String inString,String charsToDelete){ if (inString == null || charsToDelete == null) { return inString; } StringBuilder out = new StringBuilder(inString); for (char c : charsToDelete.toCharArray()) { if (out.indexOf(c) == -1) { out.deleteCharAt(out.indexOf(c)); } } return out.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (inString == null || charsToDelete == null) { return null; } if (inString.length() == 0 || charsToDelete.length() == 0) { return inString; } StringBuilder out = new StringBuilder(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { out.append(c); } } return out.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (inString == null || charsToDelete == null) { return null; } StringBuffer outString = new StringBuffer(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { outString.append(c); } } return outString.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (isEmpty(inString) || isEmpty(charsToDelete)) { return inString; } StringBuilder out = new StringBuilder(); int pos = 0; while ((pos = inString.indexOf(charsToDelete, pos)) != -1) { out.append(inString.substring(pos)); out.append(\" \"); pos += charsToDelete.length(); } out.append(inString.substring(pos)); return out.toString(); }", "public static String deleteAny(String inString,String charsToDelete){ if (inString == null || charsToDelete == null) { return null; } StringBuffer out = new StringBuffer(); for (int i = 0; i < inString.length(); i++) { char c = inString.charAt(i); if (charsToDelete.indexOf(c) == -1) { out.append(c); } } return out.toString(); }"], "code_level": "class_runnable", "_id": "6367676c1a6d9265ec01820b", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null || element == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null || element == null) {\n    return false;\n  }\n  if (collection instanceof List) {\n    List list = (List) collection;\n    return list.contains(element);\n  }\n  Iterator iter = collection.iterator();\n  while (iter.hasNext()) {\n    Object o = iter.next();\n    if (element.equals(o)) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null || element == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    return false;\n  }\n  if (element == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) {\n    throw new NullPointerException(\"collection cannot be null\");\n  }\n  if (element == null) {\n    throw new NullPointerException(\"element cannot be null\");\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null || element == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null) return false;\n  if (collection.isEmpty()) return false;\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null || element == null) {\n    return false;\n  }\n  boolean result = false;\n  Iterator iter = collection.iterator();\n  while (iter.hasNext()) {\n    Object obj = iter.next();\n    if (element.equals(obj)) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection, Object element) {\n  if (collection == null || element == null) {\n    return false;\n  }\n  return collection.contains(element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Check whether the given Collection contains the given element instance. <p>Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.\n * @param collection the Collection to check\n * @param element the element to look for\n * @return <code>true</code> if found, <code>false</code> else\n */\n", "method_name": "containsInstance", "codes": ["public static boolean containsInstance(Collection collection,Object element){ if (collection == null || element == null) { return false; } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null || element == null) { return false; } if (collection instanceof List) { List list = (List) collection; return list.contains(element); } Iterator iter = collection.iterator(); while (iter.hasNext()) { Object o = iter.next(); if (element.equals(o)) { return true; } } return false; }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null || element == null) { return false; } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { return false; } if (element == null) { return false; } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { return false; } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) { throw new NullPointerException(\"collection cannot be null\"); } if (element == null) { throw new NullPointerException(\"element cannot be null\"); } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null || element == null) { return false; } return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null) return false; if (collection.isEmpty()) return false; return collection.contains(element); }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null || element == null) { return false; } boolean result = false; Iterator iter = collection.iterator(); while (iter.hasNext()) { Object obj = iter.next(); if (element.equals(obj)) { result = true; break; } } return result; }", "public static boolean containsInstance(Collection collection,Object element){ if (collection == null || element == null) { return false; } return collection.contains(element); }"], "code_level": "slib_runnable", "_id": "6367676c1a6d9265ec018223", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  String[] result = new String[array1.length + array2.length];\n  System.arraycopy(array1, 0, result, 0, array1.length);\n  System.arraycopy(array2, 0, result, array1.length, array2.length);\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  int length1 = array1.length;\n  int length2 = array2.length;\n  String[] result = new String[length1 + length2];\n  System.arraycopy(array1, 0, result, 0, length1);\n  System.arraycopy(array2, 0, result, length1, length2);\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  String[] result = new String[array1.length + array2.length];\n  System.arraycopy(array1, 0, result, 0, array1.length);\n  System.arraycopy(array2, 0, result, array1.length, array2.length);\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  String[] result = new String[array1.length + array2.length];\n  System.arraycopy(array1, 0, result, 0, array1.length);\n  System.arraycopy(array2, 0, result, array1.length, array2.length);\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  int length1 = array1.length;\n  int length2 = array2.length;\n  String[] retArray = new String[length1 + length2];\n  System.arraycopy(array1, 0, retArray, 0, length1);\n  System.arraycopy(array2, 0, retArray, length1, length2);\n  return retArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  String[] newArr = new String[array1.length + array2.length];\n  System.arraycopy(array1, 0, newArr, 0, array1.length);\n  System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  String[] result = new String[array1.length + array2.length];\n  int i = 0;\n  for (String s : array1) {\n    result[i] = s;\n    i++;\n  }\n  for (String s : array2) {\n    result[i] = s;\n    i++;\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  String[] result = new String[array1.length + array2.length];\n  System.arraycopy(array1, 0, result, 0, array1.length);\n  System.arraycopy(array2, 0, result, array1.length, array2.length);\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  if ((array1 == null) || (array2 == null)) {\n    return null;\n  }\n  int array1Length = array1.length;\n  int array2Length = array2.length;\n  String[] newArray = new String[array1Length + array2Length];\n  System.arraycopy(array1, 0, newArray, 0, array1Length);\n  System.arraycopy(array2, 0, newArray, array1Length, array2Length);\n  return newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n  String[] result = new String[array1.length + array2.length];\n  System.arraycopy(array1, 0, result, 0, array1.length);\n  System.arraycopy(array2, 0, result, array1.length, array2.length);\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.\n * @param array1 the first array (can be <code>null</code>)\n * @param array2 the second array (can be <code>null</code>)\n * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n */\n", "method_name": "concatenateStringArrays", "codes": ["public static String[] concatenateStringArrays(String[] array1,String[] array2){ String[] result = new String[array1.length + array2.length]; System.arraycopy(array1, 0, result, 0, array1.length); System.arraycopy(array2, 0, result, array1.length, array2.length); return result; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ int length1 = array1.length; int length2 = array2.length; String[] result = new String[length1 + length2]; System.arraycopy(array1, 0, result, 0, length1); System.arraycopy(array2, 0, result, length1, length2); return result; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ String[] result = new String[array1.length + array2.length]; System.arraycopy(array1, 0, result, 0, array1.length); System.arraycopy(array2, 0, result, array1.length, array2.length); return result; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ String[] result = new String[array1.length + array2.length]; System.arraycopy(array1, 0, result, 0, array1.length); System.arraycopy(array2, 0, result, array1.length, array2.length); return result; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ int length1 = array1.length; int length2 = array2.length; String[] retArray = new String[length1 + length2]; System.arraycopy(array1, 0, retArray, 0, length1); System.arraycopy(array2, 0, retArray, length1, length2); return retArray; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ String[] newArr = new String[array1.length + array2.length]; System.arraycopy(array1, 0, newArr, 0, array1.length); System.arraycopy(array2, 0, newArr, array1.length, array2.length); return newArr; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ String[] result = new String[array1.length + array2.length]; int i = 0; for (String s : array1) { result[i] = s; i++; } for (String s : array2) { result[i] = s; i++; } return result; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ String[] result = new String[array1.length + array2.length]; System.arraycopy(array1, 0, result, 0, array1.length); System.arraycopy(array2, 0, result, array1.length, array2.length); return result; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ if ((array1 == null) || (array2 == null)) { return null; } int array1Length = array1.length; int array2Length = array2.length; String[] newArray = new String[array1Length + array2Length]; System.arraycopy(array1, 0, newArray, 0, array1Length); System.arraycopy(array2, 0, newArray, array1Length, array2Length); return newArray; }", "public static String[] concatenateStringArrays(String[] array1,String[] array2){ String[] result = new String[array1.length + array2.length]; System.arraycopy(array1, 0, result, 0, array1.length); System.arraycopy(array2, 0, result, array1.length, array2.length); return result; }"], "code_level": "slib_runnable", "_id": "6367676c1a6d9265ec018204", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (array == null) {\n    array = new String[1];\n    array[0] = str;\n  } else {\n    array = ArrayUtils.add(array, str);\n  }\n  return array;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  String[] newArray = new String[array.length + 1];\n  for (int i = 0; i < array.length; i++) newArray[i] = array[i];\n  newArray[array.length] = str;\n  return newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (array == null) return (new String[] {str});\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return (newArr);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  String[] newArray = new String[array.length + 1];\n  for (int i = 0; i < array.length; i++) newArray[i] = array[i];\n  newArray[array.length] = str;\n  return newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (array == null) {\n    return new String[] {str};\n  }\n  String[] newArr = new String[array.length + 1];\n  System.arraycopy(array, 0, newArr, 0, array.length);\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  String[] newArr = new String[array.length + 1];\n  for (int i = 0; i < array.length; i++) {\n    newArr[i] = array[i];\n  }\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  String[] newArr = new String[array.length + 1];\n  for (int i = 0; i < array.length; i++) {\n    newArr[i] = array[i];\n  }\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  String[] newArr = new String[array.length + 1];\n  for (int i = 0; i < array.length; i++) {\n    newArr[i] = array[i];\n  }\n  newArr[array.length] = str;\n  return newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  if (array == null) {\n    array = new String[1];\n    array[0] = str;\n  } else {\n    String[] newArray = new String[array.length + 1];\n    System.arraycopy(array, 0, newArray, 0, array.length);\n    newArray[array.length] = str;\n    array = newArray;\n  }\n  return array;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array, String str) {\n  String[] newArray = new String[array.length + 1];\n  for (int i = 0; i < array.length; i++) {\n    newArray[i] = array[i];\n  }\n  newArray[array.length] = str;\n  return newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.\n * @param array the array to append to (can be <code>null</code>)\n * @param str the String to append\n * @return the new array (never <code>null</code>)\n */\n", "method_name": "addStringToArray", "codes": ["public static String[] addStringToArray(String[] array,String str){ if (array == null) { array = new String[1]; array[0] = str; } else { array = ArrayUtils.add(array, str); } return array; }", "public static String[] addStringToArray(String[] array,String str){ String[] newArray = new String[array.length + 1]; for (int i = 0; i < array.length; i++) newArray[i] = array[i]; newArray[array.length] = str; return newArray; }", "public static String[] addStringToArray(String[] array,String str){ if (array == null) return (new String[] { str }); String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return (newArr); }", "public static String[] addStringToArray(String[] array,String str){ String[] newArray = new String[array.length + 1]; for (int i = 0; i < array.length; i++) newArray[i] = array[i]; newArray[array.length] = str; return newArray; }", "public static String[] addStringToArray(String[] array,String str){ if (array == null) { return new String[] { str }; } String[] newArr = new String[array.length + 1]; System.arraycopy(array, 0, newArr, 0, array.length); newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ String[] newArr = new String[array.length + 1]; for (int i = 0; i < array.length; i++) { newArr[i] = array[i]; } newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ String[] newArr = new String[array.length + 1]; for (int i = 0; i < array.length; i++) { newArr[i] = array[i]; } newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ String[] newArr = new String[array.length + 1]; for (int i = 0; i < array.length; i++) { newArr[i] = array[i]; } newArr[array.length] = str; return newArr; }", "public static String[] addStringToArray(String[] array,String str){ if (array == null) { array = new String[1]; array[0] = str; } else { String[] newArray = new String[array.length + 1]; System.arraycopy(array, 0, newArray, 0, array.length); newArray[array.length] = str; array = newArray; } return array; }", "public static String[] addStringToArray(String[] array,String str){ String[] newArray = new String[array.length + 1]; for (int i = 0; i < array.length; i++) { newArray[i] = array[i]; } newArray[array.length] = str; return newArray; }"], "code_level": "slib_runnable", "_id": "6367676a1a6d9265ec0181d4", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  int count = 0;\n  for (int i = 0; i < str.length() - sub.length() + 1; i++) {\n    if (str.substring(i, i + sub.length()).equalsIgnoreCase(sub)) count++;\n  }\n  return count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  int count = 0;\n  for (int i = 0; i < str.length(); i++) {\n    if (str.substring(i, i + sub.length()).equals(sub)) {\n      count++;\n    }\n  }\n  return count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  int count = 0;\n  for (int i = 0; i < str.length(); i++) {\n    if (str.substring(i, i + sub.length()).equals(sub)) count++;\n  }\n  return count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  int count = 0;\n  for (int i = 0; i < str.length() - sub.length() + 1; i++) {\n    if (str.substring(i, i + sub.length()).equals(sub)) {\n      count++;\n    }\n  }\n  return count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n    return 0;\n  }\n  int count = 0;\n  int idx = 0;\n  while ((idx = str.indexOf(sub, idx)) != -1) {\n    count++;\n    idx += sub.length();\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  int count = 0;\n  for (int i = 0; i < str.length(); i++) {\n    if (str.substring(i, i + sub.length()).equals(sub)) {\n      count++;\n    }\n  }\n  return count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  int count = 0;\n  for (int i = 0; i < str.length(); i++) {\n    if (str.substring(i, i + sub.length()).equals(sub)) {\n      count++;\n    }\n  }\n  return count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n    return 0;\n  }\n  int count = 0;\n  int idx = 0;\n  while ((idx = str.indexOf(sub, idx)) != -1) {\n    count++;\n    idx += sub.length();\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  int count = 0;\n  for (int i = 0; i < str.length() - sub.length() + 1; i++) {\n    if (str.substring(i, i + sub.length()).equals(sub)) count++;\n  }\n  return count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int countOccurrencesOf(String str, String sub) {\n  int count = 0;\n  int index = 0;\n  while ((index = str.indexOf(sub, index)) != -1) {\n    count++;\n    index += sub.length();\n  }\n  return count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns the number of occurrences the substring  {@code sub} appears in string {@code str}.\n * @param str string to search in. Return 0 if this is null.\n * @param sub string to search for. Return 0 if this is null.\n * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n */\n", "method_name": "countOccurrencesOf", "codes": ["public static int countOccurrencesOf(String str,String sub){ int count = 0; for (int i = 0; i < str.length() - sub.length() + 1; i++) { if (str.substring(i, i + sub.length()).equalsIgnoreCase(sub)) count++; } return count; }", "public static int countOccurrencesOf(String str,String sub){ int count = 0; for (int i = 0; i < str.length(); i++) { if (str.substring(i, i + sub.length()).equals(sub)) { count++; } } return count; }", "public static int countOccurrencesOf(String str,String sub){ int count = 0; for (int i = 0; i < str.length(); i++) { if (str.substring(i, i + sub.length()).equals(sub)) count++; } return count; }", "public static int countOccurrencesOf(String str,String sub){ int count = 0; for (int i = 0; i < str.length() - sub.length() + 1; i++) { if (str.substring(i, i + sub.length()).equals(sub)) { count++; } } return count; }", "public static int countOccurrencesOf(String str,String sub){ if (str == null || sub == null || str.length() == 0 || sub.length() == 0) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != -1) { count++; idx += sub.length(); } return count; }", "public static int countOccurrencesOf(String str,String sub){ int count = 0; for (int i = 0; i < str.length(); i++) { if (str.substring(i, i + sub.length()).equals(sub)) { count++; } } return count; }", "public static int countOccurrencesOf(String str,String sub){ int count = 0; for (int i = 0; i < str.length(); i++) { if (str.substring(i, i + sub.length()).equals(sub)) { count++; } } return count; }", "public static int countOccurrencesOf(String str,String sub){ if (str == null || sub == null || str.length() == 0 || sub.length() == 0) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != -1) { count++; idx += sub.length(); } return count; }", "public static int countOccurrencesOf(String str,String sub){ int count = 0; for (int i = 0; i < str.length() - sub.length() + 1; i++) { if (str.substring(i, i + sub.length()).equals(sub)) count++; } return count; }", "public static int countOccurrencesOf(String str,String sub){ int count = 0; int index = 0; while ((index = str.indexOf(sub, index)) != -1) { count++; index += sub.length(); } return count; }"], "code_level": "self_contained", "_id": "6367676b1a6d9265ec0181dd", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int i = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (i == -1) {\n    return path;\n  }\n  return path.substring(0, i);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int index = path.lastIndexOf('.');\n  if (index == -1) {\n    return path;\n  }\n  return path.substring(0, index);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extenPosi = path.lastIndexOf(FILE_EXTENSION_SEPARATOR);\n  int filePosi = path.lastIndexOf(File.separator);\n  if (filePosi == -1) {\n    return (extenPosi == -1 ? path : path.substring(0, extenPosi));\n  }\n  if (extenPosi == -1) {\n    return path.substring(filePosi + 1);\n  }\n  return (path.substring(filePosi + 1, extenPosi));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int index = path.lastIndexOf('.');\n  if (index == -1) {\n    return path;\n  }\n  return path.substring(0, index);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf('.');\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path) {\n  if (path == null) {\n    return null;\n  }\n  int extIndex = path.lastIndexOf('.');\n  if (extIndex == -1) {\n    return path;\n  }\n  int sepIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (sepIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Strip the filename extension from the given path, e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n * @param path the file path (may be <code>null</code>)\n * @return the path with stripped filename extension,or <code>null</code> if none\n */\n", "method_name": "stripFilenameExtension", "codes": ["public static String stripFilenameExtension(String path){ if (path == null) { return null; } int i = path.lastIndexOf(EXTENSION_SEPARATOR); if (i == -1) { return path; } return path.substring(0, i); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int index = path.lastIndexOf('.'); if (index == -1) { return path; } return path.substring(0, index); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extenPosi = path.lastIndexOf(FILE_EXTENSION_SEPARATOR); int filePosi = path.lastIndexOf(File.separator); if (filePosi == -1) { return (extenPosi == -1 ? path : path.substring(0, extenPosi)); } if (extenPosi == -1) { return path.substring(filePosi + 1); } return (path.substring(filePosi + 1, extenPosi)); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int index = path.lastIndexOf('.'); if (index == -1) { return path; } return path.substring(0, index); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf('.'); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR); if (extIndex == -1) { return path; } int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (folderIndex > extIndex) { return path; } return path.substring(0, extIndex); }", "public static String stripFilenameExtension(String path){ if (path == null) { return null; } int extIndex = path.lastIndexOf('.'); if (extIndex == -1) { return path; } int sepIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (sepIndex > extIndex) { return path; } return path.substring(0, extIndex); }"], "code_level": "class_runnable", "_id": "6367676c1a6d9265ec018220", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (str == null) {\n    return null;\n  }\n  if (str.length() == 0) {\n    return EMPTY;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (isEmpty(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb = new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (str == null) {\n    return null;\n  }\n  int length = str.length();\n  if (length == 0) {\n    return str;\n  }\n  StringBuilder builder = new StringBuilder(length);\n  for (int i = 0; i < length; i++) {\n    if (str.charAt(i) != leadingCharacter) {\n      builder.append(str.charAt(i));\n    }\n  }\n  return builder.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String trimLeadingCharacter(String str, char leadingCharacter) {\n  if (str == null) {\n    return null;\n  }\n  if (leadingCharacter == '\\0') {\n    return str;\n  }\n  int index = str.indexOf(leadingCharacter);\n  if (index == -1) {\n    return str;\n  } else {\n    return str.substring(0, index);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Trim all occurrences of the supplied leading character from the given String.\n * @param str the String to check\n * @param leadingCharacter the leading character to be trimmed\n * @return the trimmed String\n */\n", "method_name": "trimLeadingCharacter", "codes": ["public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (str == null) { return null; } if (str.length() == 0) { return EMPTY; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (isEmpty(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (!hasLength(str)) { return str; } StringBuilder sb = new StringBuilder(str); while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) { sb.deleteCharAt(0); } return sb.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (str == null) { return null; } int length = str.length(); if (length == 0) { return str; } StringBuilder builder = new StringBuilder(length); for (int i = 0; i < length; i++) { if (str.charAt(i) != leadingCharacter) { builder.append(str.charAt(i)); } } return builder.toString(); }", "public static String trimLeadingCharacter(String str,char leadingCharacter){ if (str == null) { return null; } if (leadingCharacter == '\\0') { return str; } int index = str.indexOf(leadingCharacter); if (index == -1) { return str; } else { return str.substring(0, index); } }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181a7", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  if (isEmpty(toSplit) || isEmpty(delimiter)) return null;\n  int offset = toSplit.indexOf(delimiter);\n  if (offset < 0) return null;\n  String beforeDelimiter = toSplit.substring(0, offset);\n  String afterDelimiter = toSplit.substring(offset + delimiter.length());\n  return new String[] {beforeDelimiter, afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return toSplit.split(delimiter);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, -1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  if (toSplit == null || toSplit.length() == 0 || delimiter == null || delimiter.length() == 0) {\n    return new String[0];\n  }\n  int offset = toSplit.indexOf(delimiter);\n  if (offset < 0) {\n    return null;\n  }\n  String beforeDelimiter = toSplit.substring(0, offset);\n  String afterDelimiter = toSplit.substring(offset + delimiter.length());\n  return new String[] {beforeDelimiter, afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  if ((toSplit == null) || (delimiter == null)) {\n    return null;\n  }\n  StringTokenizer tokenizer = new StringTokenizer(toSplit, delimiter);\n  List<String> list = new ArrayList<String>();\n  while (tokenizer.hasMoreTokens()) {\n    list.add(tokenizer.nextToken());\n  }\n  return list.toArray(new String[list.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  if (toSplit == null) return null;\n  if (delimiter == null) return split(toSplit);\n  int delLocation = toSplit.indexOf(delimiter);\n  if (delLocation < 0) return new String[] {toSplit};\n  String beforeDelimiter = toSplit.substring(0, delLocation);\n  String afterDelimiter = toSplit.substring(delLocation + delimiter.length());\n  return new String[] {beforeDelimiter, afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit, String delimiter) {\n  return split(toSplit, delimiter, 0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.\n * @param toSplit the string to split\n * @param delimiter to split the string up with\n * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String\n */\n", "method_name": "split", "codes": ["public static String[] split(String toSplit,String delimiter){ if (isEmpty(toSplit) || isEmpty(delimiter)) return null; int offset = toSplit.indexOf(delimiter); if (offset < 0) return null; String beforeDelimiter = toSplit.substring(0, offset); String afterDelimiter = toSplit.substring(offset + delimiter.length()); return new String[] { beforeDelimiter, afterDelimiter }; }", "public static String[] split(String toSplit,String delimiter){ return toSplit.split(delimiter); }", "public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, 0); }", "public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, false); }", "public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, -1); }", "public static String[] split(String toSplit,String delimiter){ if (toSplit == null || toSplit.length() == 0 || delimiter == null || delimiter.length() == 0) { return new String[0]; } int offset = toSplit.indexOf(delimiter); if (offset < 0) { return null; } String beforeDelimiter = toSplit.substring(0, offset); String afterDelimiter = toSplit.substring(offset + delimiter.length()); return new String[] { beforeDelimiter, afterDelimiter }; }", "public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, false); }", "public static String[] split(String toSplit,String delimiter){ if ((toSplit == null) || (delimiter == null)) { return null; } StringTokenizer tokenizer = new StringTokenizer(toSplit, delimiter); List<String> list = new ArrayList<String>(); while (tokenizer.hasMoreTokens()) { list.add(tokenizer.nextToken()); } return list.toArray(new String[list.size()]); }", "public static String[] split(String toSplit,String delimiter){ if (toSplit == null) return null; if (delimiter == null) return split(toSplit); int delLocation = toSplit.indexOf(delimiter); if (delLocation < 0) return new String[] { toSplit }; String beforeDelimiter = toSplit.substring(0, delLocation); String afterDelimiter = toSplit.substring(delLocation + delimiter.length()); return new String[] { beforeDelimiter, afterDelimiter }; }", "public static String[] split(String toSplit,String delimiter){ return split(toSplit, delimiter, 0); }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181a6", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.indexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path, String relativePath) {\n  int separatorIndex = path.indexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath = path.substring(0, separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath += FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  } else {\n    return relativePath;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. \"/\" separators).\n * @param path the path to start from (usually a full file path)\n * @param relativePath the relative path to apply(relative to the full file path above)\n * @return the full file path that results from applying the relative path\n */\n", "method_name": "applyRelativePath", "codes": ["public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.indexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }", "public static String applyRelativePath(String path,String relativePath){ int separatorIndex = path.indexOf(FOLDER_SEPARATOR); if (separatorIndex != -1) { String newPath = path.substring(0, separatorIndex); if (!relativePath.startsWith(FOLDER_SEPARATOR)) { newPath += FOLDER_SEPARATOR; } return newPath + relativePath; } else { return relativePath; } }"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181ac", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  for (int j = 0; j < substring.length(); j++) {\n    int i = index + j;\n    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  for (int j = 0; j < substring.length(); j++) {\n    int i = index + j;\n    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return index + substring.length() <= str.length()\n      && str.subSequence(index, index + substring.length()).equals(substring);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  if (index < 0 || index > str.length() || substring == null) {\n    return false;\n  }\n  if (substring.length() == 0) {\n    return true;\n  }\n  int i = index;\n  int j = index + substring.length();\n  while (i < j) {\n    if (str.charAt(i) != substring.charAt(0)) {\n      i++;\n      continue;\n    }\n    if (j - i < substring.length()) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  for (int j = 0; j < substring.length(); j++) {\n    int i = index + j;\n    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  for (int j = 0; j < substring.length(); j++) {\n    int i = index + j;\n    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  for (int j = 0; j < substring.length(); j++) {\n    int i = index + j;\n    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  for (int j = 0; j < substring.length(); j++) {\n    int i = index + j;\n    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  return indexOf(str, index, substring) != INDEX_NOT_FOUND;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n  for (int j = 0; j < substring.length(); j++) {\n    int i = index + j;\n    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns  {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n * @param str the original string (or StringBuilder)\n * @param index the index in the original string to start matching against\n * @param substring the substring to match at the given index\n * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n */\n", "method_name": "substringMatch", "codes": ["public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ for (int j = 0; j < substring.length(); j++) { int i = index + j; if (i >= str.length() || str.charAt(i) != substring.charAt(j)) { return false; } } return true; }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ for (int j = 0; j < substring.length(); j++) { int i = index + j; if (i >= str.length() || str.charAt(i) != substring.charAt(j)) { return false; } } return true; }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return index + substring.length() <= str.length() && str.subSequence(index, index + substring.length()).equals(substring); }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ if (index < 0 || index > str.length() || substring == null) { return false; } if (substring.length() == 0) { return true; } int i = index; int j = index + substring.length(); while (i < j) { if (str.charAt(i) != substring.charAt(0)) { i++; continue; } if (j - i < substring.length()) { return false; } i++; j--; } return true; }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ for (int j = 0; j < substring.length(); j++) { int i = index + j; if (i >= str.length() || str.charAt(i) != substring.charAt(j)) { return false; } } return true; }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ for (int j = 0; j < substring.length(); j++) { int i = index + j; if (i >= str.length() || str.charAt(i) != substring.charAt(j)) { return false; } } return true; }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ for (int j = 0; j < substring.length(); j++) { int i = index + j; if (i >= str.length() || str.charAt(i) != substring.charAt(j)) { return false; } } return true; }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ for (int j = 0; j < substring.length(); j++) { int i = index + j; if (i >= str.length() || str.charAt(i) != substring.charAt(j)) { return false; } } return true; }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ return indexOf(str, index, substring) != INDEX_NOT_FOUND; }", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){ for (int j = 0; j < substring.length(); j++) { int i = index + j; if (i >= str.length() || str.charAt(i) != substring.charAt(j)) { return false; } } return true; }"], "code_level": "slib_runnable", "_id": "6367676b1a6d9265ec0181e9", "project_name": "jjwt-master"}, {"generate_results": [{"generate_code": "protected static void deleteFile(String fileName) {\n  if (fileName == null) {\n    throw new IllegalArgumentException(\"fileName can not be null\");\n  }\n  File file = new File(fileName);\n  if (!file.exists()) {\n    return;\n  }\n  if (file.isDirectory()) {\n    String[] children = file.list();\n    for (String child : children) {\n      deleteFile(fileName + \"/\" + child);\n    }\n  }\n  file.delete();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (!file.exists()) {\n    return;\n  }\n  file.delete();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  try {\n    File file = new File(fileName);\n    if (file.exists()) {\n      file.delete();\n    }\n  } catch (Exception ex) {\n    ex.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  if (fileName == null) return;\n  File f = new File(fileName);\n  if (f.exists() && f.isFile()) {\n    f.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (!file.delete()) {\n    System.out.println(\"Failed to delete file: \" + fileName);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName) {\n  File file = new File(fileName);\n  if (file.exists()) {\n    file.delete();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Delete's the specified file if it exists \n */\n", "method_name": "deleteFile", "codes": ["protected static void deleteFile(String fileName){ if (fileName == null) { throw new IllegalArgumentException(\"fileName can not be null\"); } File file = new File(fileName); if (!file.exists()) { return; } if (file.isDirectory()) { String[] children = file.list(); for (String child : children) { deleteFile(fileName + \"/\" + child); } } file.delete(); }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (!file.exists()) { return; } file.delete(); }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }", "protected static void deleteFile(String fileName){ try { File file = new File(fileName); if (file.exists()) { file.delete(); } } catch (Exception ex) { ex.printStackTrace(); } }", "protected static void deleteFile(String fileName){ if (fileName == null) return; File f = new File(fileName); if (f.exists() && f.isFile()) { f.delete(); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (!file.delete()) { System.out.println(\"Failed to delete file: \" + fileName); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }", "protected static void deleteFile(String fileName){ File file = new File(fileName); if (file.exists()) { file.delete(); } }"], "code_level": "slib_runnable", "_id": "636767821a6d9265ec0183a0", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public String format(LoggingEvent event) {\n  StringBuffer buf = new StringBuffer();\n  if (event.getThrowableInformation() != null\n      && event.getThrowableInformation().getThrowable() != null) {\n    StackTraceElement[] stackTrace =\n        event.getThrowableInformation().getThrowable().getStackTrace();\n    for (StackTraceElement stackTraceElement : stackTrace) {\n      buf.append(stackTraceElement.toString());\n      buf.append(\"\\n\");\n    }\n  }\n  buf.append(event.getMessage().replaceAll(\"\\n\", \"\\n\\t\"));\n  buf.append(\"\\n\");\n  buf.append(event.getLevel().getLocalizedName());\n  return buf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  StringBuffer sb = new StringBuffer();\n  sb.append(event.getMessage());\n  sb.append(\"\\n\");\n  sb.append(event.getLevel().toString());\n  sb.append(\"\\n\");\n  sb.append(event.getTimeStamp());\n  sb.append(\"\\n\");\n  sb.append(event.getThreadName());\n  sb.append(\"\\n\");\n  sb.append(event.getThreadID());\n  sb.append(\"\\n\");\n  sb.append(event.getLocationInformation());\n  sb.append(\"\\n\");\n  sb.append(event.getRenderedMessage());\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  StringBuilder sb = new StringBuilder(event.getMessage().length() + 20);\n  sb.append(event.getLevel().getLocalizedName());\n  sb.append(\": \");\n  sb.append(event.getRenderedMessage());\n  if (event.getThrowableInformation() != null) {\n    sb.append(\"\\n\");\n    sb.append(event.getThrowableInformation().getThrowableStrRep());\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  if (event == null) {\n    throw new NullPointerException(\"Cannot format null LoggingEvent\");\n  }\n  if (this.formatter == null) {\n    return event.getMessage();\n  } else {\n    return this.formatter.format(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  StringBuffer buffer = new StringBuffer();\n  if (pattern != null) {\n    buffer.append(pattern.format(event));\n  } else {\n    buffer.append(event.getMessage());\n  }\n  return buffer.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  if (pattern == null) {\n    return null;\n  }\n  if (event.getThrowableInformation().getThrowable() != null) {\n    return pattern.format(event.getThrowableInformation().getThrowable());\n  } else {\n    return pattern.format(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  if (converter == null) {\n    return format(event.getMessage());\n  }\n  return format(event.getMessage(), converter);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  if (pattern == null) {\n    return event.getMessage();\n  }\n  return pattern.format(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  try {\n    return formatter.format(event);\n  } catch (Exception e) {\n  }\n  return \"\";\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event) {\n  if (pattern == null) {\n    pattern = Pattern.compile(\"\\\\{\\\\{(.+?)\\\\}\\\\}\");\n  }\n  Matcher matcher = pattern.matcher(event.getMessage().toString());\n  if (matcher.find()) {\n    StringBuffer buffer = new StringBuffer(event.getLevel().toString());\n    buffer.append(\": \");\n    buffer.append(event.getLoggerName());\n    buffer.append(\" - \");\n    buffer.append(matcher.group(1));\n    return buffer.toString();\n  }\n  return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Produces a formatted string as specified by the conversion pattern.\n */\n", "method_name": "format", "codes": ["public String format(LoggingEvent event){ StringBuffer buf = new StringBuffer(); if (event.getThrowableInformation() != null && event.getThrowableInformation().getThrowable() != null) { StackTraceElement[] stackTrace = event.getThrowableInformation().getThrowable().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) { buf.append(stackTraceElement.toString()); buf.append(\"\\n\"); } } buf.append(event.getMessage().replaceAll(\"\\n\", \"\\n\\t\")); buf.append(\"\\n\"); buf.append(event.getLevel().getLocalizedName()); return buf.toString(); }", "public String format(LoggingEvent event){ StringBuffer sb = new StringBuffer(); sb.append(event.getMessage()); sb.append(\"\\n\"); sb.append(event.getLevel().toString()); sb.append(\"\\n\"); sb.append(event.getTimeStamp()); sb.append(\"\\n\"); sb.append(event.getThreadName()); sb.append(\"\\n\"); sb.append(event.getThreadID()); sb.append(\"\\n\"); sb.append(event.getLocationInformation()); sb.append(\"\\n\"); sb.append(event.getRenderedMessage()); return sb.toString(); }", "public String format(LoggingEvent event){ StringBuilder sb = new StringBuilder(event.getMessage().length() + 20); sb.append(event.getLevel().getLocalizedName()); sb.append(\": \"); sb.append(event.getRenderedMessage()); if (event.getThrowableInformation() != null) { sb.append(\"\\n\"); sb.append(event.getThrowableInformation().getThrowableStrRep()); } return sb.toString(); }", "public String format(LoggingEvent event){ if (event == null) { throw new NullPointerException(\"Cannot format null LoggingEvent\"); } if (this.formatter == null) { return event.getMessage(); } else { return this.formatter.format(event); } }", "public String format(LoggingEvent event){ StringBuffer buffer = new StringBuffer(); if (pattern != null) { buffer.append(pattern.format(event)); } else { buffer.append(event.getMessage()); } return buffer.toString(); }", "public String format(LoggingEvent event){ if (pattern == null) { return null; } if (event.getThrowableInformation().getThrowable() != null) { return pattern.format(event.getThrowableInformation().getThrowable()); } else { return pattern.format(event); } }", "public String format(LoggingEvent event){ if (converter == null) { return format(event.getMessage()); } return format(event.getMessage(), converter); }", "public String format(LoggingEvent event){ if (pattern == null) { return event.getMessage(); } return pattern.format(event); }", "public String format(LoggingEvent event){ try { return formatter.format(event); } catch (Exception e) { } return \"\"; }", "public String format(LoggingEvent event){ if (pattern == null) { pattern = Pattern.compile(\"\\\\{\\\\{(.+?)\\\\}\\\\}\"); } Matcher matcher = pattern.matcher(event.getMessage().toString()); if (matcher.find()) { StringBuffer buffer = new StringBuffer(event.getLevel().toString()); buffer.append(\": \"); buffer.append(event.getLoggerName()); buffer.append(\" - \"); buffer.append(matcher.group(1)); return buffer.toString(); } return null; }"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec01830f", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (this.file == null) {\n    File file = new File(this.filename);\n    if (!file.exists()) {\n      try {\n        file.createNewFile();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n    this.filename = file.getAbsolutePath();\n  }\n  try {\n    FileOutputStream out = new FileOutputStream(this.filename, true);\n    byte[] bytes = this.message.getBytes();\n    out.write(bytes, 0, bytes.length);\n    out.flush();\n    out.close();\n  } catch (IOException e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  StringBuffer buffer = (StringBuffer) event.getMessage();\n  try {\n    String filename = getFileName(event);\n    FileOutputStream fstream = new FileOutputStream(filename, true);\n    fstream.write(buffer.toString().getBytes());\n    fstream.close();\n  } catch (Exception e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (this.file != null) {\n    try {\n      synchronized (this.file) {\n        if (this.file.exists()) {\n          this.file.delete();\n        }\n        this.file.createNewFile();\n      }\n      FileOutputStream out = new FileOutputStream(this.file, true);\n      String msg = event.getFormattedMessage();\n      if (this.outputStream == null) {\n        this.outputStream = out;\n      } else {\n        out.write(msg.getBytes());\n      }\n      out.flush();\n      out.close();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (file != null) {\n    try {\n      FileOutputStream fos = new FileOutputStream(file, true);\n      PrintWriter pw = new PrintWriter(fos);\n      pw.println(event.getFormattedMessage());\n      pw.flush();\n      pw.close();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (!isAppendEnabled) {\n    return;\n  }\n  if (this.file == null) {\n    return;\n  }\n  try {\n    String message = event.getMessage().toString();\n    if (message.length() >= this.maxLength) {\n      String fileName = this.file.getCanonicalPath();\n      String tmpFileName = fileName + \".\" + this.fileExtension;\n      if (this.tempFile != null) {\n        this.tempFile.renameTo(new File(tmpFileName));\n      }\n    }\n    FileOutputStream fos = new FileOutputStream(this.file, true);\n    fos.write(message.getBytes());\n    fos.flush();\n    fos.close();\n  } catch (IOException e) {\n    logger.error(\"Failed to append message to file: \" + this.file.getAbsolutePath(), e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (this.tempFile != null) {\n    try {\n      FileOutputStream fileOutputStream = new FileOutputStream(this.tempFile, true);\n      PrintStream printStream = new PrintStream(fileOutputStream);\n      this.formatter.format(event, printStream);\n      printStream.close();\n      fileOutputStream.close();\n      this.tempFile.delete();\n    } catch (IOException e) {\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  if (event.getLevel() == Level.ERROR) {\n    try {\n      File tempFile =\n          File.createTempFile(\n              \"logback-\" + System.currentTimeMillis(), \".txt\", new File(this.tempDir));\n      tempFile.deleteOnExit();\n      PrintWriter pw =\n          new PrintWriter(new OutputStreamWriter(new FileOutputStream(tempFile, true)));\n      pw.println(\n          \"<\"\n              + getFileName(event)\n              + \">\"\n              + event.getFormattedMessage()\n              + \"</\"\n              + getFileName(event)\n              + \">\");\n      pw.close();\n    } catch (IOException e) {\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  try {\n    FileOutputStream fos = new FileOutputStream(tempFile, true);\n    ObjectOutputStream oos = new ObjectOutputStream(fos);\n    oos.writeObject(event);\n    oos.close();\n    fos.close();\n  } catch (IOException ioe) {\n    System.err.println(\"Exception in subAppend(): \" + ioe);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  File file = null;\n  if (!isCreated()) {\n    file = new File(getLogDir(), getFileName());\n  } else {\n    file = new File(getLogDir(), getFileName() + \"_temp\");\n  }\n  try {\n    file.createNewFile();\n    FileOutputStream fos = new FileOutputStream(file, true);\n    fos.write(event.getMessage().getBytes());\n    fos.close();\n  } catch (IOException ioe) {\n    ioe.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event) {\n  File file = null;\n  if (this.tmpFile != null) {\n    file = this.tmpFile;\n  } else {\n    file = getTempFile();\n  }\n  try {\n    FileOutputStream fileOutputStream = new FileOutputStream(file, true);\n    fileOutputStream.write(event.getRenderedMessage().getBytes());\n    fileOutputStream.close();\n  } catch (FileNotFoundException e) {\n    logger.error(\"Failed to create temp file: \" + file.getAbsolutePath(), e);\n  } catch (IOException e) {\n    logger.error(\"Failed to write the message: \" + event.getRenderedMessage(), e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * This method does actual writing\n */\n", "method_name": "subAppend", "codes": ["protected void subAppend(LoggingEvent event){ if (this.file == null) { File file = new File(this.filename); if (!file.exists()) { try { file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } this.filename = file.getAbsolutePath(); } try { FileOutputStream out = new FileOutputStream(this.filename, true); byte[] bytes = this.message.getBytes(); out.write(bytes, 0, bytes.length); out.flush(); out.close(); } catch (IOException e) { e.printStackTrace(); } }", "protected void subAppend(LoggingEvent event){ StringBuffer buffer = (StringBuffer) event.getMessage(); try { String filename = getFileName(event); FileOutputStream fstream = new FileOutputStream(filename, true); fstream.write(buffer.toString().getBytes()); fstream.close(); } catch (Exception e) { e.printStackTrace(); } }", "protected void subAppend(LoggingEvent event){ if (this.file != null) { try { synchronized (this.file) { if (this.file.exists()) { this.file.delete(); } this.file.createNewFile(); } FileOutputStream out = new FileOutputStream(this.file, true); String msg = event.getFormattedMessage(); if (this.outputStream == null) { this.outputStream = out; } else { out.write(msg.getBytes()); } out.flush(); out.close(); } catch (Exception e) { e.printStackTrace(); } } }", "protected void subAppend(LoggingEvent event){ if (file != null) { try { FileOutputStream fos = new FileOutputStream(file, true); PrintWriter pw = new PrintWriter(fos); pw.println(event.getFormattedMessage()); pw.flush(); pw.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } } }", "protected void subAppend(LoggingEvent event){ if (!isAppendEnabled) { return; } if (this.file == null) { return; } try { String message = event.getMessage().toString(); if (message.length() >= this.maxLength) { String fileName = this.file.getCanonicalPath(); String tmpFileName = fileName + \".\" + this.fileExtension; if (this.tempFile != null) { this.tempFile.renameTo(new File(tmpFileName)); } } FileOutputStream fos = new FileOutputStream(this.file, true); fos.write(message.getBytes()); fos.flush(); fos.close(); } catch (IOException e) { logger.error(\"Failed to append message to file: \" + this.file.getAbsolutePath(), e); } }", "protected void subAppend(LoggingEvent event){ if (this.tempFile != null) { try { FileOutputStream fileOutputStream = new FileOutputStream(this.tempFile, true); PrintStream printStream = new PrintStream(fileOutputStream); this.formatter.format(event, printStream); printStream.close(); fileOutputStream.close(); this.tempFile.delete(); } catch (IOException e) { } } }", "protected void subAppend(LoggingEvent event){ if (event.getLevel() == Level.ERROR) { try { File tempFile = File.createTempFile(\"logback-\" + System.currentTimeMillis(), \".txt\", new File(this.tempDir)); tempFile.deleteOnExit(); PrintWriter pw = new PrintWriter(new OutputStreamWriter(new FileOutputStream(tempFile, true))); pw.println(\"<\" + getFileName(event) + \">\" + event.getFormattedMessage() + \"</\" + getFileName(event) + \">\"); pw.close(); } catch (IOException e) { } } }", "protected void subAppend(LoggingEvent event){ try { FileOutputStream fos = new FileOutputStream(tempFile, true); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(event); oos.close(); fos.close(); } catch (IOException ioe) { System.err.println(\"Exception in subAppend(): \" + ioe); } }", "protected void subAppend(LoggingEvent event){ File file = null; if (!isCreated()) { file = new File(getLogDir(), getFileName()); } else { file = new File(getLogDir(), getFileName() + \"_temp\"); } try { file.createNewFile(); FileOutputStream fos = new FileOutputStream(file, true); fos.write(event.getMessage().getBytes()); fos.close(); } catch (IOException ioe) { ioe.printStackTrace(); } }", "protected void subAppend(LoggingEvent event){ File file = null; if (this.tmpFile != null) { file = this.tmpFile; } else { file = getTempFile(); } try { FileOutputStream fileOutputStream = new FileOutputStream(file, true); fileOutputStream.write(event.getRenderedMessage().getBytes()); fileOutputStream.close(); } catch (FileNotFoundException e) { logger.error(\"Failed to create temp file: \" + file.getAbsolutePath(), e); } catch (IOException e) { logger.error(\"Failed to write the message: \" + event.getRenderedMessage(), e); } }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec01823d", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static String peek() {\n  if (!stack2.empty()) return stack2.peek();\n  return \"\";\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  if (!stack.isEmpty()) {\n    return stack.get(stack.size() - 1);\n  } else {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  if (top == -1) {\n    return null;\n  } else {\n    return s[top];\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  return stack.get(stack.size() - 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  if (isEmpty()) {\n    return null;\n  } else {\n    return stack.get(top);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  if (!isEmpty()) {\n    return stack[top];\n  } else {\n    return \"Stack is empty\";\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  return stack.get(stack.size() - 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  if (top == -1) {\n    return null;\n  } else {\n    return stack[top];\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  return stack.peek();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek() {\n  if (isEmpty()) {\n    throw new EmptyStackException();\n  }\n  return stack.get(stack.size() - 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string \"\" is returned.\n * @return String The innermost diagnostic context.\n */\n", "method_name": "peek", "codes": ["public static String peek(){ if (!stack2.empty()) return stack2.peek(); return \"\"; }", "public static String peek(){ if (!stack.isEmpty()) { return stack.get(stack.size() - 1); } else { return null; } }", "public static String peek(){ if (top == -1) { return null; } else { return s[top]; } }", "public static String peek(){ return stack.get(stack.size() - 1); }", "public static String peek(){ if (isEmpty()) { return null; } else { return stack.get(top); } }", "public static String peek(){ if (!isEmpty()) { return stack[top]; } else { return \"Stack is empty\"; } }", "public static String peek(){ return stack.get(stack.size() - 1); }", "public static String peek(){ if (top == -1) { return null; } else { return stack[top]; } }", "public static String peek(){ return stack.peek(); }", "public static String peek(){ if (isEmpty()) { throw new EmptyStackException(); } return stack.get(stack.size() - 1); }"], "code_level": "class_runnable", "_id": "636767831a6d9265ec0183c9", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public Logger exists(String name) {\n  return loggers.get(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  return nameToLogger.get(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  Logger logger = null;\n  for (Logger l : loggers) {\n    if (l.getName().equals(name)) {\n      logger = l;\n      break;\n    }\n  }\n  return logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  Logger logger = null;\n  if (name != null) {\n    logger = loggers.get(name);\n  }\n  return logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  if (name == null) {\n    return null;\n  }\n  synchronized (this) {\n    for (Logger logger : loggers) {\n      if (logger.getName().equals(name)) {\n        return logger;\n      }\n    }\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  Logger logger = null;\n  for (Logger l : loggers) {\n    if (l.getName().equals(name)) {\n      logger = l;\n    }\n  }\n  return logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  return loggers.get(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  Logger logger = loggers.get(name);\n  if (logger == null) {\n    return null;\n  } else {\n    return logger;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  Logger logger = null;\n  if (name != null) {\n    logger = this.loggers.get(name.toLowerCase());\n  }\n  if (logger == null) {\n    logger = this.defaultLogger;\n  }\n  return logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name) {\n  return loggers.get(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if the named logger exists in the hierarchy. If so return its reference, otherwise returns <code>null</code>.\n * @param name The name of the logger to search for.\n */\n", "method_name": "exists", "codes": ["public Logger exists(String name){ return loggers.get(name); }", "public Logger exists(String name){ return nameToLogger.get(name); }", "public Logger exists(String name){ Logger logger = null; for (Logger l : loggers) { if (l.getName().equals(name)) { logger = l; break; } } return logger; }", "public Logger exists(String name){ Logger logger = null; if (name != null) { logger = loggers.get(name); } return logger; }", "public Logger exists(String name){ if (name == null) { return null; } synchronized (this) { for (Logger logger : loggers) { if (logger.getName().equals(name)) { return logger; } } return null; } }", "public Logger exists(String name){ Logger logger = null; for (Logger l : loggers) { if (l.getName().equals(name)) { logger = l; } } return logger; }", "public Logger exists(String name){ return loggers.get(name); }", "public Logger exists(String name){ Logger logger = loggers.get(name); if (logger == null) { return null; } else { return logger; } }", "public Logger exists(String name){ Logger logger = null; if (name != null) { logger = this.loggers.get(name.toLowerCase()); } if (logger == null) { logger = this.defaultLogger; } return logger; }", "public Logger exists(String name){ return loggers.get(name); }"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec01832e", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public String format(final LoggingEvent event) {\n  final StringBuilder sb = new StringBuilder();\n  sb.append(event.getLevel().toString());\n  sb.append(\": \");\n  sb.append(event.getRenderedMessage());\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  return this.format(event, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  return event.getFormattedMessage();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  final StringBuilder sb = new StringBuilder();\n  sb.append(event.getLevel().getName());\n  sb.append(\": \");\n  sb.append(event.getMessage());\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  if (event.getFormattedMessage() == null) {\n    return event.getLevel() + \": \" + event.getRenderedMessage();\n  } else {\n    return event.getLevel()\n        + \": \"\n        + event.getFormattedMessage()\n        + \"\\n\"\n        + event.getRenderedMessage();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  final StringBuilder sb = new StringBuilder();\n  final Object[] args = event.getArgumentArray();\n  final String level = event.getLevel().toString();\n  final String message = event.getMessage();\n  final Throwable t = event.getThrowable();\n  if (args != null) {\n    sb.append(level).append(\" \");\n    sb.append(message).append(\"\\n\");\n    for (int i = 0; i < args.length; i++) {\n      sb.append(\" \");\n      sb.append(args[i]);\n    }\n  } else {\n    sb.append(level).append(\" \");\n    sb.append(message).append(\"\\n\");\n  }\n  if (t != null) {\n    sb.append(\"\\n\");\n    sb.append(\"Throwable: \")\n        .append(t.getClass().getName())\n        .append(\": \")\n        .append(t.getMessage())\n        .append(\"\\n\");\n    sb.append(\"StackTrace:\\n\");\n    final StringWriter sw = new StringWriter();\n    t.printStackTrace(new PrintWriter(sw));\n    sb.append(sw.toString());\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  final StringBuilder sb = new StringBuilder(\"[\");\n  sb.append(event.getThreadName());\n  sb.append(\"]\");\n  sb.append(\"[\");\n  sb.append(event.getLevel());\n  sb.append(\"]\");\n  sb.append(\"[\");\n  sb.append(event.getLoggerName());\n  sb.append(\"]\");\n  sb.append(\"[\");\n  sb.append(event.getMessage());\n  sb.append(\"]\");\n  sb.append(\"[\");\n  sb.append(event.getTimeStamp());\n  sb.append(\"]\");\n  sb.append(\"[\");\n  sb.append(event.getThreadID());\n  sb.append(\"]\");\n  sb.append(\"[\");\n  sb.append(event.getPropertyMap());\n  sb.append(\"]\");\n  sb.append(\"[\");\n  sb.append(event.getThreadPriority());\n  sb.append(\"]\");\n  sb.append(\"[\");\n  sb.append(event.getThrowableInformation().getThrowableStrRep());\n  sb.append(\"]\");\n  sb.append(\"[\");\n  sb.append(event.getMDCPropertyMap());\n  sb.append(\"]\");\n  sb.append(\"[\");\n  sb.append(event.getMDCPropertyMap());\n  sb.append(\"]\");\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  return format(event.getLevel(), event.getMessage());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  final StringBuilder sb = new StringBuilder();\n  sb.append(event.getLevel().toString()).append(\": \").append(event.getMessage()).append(\"\\n\");\n  sb.append(\"Thread: \").append(Thread.currentThread().getName()).append(\"\\n\");\n  sb.append(\"Time: \").append(event.getTimeStamp()).append(\"\\n\");\n  sb.append(\"Thread ID: \").append(event.getThreadID()).append(\"\\n\");\n  sb.append(\"Logger: \").append(event.getLoggerName()).append(\"\\n\");\n  sb.append(\"Host: \").append(event.getLoggerContextVO().getHostName()).append(\"\\n\");\n  sb.append(\"Level: \").append(event.getLevel().toString()).append(\"\\n\");\n  sb.append(\"Thread name: \").append(event.getThreadName()).append(\"\\n\");\n  sb.append(\"FQCN: \").append(event.getLoggerContextVO().getFQCN()).append(\"\\n\");\n  sb.append(\"Message: \").append(event.getMessage()).append(\"\\n\");\n  sb.append(\"Logger name: \").append(event.getLoggerName()).append(\"\\n\");\n  sb.append(\"Runtime: \").append(event.getRuntimeMXBean().getUptime()).append(\"ms\\n\");\n  sb.append(\"Thread ID: \").append(event.getThreadID()).append(\"\\n\");\n  sb.append(\"Stack trace: \").append(event.getThrowableInformation()).append(\"\\n\");\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event) {\n  return event.getMessage();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Formats a logging event to a writer.\n * @param event logging event to be formatted.\n */\n", "method_name": "format", "codes": ["public String format(final LoggingEvent event){ final StringBuilder sb = new StringBuilder(); sb.append(event.getLevel().toString()); sb.append(\": \"); sb.append(event.getRenderedMessage()); return sb.toString(); }", "public String format(final LoggingEvent event){ return this.format(event, null); }", "public String format(final LoggingEvent event){ return event.getFormattedMessage(); }", "public String format(final LoggingEvent event){ final StringBuilder sb = new StringBuilder(); sb.append(event.getLevel().getName()); sb.append(\": \"); sb.append(event.getMessage()); return sb.toString(); }", "public String format(final LoggingEvent event){ if (event.getFormattedMessage() == null) { return event.getLevel() + \": \" + event.getRenderedMessage(); } else { return event.getLevel() + \": \" + event.getFormattedMessage() + \"\\n\" + event.getRenderedMessage(); } }", "public String format(final LoggingEvent event){ final StringBuilder sb = new StringBuilder(); final Object[] args = event.getArgumentArray(); final String level = event.getLevel().toString(); final String message = event.getMessage(); final Throwable t = event.getThrowable(); if (args != null) { sb.append(level).append(\" \"); sb.append(message).append(\"\\n\"); for (int i = 0; i < args.length; i++) { sb.append(\" \"); sb.append(args[i]); } } else { sb.append(level).append(\" \"); sb.append(message).append(\"\\n\"); } if (t != null) { sb.append(\"\\n\"); sb.append(\"Throwable: \").append(t.getClass().getName()).append(\": \").append(t.getMessage()).append(\"\\n\"); sb.append(\"StackTrace:\\n\"); final StringWriter sw = new StringWriter(); t.printStackTrace(new PrintWriter(sw)); sb.append(sw.toString()); } return sb.toString(); }", "public String format(final LoggingEvent event){ final StringBuilder sb = new StringBuilder(\"[\"); sb.append(event.getThreadName()); sb.append(\"]\"); sb.append(\"[\"); sb.append(event.getLevel()); sb.append(\"]\"); sb.append(\"[\"); sb.append(event.getLoggerName()); sb.append(\"]\"); sb.append(\"[\"); sb.append(event.getMessage()); sb.append(\"]\"); sb.append(\"[\"); sb.append(event.getTimeStamp()); sb.append(\"]\"); sb.append(\"[\"); sb.append(event.getThreadID()); sb.append(\"]\"); sb.append(\"[\"); sb.append(event.getPropertyMap()); sb.append(\"]\"); sb.append(\"[\"); sb.append(event.getThreadPriority()); sb.append(\"]\"); sb.append(\"[\"); sb.append(event.getThrowableInformation().getThrowableStrRep()); sb.append(\"]\"); sb.append(\"[\"); sb.append(event.getMDCPropertyMap()); sb.append(\"]\"); sb.append(\"[\"); sb.append(event.getMDCPropertyMap()); sb.append(\"]\"); return sb.toString(); }", "public String format(final LoggingEvent event){ return format(event.getLevel(), event.getMessage()); }", "public String format(final LoggingEvent event){ final StringBuilder sb = new StringBuilder(); sb.append(event.getLevel().toString()).append(\": \").append(event.getMessage()).append(\"\\n\"); sb.append(\"Thread: \").append(Thread.currentThread().getName()).append(\"\\n\"); sb.append(\"Time: \").append(event.getTimeStamp()).append(\"\\n\"); sb.append(\"Thread ID: \").append(event.getThreadID()).append(\"\\n\"); sb.append(\"Logger: \").append(event.getLoggerName()).append(\"\\n\"); sb.append(\"Host: \").append(event.getLoggerContextVO().getHostName()).append(\"\\n\"); sb.append(\"Level: \").append(event.getLevel().toString()).append(\"\\n\"); sb.append(\"Thread name: \").append(event.getThreadName()).append(\"\\n\"); sb.append(\"FQCN: \").append(event.getLoggerContextVO().getFQCN()).append(\"\\n\"); sb.append(\"Message: \").append(event.getMessage()).append(\"\\n\"); sb.append(\"Logger name: \").append(event.getLoggerName()).append(\"\\n\"); sb.append(\"Runtime: \").append(event.getRuntimeMXBean().getUptime()).append(\"ms\\n\"); sb.append(\"Thread ID: \").append(event.getThreadID()).append(\"\\n\"); sb.append(\"Stack trace: \").append(event.getThrowableInformation()).append(\"\\n\"); return sb.toString(); }", "public String format(final LoggingEvent event){ return event.getMessage(); }"], "code_level": "project_runnable", "_id": "6367677b1a6d9265ec0182bd", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  if (className == null) {\n    return null;\n  }\n  Class clazz = null;\n  try {\n    clazz = Class.forName(className);\n  } catch (final ClassNotFoundException e) {\n    clazz = Class.forName(className.substring(className.lastIndexOf(\".\") + 1));\n  }\n  return clazz;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  final ClassLoader cl = getClassLoader();\n  return cl.loadClass(className);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  final ClassLoader classLoader = getClassLoader();\n  if (classLoader == null) {\n    throw new ClassNotFoundException(\"No ClassLoader set\");\n  }\n  final String classFullName = className.replace('.', '/') + \".class\";\n  final URL classUrl = classLoader.getResource(classFullName);\n  if (classUrl == null) {\n    throw new ClassNotFoundException(\"Class not found: \" + className);\n  }\n  return classLoader.loadClass(className);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  return Class.forName(className);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  Class clazz = null;\n  try {\n    clazz = Class.forName(className);\n  } catch (ClassNotFoundException e) {\n    final ClassLoader loader = Thread.currentThread().getContextClassLoader();\n    if (loader != null) {\n      clazz = loader.loadClass(className);\n    }\n  }\n  return clazz;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n  final String resourcePath = \"META-INF/services/\" + className.replace('.', '/') + \".class\";\n  final Enumeration<URL> resources = classLoader.getResources(resourcePath);\n  if (resources.hasMoreElements()) {\n    final URL resource = resources.nextElement();\n    final InputStream is = resource.openStream();\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final byte[] buffer = new byte[1024];\n    int len;\n    while ((len = is.read(buffer)) >= 0) {\n      baos.write(buffer, 0, len);\n    }\n    return defineClass(className, baos.toByteArray(), 0, baos.size());\n  } else {\n    return Class.forName(className);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  if (className == null) {\n    return null;\n  }\n  ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n  if (classLoader == null) {\n    classLoader = ClassLoader.getSystemClassLoader();\n  }\n  String classPath = className.replace('.', '/');\n  Enumeration<URL> resources = null;\n  try {\n    resources = classLoader.getResources(classPath);\n  } catch (IOException e) {\n    throw new ClassNotFoundException(\"Cannot find class \" + className, e);\n  }\n  if (resources.hasMoreElements()) {\n    URL resource = resources.nextElement();\n    if (resource.getProtocol().equals(\"jar\")) {\n      try {\n        JarFile jarFile = new JarFile(resource.getFile());\n        if (jarFile.getEntry(classPath) == null) {\n          throw new ClassNotFoundException(\n              \"Cannot find class \" + className + \" in jar file \" + jarFile.getName());\n        }\n        return jarFile.getClassLoader().loadClass(className);\n      } catch (IOException e) {\n        throw new ClassNotFoundException(\"Cannot load class \" + className, e);\n      } catch (ClassNotFoundException e) {\n        throw new ClassNotFoundException(\"Cannot load class \" + className, e);\n      }\n    } else if (resource.getProtocol().equals(\"file\")) {\n      String filePath = resource.getFile();\n      filePath = filePath.replace('/', '.');\n      filePath = filePath.substring(0, filePath.length() - 6);\n      return classLoader.getResourceAsStream(filePath).readClass();\n    }\n  }\n  return classLoader.loadClass(className);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  return findClass(className, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  Class clazz = null;\n  try {\n    clazz = Class.forName(className);\n  } catch (ClassNotFoundException e) {\n    clazz = Class.forName(\"java.lang.\" + className);\n  }\n  return clazz;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n  if (className == null) {\n    throw new IllegalArgumentException(\"Class name is null\");\n  }\n  Class clazz = null;\n  if (className.startsWith(\"java.\")) {\n    clazz = Class.forName(className);\n  } else {\n    clazz = getClass().getClassLoader().loadClass(className);\n  }\n  return clazz;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n", "method_name": "findClass", "codes": ["private Class findClass(final String className) throws ClassNotFoundException { if (className == null) { return null; } Class clazz = null; try { clazz = Class.forName(className); } catch (final ClassNotFoundException e) { clazz = Class.forName(className.substring(className.lastIndexOf(\".\") + 1)); } return clazz; }", "private Class findClass(final String className) throws ClassNotFoundException { final ClassLoader cl = getClassLoader(); return cl.loadClass(className); }", "private Class findClass(final String className) throws ClassNotFoundException { final ClassLoader classLoader = getClassLoader(); if (classLoader == null) { throw new ClassNotFoundException(\"No ClassLoader set\"); } final String classFullName = className.replace('.', '/') + \".class\"; final URL classUrl = classLoader.getResource(classFullName); if (classUrl == null) { throw new ClassNotFoundException(\"Class not found: \" + className); } return classLoader.loadClass(className); }", "private Class findClass(final String className) throws ClassNotFoundException { return Class.forName(className); }", "private Class findClass(final String className) throws ClassNotFoundException { Class clazz = null; try { clazz = Class.forName(className); } catch (ClassNotFoundException e) { final ClassLoader loader = Thread.currentThread().getContextClassLoader(); if (loader != null) { clazz = loader.loadClass(className); } } return clazz; }", "private Class findClass(final String className) throws ClassNotFoundException { final ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); final String resourcePath = \"META-INF/services/\" + className.replace('.', '/') + \".class\"; final Enumeration<URL> resources = classLoader.getResources(resourcePath); if (resources.hasMoreElements()) { final URL resource = resources.nextElement(); final InputStream is = resource.openStream(); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) >= 0) { baos.write(buffer, 0, len); } return defineClass(className, baos.toByteArray(), 0, baos.size()); } else { return Class.forName(className); } }", "private Class findClass(final String className) throws ClassNotFoundException { if (className == null) { return null; } ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); if (classLoader == null) { classLoader = ClassLoader.getSystemClassLoader(); } String classPath = className.replace('.', '/'); Enumeration<URL> resources = null; try { resources = classLoader.getResources(classPath); } catch (IOException e) { throw new ClassNotFoundException(\"Cannot find class \" + className, e); } if (resources.hasMoreElements()) { URL resource = resources.nextElement(); if (resource.getProtocol().equals(\"jar\")) { try { JarFile jarFile = new JarFile(resource.getFile()); if (jarFile.getEntry(classPath) == null) { throw new ClassNotFoundException(\"Cannot find class \" + className + \" in jar file \" + jarFile.getName()); } return jarFile.getClassLoader().loadClass(className); } catch (IOException e) { throw new ClassNotFoundException(\"Cannot load class \" + className, e); } catch (ClassNotFoundException e) { throw new ClassNotFoundException(\"Cannot load class \" + className, e); } } else if (resource.getProtocol().equals(\"file\")) { String filePath = resource.getFile(); filePath = filePath.replace('/', '.'); filePath = filePath.substring(0, filePath.length() - 6); return classLoader.getResourceAsStream(filePath).readClass(); } } return classLoader.loadClass(className); }", "private Class findClass(final String className) throws ClassNotFoundException { return findClass(className, null); }", "private Class findClass(final String className) throws ClassNotFoundException { Class clazz = null; try { clazz = Class.forName(className); } catch (ClassNotFoundException e) { clazz = Class.forName(\"java.lang.\" + className); } return clazz; }", "private Class findClass(final String className) throws ClassNotFoundException { if (className == null) { throw new IllegalArgumentException(\"Class name is null\"); } Class clazz = null; if (className.startsWith(\"java.\")) { clazz = Class.forName(className); } else { clazz = getClass().getClassLoader().loadClass(className); } return clazz; }"], "code_level": "slib_runnable", "_id": "636767791a6d9265ec018263", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void addMessage(final LogRecord lr) {\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          log.add(lr);\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  final String msg = lr.getMessage();\n  if (msg != null) {\n    log.append(msg + \"\\n\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  String message = lr.getMessage();\n  String logLevel = lr.getLevel().getName();\n  String logMessage = lr.getMessage();\n  if (message.length() > MAX_MESSAGE_LENGTH) {\n    message = message.substring(0, MAX_MESSAGE_LENGTH - 3) + \"...\";\n  }\n  logTableModel.addRow(new String[] {logLevel, message, logMessage});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  if (this.getRowCount() > 0) {\n    this.removeRow(0);\n  }\n  final Object[] row = new Object[3];\n  row[0] = lr.getLevel();\n  row[1] = lr.getMessage();\n  row[2] = lr.getThrown();\n  this.addRow(row);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  if (!this.isShowLogs()) {\n    return;\n  }\n  final MessageFormat mf = new MessageFormat(lr.getMessage());\n  final Object[] msgArgs = mf.getMessageArguments();\n  final StringBuffer sb = new StringBuffer();\n  for (int i = 0; i < msgArgs.length; i++) {\n    sb.append(msgArgs[i]);\n    if (i < msgArgs.length - 1) {\n      sb.append(\" \");\n    }\n  }\n  final String s = sb.toString();\n  final int width = this.getWidth();\n  this.tableModel.addRow(new Object[] {lr.getThreadID(), s, s});\n  this.logTextArea.append(s + \"\\n\");\n  this.logTextArea.setCaretPosition(this.logTextArea.getText().length() - 2);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr){ if (!lr.getMessage().startsWith(\"--\")) { if (logTableModel == null) { logTableModel = new LogTableModel(lr.getMessage()); logTable = new JTable(logTableModel); logTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF); logTable.getColumnModel().getColumn(0).setPreferredWidth(20); logTable.getColumnModel().getColumn(1).setPreferredWidth(100); logTable.getColumnModel().getColumn(2).setPreferredWidth(50); logTable.getColumnModel().getColumn(3).setPreferredWidth(50); logTable.getColumnModel().getColumn(4).setPreferredWidth(50); logTable.getColumnModel().getColumn(5).setPreferredWidth(50); logTable.getColumnModel().getColumn(6).setPreferredWidth(50); logTable.getColumnModel().getColumn(7).setPreferredWidth(50); logTable.getColumnModel().getColumn(8).setPreferredWidth(50); logTable.getColumnModel().getColumn(9).setPreferredWidth(50); logTable.getColumnModel().getColumn(10).setPreferredWidth(50); logTable.getColumnModel().getColumn(11).setPreferredWidth(50); logTable.getColumnModel().getColumn(12).setPreferredWidth(50); logTable.getColumnModel().getColumn(13).setPreferredWidth(50); logTable.getColumnModel().getColumn(14).setPreferredWidth(50); logTable.getColumnModel().getColumn(15).setPreferredWidth(50); logTable.getColumnModel().getColumn(16).setPreferredWidth(50); logTable.getColumnModel().getColumn(17).setPreferredWidth(50); logTable.getColumnModel().getColumn(18).setPreferredWidth(50); logTable.getColumnModel().getColumn(19).setPreferredWidth(50); logTable.getColumnModel().getColumn(20).setPreferredWidth(50); logTable.setDefaultRenderer(Object.class, new TableCellRenderer() { @Override public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { JLabel l = (JLabel) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column); l.setHorizontalAlignment(SwingConstants.CENTER); return l; } }); logTable.addMouseListener(new MouseAdapter() { @Override public void mouseClicked(MouseEvent e) { if (e.getClickCount() == 2) { int row = logTable.rowAtPoint(e.getPoint()); int col = logTable.columnAtPoint(e.getPoint()); if (col == 8) { if (logTable.getValueAt(row, col).equals(\"\")) { return; } JOptionPane.showMessageDialog(null, \"Log Record: \" + logTable.getValueAt(row, col)); } } } }); logTable.setSelectionMode(ListSelectionModel.", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          String message = lr.getMessage();\n          if (message != null) {\n            addLogEntry(message);\n          }\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  if (lr.getMessage() != null) {\n    final String message = lr.getMessage();\n    final int length = message.length();\n    if (length > MAX_MESSAGE_LENGTH) {\n      message = message.substring(0, MAX_MESSAGE_LENGTH - 3) + \"...\";\n    }\n    final String t = \"[\" + lr.getMillis() + \"] \" + message;\n    addMessage(t);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  final String msg = lr.getMessage();\n  SwingUtilities.invokeLater(\n      new Runnable() {\n        public void run() {\n          logTableModel.add(lr);\n          logTable.setRowSelectionInterval(\n              logTableModel.getRowCount() - 1, logTableModel.getRowCount() - 1);\n        }\n      });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr) {\n  String msg = lr.getMessage();\n  if (msg != null && msg.length() > 0) {\n    addRow(msg);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a log record message to be displayed in the LogTable. This method is thread-safe as it posts requests to the SwingThread rather than processing directly.\n */\n", "method_name": "addMessage", "codes": ["public void addMessage(final LogRecord lr){ SwingUtilities.invokeLater(new Runnable() { public void run() { log.add(lr); } }); }", "public void addMessage(final LogRecord lr){ final String msg = lr.getMessage(); if (msg != null) { log.append(msg + \"\\n\"); } }", "public void addMessage(final LogRecord lr){ String message = lr.getMessage(); String logLevel = lr.getLevel().getName(); String logMessage = lr.getMessage(); if (message.length() > MAX_MESSAGE_LENGTH) { message = message.substring(0, MAX_MESSAGE_LENGTH - 3) + \"...\"; } logTableModel.addRow(new String[] { logLevel, message, logMessage }); }", "public void addMessage(final LogRecord lr){ if (this.getRowCount() > 0) { this.removeRow(0); } final Object[] row = new Object[3]; row[0] = lr.getLevel(); row[1] = lr.getMessage(); row[2] = lr.getThrown(); this.addRow(row); }", "public void addMessage(final LogRecord lr){ if (!this.isShowLogs()) { return; } final MessageFormat mf = new MessageFormat(lr.getMessage()); final Object[] msgArgs = mf.getMessageArguments(); final StringBuffer sb = new StringBuffer(); for (int i = 0; i < msgArgs.length; i++) { sb.append(msgArgs[i]); if (i < msgArgs.length - 1) { sb.append(\" \"); } } final String s = sb.toString(); final int width = this.getWidth(); this.tableModel.addRow(new Object[] { lr.getThreadID(), s, s }); this.logTextArea.append(s + \"\\n\"); this.logTextArea.setCaretPosition(this.logTextArea.getText().length() - 2); }", "public void addMessage(final LogRecord lr){ if (!lr.getMessage().startsWith(\"--\")) { if (logTableModel == null) { logTableModel = new LogTableModel(lr.getMessage()); logTable = new JTable(logTableModel); logTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF); logTable.getColumnModel().getColumn(0).setPreferredWidth(20); logTable.getColumnModel().getColumn(1).setPreferredWidth(100); logTable.getColumnModel().getColumn(2).setPreferredWidth(50); logTable.getColumnModel().getColumn(3).setPreferredWidth(50); logTable.getColumnModel().getColumn(4).setPreferredWidth(50); logTable.getColumnModel().getColumn(5).setPreferredWidth(50); logTable.getColumnModel().getColumn(6).setPreferredWidth(50); logTable.getColumnModel().getColumn(7).setPreferredWidth(50); logTable.getColumnModel().getColumn(8).setPreferredWidth(50); logTable.getColumnModel().getColumn(9).setPreferredWidth(50); logTable.getColumnModel().getColumn(10).setPreferredWidth(50); logTable.getColumnModel().getColumn(11).setPreferredWidth(50); logTable.getColumnModel().getColumn(12).setPreferredWidth(50); logTable.getColumnModel().getColumn(13).setPreferredWidth(50); logTable.getColumnModel().getColumn(14).setPreferredWidth(50); logTable.getColumnModel().getColumn(15).setPreferredWidth(50); logTable.getColumnModel().getColumn(16).setPreferredWidth(50); logTable.getColumnModel().getColumn(17).setPreferredWidth(50); logTable.getColumnModel().getColumn(18).setPreferredWidth(50); logTable.getColumnModel().getColumn(19).setPreferredWidth(50); logTable.getColumnModel().getColumn(20).setPreferredWidth(50); logTable.setDefaultRenderer(Object.class, new TableCellRenderer() { @Override public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { JLabel l = (JLabel) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column); l.setHorizontalAlignment(SwingConstants.CENTER); return l; } }); logTable.addMouseListener(new MouseAdapter() { @Override public void mouseClicked(MouseEvent e) { if (e.getClickCount() == 2) { int row = logTable.rowAtPoint(e.getPoint()); int col = logTable.columnAtPoint(e.getPoint()); if (col == 8) { if (logTable.getValueAt(row, col).equals(\"\")) { return; } JOptionPane.showMessageDialog(null, \"Log Record: \" + logTable.getValueAt(row, col)); } } } }); logTable.setSelectionMode(ListSelectionModel.", "public void addMessage(final LogRecord lr){ SwingUtilities.invokeLater(new Runnable() { public void run() { String message = lr.getMessage(); if (message != null) { addLogEntry(message); } } }); }", "public void addMessage(final LogRecord lr){ if (lr.getMessage() != null) { final String message = lr.getMessage(); final int length = message.length(); if (length > MAX_MESSAGE_LENGTH) { message = message.substring(0, MAX_MESSAGE_LENGTH - 3) + \"...\"; } final String t = \"[\" + lr.getMillis() + \"] \" + message; addMessage(t); } }", "public void addMessage(final LogRecord lr){ final String msg = lr.getMessage(); SwingUtilities.invokeLater(new Runnable() { public void run() { logTableModel.add(lr); logTable.setRowSelectionInterval(logTableModel.getRowCount() - 1, logTableModel.getRowCount() - 1); } }); }", "public void addMessage(final LogRecord lr){ String msg = lr.getMessage(); if (msg != null && msg.length() > 0) { addRow(msg); } }"], "code_level": "project_runnable", "_id": "636767791a6d9265ec018257", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  try {\n    int i = table.convertRowIndexToView(row);\n    pane.setViewportView(table.getModel().getValueAt(i, 0));\n  } catch (Exception e) {\n    System.out.println(e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  table.setRowSelectionInterval(row, row);\n  pane.setViewportView(table);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  table.getSelectionModel().setSelectionInterval(row, row);\n  pane.setViewportView(table);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  if (table == null || pane == null) {\n    return;\n  }\n  DefaultTableModel model = (DefaultTableModel) table.getModel();\n  model.setValueAt(row, row, 0);\n  model.setValueAt(row, row, 1);\n  model.setValueAt(row, row, 2);\n  model.setValueAt(row, row, 3);\n  pane.setViewportView(table);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  table.setRowSelectionInterval(row, row);\n  pane.setViewportView(table);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  if (row < 0) return;\n  if (row >= table.getRowCount()) return;\n  if (pane == null) {\n    pane = new JScrollPane(table);\n  }\n  pane.setViewportView(table.getModel().getValueAt(row, 0));\n  table.getSelectionModel().setSelectionInterval(row, row);\n  table.requestFocusInWindow();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  if (row == -1) {\n    return;\n  }\n  int modelRow = table.convertRowIndexToModel(row);\n  if (modelRow == -1) {\n    return;\n  }\n  table.setRowSelectionInterval(modelRow, modelRow);\n  table.scrollRectToVisible(new Rectangle(table.getCellRect(modelRow, 0, true)));\n  pane.setViewportView(table);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  if (row < 0 || row > table.getRowCount()) {\n    throw new IndexOutOfBoundsException(\"The specified row is out of bounds.\");\n  }\n  table.getSelectionModel().setSelectionInterval(row, row);\n  pane.setViewportView(table);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  try {\n    int col = table.getColumnCount();\n    int total = table.getRowCount();\n    for (int i = 0; i < col; i++) {\n      if (table.getValueAt(row, i) != null) {\n        JTableHeader header = table.getTableHeader();\n        Object cell = table.getValueAt(row, i);\n        header.setToolTipText(cell.toString());\n      }\n    }\n    for (int i = 0; i < total; i++) {\n      if (table.getValueAt(row, i) != null) {\n        table.setRowSelectionInterval(row, row);\n      }\n    }\n    pane.setViewportView(table);\n  } catch (Exception e) {\n    System.out.println(\"Error while selecting row in table: \" + e.getMessage());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row, JTable table, JScrollPane pane) {\n  if (row < 0 || row >= table.getRowCount()) {\n    return;\n  }\n  table.setRowSelectionInterval(row, row);\n  table.scrollRectToVisible(new Rectangle(table.getCellRect(row, 0, true)));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Selects a the specified row in the specified JTable and scrolls the specified JScrollpane to the newly selected row. More importantly, the call to repaint() delayed long enough to have the table properly paint the newly selected row which may be offscre\n * @param table should belong to the specified JScrollPane\n */\n", "method_name": "selectRow", "codes": ["public static void selectRow(int row,JTable table,JScrollPane pane){ try { int i = table.convertRowIndexToView(row); pane.setViewportView(table.getModel().getValueAt(i, 0)); } catch (Exception e) { System.out.println(e); } }", "public static void selectRow(int row,JTable table,JScrollPane pane){ table.setRowSelectionInterval(row, row); pane.setViewportView(table); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ table.getSelectionModel().setSelectionInterval(row, row); pane.setViewportView(table); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ if (table == null || pane == null) { return; } DefaultTableModel model = (DefaultTableModel) table.getModel(); model.setValueAt(row, row, 0); model.setValueAt(row, row, 1); model.setValueAt(row, row, 2); model.setValueAt(row, row, 3); pane.setViewportView(table); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ table.setRowSelectionInterval(row, row); pane.setViewportView(table); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ if (row < 0) return; if (row >= table.getRowCount()) return; if (pane == null) { pane = new JScrollPane(table); } pane.setViewportView(table.getModel().getValueAt(row, 0)); table.getSelectionModel().setSelectionInterval(row, row); table.requestFocusInWindow(); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ if (row == -1) { return; } int modelRow = table.convertRowIndexToModel(row); if (modelRow == -1) { return; } table.setRowSelectionInterval(modelRow, modelRow); table.scrollRectToVisible(new Rectangle(table.getCellRect(modelRow, 0, true))); pane.setViewportView(table); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ if (row < 0 || row > table.getRowCount()) { throw new IndexOutOfBoundsException(\"The specified row is out of bounds.\"); } table.getSelectionModel().setSelectionInterval(row, row); pane.setViewportView(table); }", "public static void selectRow(int row,JTable table,JScrollPane pane){ try { int col = table.getColumnCount(); int total = table.getRowCount(); for (int i = 0; i < col; i++) { if (table.getValueAt(row, i) != null) { JTableHeader header = table.getTableHeader(); Object cell = table.getValueAt(row, i); header.setToolTipText(cell.toString()); } } for (int i = 0; i < total; i++) { if (table.getValueAt(row, i) != null) { table.setRowSelectionInterval(row, row); } } pane.setViewportView(table); } catch (Exception e) { System.out.println(\"Error while selecting row in table: \" + e.getMessage()); } }", "public static void selectRow(int row,JTable table,JScrollPane pane){ if (row < 0 || row >= table.getRowCount()) { return; } table.setRowSelectionInterval(row, row); table.scrollRectToVisible(new Rectangle(table.getCellRect(row, 0, true))); }"], "code_level": "project_runnable", "_id": "636767841a6d9265ec0183ff", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static void createConfigurationDirectory() {\n  File lf5Directory =\n      new File(\n          System.getProperty(\"user.home\") + \"/Documents and Settings/Linux/Linux Server/Lf5\");\n  if (!lf5Directory.exists()) {\n    lf5Directory.mkdir();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory(){ String configDir = System.getProperty(\"user.home\"); if (configDir == null || configDir.equals(\"\")) { configDir = System.getenv(\"APPDATA\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  File directory =\n      new File(\n          \"C:\\\\Users\\\\Administrator\\\\Documents\\\\NetBeansProjects\\\\LearnSecurity\\\\src\\\\main\\\\r\"\n              + \"esources\\\\config\");\n  if (!directory.exists()) {\n    directory.mkdirs();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  try {\n    if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {\n      if (new File(\"C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\").exists()) {\n        String lf5Directory = System.getProperty(\"user.home\");\n        if (lf5Directory == null) {\n          lf5Directory = \"\";\n        }\n        lf5Directory += \"\\\\.lf5\\\\\";\n        lf5Directory = lf5Directory.replace(\"\\\\\", \"/\");\n        File lf5Dir = new File(lf5Directory);\n        if (!lf5Dir.exists()) {\n          lf5Dir.mkdir();\n        }\n      }\n    } else {\n      if (new File(\"/usr/local/bin/lf5\").exists()) {\n        String lf5Directory = System.getProperty(\"user.home\");\n        if (lf5Directory == null) {\n          lf5Directory = \"\";\n        }\n        lf5Directory += \"/.lf5/\";\n        lf5Directory = lf5Directory.replace(\"\\\\\", \"/\");\n        File lf5Dir = new File(lf5Directory);\n        if (!lf5Dir.exists()) {\n          lf5Dir.mkdir();\n        }\n      }\n    }\n  } catch (Exception e) {\n    System.out.println(\"Failed to create configuration directory\");\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  if (!new File(\"config\").exists()) {\n    new File(\"config\").mkdir();\n  }\n  if (!new File(\"settings\").exists()) {\n    new File(\"settings\").mkdir();\n  }\n  if (!new File(\"lf5\").exists()) {\n    new File(\"lf5\").mkdir();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  File configDir = new File(\".\");\n  String userHome = System.getProperty(\"user.home\");\n  if (userHome.endsWith(\"\\\\Documents\")) {\n    configDir = new File(userHome + \"\\\\Documents\");\n  } else if (userHome.endsWith(\"\\\\Settings\")) {\n    configDir = new File(userHome + \"\\\\Settings\");\n  } else {\n    configDir = new File(userHome + \"\\\\Configuration\");\n  }\n  if (!configDir.exists()) {\n    configDir.mkdirs();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  String userHome = System.getProperty(\"user.home\");\n  String configDirectory = userHome + \"/Documents/Configurations/\";\n  try {\n    Files.createDirectories(Paths.get(configDirectory));\n  } catch (IOException e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  String home = System.getProperty(\"user.home\");\n  if (home != null) {\n    if (home.endsWith(\"\\\\Documents\")) {\n      home = home.substring(0, home.length() - \"\\\\Documents\".length());\n    } else if (home.endsWith(\"\\\\Settings\")) {\n      home = home.substring(0, home.length() - \"\\\\Settings\".length());\n    } else {\n      home = home + \"\\\\Documents\";\n    }\n  } else {\n    home = System.getProperty(\"user.home\");\n  }\n  String homeDirectory = home + \"\\\\Configuration\";\n  File homeDirectoryFile = new File(homeDirectory);\n  if (!homeDirectoryFile.exists()) {\n    homeDirectoryFile.mkdirs();\n  }\n  String configDirectory = homeDirectory + \"\\\\Configuration\\\\\";\n  File configDirectoryFile = new File(configDirectory);\n  if (!configDirectoryFile.exists()) {\n    configDirectoryFile.mkdirs();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  if (!configDirectory.exists()) {\n    configDirectory.mkdirs();\n  }\n  if (!settingsDirectory.exists()) {\n    settingsDirectory.mkdirs();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory() {\n  if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n    String directory =\n        System.getProperty(\"user.home\")\n            + File.separator\n            + \"Documents\"\n            + File.separator\n            + \"Configuration\";\n    System.out.println(\"Directory for configuration directory: \" + directory);\n    File directoryFile = new File(directory);\n    if (!directoryFile.exists()) {\n      directoryFile.mkdirs();\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Creates the directory where the MRU file list will be written. The \"lf5\" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.\n */\n", "method_name": "createConfigurationDirectory", "codes": ["public static void createConfigurationDirectory(){ File lf5Directory = new File(System.getProperty(\"user.home\") + \"/Documents and Settings/Linux/Linux Server/Lf5\"); if (!lf5Directory.exists()) { lf5Directory.mkdir(); } }", "public static void createConfigurationDirectory(){ String configDir = System.getProperty(\"user.home\"); if (configDir == null || configDir.equals(\"\")) { configDir = System.getenv(\"APPDATA\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")) { configDir = System.getProperty(\"user.home\"); } if (configDir == null || configDir.equals(\"\")", "public static void createConfigurationDirectory(){ File directory = new File(\"C:\\\\Users\\\\Administrator\\\\Documents\\\\NetBeansProjects\\\\LearnSecurity\\\\src\\\\main\\\\resources\\\\config\"); if (!directory.exists()) { directory.mkdirs(); } }", "public static void createConfigurationDirectory(){ try { if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) { if (new File(\"C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\").exists()) { String lf5Directory = System.getProperty(\"user.home\"); if (lf5Directory == null) { lf5Directory = \"\"; } lf5Directory += \"\\\\.lf5\\\\\"; lf5Directory = lf5Directory.replace(\"\\\\\", \"/\"); File lf5Dir = new File(lf5Directory); if (!lf5Dir.exists()) { lf5Dir.mkdir(); } } } else { if (new File(\"/usr/local/bin/lf5\").exists()) { String lf5Directory = System.getProperty(\"user.home\"); if (lf5Directory == null) { lf5Directory = \"\"; } lf5Directory += \"/.lf5/\"; lf5Directory = lf5Directory.replace(\"\\\\\", \"/\"); File lf5Dir = new File(lf5Directory); if (!lf5Dir.exists()) { lf5Dir.mkdir(); } } } } catch (Exception e) { System.out.println(\"Failed to create configuration directory\"); } }", "public static void createConfigurationDirectory(){ if (!new File(\"config\").exists()) { new File(\"config\").mkdir(); } if (!new File(\"settings\").exists()) { new File(\"settings\").mkdir(); } if (!new File(\"lf5\").exists()) { new File(\"lf5\").mkdir(); } }", "public static void createConfigurationDirectory(){ File configDir = new File(\".\"); String userHome = System.getProperty(\"user.home\"); if (userHome.endsWith(\"\\\\Documents\")) { configDir = new File(userHome + \"\\\\Documents\"); } else if (userHome.endsWith(\"\\\\Settings\")) { configDir = new File(userHome + \"\\\\Settings\"); } else { configDir = new File(userHome + \"\\\\Configuration\"); } if (!configDir.exists()) { configDir.mkdirs(); } }", "public static void createConfigurationDirectory(){ String userHome = System.getProperty(\"user.home\"); String configDirectory = userHome + \"/Documents/Configurations/\"; try { Files.createDirectories(Paths.get(configDirectory)); } catch (IOException e) { e.printStackTrace(); } }", "public static void createConfigurationDirectory(){ String home = System.getProperty(\"user.home\"); if (home != null) { if (home.endsWith(\"\\\\Documents\")) { home = home.substring(0, home.length() - \"\\\\Documents\".length()); } else if (home.endsWith(\"\\\\Settings\")) { home = home.substring(0, home.length() - \"\\\\Settings\".length()); } else { home = home + \"\\\\Documents\"; } } else { home = System.getProperty(\"user.home\"); } String homeDirectory = home + \"\\\\Configuration\"; File homeDirectoryFile = new File(homeDirectory); if (!homeDirectoryFile.exists()) { homeDirectoryFile.mkdirs(); } String configDirectory = homeDirectory + \"\\\\Configuration\\\\\"; File configDirectoryFile = new File(configDirectory); if (!configDirectoryFile.exists()) { configDirectoryFile.mkdirs(); } }", "public static void createConfigurationDirectory(){ if (!configDirectory.exists()) { configDirectory.mkdirs(); } if (!settingsDirectory.exists()) { settingsDirectory.mkdirs(); } }", "public static void createConfigurationDirectory(){ if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) { String directory = System.getProperty(\"user.home\") + File.separator + \"Documents\" + File.separator + \"Configuration\"; System.out.println(\"Directory for configuration directory: \" + directory); File directoryFile = new File(directory); if (!directoryFile.exists()) { directoryFile.mkdirs(); } } }"], "code_level": "slib_runnable", "_id": "636767871a6d9265ec01846d", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public synchronized void send(final String message) {\n  for (final WebSocket webSocket : webSockets) {\n    try {\n      webSocket.send(message);\n    } catch (final IOException e) {\n      e.printStackTrace();\n      continue;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  final String messageToSend = message;\n  final ArrayList<String> messages = new ArrayList<String>();\n  messages.add(messageToSend);\n  Runnable r =\n      new Runnable() {\n        public void run() {\n          for (String s : messages) {\n            if (s != null) {\n              telnet.send(s);\n            }\n          }\n        }\n      };\n  new Thread(r).start();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  for (final TelnetConnection connection : connections) {\n    connection.send(message);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  if (message == null) {\n    return;\n  }\n  final String messageToSend = message;\n  new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              try {\n                outputStream.write(messageToSend.getBytes());\n                outputStream.flush();\n              } catch (IOException e) {\n                e.printStackTrace();\n              }\n            }\n          })\n      .start();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  new Thread() {\n    @Override\n    public void run() {\n      if (message.startsWith(\"/\")) {\n        for (String connection : connections) {\n          if (!connection.equals(getName())) {\n            try {\n              outputStream.writeBytes(\":\" + connection + \":\" + message + \"\\n\");\n              outputStream.flush();\n            } catch (IOException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      } else {\n        for (String connection : connections) {\n          try {\n            outputStream.writeBytes(\":\" + connection + \":\" + message + \"\\n\");\n            outputStream.flush();\n          } catch (IOException e) {\n            e.printStackTrace();\n          }\n        }\n      }\n    }\n  }.start();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){ if (message == null) { return; } if (!connected) { return; } if (message.trim().length() == 0) { return; } if (message.length() > 0 && message.charAt(0) == '#') { if (message.equals(\"#quit\")) { System.exit(0); } else if (message.equals(\"#exit\")) { System.exit(0); } else if (message.equals(\"#help\")) { System.out.println(\"#telnet-friendly help\"); } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#exit\")) { connected = false; } else if (message.equals(\"#exit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) ", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  if (message == null) {\n    return;\n  }\n  if (message.length() == 0) {\n    return;\n  }\n  if (message.equals(\"\\r\\n\")) {\n    return;\n  }\n  if (message.equals(\"\\n\")) {\n    return;\n  }\n  if (!connected) {\n    return;\n  }\n  final StringBuilder stringBuilder = new StringBuilder(message.length() + 5);\n  stringBuilder.append(\"> \");\n  stringBuilder.append(message);\n  stringBuilder.append(\"\\r\\n\");\n  try {\n    for (final InetAddress inetAddress : getConnected()) {\n      if (inetAddress instanceof Inet6Address) {\n        continue;\n      }\n      final byte[] data = stringBuilder.toString().getBytes(\"UTF-8\");\n      telnetClient.send(data);\n    }\n  } catch (final IOException e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){ if (message == null) { return; } if (message.equals(\"quit\")) { return; } if (message.equals(\"exit\")) { return; } if (message.equals(\"quit-server\")) { if (server != null) { server.shutdown(); server = null; } return; } if (message.equals(\"quit-client\")) { if (client != null) { client.shutdown(); client = null; } return; } if (message.equals(\"quit-client-input\")) { if (client != null) { client.setInputStream(null); } return; } if (message.equals(\"quit-client-output\")) { if (client != null) { client.setOutputStream(null); } return; } if (message.equals(\"quit-server-input\")) { if (server != null) { server.setInputStream(null); } return; } if (message.equals(\"quit-server-output\")) { if (server != null) { server.setOutputStream(null); } return; } if (message.startsWith(\"quit:\")) { String[] split = message.split(\":\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); if (port < 1024 || port > 65535) { throw new Exception(); } client.shutdown(port); } catch (Exception e) { } } return; } if (message.startsWith(\"quit:server:\")) { String[] split = message.split(\":server:\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); server.shutdown(port); } catch (Exception e) { } } return; } if (message.startsWith(\"quit:client:\")) { String[] split = message.split(\":client:\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); client.shutdown(port); } catch (Exception e) { } } return; } if (message.startsWith(\"quit:server:\")) { String[] split = message.split(\":server:\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); server.shutdown(port); } catch (Exception e) { } } return; } if (message.startsWith(\"quit:client-input\")) { String[] split = message.split(\":client-input\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); client.setInputStream(new BufferedInputStream(client.getSocket().getInputStream())); } catch (Exception e) { } } return; } if (message.startsWith(\"quit:client-output\")) { String[] split = message.split(\":client-output\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); client.setOutputStream(new B", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  if (message == null) {\n    return;\n  }\n  final String msg = message;\n  if (isConnected()) {\n    if (msg.length() > 0) {\n      final String[] msgArray = msg.split(\";\");\n      for (final String msgItem : msgArray) {\n        send(msgItem);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message) {\n  new Thread(\n          new Runnable() {\n            public void run() {\n              try {\n                if (socket == null) {\n                  socket = new Socket(\"127.0.0.1\", 8888);\n                }\n                DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n                out.writeUTF(message);\n                out.flush();\n              } catch (Exception e) {\n                e.printStackTrace();\n              }\n            }\n          })\n      .start();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * sends a message to each of the clients in telnet-friendly output. \n */\n", "method_name": "send", "codes": ["public synchronized void send(final String message){ for (final WebSocket webSocket : webSockets) { try { webSocket.send(message); } catch (final IOException e) { e.printStackTrace(); continue; } } }", "public synchronized void send(final String message){ final String messageToSend = message; final ArrayList<String> messages = new ArrayList<String>(); messages.add(messageToSend); Runnable r = new Runnable() { public void run() { for (String s : messages) { if (s != null) { telnet.send(s); } } } }; new Thread(r).start(); }", "public synchronized void send(final String message){ for (final TelnetConnection connection : connections) { connection.send(message); } }", "public synchronized void send(final String message){ if (message == null) { return; } final String messageToSend = message; new Thread(new Runnable() { @Override public void run() { try { outputStream.write(messageToSend.getBytes()); outputStream.flush(); } catch (IOException e) { e.printStackTrace(); } } }).start(); }", "public synchronized void send(final String message){ new Thread() { @Override public void run() { if (message.startsWith(\"/\")) { for (String connection : connections) { if (!connection.equals(getName())) { try { outputStream.writeBytes(\":\" + connection + \":\" + message + \"\\n\"); outputStream.flush(); } catch (IOException e) { e.printStackTrace(); } } } } else { for (String connection : connections) { try { outputStream.writeBytes(\":\" + connection + \":\" + message + \"\\n\"); outputStream.flush(); } catch (IOException e) { e.printStackTrace(); } } } } }.start(); }", "public synchronized void send(final String message){ if (message == null) { return; } if (!connected) { return; } if (message.trim().length() == 0) { return; } if (message.length() > 0 && message.charAt(0) == '#') { if (message.equals(\"#quit\")) { System.exit(0); } else if (message.equals(\"#exit\")) { System.exit(0); } else if (message.equals(\"#help\")) { System.out.println(\"#telnet-friendly help\"); } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#exit\")) { connected = false; } else if (message.equals(\"#exit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) { connected = false; } else if (message.equals(\"#quit\")) ", "public synchronized void send(final String message){ if (message == null) { return; } if (message.length() == 0) { return; } if (message.equals(\"\\r\\n\")) { return; } if (message.equals(\"\\n\")) { return; } if (!connected) { return; } final StringBuilder stringBuilder = new StringBuilder(message.length() + 5); stringBuilder.append(\"> \"); stringBuilder.append(message); stringBuilder.append(\"\\r\\n\"); try { for (final InetAddress inetAddress : getConnected()) { if (inetAddress instanceof Inet6Address) { continue; } final byte[] data = stringBuilder.toString().getBytes(\"UTF-8\"); telnetClient.send(data); } } catch (final IOException e) { e.printStackTrace(); } }", "public synchronized void send(final String message){ if (message == null) { return; } if (message.equals(\"quit\")) { return; } if (message.equals(\"exit\")) { return; } if (message.equals(\"quit-server\")) { if (server != null) { server.shutdown(); server = null; } return; } if (message.equals(\"quit-client\")) { if (client != null) { client.shutdown(); client = null; } return; } if (message.equals(\"quit-client-input\")) { if (client != null) { client.setInputStream(null); } return; } if (message.equals(\"quit-client-output\")) { if (client != null) { client.setOutputStream(null); } return; } if (message.equals(\"quit-server-input\")) { if (server != null) { server.setInputStream(null); } return; } if (message.equals(\"quit-server-output\")) { if (server != null) { server.setOutputStream(null); } return; } if (message.startsWith(\"quit:\")) { String[] split = message.split(\":\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); if (port < 1024 || port > 65535) { throw new Exception(); } client.shutdown(port); } catch (Exception e) { } } return; } if (message.startsWith(\"quit:server:\")) { String[] split = message.split(\":server:\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); server.shutdown(port); } catch (Exception e) { } } return; } if (message.startsWith(\"quit:client:\")) { String[] split = message.split(\":client:\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); client.shutdown(port); } catch (Exception e) { } } return; } if (message.startsWith(\"quit:server:\")) { String[] split = message.split(\":server:\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); server.shutdown(port); } catch (Exception e) { } } return; } if (message.startsWith(\"quit:client-input\")) { String[] split = message.split(\":client-input\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); client.setInputStream(new BufferedInputStream(client.getSocket().getInputStream())); } catch (Exception e) { } } return; } if (message.startsWith(\"quit:client-output\")) { String[] split = message.split(\":client-output\"); if (split.length == 2) { try { int port = Integer.parseInt(split[1]); client.setOutputStream(new B", "public synchronized void send(final String message){ if (message == null) { return; } final String msg = message; if (isConnected()) { if (msg.length() > 0) { final String[] msgArray = msg.split(\";\"); for (final String msgItem : msgArray) { send(msgItem); } } } }", "public synchronized void send(final String message){ new Thread(new Runnable() { public void run() { try { if (socket == null) { socket = new Socket(\"127.0.0.1\", 8888); } DataOutputStream out = new DataOutputStream(socket.getOutputStream()); out.writeUTF(message); out.flush(); } catch (Exception e) { e.printStackTrace(); } } }).start(); }"], "code_level": "class_runnable", "_id": "6367677f1a6d9265ec018347", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "protected void append(LoggingEvent event) {\n  String strRep = layout.format(event);\n  if (layout.ignoresThrowable()) {\n    return;\n  }\n  if (strRep.length() > 0) {\n    strRep = strRep.replace(\"\\r\\n\", \"\\n\");\n  }\n  if (strRep.length() > MAX_STRING_LENGTH) {\n    strRep = strRep.substring(0, MAX_STRING_LENGTH);\n  }\n  event.setStringifiedMessage(strRep);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  try {\n    if (layout.format(event).length() > 0) {\n      output.append(layout.format(event));\n    }\n    if (layout.ignoresThrowable()) {\n      if (event.getThrowableInformation() != null) {\n        output.append(\"\\n\");\n        output.append(layout.format(event.getThrowableInformation()));\n      }\n    }\n  } catch (Exception e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (layout.format(event)) {\n    return;\n  }\n  if (layout.ignoresThrowable()) {\n    String[] messages = layout.getThrowableStrRep();\n    if (messages == null) {\n      messages = new String[0];\n    }\n    for (String message : messages) {\n      event.setThrowableStrRep(message);\n    }\n  }\n  event.setLevel(level);\n  event.setTimeStamp(new Date());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (layout.getFormat() != null) {\n    try {\n      String message = layout.format(event);\n      if (layout.ignoresThrowable()) {\n        event.setThrowableInformation(null);\n      }\n      if (!getChildLoggers().isEmpty()) {\n        for (Logger child : getChildLoggers()) {\n          child.log(event);\n        }\n      }\n      if (!getOutputStreams().isEmpty()) {\n        for (Logger output : getOutputStreams()) {\n          output.log(event);\n        }\n      }\n      if (!getErrorStreams().isEmpty()) {\n        for (Logger error : getErrorStreams()) {\n          error.log(event);\n        }\n      }\n      if (!getFileStreams().isEmpty()) {\n        for (Logger file : getFileStreams()) {\n          file.log(event);\n        }\n      }\n      if (!getCallerData().isEmpty()) {\n        for (String data : getCallerData()) {\n          System.out.println(data);\n        }\n      }\n      if (!getMessages().isEmpty()) {\n        for (String message : getMessages()) {\n          System.out.println(message);\n        }\n      }\n      System.out.println(message);\n    } catch (Throwable t) {\n    }\n  }\n  if (layout.getIgnoreExceptions()) {\n    return;\n  }\n  if (layout.getThrowable() != null) {\n    event.setThrowableInformation(null);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (layout != null && layout.formatter != null) {\n    String msg = layout.formatter.format(event);\n    if (!msg.isEmpty()) {\n      StringBuilder sb = new StringBuilder(msg.length() + 100);\n      sb.append(msg);\n      sb.append(\"\\n\");\n      msg = sb.toString();\n    }\n  }\n  if (layout != null && layout.ignoresThrowable()) {\n    if (event.getThrowableInformation() != null) {\n      if (event.getThrowableInformation().getThrowable() != null) {\n        StringWriter sw = new StringWriter();\n        event.getThrowableInformation().getThrowable().printStackTrace(new PrintWriter(sw, true));\n        msg = sw.toString();\n      }\n    }\n  }\n  if (!msg.isEmpty()) {\n    if (level == Level.INFO) {\n      if (stdout != null) {\n        stdout.println(msg);\n      }\n    } else {\n      if (stderr != null) {\n        stderr.println(msg);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (layout != null\n      && event.getThrowableInformation().getThrowable() != null\n      && layout.format(event).contains(layout.ignoresThrowable() ? \"\" : \"\\n\")) {\n    if (!response.getWriter().checkError()) {\n      response.getWriter().print(layout.format(event));\n    }\n  } else {\n    if (!response.getWriter().checkError()) {\n      response.getWriter().print(layout.format(event));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (layout == null) {\n    return;\n  }\n  if (layout.format(event)) {\n    return;\n  }\n  if (layout.ignoresThrowable()) {\n    return;\n  }\n  if (!(event.getMessage() instanceof String)) {\n    return;\n  }\n  String s = (String) event.getMessage();\n  if (s.length() > MAX_LEN) {\n    s = s.substring(0, MAX_LEN);\n  }\n  String msg = layout.format(event);\n  if (msg.length() > MAX_LEN) {\n    msg = msg.substring(0, MAX_LEN);\n  }\n  if (layout.getThrowableStrRep()) {\n    msg = msg.replaceAll(\"\\n\", \"\\\\\\\\n\");\n  }\n  event.setMessage(msg);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){ if (layout.formatter == null) { if (layout.ignoresThrowable()) { event.getThrowableInformation().setThrowable(null); } return; } if (layout.ignoresThrowable()) { if (event.getThrowableInformation().getThrowable() == null) { event.getThrowableInformation().setThrowable(new NullPointerException()); } } String message = layout.formatter.format(event); if (layout.sendsInfo()) { if (layout.getLevel().intValue() >= Level.INFO.intValue()) { synchronized (layout.getAppenders()) { if (layout.getAppenders().size() == 0) { return; } } } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } ", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (layout == null || layout.format(event) == null) {\n    return;\n  }\n  String msg = layout.format(event);\n  if (layout.ignoresThrowable()) {\n    msg = msg.replaceAll(\"\\\\[|\\\\]\", \"\");\n  }\n  if (msg.startsWith(\"[\") && msg.endsWith(\"]\")) {\n    msg = msg.substring(1, msg.length() - 1);\n  }\n  if (!msg.equals(lastMsg)) {\n    if (stackTrace != null) {\n      logger.log(FQCN, Level.WARNING, null, msg, null, stackTrace);\n    } else {\n      logger.log(FQCN, Level.WARNING, null, msg, null, null);\n    }\n  }\n  lastMsg = msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event) {\n  if (layout.format(event)) {\n    String msg = layout.format(event);\n    if (layout.ignoresThrowable()) {\n      String[] msgSplit = msg.split(\"\\\\r?\\\\n\");\n      if (msgSplit.length > 0) {\n        msg = msgSplit[0];\n      }\n    }\n    if (getLevel().intValue() >= Level.WARNING.intValue()) {\n      if (msg.indexOf(\"\\r\\n\") >= 0) {\n        msg = msg.replaceAll(\"\\r\\n\", \"\\n\");\n      }\n      event.setThrowable(new RuntimeException(msg));\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n", "method_name": "append", "codes": ["protected void append(LoggingEvent event){ String strRep = layout.format(event); if (layout.ignoresThrowable()) { return; } if (strRep.length() > 0) { strRep = strRep.replace(\"\\r\\n\", \"\\n\"); } if (strRep.length() > MAX_STRING_LENGTH) { strRep = strRep.substring(0, MAX_STRING_LENGTH); } event.setStringifiedMessage(strRep); }", "protected void append(LoggingEvent event){ try { if (layout.format(event).length() > 0) { output.append(layout.format(event)); } if (layout.ignoresThrowable()) { if (event.getThrowableInformation() != null) { output.append(\"\\n\"); output.append(layout.format(event.getThrowableInformation())); } } } catch (Exception e) { e.printStackTrace(); } }", "protected void append(LoggingEvent event){ if (layout.format(event)) { return; } if (layout.ignoresThrowable()) { String[] messages = layout.getThrowableStrRep(); if (messages == null) { messages = new String[0]; } for (String message : messages) { event.setThrowableStrRep(message); } } event.setLevel(level); event.setTimeStamp(new Date()); }", "protected void append(LoggingEvent event){ if (layout.getFormat() != null) { try { String message = layout.format(event); if (layout.ignoresThrowable()) { event.setThrowableInformation(null); } if (!getChildLoggers().isEmpty()) { for (Logger child : getChildLoggers()) { child.log(event); } } if (!getOutputStreams().isEmpty()) { for (Logger output : getOutputStreams()) { output.log(event); } } if (!getErrorStreams().isEmpty()) { for (Logger error : getErrorStreams()) { error.log(event); } } if (!getFileStreams().isEmpty()) { for (Logger file : getFileStreams()) { file.log(event); } } if (!getCallerData().isEmpty()) { for (String data : getCallerData()) { System.out.println(data); } } if (!getMessages().isEmpty()) { for (String message : getMessages()) { System.out.println(message); } } System.out.println(message); } catch (Throwable t) { } } if (layout.getIgnoreExceptions()) { return; } if (layout.getThrowable() != null) { event.setThrowableInformation(null); } }", "protected void append(LoggingEvent event){ if (layout != null && layout.formatter != null) { String msg = layout.formatter.format(event); if (!msg.isEmpty()) { StringBuilder sb = new StringBuilder(msg.length() + 100); sb.append(msg); sb.append(\"\\n\"); msg = sb.toString(); } } if (layout != null && layout.ignoresThrowable()) { if (event.getThrowableInformation() != null) { if (event.getThrowableInformation().getThrowable() != null) { StringWriter sw = new StringWriter(); event.getThrowableInformation().getThrowable().printStackTrace(new PrintWriter(sw, true)); msg = sw.toString(); } } } if (!msg.isEmpty()) { if (level == Level.INFO) { if (stdout != null) { stdout.println(msg); } } else { if (stderr != null) { stderr.println(msg); } } } }", "protected void append(LoggingEvent event){ if (layout != null && event.getThrowableInformation().getThrowable() != null && layout.format(event).contains(layout.ignoresThrowable() ? \"\" : \"\\n\")) { if (!response.getWriter().checkError()) { response.getWriter().print(layout.format(event)); } } else { if (!response.getWriter().checkError()) { response.getWriter().print(layout.format(event)); } } }", "protected void append(LoggingEvent event){ if (layout == null) { return; } if (layout.format(event)) { return; } if (layout.ignoresThrowable()) { return; } if (!(event.getMessage() instanceof String)) { return; } String s = (String) event.getMessage(); if (s.length() > MAX_LEN) { s = s.substring(0, MAX_LEN); } String msg = layout.format(event); if (msg.length() > MAX_LEN) { msg = msg.substring(0, MAX_LEN); } if (layout.getThrowableStrRep()) { msg = msg.replaceAll(\"\\n\", \"\\\\\\\\n\"); } event.setMessage(msg); }", "protected void append(LoggingEvent event){ if (layout.formatter == null) { if (layout.ignoresThrowable()) { event.getThrowableInformation().setThrowable(null); } return; } if (layout.ignoresThrowable()) { if (event.getThrowableInformation().getThrowable() == null) { event.getThrowableInformation().setThrowable(new NullPointerException()); } } String message = layout.formatter.format(event); if (layout.sendsInfo()) { if (layout.getLevel().intValue() >= Level.INFO.intValue()) { synchronized (layout.getAppenders()) { if (layout.getAppenders().size() == 0) { return; } } } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } if (layout.getLevel().intValue() >= Level.INFO.intValue()) { if (layout.getAppenders().size() == 0) { return; } } ", "protected void append(LoggingEvent event){ if (layout == null || layout.format(event) == null) { return; } String msg = layout.format(event); if (layout.ignoresThrowable()) { msg = msg.replaceAll(\"\\\\[|\\\\]\", \"\"); } if (msg.startsWith(\"[\") && msg.endsWith(\"]\")) { msg = msg.substring(1, msg.length() - 1); } if (!msg.equals(lastMsg)) { if (stackTrace != null) { logger.log(FQCN, Level.WARNING, null, msg, null, stackTrace); } else { logger.log(FQCN, Level.WARNING, null, msg, null, null); } } lastMsg = msg; }", "protected void append(LoggingEvent event){ if (layout.format(event)) { String msg = layout.format(event); if (layout.ignoresThrowable()) { String[] msgSplit = msg.split(\"\\\\r?\\\\n\"); if (msgSplit.length > 0) { msg = msgSplit[0]; } } if (getLevel().intValue() >= Level.WARNING.intValue()) { if (msg.indexOf(\"\\r\\n\") >= 0) { msg = msg.replaceAll(\"\\r\\n\", \"\\n\"); } event.setThrowable(new RuntimeException(msg)); } } }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec01823e", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void put(LoggingEvent o) {\n  if (buf.length() >= capacity) {\n    if (buf.length() > 0) {\n      buffer.remove(0);\n    }\n  }\n  buffer.add(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (!isFull()) {\n    buf.add(o);\n  } else {\n    flush();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  buf.add(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  buf.add(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (o == null) {\n    return;\n  }\n  if (buf == null) {\n    buf = new StringBuffer();\n  }\n  buf.append(o.getMessage());\n  buf.append(\"\\n\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  buf.append(o.getRenderedMessage());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  buf.add(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  buf.add(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (o.getLevel().intValue() <= level.intValue()) {\n    buf.add(o);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o) {\n  if (buf.length() > 0) {\n    buf.append(\"\\n\");\n  }\n  buf.append(o.getLevel().toString());\n  buf.append(\" \");\n  buf.append(o.getThreadName());\n  buf.append(\" \");\n  buf.append(o.getTimeStamp());\n  buf.append(\" \");\n  buf.append(o.getMessage());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  \n */\n", "method_name": "put", "codes": ["public void put(LoggingEvent o){ if (buf.length() >= capacity) { if (buf.length() > 0) { buffer.remove(0); } } buffer.add(o); }", "public void put(LoggingEvent o){ if (!isFull()) { buf.add(o); } else { flush(); } }", "public void put(LoggingEvent o){ buf.add(o); }", "public void put(LoggingEvent o){ buf.add(o); }", "public void put(LoggingEvent o){ if (o == null) { return; } if (buf == null) { buf = new StringBuffer(); } buf.append(o.getMessage()); buf.append(\"\\n\"); }", "public void put(LoggingEvent o){ buf.append(o.getRenderedMessage()); }", "public void put(LoggingEvent o){ buf.add(o); }", "public void put(LoggingEvent o){ buf.add(o); }", "public void put(LoggingEvent o){ if (o.getLevel().intValue() <= level.intValue()) { buf.add(o); } }", "public void put(LoggingEvent o){ if (buf.length() > 0) { buf.append(\"\\n\"); } buf.append(o.getLevel().toString()); buf.append(\" \"); buf.append(o.getThreadName()); buf.append(\" \"); buf.append(o.getTimeStamp()); buf.append(\" \"); buf.append(o.getMessage()); }"], "code_level": "class_runnable", "_id": "6367677f1a6d9265ec01834b", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static String findAndSubst(String key, Properties props) {\n  String value = props.getProperty(key);\n  if (value == null) {\n    throw new RuntimeException(\"Cannot find property '\" + key + \"'\");\n  }\n  return substVars(value, props);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key,Properties props){ String retVal = props.getProperty(key); if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getPro", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  return findAndSubst(key, props, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  String value = findAndSubst(key, props.getProperty(key));\n  if (value == null) {\n    throw new RuntimeException(\"Could not find \" + key + \" in props\");\n  }\n  return value;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  return findAndSubst(key, props, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  String value = props.getProperty(key);\n  if (value == null) {\n    value = props.getProperty(key.toUpperCase());\n  }\n  if (value == null) {\n    value = props.getProperty(key);\n  }\n  if (value == null) {\n    value = props.getProperty(key.toLowerCase());\n  }\n  if (value == null) {\n    value = props.getProperty(key.toUpperCase().toLowerCase());\n  }\n  return value;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  return findAndSubst(key, props, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  if (key == null) {\n    return null;\n  }\n  String value = props.getProperty(key);\n  if (value == null) {\n    value = props.getProperty(key.toLowerCase());\n  }\n  if (value == null) {\n    value = props.getProperty(key.toUpperCase());\n  }\n  if (value == null) {\n    value = props.getProperty(key.replaceAll(\"\\\\*\", \".*\"));\n  }\n  return value;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  return findAndSubst(key, props, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key, Properties props) {\n  if (props == null) {\n    throw new IllegalArgumentException(\"Properties must not be null\");\n  }\n  String value = props.getProperty(key);\n  if (value == null) {\n    throw new IllegalArgumentException(\"Property '\" + key + \"' not found in \" + props);\n  }\n  return value;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.\n */\n", "method_name": "findAndSubst", "codes": ["public static String findAndSubst(String key,Properties props){ String value = props.getProperty(key); if (value == null) { throw new RuntimeException(\"Cannot find property '\" + key + \"'\"); } return substVars(value, props); }", "public static String findAndSubst(String key,Properties props){ String retVal = props.getProperty(key); if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getProperty(key.replaceAll(\"\\\\$\\\\{\", \"\").replaceAll(\"\\\\}\", \"\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\").replaceAll(\"\\\\*\", \".*\")); } if (retVal == null) { retVal = props.getPro", "public static String findAndSubst(String key,Properties props){ return findAndSubst(key, props, true); }", "public static String findAndSubst(String key,Properties props){ String value = findAndSubst(key, props.getProperty(key)); if (value == null) { throw new RuntimeException(\"Could not find \" + key + \" in props\"); } return value; }", "public static String findAndSubst(String key,Properties props){ return findAndSubst(key, props, null); }", "public static String findAndSubst(String key,Properties props){ String value = props.getProperty(key); if (value == null) { value = props.getProperty(key.toUpperCase()); } if (value == null) { value = props.getProperty(key); } if (value == null) { value = props.getProperty(key.toLowerCase()); } if (value == null) { value = props.getProperty(key.toUpperCase().toLowerCase()); } return value; }", "public static String findAndSubst(String key,Properties props){ return findAndSubst(key, props, null); }", "public static String findAndSubst(String key,Properties props){ if (key == null) { return null; } String value = props.getProperty(key); if (value == null) { value = props.getProperty(key.toLowerCase()); } if (value == null) { value = props.getProperty(key.toUpperCase()); } if (value == null) { value = props.getProperty(key.replaceAll(\"\\\\*\", \".*\")); } return value; }", "public static String findAndSubst(String key,Properties props){ return findAndSubst(key, props, false); }", "public static String findAndSubst(String key,Properties props){ if (props == null) { throw new IllegalArgumentException(\"Properties must not be null\"); } String value = props.getProperty(key); if (value == null) { throw new IllegalArgumentException(\"Property '\" + key + \"' not found in \" + props); } return value; }"], "code_level": "project_runnable", "_id": "636767791a6d9265ec01826d", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public boolean isAttached(Appender appender) {\n  return appenderList.contains(appender);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender) {\n  if (appenderList.contains(appender)) {\n    return true;\n  } else {\n    return false;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return appenderList.contains(appender);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return appenderList.contains(appender);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return appenderList.contains(appender);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender) {\n  if (appenderList == null) {\n    return false;\n  }\n  return appenderList.contains(appender);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender) {\n  if (appenderList == null) {\n    return false;\n  }\n  for (int i = 0; i < appenderList.size(); i++) {\n    Appender app = (Appender) appenderList.get(i);\n    if (app == appender) {\n      return true;\n    }\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return appenderList.contains(appender);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender) {\n  return appenderList.contains(appender);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender) {\n  boolean isAttached = false;\n  if (appenderList != null && appenderList.size() > 0) {\n    for (Appender appenderElement : appenderList) {\n      if (appenderElement.equals(appender)) {\n        isAttached = true;\n        break;\n      }\n    }\n  }\n  return isAttached;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns <code>true</code> if the specified appender is in the list of attached appenders, <code>false</code> otherwise.\n * @since 1.2 \n */\n", "method_name": "isAttached", "codes": ["public boolean isAttached(Appender appender){ return appenderList.contains(appender); }", "public boolean isAttached(Appender appender){ if (appenderList.contains(appender)) { return true; } else { return false; } }", "public boolean isAttached(Appender appender){ return appenderList.contains(appender); }", "public boolean isAttached(Appender appender){ return appenderList.contains(appender); }", "public boolean isAttached(Appender appender){ return appenderList.contains(appender); }", "public boolean isAttached(Appender appender){ if (appenderList == null) { return false; } return appenderList.contains(appender); }", "public boolean isAttached(Appender appender){ if (appenderList == null) { return false; } for (int i = 0; i < appenderList.size(); i++) { Appender app = (Appender) appenderList.get(i); if (app == appender) { return true; } } return false; }", "public boolean isAttached(Appender appender){ return appenderList.contains(appender); }", "public boolean isAttached(Appender appender){ return appenderList.contains(appender); }", "public boolean isAttached(Appender appender){ boolean isAttached = false; if (appenderList != null && appenderList.size() > 0) { for (Appender appenderElement : appenderList) { if (appenderElement.equals(appender)) { isAttached = true; break; } } } return isAttached; }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018238", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null || value.length() == 0) return dEfault;\n  return Boolean.parseBoolean(value);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  return toBoolean(value, dEfault, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) return dEfault;\n  if (value.equalsIgnoreCase(\"true\")) return true;\n  if (value.equalsIgnoreCase(\"false\")) return false;\n  if (value.equalsIgnoreCase(\"yes\")) return true;\n  if (value.equalsIgnoreCase(\"no\")) return false;\n  if (value.equalsIgnoreCase(\"1\")) return true;\n  if (value.equalsIgnoreCase(\"0\")) return false;\n  return dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) return dEfault;\n  if (value.equalsIgnoreCase(\"true\")) return true;\n  if (value.equalsIgnoreCase(\"false\")) return false;\n  return dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  return toBoolean(value, dEfault, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null || value.length() == 0) {\n    return dEfault;\n  }\n  value = value.toLowerCase();\n  if (value.equals(\"true\") || value.equals(\"yes\") || value.equals(\"1\")) {\n    return true;\n  } else if (value.equals(\"false\") || value.equals(\"no\") || value.equals(\"0\")) {\n    return false;\n  } else {\n    return dEfault;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) return dEfault;\n  if (value.equalsIgnoreCase(\"true\")) return true;\n  if (value.equalsIgnoreCase(\"false\")) return false;\n  return dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) {\n    return dEfault;\n  } else if (value.equalsIgnoreCase(\"true\")) {\n    return true;\n  } else if (value.equalsIgnoreCase(\"false\")) {\n    return false;\n  } else {\n    return dEfault;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) {\n    return dEfault;\n  }\n  if (value.equalsIgnoreCase(\"true\")) {\n    return true;\n  }\n  if (value.equalsIgnoreCase(\"false\")) {\n    return false;\n  }\n  return dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value, boolean dEfault) {\n  if (value == null) return dEfault;\n  if (value.equalsIgnoreCase(\"true\")) return true;\n  if (value.equalsIgnoreCase(\"false\")) return false;\n  if (value.equalsIgnoreCase(\"on\")) return true;\n  if (value.equalsIgnoreCase(\"off\")) return false;\n  return dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * If <code>value</code> is \"true\", then <code>true</code> is returned. If <code>value</code> is \"false\", then <code>true</code> is returned. Otherwise, <code>default</code> is returned. <p>Case of value is unimportant.  \n */\n", "method_name": "toBoolean", "codes": ["public static boolean toBoolean(String value,boolean dEfault){ if (value == null || value.length() == 0) return dEfault; return Boolean.parseBoolean(value); }", "public static boolean toBoolean(String value,boolean dEfault){ return toBoolean(value, dEfault, null); }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) return dEfault; if (value.equalsIgnoreCase(\"true\")) return true; if (value.equalsIgnoreCase(\"false\")) return false; if (value.equalsIgnoreCase(\"yes\")) return true; if (value.equalsIgnoreCase(\"no\")) return false; if (value.equalsIgnoreCase(\"1\")) return true; if (value.equalsIgnoreCase(\"0\")) return false; return dEfault; }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) return dEfault; if (value.equalsIgnoreCase(\"true\")) return true; if (value.equalsIgnoreCase(\"false\")) return false; return dEfault; }", "public static boolean toBoolean(String value,boolean dEfault){ return toBoolean(value, dEfault, false); }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null || value.length() == 0) { return dEfault; } value = value.toLowerCase(); if (value.equals(\"true\") || value.equals(\"yes\") || value.equals(\"1\")) { return true; } else if (value.equals(\"false\") || value.equals(\"no\") || value.equals(\"0\")) { return false; } else { return dEfault; } }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) return dEfault; if (value.equalsIgnoreCase(\"true\")) return true; if (value.equalsIgnoreCase(\"false\")) return false; return dEfault; }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) { return dEfault; } else if (value.equalsIgnoreCase(\"true\")) { return true; } else if (value.equalsIgnoreCase(\"false\")) { return false; } else { return dEfault; } }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) { return dEfault; } if (value.equalsIgnoreCase(\"true\")) { return true; } if (value.equalsIgnoreCase(\"false\")) { return false; } return dEfault; }", "public static boolean toBoolean(String value,boolean dEfault){ if (value == null) return dEfault; if (value.equalsIgnoreCase(\"true\")) return true; if (value.equalsIgnoreCase(\"false\")) return false; if (value.equalsIgnoreCase(\"on\")) return true; if (value.equalsIgnoreCase(\"off\")) return false; return dEfault; }"], "code_level": "self_contained", "_id": "6367677d1a6d9265ec0182fd", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void add(LoggingEvent event) {\n  if (events.size() == 0) {\n    events.add(event);\n  } else {\n    events.add(events.size() - 1, event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  if (event.getLevel().intValue() >= this.level.intValue()) {\n    this.events.add(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  if (event.getLevel().isGreaterOrEqual(level)) {\n    events.add(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  if (events.size() == 0) {\n    lastEvent = event;\n  }\n  events.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  if (this.buffer.size() >= this.bufferSize) {\n    this.buffer.remove(0);\n  }\n  this.buffer.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  if (events.size() >= bufferSize) {\n    events.removeFirst();\n  }\n  events.addLast(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  if (event == null) {\n    throw new NullPointerException(\"Event cannot be null\");\n  }\n  eventBuffer.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  if (event.getLevel().isGreaterOrEqual(level)) {\n    if (buffer.size() >= bufferSize) {\n      LoggingEvent lastEvent = buffer.removeLast();\n      if (lastEvent.getLevel().isGreaterOrEqual(level)) {\n        return;\n      }\n    }\n    buffer.addLast(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  if (event.getTimeStamp() > this.last) {\n    this.buffer.add(event);\n    this.last = event.getTimeStamp();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event) {\n  synchronized (buffer) {\n    buffer.add(event);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add an <code>event</code> as the last event in the buffer.\n */\n", "method_name": "add", "codes": ["public void add(LoggingEvent event){ if (events.size() == 0) { events.add(event); } else { events.add(events.size() - 1, event); } }", "public void add(LoggingEvent event){ if (event.getLevel().intValue() >= this.level.intValue()) { this.events.add(event); } }", "public void add(LoggingEvent event){ if (event.getLevel().isGreaterOrEqual(level)) { events.add(event); } }", "public void add(LoggingEvent event){ if (events.size() == 0) { lastEvent = event; } events.add(event); }", "public void add(LoggingEvent event){ if (this.buffer.size() >= this.bufferSize) { this.buffer.remove(0); } this.buffer.add(event); }", "public void add(LoggingEvent event){ if (events.size() >= bufferSize) { events.removeFirst(); } events.addLast(event); }", "public void add(LoggingEvent event){ if (event == null) { throw new NullPointerException(\"Event cannot be null\"); } eventBuffer.add(event); }", "public void add(LoggingEvent event){ if (event.getLevel().isGreaterOrEqual(level)) { if (buffer.size() >= bufferSize) { LoggingEvent lastEvent = buffer.removeLast(); if (lastEvent.getLevel().isGreaterOrEqual(level)) { return; } } buffer.addLast(event); } }", "public void add(LoggingEvent event){ if (event.getTimeStamp() > this.last) { this.buffer.add(event); this.last = event.getTimeStamp(); } }", "public void add(LoggingEvent event){ synchronized (buffer) { buffer.add(event); } }"], "code_level": "class_runnable", "_id": "636767841a6d9265ec0183e8", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    appenders.remove(name);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    appenders.remove(name);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  appenders.remove(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  if (appenders != null) {\n    appenders.remove(name);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  if (name == null) {\n    throw new IllegalArgumentException(\"name cannot be null.\");\n  }\n  synchronized (appenders) {\n    if (appenders.remove(name) != null) {\n      log.info(\"Removed appender {} from the list of appenders.\", name);\n    } else {\n      log.warn(\"Appender {} was not found in the list of appenders.\", name);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    appenders.remove(name);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  Appender appender = null;\n  for (Iterator iterator = appenders.iterator(); iterator.hasNext(); ) {\n    appender = (Appender) iterator.next();\n    if (appender.getName().equals(name)) {\n      appenders.remove(appender);\n      break;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    if (appenders.containsKey(name)) {\n      appenders.remove(name);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    for (Appender appender : appenders) {\n      if (appender.getName().equals(name)) {\n        appender.stop();\n        appender.destroy();\n        appenders.remove(appender);\n        return;\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name) {\n  synchronized (appenders) {\n    for (Iterator i = appenders.iterator(); i.hasNext(); ) {\n      Appender app = (Appender) i.next();\n      if (name.equals(app.getName())) {\n        appenders.remove(app);\n        break;\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Remove the appender with the name passed as parameter form the list of appenders.  \n */\n", "method_name": "removeAppender", "codes": ["public void removeAppender(String name){ synchronized (appenders) { appenders.remove(name); } }", "public void removeAppender(String name){ synchronized (appenders) { appenders.remove(name); } }", "public void removeAppender(String name){ appenders.remove(name); }", "public void removeAppender(String name){ if (appenders != null) { appenders.remove(name); } }", "public void removeAppender(String name){ if (name == null) { throw new IllegalArgumentException(\"name cannot be null.\"); } synchronized (appenders) { if (appenders.remove(name) != null) { log.info(\"Removed appender {} from the list of appenders.\", name); } else { log.warn(\"Appender {} was not found in the list of appenders.\", name); } } }", "public void removeAppender(String name){ synchronized (appenders) { appenders.remove(name); } }", "public void removeAppender(String name){ Appender appender = null; for (Iterator iterator = appenders.iterator(); iterator.hasNext(); ) { appender = (Appender) iterator.next(); if (appender.getName().equals(name)) { appenders.remove(appender); break; } } }", "public void removeAppender(String name){ synchronized (appenders) { if (appenders.containsKey(name)) { appenders.remove(name); } } }", "public void removeAppender(String name){ synchronized (appenders) { for (Appender appender : appenders) { if (appender.getName().equals(name)) { appender.stop(); appender.destroy(); appenders.remove(appender); return; } } } }", "public void removeAppender(String name){ synchronized (appenders) { for (Iterator i = appenders.iterator(); i.hasNext(); ) { Appender app = (Appender) i.next(); if (name.equals(app.getName())) { appenders.remove(app); break; } } } }"], "code_level": "project_runnable", "_id": "636767861a6d9265ec01844c", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int result = 0;\n  for (Iterator it = appenders.iterator(); it.hasNext(); ) {\n    Appender appender = (Appender) it.next();\n    result += appender.appendLoopOnAppenders(event);\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int count = 0;\n  for (Iterator it = appenders.iterator(); it.hasNext(); ) {\n    count += ((Appender) it.next()).doAppend(event);\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int i = 0;\n  boolean appended = false;\n  for (Iterator iterator = appenders.iterator(); iterator.hasNext(); i++) {\n    Appender appender = (Appender) iterator.next();\n    try {\n      appended = appender.doAppend(event);\n      if (appended) {\n        break;\n      }\n    } catch (Throwable t) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\n            \"Appender \"\n                + appender.getName()\n                + \" encountered an exception while attempting to append event \"\n                + event.getMessage(),\n            t);\n      }\n    }\n  }\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  if (!isEnabled()) {\n    return LOG_NOT_ENABLED;\n  }\n  int result = LOG_NOT_ENABLED;\n  synchronized (appenders) {\n    for (Appender appender : appenders.values()) {\n      appender.doAppend(event);\n      if (appender.isEnabled()) {\n        result = LOG_ENABLED;\n        break;\n      }\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int count = 0;\n  for (Appender appender : getAppenders()) {\n    if (appender instanceof AppenderSkeleton) {\n      count++;\n      ((AppenderSkeleton) appender).doAppend(event);\n    }\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int i = 0;\n  for (Iterator iterator = this.appenders.iterator(); iterator.hasNext(); i++) {\n    Appender appender = (Appender) iterator.next();\n    if (appender instanceof org.apache.log4j.core.Appender) {\n      ((org.apache.log4j.core.Appender) appender).doAppend(event);\n    }\n  }\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  if (appenders == null || appenders.length == 0) return 0;\n  int i = 0;\n  for (Appender appender : appenders) {\n    if (appender.doAppend(event)) {\n      i++;\n    }\n  }\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int count = 0;\n  if (appenders != null) {\n    for (Appender appender : appenders) {\n      count += appender.doAppend(event);\n    }\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  int count = 0;\n  for (Appender appender : appenders) {\n    if (appender instanceof AbstractAppender) {\n      count += ((AbstractAppender) appender).append(event);\n    }\n  }\n  return count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event) {\n  if (appenders == null) {\n    return 0;\n  }\n  int numAppenders = appenders.size();\n  for (int i = 0; i < numAppenders; i++) {\n    LoggingEventAppender appender = appenders.get(i);\n    appender.appendLoopOnAppenders(event);\n  }\n  return numAppenders;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Call the <code>doAppend</code> method on all attached appenders.  \n */\n", "method_name": "appendLoopOnAppenders", "codes": ["public int appendLoopOnAppenders(LoggingEvent event){ int result = 0; for (Iterator it = appenders.iterator(); it.hasNext(); ) { Appender appender = (Appender) it.next(); result += appender.appendLoopOnAppenders(event); } return result; }", "public int appendLoopOnAppenders(LoggingEvent event){ int count = 0; for (Iterator it = appenders.iterator(); it.hasNext(); ) { count += ((Appender) it.next()).doAppend(event); } return count; }", "public int appendLoopOnAppenders(LoggingEvent event){ int i = 0; boolean appended = false; for (Iterator iterator = appenders.iterator(); iterator.hasNext(); i++) { Appender appender = (Appender) iterator.next(); try { appended = appender.doAppend(event); if (appended) { break; } } catch (Throwable t) { if (logger.isDebugEnabled()) { logger.debug(\"Appender \" + appender.getName() + \" encountered an exception while attempting to append event \" + event.getMessage(), t); } } } return i; }", "public int appendLoopOnAppenders(LoggingEvent event){ if (!isEnabled()) { return LOG_NOT_ENABLED; } int result = LOG_NOT_ENABLED; synchronized (appenders) { for (Appender appender : appenders.values()) { appender.doAppend(event); if (appender.isEnabled()) { result = LOG_ENABLED; break; } } } return result; }", "public int appendLoopOnAppenders(LoggingEvent event){ int count = 0; for (Appender appender : getAppenders()) { if (appender instanceof AppenderSkeleton) { count++; ((AppenderSkeleton) appender).doAppend(event); } } return count; }", "public int appendLoopOnAppenders(LoggingEvent event){ int i = 0; for (Iterator iterator = this.appenders.iterator(); iterator.hasNext(); i++) { Appender appender = (Appender) iterator.next(); if (appender instanceof org.apache.log4j.core.Appender) { ((org.apache.log4j.core.Appender) appender).doAppend(event); } } return i; }", "public int appendLoopOnAppenders(LoggingEvent event){ if (appenders == null || appenders.length == 0) return 0; int i = 0; for (Appender appender : appenders) { if (appender.doAppend(event)) { i++; } } return i; }", "public int appendLoopOnAppenders(LoggingEvent event){ int count = 0; if (appenders != null) { for (Appender appender : appenders) { count += appender.doAppend(event); } } return count; }", "public int appendLoopOnAppenders(LoggingEvent event){ int count = 0; for (Appender appender : appenders) { if (appender instanceof AbstractAppender) { count += ((AbstractAppender) appender).append(event); } } return count; }", "public int appendLoopOnAppenders(LoggingEvent event){ if (appenders == null) { return 0; } int numAppenders = appenders.size(); for (int i = 0; i < numAppenders; i++) { LoggingEventAppender appender = appenders.get(i); appender.appendLoopOnAppenders(event); } return numAppenders; }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018242", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public boolean hasThrown() {\n  return thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return this.thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown() {\n  return thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return true if getThrown().toString() is a non-empty string.\n */\n", "method_name": "hasThrown", "codes": ["public boolean hasThrown(){ return thrown; }", "public boolean hasThrown(){ return thrown != null; }", "public boolean hasThrown(){ return thrown != null; }", "public boolean hasThrown(){ return thrown != null; }", "public boolean hasThrown(){ return thrown != null; }", "public boolean hasThrown(){ return thrown != null; }", "public boolean hasThrown(){ return thrown; }", "public boolean hasThrown(){ return this.thrown; }", "public boolean hasThrown(){ return thrown; }", "public boolean hasThrown(){ return thrown; }"], "code_level": "class_runnable", "_id": "636767821a6d9265ec0183ab", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "protected int removeUnusedNodes() {\n  int removedNodes = 0;\n  if (root == null) {\n    return 0;\n  }\n  removedNodes = removeUnusedNodes(root);\n  return removedNodes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  if (!isRoot) {\n    removed += removeUnusedNodes((Category) getParent());\n  }\n  if (!isLeaf) {\n    removed += removeUnusedNodes((Category) getChildAt(0));\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  for (int i = 0; i < category.getNodeCount(); i++) {\n    CategoryTreeNode node = (CategoryTreeNode) category.getNode(i);\n    if (node.getChildCount() == 0) {\n      category.removeNodeFromParent(node);\n      removed++;\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  if (root != null) {\n    ArrayList<TreeNode> children = root.getChildren();\n    for (TreeNode child : children) {\n      if (child.isInactive()) {\n        child.setInactive(false);\n        removed++;\n      }\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removedNodes = 0;\n  int n = categoryTree.getRowCount();\n  for (int i = 0; i < n; i++) {\n    Object obj = categoryTree.getModel().getValueAt(i, 0);\n    if (obj instanceof CategoryNode) {\n      CategoryNode cn = (CategoryNode) obj;\n      if (!cn.isInactive()) {\n        cn.removeFromTree();\n        removedNodes++;\n      }\n    }\n  }\n  return removedNodes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  for (int i = 0; i < categoryTree.getRowCount(); i++) {\n    if (categoryTree.isRowSelected(i)) {\n      Object[] row = categoryTree.getPathForRow(i).toArray();\n      if (row.length > 0) {\n        CategoryNode node = (CategoryNode) row[0];\n        if (node.isInactive()) {\n          removed++;\n        } else {\n          removeNode(node);\n          removed++;\n        }\n      }\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removed = 0;\n  if (this.categoryTreeModel != null) {\n    CategoryNode root = this.categoryTreeModel.getRoot();\n    if (root != null) {\n      DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) root.getUserObject();\n      if (rootNode != null) {\n        rootNode.removeAllChildren();\n      }\n      if (rootNode != null) {\n        int numChildren = rootNode.getChildCount();\n        if (numChildren > 0) {\n          for (int i = 0; i < numChildren; i++) {\n            CategoryNode child = (CategoryNode) rootNode.getChildAt(i);\n            child.removeAllChildren();\n            removed++;\n          }\n        }\n      }\n    }\n  }\n  return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removedNodes = 0;\n  TreePath path = categoryTree.getSelectionPath();\n  if (path != null) {\n    DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();\n    if (node.getUserObject() instanceof Category) {\n      Category category = (Category) node.getUserObject();\n      removedNodes = removeUnusedNodes(category);\n    }\n  }\n  return removedNodes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int n = 0;\n  int numNodes = getNumNodes();\n  for (int i = 0; i < numNodes; i++) {\n    if (!nodeStatus[i]) {\n      nodeStatus[i] = true;\n      n++;\n    }\n  }\n  return n;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes() {\n  int removedNodes = 0;\n  if (isCategoryTreeEmpty()) {\n    return removedNodes;\n  }\n  CategoryTreeNode root = getRoot();\n  if (root != null) {\n    CategoryTreeNode current = root;\n    while (current.hasChildren()) {\n      current = current.getFirstChild();\n      if (!current.isActive()) {\n        removedNodes++;\n        removeNode(current);\n      }\n    }\n  }\n  return removedNodes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes any inactive nodes from the Category tree.\n */\n", "method_name": "removeUnusedNodes", "codes": ["protected int removeUnusedNodes(){ int removedNodes = 0; if (root == null) { return 0; } removedNodes = removeUnusedNodes(root); return removedNodes; }", "protected int removeUnusedNodes(){ int removed = 0; if (!isRoot) { removed += removeUnusedNodes((Category) getParent()); } if (!isLeaf) { removed += removeUnusedNodes((Category) getChildAt(0)); } return removed; }", "protected int removeUnusedNodes(){ int removed = 0; for (int i = 0; i < category.getNodeCount(); i++) { CategoryTreeNode node = (CategoryTreeNode) category.getNode(i); if (node.getChildCount() == 0) { category.removeNodeFromParent(node); removed++; } } return removed; }", "protected int removeUnusedNodes(){ int removed = 0; if (root != null) { ArrayList<TreeNode> children = root.getChildren(); for (TreeNode child : children) { if (child.isInactive()) { child.setInactive(false); removed++; } } } return removed; }", "protected int removeUnusedNodes(){ int removedNodes = 0; int n = categoryTree.getRowCount(); for (int i = 0; i < n; i++) { Object obj = categoryTree.getModel().getValueAt(i, 0); if (obj instanceof CategoryNode) { CategoryNode cn = (CategoryNode) obj; if (!cn.isInactive()) { cn.removeFromTree(); removedNodes++; } } } return removedNodes; }", "protected int removeUnusedNodes(){ int removed = 0; for (int i = 0; i < categoryTree.getRowCount(); i++) { if (categoryTree.isRowSelected(i)) { Object[] row = categoryTree.getPathForRow(i).toArray(); if (row.length > 0) { CategoryNode node = (CategoryNode) row[0]; if (node.isInactive()) { removed++; } else { removeNode(node); removed++; } } } } return removed; }", "protected int removeUnusedNodes(){ int removed = 0; if (this.categoryTreeModel != null) { CategoryNode root = this.categoryTreeModel.getRoot(); if (root != null) { DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) root.getUserObject(); if (rootNode != null) { rootNode.removeAllChildren(); } if (rootNode != null) { int numChildren = rootNode.getChildCount(); if (numChildren > 0) { for (int i = 0; i < numChildren; i++) { CategoryNode child = (CategoryNode) rootNode.getChildAt(i); child.removeAllChildren(); removed++; } } } } } return removed; }", "protected int removeUnusedNodes(){ int removedNodes = 0; TreePath path = categoryTree.getSelectionPath(); if (path != null) { DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent(); if (node.getUserObject() instanceof Category) { Category category = (Category) node.getUserObject(); removedNodes = removeUnusedNodes(category); } } return removedNodes; }", "protected int removeUnusedNodes(){ int n = 0; int numNodes = getNumNodes(); for (int i = 0; i < numNodes; i++) { if (!nodeStatus[i]) { nodeStatus[i] = true; n++; } } return n; }", "protected int removeUnusedNodes(){ int removedNodes = 0; if (isCategoryTreeEmpty()) { return removedNodes; } CategoryTreeNode root = getRoot(); if (root != null) { CategoryTreeNode current = root; while (current.hasChildren()) { current = current.getFirstChild(); if (!current.isActive()) { removedNodes++; removeNode(current); } } } return removedNodes; }"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec018314", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event e1 = (Event) aObj1;\n  Event e2 = (Event) aObj2;\n  return e1.getTimeStamp().compareTo(e2.getTimeStamp());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event aEvent1 = (Event) aObj1;\n  Event aEvent2 = (Event) aObj2;\n  return aEvent1.getTimeStamp().compareTo(aEvent2.getTimeStamp());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event e1 = (Event) aObj1;\n  Event e2 = (Event) aObj2;\n  return e1.getTimeStamp().compareTo(e2.getTimeStamp());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event aEvent1 = (Event) aObj1;\n  Event aEvent2 = (Event) aObj2;\n  if (aEvent1.getTimeStamp() == aEvent2.getTimeStamp()) return 0;\n  else if (aEvent1.getTimeStamp() < aEvent2.getTimeStamp()) return -1;\n  else return 1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event aEvent1 = (Event) aObj1;\n  Event aEvent2 = (Event) aObj2;\n  return aEvent1.getTimeStamp().compareTo(aEvent2.getTimeStamp());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event aEvent1 = (Event) aObj1;\n  Event aEvent2 = (Event) aObj2;\n  return aEvent1.getTimeStamp().compareTo(aEvent2.getTimeStamp());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event e1 = (Event) aObj1;\n  Event e2 = (Event) aObj2;\n  if (e1.getTimeStamp() > e2.getTimeStamp()) {\n    return 1;\n  } else if (e1.getTimeStamp() < e2.getTimeStamp()) {\n    return -1;\n  } else {\n    return 0;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event e1 = (Event) aObj1;\n  Event e2 = (Event) aObj2;\n  return e1.getTimeStamp().compareTo(e2.getTimeStamp());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event e1 = (Event) aObj1;\n  Event e2 = (Event) aObj2;\n  int result = e1.getTimeStamp().compareTo(e2.getTimeStamp());\n  if (result == 0) {\n    result = e1.getEventType().compareTo(e2.getEventType());\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1, Object aObj2) {\n  Event aEvent1 = (Event) aObj1;\n  Event aEvent2 = (Event) aObj2;\n  return (int) (aEvent1.getTimeStamp() - aEvent2.getTimeStamp());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @see Comparator \n */\n", "method_name": "compare", "codes": ["public int compare(Object aObj1,Object aObj2){ Event e1 = (Event) aObj1; Event e2 = (Event) aObj2; return e1.getTimeStamp().compareTo(e2.getTimeStamp()); }", "public int compare(Object aObj1,Object aObj2){ Event aEvent1 = (Event) aObj1; Event aEvent2 = (Event) aObj2; return aEvent1.getTimeStamp().compareTo(aEvent2.getTimeStamp()); }", "public int compare(Object aObj1,Object aObj2){ Event e1 = (Event) aObj1; Event e2 = (Event) aObj2; return e1.getTimeStamp().compareTo(e2.getTimeStamp()); }", "public int compare(Object aObj1,Object aObj2){ Event aEvent1 = (Event) aObj1; Event aEvent2 = (Event) aObj2; if (aEvent1.getTimeStamp() == aEvent2.getTimeStamp()) return 0; else if (aEvent1.getTimeStamp() < aEvent2.getTimeStamp()) return -1; else return 1; }", "public int compare(Object aObj1,Object aObj2){ Event aEvent1 = (Event) aObj1; Event aEvent2 = (Event) aObj2; return aEvent1.getTimeStamp().compareTo(aEvent2.getTimeStamp()); }", "public int compare(Object aObj1,Object aObj2){ Event aEvent1 = (Event) aObj1; Event aEvent2 = (Event) aObj2; return aEvent1.getTimeStamp().compareTo(aEvent2.getTimeStamp()); }", "public int compare(Object aObj1,Object aObj2){ Event e1 = (Event) aObj1; Event e2 = (Event) aObj2; if (e1.getTimeStamp() > e2.getTimeStamp()) { return 1; } else if (e1.getTimeStamp() < e2.getTimeStamp()) { return -1; } else { return 0; } }", "public int compare(Object aObj1,Object aObj2){ Event e1 = (Event) aObj1; Event e2 = (Event) aObj2; return e1.getTimeStamp().compareTo(e2.getTimeStamp()); }", "public int compare(Object aObj1,Object aObj2){ Event e1 = (Event) aObj1; Event e2 = (Event) aObj2; int result = e1.getTimeStamp().compareTo(e2.getTimeStamp()); if (result == 0) { result = e1.getEventType().compareTo(e2.getEventType()); } return result; }", "public int compare(Object aObj1,Object aObj2){ Event aEvent1 = (Event) aObj1; Event aEvent2 = (Event) aObj2; return (int) (aEvent1.getTimeStamp() - aEvent2.getTimeStamp()); }"], "code_level": "project_runnable", "_id": "636767841a6d9265ec0183f2", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public int decide(LoggingEvent event) {\n  if (event.getMessage().toLowerCase().contains(\"bye\")\n      || event.getMessage().toLowerCase().contains(\"bye\")) {\n    return -1;\n  } else {\n    return 0;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  if (event.getMessage() == null || event.getMessage().isEmpty()) {\n    return 0;\n  }\n  String msg = event.getMessage();\n  if (msg.indexOf(\"success\") >= 0) {\n    return 1;\n  }\n  if (msg.indexOf(\"failure\") >= 0) {\n    return 2;\n  }\n  if (msg.indexOf(\"cancel\") >= 0) {\n    return 3;\n  }\n  if (msg.indexOf(\"decision\") >= 0) {\n    return 4;\n  }\n  return 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  if (this.m_matcher.matches(event)) {\n    return this.m_decide;\n  }\n  return this.m_undecide;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  if (event.getMessage().contains(\"Say Hello\")) {\n    return LoggingEvent.WARN;\n  } else if (event.getMessage().contains(\"Say Goodbye\")) {\n    return LoggingEvent.ERROR;\n  } else {\n    return LoggingEvent.INFO;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event){ if (event.getMessage() == null || event.getMessage().toString().equals(\"\")) { return 0; } String msg = event.getMessage().toString(); if (msg.indexOf(\"${\") != -1) { String[] msgParts = msg.split(\"\\\\$\\\\{\"); if (msgParts.length == 2) { String varName = msgParts[0]; String varValue = msgParts[1]; if (varValue.indexOf(\"${\") != -1) { varValue = varValue.replace(\"${\", \"\"); varValue = varValue.replace(\"}\", \"\"); varValue = varValue.replace(\"\\\"\", \"\"); varValue = varValue.replace(\"\\\\\", \"\"); if (varName.equals(\"time\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"ip\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"port\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"sid\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"username\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"password\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"hostname\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"timestamp\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"request\")) { return Integer.parseInt(varValue); } } else { return Integer.parseInt(varValue); } } else { return Integer.parseInt(varValue); } } else { return 0; } } else { return 0; } }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  if (!matches(event.getMessage())) return DECISION_CONTINUE;\n  else return DECISION_SKIP;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  if (StringUtils.isEmpty(event.getMessage())) {\n    return ERROR;\n  }\n  String msg = event.getMessage();\n  if (matches(msg)) {\n    return INFO;\n  }\n  return WARN;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  if (event.getMessage().toString().equals(\"Hello World\")) {\n    return OUTPUT;\n  } else {\n    return INPUT;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  if (event.getMessage().startsWith(\"RESTART\")) {\n    return 0;\n  } else if (event.getMessage().startsWith(\"SUCCESS\")) {\n    return 1;\n  } else if (event.getMessage().startsWith(\"FAILURE\")) {\n    return 2;\n  } else {\n    return 3;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event) {\n  String message = event.getMessage();\n  int decision = 0;\n  String[] tokens = message.split(\" \");\n  if (tokens.length >= 2 && tokens[0].equals(\"decision\")) {\n    decision = Integer.parseInt(tokens[1]);\n  }\n  return decision;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns  {@link Filter#NEUTRAL} is there is no string match.\n */\n", "method_name": "decide", "codes": ["public int decide(LoggingEvent event){ if (event.getMessage().toLowerCase().contains(\"bye\") || event.getMessage().toLowerCase().contains(\"bye\")) { return -1; } else { return 0; } }", "public int decide(LoggingEvent event){ if (event.getMessage() == null || event.getMessage().isEmpty()) { return 0; } String msg = event.getMessage(); if (msg.indexOf(\"success\") >= 0) { return 1; } if (msg.indexOf(\"failure\") >= 0) { return 2; } if (msg.indexOf(\"cancel\") >= 0) { return 3; } if (msg.indexOf(\"decision\") >= 0) { return 4; } return 0; }", "public int decide(LoggingEvent event){ if (this.m_matcher.matches(event)) { return this.m_decide; } return this.m_undecide; }", "public int decide(LoggingEvent event){ if (event.getMessage().contains(\"Say Hello\")) { return LoggingEvent.WARN; } else if (event.getMessage().contains(\"Say Goodbye\")) { return LoggingEvent.ERROR; } else { return LoggingEvent.INFO; } }", "public int decide(LoggingEvent event){ if (event.getMessage() == null || event.getMessage().toString().equals(\"\")) { return 0; } String msg = event.getMessage().toString(); if (msg.indexOf(\"${\") != -1) { String[] msgParts = msg.split(\"\\\\$\\\\{\"); if (msgParts.length == 2) { String varName = msgParts[0]; String varValue = msgParts[1]; if (varValue.indexOf(\"${\") != -1) { varValue = varValue.replace(\"${\", \"\"); varValue = varValue.replace(\"}\", \"\"); varValue = varValue.replace(\"\\\"\", \"\"); varValue = varValue.replace(\"\\\\\", \"\"); if (varName.equals(\"time\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"ip\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"port\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"sid\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"username\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"password\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"hostname\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"timestamp\")) { return Integer.parseInt(varValue); } else if (varName.equals(\"request\")) { return Integer.parseInt(varValue); } } else { return Integer.parseInt(varValue); } } else { return Integer.parseInt(varValue); } } else { return 0; } } else { return 0; } }", "public int decide(LoggingEvent event){ if (!matches(event.getMessage())) return DECISION_CONTINUE; else return DECISION_SKIP; }", "public int decide(LoggingEvent event){ if (StringUtils.isEmpty(event.getMessage())) { return ERROR; } String msg = event.getMessage(); if (matches(msg)) { return INFO; } return WARN; }", "public int decide(LoggingEvent event){ if (event.getMessage().toString().equals(\"Hello World\")) { return OUTPUT; } else { return INPUT; } }", "public int decide(LoggingEvent event){ if (event.getMessage().startsWith(\"RESTART\")) { return 0; } else if (event.getMessage().startsWith(\"SUCCESS\")) { return 1; } else if (event.getMessage().startsWith(\"FAILURE\")) { return 2; } else { return 3; } }", "public int decide(LoggingEvent event){ String message = event.getMessage(); int decision = 0; String[] tokens = message.split(\" \"); if (tokens.length >= 2 && tokens[0].equals(\"decision\")) { decision = Integer.parseInt(tokens[1]); } return decision; }"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018250", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  if (nameStart <= 0) return;\n  final String name = buf.toString();\n  final int lastIndex = name.length() - 1;\n  for (int i = nameStart; i < lastIndex; ++i) {\n    final char c = name.charAt(i);\n    if (c == '.' || c == '/' || c == ':' || c == '*') {\n      buf.delete(i, lastIndex);\n      break;\n    }\n  }\n  final int index = name.lastIndexOf('.');\n  if (index >= 0) {\n    buf.append(name.substring(0, index + 1));\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  if (nameStart < 0) {\n    throw new IllegalArgumentException(\"Name cannot be negative.\");\n  }\n  if (nameStart >= buf.length()) {\n    return;\n  }\n  final int l = buf.length();\n  for (int i = nameStart; i < l; i++) {\n    if (buf.charAt(i) == '.') {\n      if (i >= nameStart + 3) {\n        buf.delete(i - 2, i + 2);\n      }\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  final int nameEnd = nameStart + name.length();\n  if (nameEnd < buf.length()) {\n    final int count = buf.length() - nameEnd;\n    for (int i = 0; i < count; i++) {\n      buf.append(\".\");\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  int i = nameStart;\n  while (i < buf.length()) {\n    final char c = buf.charAt(i);\n    if (c == '.') {\n      i++;\n      continue;\n    }\n    if (c == '-') {\n      i++;\n      continue;\n    }\n    if (c == '_') {\n      i++;\n      continue;\n    }\n    if (c == '_') {\n      i++;\n      continue;\n    }\n    buf.insert(i, '_');\n    i++;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  final int n = nameStart;\n  if (n > 0) {\n    if (nameStart < buf.length()) {\n      buf.append(name.substring(nameStart));\n    }\n    if (name.length() >= n) {\n      abbreviate(n - 1, buf);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  if (nameStart < 0) return;\n  final int len = buf.length();\n  if (nameStart > len) return;\n  if (nameStart < len - 1) {\n    if (buf.charAt(nameStart) == '.') {\n      for (int i = nameStart + 1; i < len; i++) {\n        if (buf.charAt(i) == '.') {\n          buf.setCharAt(i, '.');\n        }\n      }\n    }\n  }\n  final String name = buf.toString();\n  buf.setLength(0);\n  for (int i = 0; i < len; i++) {\n    if (name.charAt(i) == '.') {\n      if (i < len - 1) {\n        if (buf.charAt(i + 1) == '.') {\n          buf.setCharAt(i + 1, '.');\n        }\n      }\n    } else {\n      buf.append(name.charAt(i));\n    }\n  }\n  if (name.length() > 0) {\n    abbreviate(nameStart + 1, buf);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  int nameEnd = nameStart;\n  int count = 1;\n  while (nameEnd < buf.length() && nameEnd < nameStart) {\n    final int charIndex = buf.charAt(nameEnd);\n    if (charIndex == '.') {\n      count++;\n    } else {\n      break;\n    }\n    nameEnd++;\n  }\n  if (nameEnd < nameStart) {\n    return;\n  }\n  final String name = buf.substring(nameStart, nameEnd);\n  final String nameAbbrev = abbreviate(name, count);\n  buf.replace(nameEnd - count, nameEnd, nameAbbrev);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  final int len = name.length();\n  if (nameStart < 0) {\n    return;\n  }\n  for (int i = nameStart; i < len; i++) {\n    final char c = name.charAt(i);\n    if (c == '.') {\n      if (++i < len) {\n        if (name.charAt(i) == '.') {\n          buf.append(\".\");\n        } else {\n          buf.append(Character.toUpperCase(c));\n        }\n      }\n    } else {\n      buf.append(c);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  if (buf.length() > 0) {\n    final int count = nameStart - buf.length();\n    for (int i = 0; i < count; i++) {\n      buf.append(\".\");\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart, final StringBuffer buf) {\n  int nameEnd = 0;\n  for (nameEnd = nameStart; nameEnd < buf.length(); nameEnd++) {\n    if (!Character.isLetter(buf.charAt(nameEnd))) {\n      break;\n    }\n  }\n  if (nameEnd == buf.length()) {\n    return;\n  }\n  if (nameEnd < buf.length() - 1) {\n    buf.append(\".\");\n  }\n  while (nameEnd < buf.length()) {\n    if (!Character.isLetter(buf.charAt(nameEnd))) {\n      break;\n    }\n    nameEnd++;\n  }\n  final int nameLength = nameEnd - nameStart;\n  final String name = buf.substring(nameStart, nameEnd);\n  final String newName = name.replace('_', ' ').toLowerCase();\n  final int newNameLength = newName.length();\n  for (int i = 0; i < nameLength; i++) {\n    final char c = newName.charAt(i);\n    if (!Character.isLetterOrDigit(c) && c != ' ') {\n      continue;\n    }\n    final String newNameSubstring = newName.substring(0, i) + newName.substring(i + 1);\n    if (buf.indexOf(newNameSubstring) == -1) {\n      buf.insert(nameEnd, newNameSubstring);\n      nameEnd += newNameLength;\n    }\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Abbreviate name.\n * @param buf buffer to append abbreviation.\n * @param nameStart start of name to abbreviate.\n */\n", "method_name": "abbreviate", "codes": ["public void abbreviate(final int nameStart,final StringBuffer buf){ if (nameStart <= 0) return; final String name = buf.toString(); final int lastIndex = name.length() - 1; for (int i = nameStart; i < lastIndex; ++i) { final char c = name.charAt(i); if (c == '.' || c == '/' || c == ':' || c == '*') { buf.delete(i, lastIndex); break; } } final int index = name.lastIndexOf('.'); if (index >= 0) { buf.append(name.substring(0, index + 1)); } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ if (nameStart < 0) { throw new IllegalArgumentException(\"Name cannot be negative.\"); } if (nameStart >= buf.length()) { return; } final int l = buf.length(); for (int i = nameStart; i < l; i++) { if (buf.charAt(i) == '.') { if (i >= nameStart + 3) { buf.delete(i - 2, i + 2); } } } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ final int nameEnd = nameStart + name.length(); if (nameEnd < buf.length()) { final int count = buf.length() - nameEnd; for (int i = 0; i < count; i++) { buf.append(\".\"); } } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ int i = nameStart; while (i < buf.length()) { final char c = buf.charAt(i); if (c == '.') { i++; continue; } if (c == '-') { i++; continue; } if (c == '_') { i++; continue; } if (c == '_') { i++; continue; } buf.insert(i, '_'); i++; } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ final int n = nameStart; if (n > 0) { if (nameStart < buf.length()) { buf.append(name.substring(nameStart)); } if (name.length() >= n) { abbreviate(n - 1, buf); } } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ if (nameStart < 0) return; final int len = buf.length(); if (nameStart > len) return; if (nameStart < len - 1) { if (buf.charAt(nameStart) == '.') { for (int i = nameStart + 1; i < len; i++) { if (buf.charAt(i) == '.') { buf.setCharAt(i, '.'); } } } } final String name = buf.toString(); buf.setLength(0); for (int i = 0; i < len; i++) { if (name.charAt(i) == '.') { if (i < len - 1) { if (buf.charAt(i + 1) == '.') { buf.setCharAt(i + 1, '.'); } } } else { buf.append(name.charAt(i)); } } if (name.length() > 0) { abbreviate(nameStart + 1, buf); } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ int nameEnd = nameStart; int count = 1; while (nameEnd < buf.length() && nameEnd < nameStart) { final int charIndex = buf.charAt(nameEnd); if (charIndex == '.') { count++; } else { break; } nameEnd++; } if (nameEnd < nameStart) { return; } final String name = buf.substring(nameStart, nameEnd); final String nameAbbrev = abbreviate(name, count); buf.replace(nameEnd - count, nameEnd, nameAbbrev); }", "public void abbreviate(final int nameStart,final StringBuffer buf){ final int len = name.length(); if (nameStart < 0) { return; } for (int i = nameStart; i < len; i++) { final char c = name.charAt(i); if (c == '.') { if (++i < len) { if (name.charAt(i) == '.') { buf.append(\".\"); } else { buf.append(Character.toUpperCase(c)); } } } else { buf.append(c); } } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ if (buf.length() > 0) { final int count = nameStart - buf.length(); for (int i = 0; i < count; i++) { buf.append(\".\"); } } }", "public void abbreviate(final int nameStart,final StringBuffer buf){ int nameEnd = 0; for (nameEnd = nameStart; nameEnd < buf.length(); nameEnd++) { if (!Character.isLetter(buf.charAt(nameEnd))) { break; } } if (nameEnd == buf.length()) { return; } if (nameEnd < buf.length() - 1) { buf.append(\".\"); } while (nameEnd < buf.length()) { if (!Character.isLetter(buf.charAt(nameEnd))) { break; } nameEnd++; } final int nameLength = nameEnd - nameStart; final String name = buf.substring(nameStart, nameEnd); final String newName = name.replace('_', ' ').toLowerCase(); final int newNameLength = newName.length(); for (int i = 0; i < nameLength; i++) { final char c = newName.charAt(i); if (!Character.isLetterOrDigit(c) && c != ' ') { continue; } final String newNameSubstring = newName.substring(0, i) + newName.substring(i + 1); if (buf.indexOf(newNameSubstring) == -1) { buf.insert(nameEnd, newNameSubstring); nameEnd += newNameLength; } } }"], "code_level": "class_runnable", "_id": "636767861a6d9265ec018440", "project_name": "logging-log4j1-main"}, {"generate_results": [{"generate_code": "public String id(String entityId) {\n  return id(entityId, connector);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return id(entityId, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  if (entityId.endsWith(\"-connector\")) {\n    return entityId.replace(\"-connector\", \"\");\n  }\n  return entityId + \"-connector\";\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  if (entityId == null) {\n    return \"\";\n  }\n  return entityId.concat(idConnector);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return entityId + \"-\" + connectorId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return entityId + connector;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  String id = \"\";\n  id = id + entityId + \"_\";\n  return id;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return id(entityId, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return id(entityId, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId) {\n  return entityId + connector + id;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return the row id\n */\n", "method_name": "id", "codes": ["public String id(String entityId){ return id(entityId, connector); }", "public String id(String entityId){ return id(entityId, null); }", "public String id(String entityId){ if (entityId.endsWith(\"-connector\")) { return entityId.replace(\"-connector\", \"\"); } return entityId + \"-connector\"; }", "public String id(String entityId){ if (entityId == null) { return \"\"; } return entityId.concat(idConnector); }", "public String id(String entityId){ return entityId + \"-\" + connectorId; }", "public String id(String entityId){ return entityId + connector; }", "public String id(String entityId){ String id = \"\"; id = id + entityId + \"_\"; return id; }", "public String id(String entityId){ return id(entityId, null); }", "public String id(String entityId){ return id(entityId, null); }", "public String id(String entityId){ return entityId + connector + id; }"], "code_level": "project_runnable", "_id": "636767df1a6d9265ec01873c", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (!this.ids.contains(data.getId())) {\n    this.ids.add(data.getId());\n    this.values.add(data);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (!_buffer.containsKey(data.getId())) {\n    _buffer.put(data.getId(), data);\n  } else {\n    _buffer.get(data.getId()).merge(data);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  final int id = data.getId();\n  if (id < 0) {\n    final int tmp = id;\n    id = buffer.add(data);\n    if (id != tmp) {\n      throw new IllegalArgumentException(\"Data with id \" + id + \" already exists in the buffer\");\n    }\n  } else {\n    buffer.set(id, data);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (data.getMetricID() == null) {\n    LOGGER.error(\"MetricID cannot be null\");\n    return;\n  }\n  final MetricID metricID = new MetricID(data.getMetricID());\n  if (metricID.getVersion() >= 0) {\n    final String metricName = metricID.getMetricName();\n    final String metricValue = data.getMetricValue();\n    final MetricValue metricValueObject = new MetricValue(metricValue);\n    if (metricValueObject.getVersion() >= 0) {\n      final MetricValue existingValue = metricValues.get(metricName);\n      if (existingValue != null) {\n        if (existingValue.getVersion() > metricValueObject.getVersion()) {\n          metricValues.put(metricName, metricValueObject);\n        }\n      } else {\n        metricValues.put(metricName, metricValueObject);\n      }\n    } else {\n      metricValues.put(metricName, metricValueObject);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void accept(final METRICS data){ if (data.getId() == null) { if (getId() == null) { setId(data.getId()); } } else { if (getId() == null) { setId(data.getId()); } else if (getId() != data.getId()) { setId(null); } } if (data.getType() == null) { if (getType() == null) { setType(data.getType()); } } else { if (getType() == null) { setType(data.getType()); } else if (getType() != data.getType()) { setType(null); } } if (data.getSubType() == null) { if (getSubType() == null) { setSubType(data.getSubType()); } } else { if (getSubType() == null) { setSubType(data.getSubType()); } else if (getSubType() != data.getSubType()) { setSubType(null); } } if (data.getDescription() == null) { if (getDescription() == null) { setDescription(data.getDescription()); } } else { if (getDescription() == null) { setDescription(data.getDescription()); } else if (getDescription() != data.getDescription()) { setDescription(null); } } if (data.getMetrics() == null) { if (getMetrics() == null) { setMetrics(data.getMetrics()); } } else { if (getMetrics() == null) { setMetrics(data.getMetrics()); } else if (getMetrics() != data.getMetrics()) { setMetrics(null); } } if (data.getTitle() == null) { if (getTitle() == null) { setTitle(data.getTitle()); } } else { if (getTitle() == null) { setTitle(data.getTitle()); } else if (getTitle() != data.getTitle()) { setTitle(null); } } if (data.getStatus() == null) { if (getStatus() == null) { setStatus(data.getStatus()); } } else { if (getStatus() == null) { setStatus(data.getStatus()); } else if (getStatus() != data.getStatus()) { setStatus(null); } } if (data.getPriority() == null) { if (getPriority() == null) { setPriority(data.getPriority()); } } else { if (getPriority() == null) { setPriority(data.getPriority()); } else if (getPriority() != data.getPriority()) { setPriority(null); } } if (data.getSource() == null) { if (getSource() == null) { setSource(data.getSource()); } } else { if (getSource() == null) { setSource(data.getSource()); } else if (getSource() != data.getSource()) { setSource(null); } } if (", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (!buffer.containsKey(data.getId())) {\n    buffer.put(data.getId(), data);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (!buffer.containsKey(data.getId())) {\n    buffer.put(data.getId(), data);\n  } else {\n    buffer.get(data.getId()).merge(data);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (data.getId() == null) {\n    data.setId(++counter);\n  }\n  buffer.put(data);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (data.getId() == null) {\n    data.setId(nextId);\n    nextId++;\n  }\n  buffer.add(data);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic void accept(final METRICS data) {\n  if (this.ids.containsKey(data.getId())) {\n    this.ids.remove(data.getId());\n  }\n  this.ids.put(data.getId(), data);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.\n * @param data to be added potentially.\n */\n", "method_name": "accept", "codes": ["@Override public void accept(final METRICS data){ if (!this.ids.contains(data.getId())) { this.ids.add(data.getId()); this.values.add(data); } }", "@Override public void accept(final METRICS data){ if (!_buffer.containsKey(data.getId())) { _buffer.put(data.getId(), data); } else { _buffer.get(data.getId()).merge(data); } }", "@Override public void accept(final METRICS data){ final int id = data.getId(); if (id < 0) { final int tmp = id; id = buffer.add(data); if (id != tmp) { throw new IllegalArgumentException(\"Data with id \" + id + \" already exists in the buffer\"); } } else { buffer.set(id, data); } }", "@Override public void accept(final METRICS data){ if (data.getMetricID() == null) { LOGGER.error(\"MetricID cannot be null\"); return; } final MetricID metricID = new MetricID(data.getMetricID()); if (metricID.getVersion() >= 0) { final String metricName = metricID.getMetricName(); final String metricValue = data.getMetricValue(); final MetricValue metricValueObject = new MetricValue(metricValue); if (metricValueObject.getVersion() >= 0) { final MetricValue existingValue = metricValues.get(metricName); if (existingValue != null) { if (existingValue.getVersion() > metricValueObject.getVersion()) { metricValues.put(metricName, metricValueObject); } } else { metricValues.put(metricName, metricValueObject); } } else { metricValues.put(metricName, metricValueObject); } } }", "@Override public void accept(final METRICS data){ if (data.getId() == null) { if (getId() == null) { setId(data.getId()); } } else { if (getId() == null) { setId(data.getId()); } else if (getId() != data.getId()) { setId(null); } } if (data.getType() == null) { if (getType() == null) { setType(data.getType()); } } else { if (getType() == null) { setType(data.getType()); } else if (getType() != data.getType()) { setType(null); } } if (data.getSubType() == null) { if (getSubType() == null) { setSubType(data.getSubType()); } } else { if (getSubType() == null) { setSubType(data.getSubType()); } else if (getSubType() != data.getSubType()) { setSubType(null); } } if (data.getDescription() == null) { if (getDescription() == null) { setDescription(data.getDescription()); } } else { if (getDescription() == null) { setDescription(data.getDescription()); } else if (getDescription() != data.getDescription()) { setDescription(null); } } if (data.getMetrics() == null) { if (getMetrics() == null) { setMetrics(data.getMetrics()); } } else { if (getMetrics() == null) { setMetrics(data.getMetrics()); } else if (getMetrics() != data.getMetrics()) { setMetrics(null); } } if (data.getTitle() == null) { if (getTitle() == null) { setTitle(data.getTitle()); } } else { if (getTitle() == null) { setTitle(data.getTitle()); } else if (getTitle() != data.getTitle()) { setTitle(null); } } if (data.getStatus() == null) { if (getStatus() == null) { setStatus(data.getStatus()); } } else { if (getStatus() == null) { setStatus(data.getStatus()); } else if (getStatus() != data.getStatus()) { setStatus(null); } } if (data.getPriority() == null) { if (getPriority() == null) { setPriority(data.getPriority()); } } else { if (getPriority() == null) { setPriority(data.getPriority()); } else if (getPriority() != data.getPriority()) { setPriority(null); } } if (data.getSource() == null) { if (getSource() == null) { setSource(data.getSource()); } } else { if (getSource() == null) { setSource(data.getSource()); } else if (getSource() != data.getSource()) { setSource(null); } } if (", "@Override public void accept(final METRICS data){ if (!buffer.containsKey(data.getId())) { buffer.put(data.getId(), data); } }", "@Override public void accept(final METRICS data){ if (!buffer.containsKey(data.getId())) { buffer.put(data.getId(), data); } else { buffer.get(data.getId()).merge(data); } }", "@Override public void accept(final METRICS data){ if (data.getId() == null) { data.setId(++counter); } buffer.put(data); }", "@Override public void accept(final METRICS data){ if (data.getId() == null) { data.setId(nextId); nextId++; } buffer.add(data); }", "@Override public void accept(final METRICS data){ if (this.ids.containsKey(data.getId())) { this.ids.remove(data.getId()); } this.ids.put(data.getId(), data); }"], "code_level": "self_contained", "_id": "636767e11a6d9265ec018781", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<>();\n  timeRanges.add(new TimeRange(start, end));\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<TimeRange>();\n  long i = start;\n  long j = end;\n  while (i <= j) {\n    i = timeRanges.size();\n    timeRanges.add(new TimeRange(i, j));\n    j = i;\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<TimeRange>();\n  timeRanges.add(new TimeRange(start, end));\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<>();\n  timeRanges.add(new TimeRange(start, end));\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<TimeRange>();\n  for (int i = 0; i < numReplicas; i++) {\n    timeRanges.add(new TimeRange(start, end));\n    start += FETCH_DATA_DURATION;\n    end -= FETCH_DATA_DURATION;\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = Lists.newArrayList();\n  timeRanges.add(new TimeRange(start, end));\n  if (start > end) {\n    timeRanges.add(new TimeRange(start, end));\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  if (start > end) {\n    return ImmutableList.of();\n  } else {\n    List<TimeRange> timeRanges = Lists.newArrayList();\n    timeRanges.add(new TimeRange(start, end));\n    return timeRanges;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<>();\n  timeRanges.add(new TimeRange(start, end));\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = Lists.newArrayList();\n  if (start > end) {\n    timeRanges.add(new TimeRange(start, end));\n    return timeRanges;\n  } else if (start < FETCH_DATA_DURATION) {\n    timeRanges.add(new TimeRange(start, FETCH_DATA_DURATION));\n  } else if (end > FETCH_DATA_DURATION) {\n    timeRanges.add(new TimeRange(FETCH_DATA_DURATION, end));\n  } else if (start == FETCH_DATA_DURATION) {\n    timeRanges.add(new TimeRange(start, FETCH_DATA_DURATION));\n  } else if (end == FETCH_DATA_DURATION) {\n    timeRanges.add(new TimeRange(start, FETCH_DATA_DURATION));\n  } else {\n    timeRanges.add(new TimeRange(start, end));\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start, long end) {\n  List<TimeRange> timeRanges = new ArrayList<TimeRange>();\n  if (start > end) {\n    long tmp = start;\n    start = end;\n    end = tmp;\n  }\n  for (long i = start; i <= end; i += FETCH_DATA_DURATION) {\n    timeRanges.add(new TimeRange(i, i + FETCH_DATA_DURATION));\n  }\n  return timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}\n */\n", "method_name": "buildTimeRanges", "codes": ["protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<>(); timeRanges.add(new TimeRange(start, end)); return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<TimeRange>(); long i = start; long j = end; while (i <= j) { i = timeRanges.size(); timeRanges.add(new TimeRange(i, j)); j = i; } return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<TimeRange>(); timeRanges.add(new TimeRange(start, end)); return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<>(); timeRanges.add(new TimeRange(start, end)); return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<TimeRange>(); for (int i = 0; i < numReplicas; i++) { timeRanges.add(new TimeRange(start, end)); start += FETCH_DATA_DURATION; end -= FETCH_DATA_DURATION; } return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = Lists.newArrayList(); timeRanges.add(new TimeRange(start, end)); if (start > end) { timeRanges.add(new TimeRange(start, end)); } return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ if (start > end) { return ImmutableList.of(); } else { List<TimeRange> timeRanges = Lists.newArrayList(); timeRanges.add(new TimeRange(start, end)); return timeRanges; } }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<>(); timeRanges.add(new TimeRange(start, end)); return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = Lists.newArrayList(); if (start > end) { timeRanges.add(new TimeRange(start, end)); return timeRanges; } else if (start < FETCH_DATA_DURATION) { timeRanges.add(new TimeRange(start, FETCH_DATA_DURATION)); } else if (end > FETCH_DATA_DURATION) { timeRanges.add(new TimeRange(FETCH_DATA_DURATION, end)); } else if (start == FETCH_DATA_DURATION) { timeRanges.add(new TimeRange(start, FETCH_DATA_DURATION)); } else if (end == FETCH_DATA_DURATION) { timeRanges.add(new TimeRange(start, FETCH_DATA_DURATION)); } else { timeRanges.add(new TimeRange(start, end)); } return timeRanges; }", "protected List<TimeRange> buildTimeRanges(long start,long end){ List<TimeRange> timeRanges = new ArrayList<TimeRange>(); if (start > end) { long tmp = start; start = end; end = tmp; } for (long i = start; i <= end; i += FETCH_DATA_DURATION) { timeRanges.add(new TimeRange(i, i + FETCH_DATA_DURATION)); } return timeRanges; }"], "code_level": "self_contained", "_id": "636767df1a6d9265ec018744", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void valueAccumulation(String key, Long value) {\n  valueAccumulation.put(key, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value == null) {\n    return;\n  }\n  if (values.containsKey(key)) {\n    values.put(key, values.get(key) + value);\n  } else {\n    values.put(key, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value == null) {\n    return;\n  }\n  long newValue = value + value;\n  if (newValue > maxValue) {\n    maxValue = newValue;\n  }\n  long newCount = counts.getOrDefault(key, 0L) + 1;\n  counts.put(key, newCount);\n  if (newValue > maxValue) {\n    maxValue = newValue;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  valueAccumulation.put(key, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  Long oldValue = this.get(key);\n  if (oldValue == null) {\n    oldValue = 0L;\n  }\n  this.put(key, oldValue + value);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (!values.containsKey(key)) {\n    values.put(key, value);\n  } else {\n    values.put(key, values.get(key) + value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value == null) {\n    return;\n  }\n  if (valueMap.containsKey(key)) {\n    valueMap.put(key, valueMap.get(key) + value);\n  } else {\n    valueMap.put(key, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value == null) {\n    valueAccumulation(key, 0L);\n  } else {\n    valueAccumulation(key, value + 1L);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value == null) return;\n  if (valueMap.containsKey(key)) {\n    Long oldValue = valueMap.get(key);\n    valueMap.put(key, oldValue + value);\n  } else {\n    valueMap.put(key, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key, Long value) {\n  if (value != null) {\n    if (value < min) min = value;\n    if (value > max) max = value;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Accumulate the value with existing value in the same given key.\n */\n", "method_name": "valueAccumulation", "codes": ["public void valueAccumulation(String key,Long value){ valueAccumulation.put(key, value); }", "public void valueAccumulation(String key,Long value){ if (value == null) { return; } if (values.containsKey(key)) { values.put(key, values.get(key) + value); } else { values.put(key, value); } }", "public void valueAccumulation(String key,Long value){ if (value == null) { return; } long newValue = value + value; if (newValue > maxValue) { maxValue = newValue; } long newCount = counts.getOrDefault(key, 0L) + 1; counts.put(key, newCount); if (newValue > maxValue) { maxValue = newValue; } }", "public void valueAccumulation(String key,Long value){ valueAccumulation.put(key, value); }", "public void valueAccumulation(String key,Long value){ Long oldValue = this.get(key); if (oldValue == null) { oldValue = 0L; } this.put(key, oldValue + value); }", "public void valueAccumulation(String key,Long value){ if (!values.containsKey(key)) { values.put(key, value); } else { values.put(key, values.get(key) + value); } }", "public void valueAccumulation(String key,Long value){ if (value == null) { return; } if (valueMap.containsKey(key)) { valueMap.put(key, valueMap.get(key) + value); } else { valueMap.put(key, value); } }", "public void valueAccumulation(String key,Long value){ if (value == null) { valueAccumulation(key, 0L); } else { valueAccumulation(key, value + 1L); } }", "public void valueAccumulation(String key,Long value){ if (value == null) return; if (valueMap.containsKey(key)) { Long oldValue = valueMap.get(key); valueMap.put(key, oldValue + value); } else { valueMap.put(key, value); } }", "public void valueAccumulation(String key,Long value){ if (value != null) { if (value < min) min = value; if (value > max) max = value; } }"], "code_level": "class_runnable", "_id": "636767de1a6d9265ec01871c", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  if (timestamp < lastUpdateTimestamp) return true;\n  return timestamp >= lastUpdateTimestamp + expiredThreshold;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  if (timestamp <= expiredThreshold) return true;\n  return false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  if (timestamp - lastUpdateTimestamp > expiredThreshold) {\n    return true;\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  if (timestamp <= 0) return true;\n  long lastUpdateTimestamp = getLastUpdateTimestamp();\n  if (lastUpdateTimestamp == 0 || timestamp > lastUpdateTimestamp) return true;\n  return (timestamp - lastUpdateTimestamp) > expiredThreshold;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  if (timestamp <= getExpiredTimestamp()) {\n    return true;\n  }\n  return (timestamp - getExpiredTimestamp()) > expiredThreshold;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  long lastUpdateTimestamp = getLastUpdateTimestamp();\n  return timestamp - lastUpdateTimestamp > expiredThreshold;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  return timestamp <= expiredThreshold;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  return timestamp - lastUpdateTimestamp < expiredThreshold;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  return timestamp <= getLastUpdateTimestamp() + expiredThreshold;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp, long expiredThreshold) {\n  return timestamp <= expiredThreshold;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * @param timestamp        of current time\n * @param expiredThreshold represents the duration between last update time and the time point removing from cache.\n * @return true means this metrics should be removed from cache.\n */\n", "method_name": "isExpired", "codes": ["public boolean isExpired(long timestamp,long expiredThreshold){ if (timestamp < lastUpdateTimestamp) return true; return timestamp >= lastUpdateTimestamp + expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ if (timestamp <= expiredThreshold) return true; return false; }", "public boolean isExpired(long timestamp,long expiredThreshold){ if (timestamp - lastUpdateTimestamp > expiredThreshold) { return true; } return false; }", "public boolean isExpired(long timestamp,long expiredThreshold){ if (timestamp <= 0) return true; long lastUpdateTimestamp = getLastUpdateTimestamp(); if (lastUpdateTimestamp == 0 || timestamp > lastUpdateTimestamp) return true; return (timestamp - lastUpdateTimestamp) > expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ if (timestamp <= getExpiredTimestamp()) { return true; } return (timestamp - getExpiredTimestamp()) > expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ long lastUpdateTimestamp = getLastUpdateTimestamp(); return timestamp - lastUpdateTimestamp > expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ return timestamp <= expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ return timestamp - lastUpdateTimestamp < expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ return timestamp <= getLastUpdateTimestamp() + expiredThreshold; }", "public boolean isExpired(long timestamp,long expiredThreshold){ return timestamp <= expiredThreshold; }"], "code_level": "class_runnable", "_id": "636767dd1a6d9265ec0186de", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  for (String key : jsonObject.keySet()) {\n    content.put(key, jsonObject.get(key).getAsString());\n  }\n  return content;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  for (String key : jsonObject.keySet()) {\n    content.put(key, jsonObject.get(key));\n  }\n  return content;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  content.put(\"title\", jsonObject.getString(\"title\"));\n  content.put(\"body\", jsonObject.getString(\"body\"));\n  content.put(\"date\", jsonObject.getString(\"date\"));\n  return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  for (String key : jsonObject.keySet()) {\n    Object value = jsonObject.get(key);\n    if (value instanceof JsonObject) {\n      content.put(key, buildContent((JsonObject) value));\n    } else if (value instanceof JsonArray) {\n      content.put(key, buildContent((JsonArray) value));\n    } else {\n      content.put(key, value);\n    }\n  }\n  return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<String, Object>();\n  if (jsonObject.containsKey(\"content\")) {\n    content.put(\"content\", jsonObject.get(\"content\").getAsString());\n  }\n  return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  if (jsonObject.has(\"title\")) {\n    String title = jsonObject.get(\"title\").getAsString();\n    content.put(\"title\", title);\n  }\n  if (jsonObject.has(\"author\")) {\n    JsonArray authors = jsonObject.get(\"author\").getAsJsonArray();\n    StringBuilder authorsBuilder = new StringBuilder();\n    for (int i = 0; i < authors.size(); i++) {\n      String author = authors.get(i).getAsString();\n      authorsBuilder.append(author).append(\", \");\n    }\n    if (authorsBuilder.length() > 0) {\n      authorsBuilder.delete(authorsBuilder.length() - 2, authorsBuilder.length());\n    }\n    content.put(\"author\", authorsBuilder.toString());\n  }\n  if (jsonObject.has(\"description\")) {\n    String description = jsonObject.get(\"description\").getAsString();\n    content.put(\"description\", description);\n  }\n  if (jsonObject.has(\"url\")) {\n    String url = jsonObject.get(\"url\").getAsString();\n    content.put(\"url\", url);\n  }\n  if (jsonObject.has(\"publishedAt\")) {\n    JsonObject publishedAt = jsonObject.get(\"publishedAt\").getAsJsonObject();\n    content.put(\"publishedAt\", publishedAt.get(\"time\").getAsString());\n  }\n  if (jsonObject.has(\"source\")) {\n    JsonObject source = jsonObject.get(\"source\").getAsJsonObject();\n    content.put(\"source\", source.get(\"name\").getAsString());\n  }\n  if (jsonObject.has(\"thumbnail\")) {\n    JsonObject thumbnail = jsonObject.get(\"thumbnail\").getAsJsonObject();\n    content.put(\"thumbnail\", thumbnail.get(\"url\").getAsString());\n  }\n  if (jsonObject.has(\"categories\")) {\n    JsonArray categories = jsonObject.get(\"categories\").getAsJsonArray();\n    List<String> categoriesList = new ArrayList<>();\n    for (int i = 0; i < categories.size(); i++) {\n      categoriesList.add(categories.get(i).getAsString());\n    }\n    content.put(\"categories\", categoriesList);\n  }\n  if (jsonObject.has(\"tags\")) {\n    JsonArray tags = jsonObject.get(\"tags\").getAsJsonArray();\n    List<String> tagsList = new ArrayList<>();\n    for (int i = 0; i < tags.size(); i++) {\n      tagsList.add(tags.get(i).getAsString());\n    }\n    content.put(\"tags\", tagsList);\n  }\n  return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  content.put(\"title\", jsonObject.get(\"title\").getAsString());\n  content.put(\"content\", jsonObject.get(\"content\").getAsString());\n  return content;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  content.put(\"name\", jsonObject.get(\"name\").getAsString());\n  content.put(\"description\", jsonObject.get(\"description\").getAsString());\n  content.put(\"version\", jsonObject.get(\"version\").getAsString());\n  content.put(\"content\", jsonObject.get(\"content\").getAsString());\n  return content;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<String, Object>();\n  for (String key : jsonObject.keySet()) {\n    Object obj = jsonObject.get(key);\n    if (obj instanceof JsonArray) {\n      content.put(key, buildContent((JsonArray) obj));\n    } else {\n      content.put(key, obj);\n    }\n  }\n  return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String, Object> buildContent(JsonObject jsonObject) {\n  Map<String, Object> content = new HashMap<>();\n  content.put(\"id\", jsonObject.get(\"id\").getAsLong());\n  content.put(\"name\", jsonObject.get(\"name\").getAsString());\n  content.put(\"description\", jsonObject.get(\"description\").getAsString());\n  content.put(\"creationDate\", jsonObject.get(\"creationDate\").getAsLong());\n  content.put(\"expirationDate\", jsonObject.get(\"expirationDate\").getAsLong());\n  return content;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * build content,if it has ats someone set the ats\n */\n", "method_name": "buildContent", "codes": ["private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); for (String key : jsonObject.keySet()) { content.put(key, jsonObject.get(key).getAsString()); } return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); for (String key : jsonObject.keySet()) { content.put(key, jsonObject.get(key)); } return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); content.put(\"title\", jsonObject.getString(\"title\")); content.put(\"body\", jsonObject.getString(\"body\")); content.put(\"date\", jsonObject.getString(\"date\")); return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); for (String key : jsonObject.keySet()) { Object value = jsonObject.get(key); if (value instanceof JsonObject) { content.put(key, buildContent((JsonObject) value)); } else if (value instanceof JsonArray) { content.put(key, buildContent((JsonArray) value)); } else { content.put(key, value); } } return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<String, Object>(); if (jsonObject.containsKey(\"content\")) { content.put(\"content\", jsonObject.get(\"content\").getAsString()); } return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); if (jsonObject.has(\"title\")) { String title = jsonObject.get(\"title\").getAsString(); content.put(\"title\", title); } if (jsonObject.has(\"author\")) { JsonArray authors = jsonObject.get(\"author\").getAsJsonArray(); StringBuilder authorsBuilder = new StringBuilder(); for (int i = 0; i < authors.size(); i++) { String author = authors.get(i).getAsString(); authorsBuilder.append(author).append(\", \"); } if (authorsBuilder.length() > 0) { authorsBuilder.delete(authorsBuilder.length() - 2, authorsBuilder.length()); } content.put(\"author\", authorsBuilder.toString()); } if (jsonObject.has(\"description\")) { String description = jsonObject.get(\"description\").getAsString(); content.put(\"description\", description); } if (jsonObject.has(\"url\")) { String url = jsonObject.get(\"url\").getAsString(); content.put(\"url\", url); } if (jsonObject.has(\"publishedAt\")) { JsonObject publishedAt = jsonObject.get(\"publishedAt\").getAsJsonObject(); content.put(\"publishedAt\", publishedAt.get(\"time\").getAsString()); } if (jsonObject.has(\"source\")) { JsonObject source = jsonObject.get(\"source\").getAsJsonObject(); content.put(\"source\", source.get(\"name\").getAsString()); } if (jsonObject.has(\"thumbnail\")) { JsonObject thumbnail = jsonObject.get(\"thumbnail\").getAsJsonObject(); content.put(\"thumbnail\", thumbnail.get(\"url\").getAsString()); } if (jsonObject.has(\"categories\")) { JsonArray categories = jsonObject.get(\"categories\").getAsJsonArray(); List<String> categoriesList = new ArrayList<>(); for (int i = 0; i < categories.size(); i++) { categoriesList.add(categories.get(i).getAsString()); } content.put(\"categories\", categoriesList); } if (jsonObject.has(\"tags\")) { JsonArray tags = jsonObject.get(\"tags\").getAsJsonArray(); List<String> tagsList = new ArrayList<>(); for (int i = 0; i < tags.size(); i++) { tagsList.add(tags.get(i).getAsString()); } content.put(\"tags\", tagsList); } return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); content.put(\"title\", jsonObject.get(\"title\").getAsString()); content.put(\"content\", jsonObject.get(\"content\").getAsString()); return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); content.put(\"name\", jsonObject.get(\"name\").getAsString()); content.put(\"description\", jsonObject.get(\"description\").getAsString()); content.put(\"version\", jsonObject.get(\"version\").getAsString()); content.put(\"content\", jsonObject.get(\"content\").getAsString()); return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<String, Object>(); for (String key : jsonObject.keySet()) { Object obj = jsonObject.get(key); if (obj instanceof JsonArray) { content.put(key, buildContent((JsonArray) obj)); } else { content.put(key, obj); } } return content; }", "private Map<String,Object> buildContent(JsonObject jsonObject){ Map<String, Object> content = new HashMap<>(); content.put(\"id\", jsonObject.get(\"id\").getAsLong()); content.put(\"name\", jsonObject.get(\"name\").getAsString()); content.put(\"description\", jsonObject.get(\"description\").getAsString()); content.put(\"creationDate\", jsonObject.get(\"creationDate\").getAsLong()); content.put(\"expirationDate\", jsonObject.get(\"expirationDate\").getAsLong()); return content; }"], "code_level": "project_runnable", "_id": "636767e01a6d9265ec018755", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (!modelName.isEmpty()) {\n    throw new IllegalStateException(\"Model name is empty.\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (modelName == null) {\n    throw new IllegalStateException(\"modelName is null\");\n  }\n  if (modelName.isEmpty()) {\n    throw new IllegalStateException(\"modelName is empty\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (modelName == null) {\n    throw new IllegalStateException(\"No key has been set!\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (modelName == null) {\n    throw new IllegalStateException(\"The key cannot be null.\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (key == null) {\n    throw new IllegalStateException(\"Cannot find key for \" + modelName);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (modelName == null) {\n    throw new IllegalStateException(\"ModelName can't be null\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (modelName == null) {\n    throw new IllegalStateException(\"The key is null\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (modelName == null) {\n    throw new IllegalStateException(\"modelName is null\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (modelName == null) {\n    throw new IllegalStateException(\"Model name cannot be null\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n  if (key.isNull()) {\n    throw new IllegalStateException(\"The key \" + modelName + \" does not contain null values.\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n", "method_name": "check", "codes": ["private void check(String modelName) throws IllegalStateException { if (!modelName.isEmpty()) { throw new IllegalStateException(\"Model name is empty.\"); } }", "private void check(String modelName) throws IllegalStateException { if (modelName == null) { throw new IllegalStateException(\"modelName is null\"); } if (modelName.isEmpty()) { throw new IllegalStateException(\"modelName is empty\"); } }", "private void check(String modelName) throws IllegalStateException { if (modelName == null) { throw new IllegalStateException(\"No key has been set!\"); } }", "private void check(String modelName) throws IllegalStateException { if (modelName == null) { throw new IllegalStateException(\"The key cannot be null.\"); } }", "private void check(String modelName) throws IllegalStateException { if (key == null) { throw new IllegalStateException(\"Cannot find key for \" + modelName); } }", "private void check(String modelName) throws IllegalStateException { if (modelName == null) { throw new IllegalStateException(\"ModelName can't be null\"); } }", "private void check(String modelName) throws IllegalStateException { if (modelName == null) { throw new IllegalStateException(\"The key is null\"); } }", "private void check(String modelName) throws IllegalStateException { if (modelName == null) { throw new IllegalStateException(\"modelName is null\"); } }", "private void check(String modelName) throws IllegalStateException { if (modelName == null) { throw new IllegalStateException(\"Model name cannot be null\"); } }", "private void check(String modelName) throws IllegalStateException { if (key.isNull()) { throw new IllegalStateException(\"The key \" + modelName + \" does not contain null values.\"); } }"], "code_level": "self_contained", "_id": "636767de1a6d9265ec01871e", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void overrideName(String oldName, String newName) {\n  for (int i = 0; i < columns.size(); i++) {\n    columns.get(i).overrideName(oldName, newName);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  for (int i = 0; i < rows; i++) {\n    for (int j = 0; j < cols; j++) {\n      if (cells[i][j].getName().equals(oldName)) {\n        cells[i][j].setName(newName);\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  if (!oldName.equals(newName)) {\n    for (int i = 0; i < this.columns.size(); i++) {\n      if (this.columns.get(i).getName().equals(oldName)) {\n        this.columns.get(i).setName(newName);\n        break;\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  for (int i = 0; i < m_columns.size(); i++) {\n    if (m_columns.get(i).getName().equals(oldName)) {\n      m_columns.get(i).setName(newName);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  for (int i = 0; i < this.getRowCount(); i++) {\n    if (this.getValueAt(i, 0).equals(oldName)) {\n      this.setValueAt(newName, i, 1);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  for (int i = 0; i < data.length; i++) {\n    if (data[i][0] == oldName) {\n      data[i][1] = newName;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  for (int i = 0; i < rows.size(); i++) {\n    if (rows.get(i).getName().equals(oldName)) {\n      rows.get(i).setName(newName);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  for (int i = 0; i < this.getRowCount(); i++) {\n    if (this.getValueAt(i, 0).equals(oldName)) {\n      this.setValueAt(newName, i, 2);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  for (int i = 0; i < this.size(); i++) {\n    if (this.get(i).getName().equals(oldName)) {\n      this.get(i).setName(newName);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName, String newName) {\n  for (int i = 0; i < numColumns; i++) {\n    if (names[i].equals(oldName)) {\n      names[i] = newName;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Keep the same name replacement as  {@link ColumnName#overrideName(String,String)}\n * @param oldName to be replaced.\n * @param newName to use in the storage level.\n */\n", "method_name": "overrideName", "codes": ["public void overrideName(String oldName,String newName){ for (int i = 0; i < columns.size(); i++) { columns.get(i).overrideName(oldName, newName); } }", "public void overrideName(String oldName,String newName){ for (int i = 0; i < rows; i++) { for (int j = 0; j < cols; j++) { if (cells[i][j].getName().equals(oldName)) { cells[i][j].setName(newName); } } } }", "public void overrideName(String oldName,String newName){ if (!oldName.equals(newName)) { for (int i = 0; i < this.columns.size(); i++) { if (this.columns.get(i).getName().equals(oldName)) { this.columns.get(i).setName(newName); break; } } } }", "public void overrideName(String oldName,String newName){ for (int i = 0; i < m_columns.size(); i++) { if (m_columns.get(i).getName().equals(oldName)) { m_columns.get(i).setName(newName); } } }", "public void overrideName(String oldName,String newName){ for (int i = 0; i < this.getRowCount(); i++) { if (this.getValueAt(i, 0).equals(oldName)) { this.setValueAt(newName, i, 1); } } }", "public void overrideName(String oldName,String newName){ for (int i = 0; i < data.length; i++) { if (data[i][0] == oldName) { data[i][1] = newName; } } }", "public void overrideName(String oldName,String newName){ for (int i = 0; i < rows.size(); i++) { if (rows.get(i).getName().equals(oldName)) { rows.get(i).setName(newName); } } }", "public void overrideName(String oldName,String newName){ for (int i = 0; i < this.getRowCount(); i++) { if (this.getValueAt(i, 0).equals(oldName)) { this.setValueAt(newName, i, 2); } } }", "public void overrideName(String oldName,String newName){ for (int i = 0; i < this.size(); i++) { if (this.get(i).getName().equals(oldName)) { this.get(i).setName(newName); } } }", "public void overrideName(String oldName,String newName){ for (int i = 0; i < numColumns; i++) { if (names[i].equals(oldName)) { names[i] = newName; } } }"], "code_level": "self_contained", "_id": "636767dd1a6d9265ec0186f3", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public boolean isCompatible(DataTable dataset) {\n  boolean compatible = true;\n  int numRows = dataset.numRows();\n  for (int i = 0; i < numRows; i++) {\n    if (!isCompatible(dataset.getRow(i))) {\n      compatible = false;\n      break;\n    }\n  }\n  return compatible;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (!(dataset instanceof DefaultDataTable)) return false;\n  DefaultDataTable dt = (DefaultDataTable) dataset;\n  if (dt.getDataset() == null || dt.getDataset().getId() == null) return false;\n  if (dt.getDataset().getId().equals(getId())) return true;\n  if (getBuckets() == null || getBuckets().size() == 0) return true;\n  for (int i = 0; i < getBuckets().size(); i++) {\n    if (dt.getBuckets().get(i).getId().equals(getBuckets().get(i).getId())) return true;\n  }\n  return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (dataset.getRowCount() != getRowCount()) {\n    return false;\n  }\n  for (int i = 0; i < getRowCount(); i++) {\n    if (!get(i).isCompatible(dataset.get(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (buckets.size() != dataset.getBuckets().size()) return false;\n  for (int i = 0; i < buckets.size(); i++) {\n    if (!buckets.get(i).isCompatible(dataset.getBuckets().get(i))) return false;\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (dataset == null) throw new IllegalArgumentException(\"dataset cannot be null.\");\n  if (dataset.size() != size()) return false;\n  for (int i = 0; i < size(); i++) {\n    if (!dataset.get(i).equals(get(i))) return false;\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  return this.dataset.isCompatible(dataset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  return (dataset.getTableName().equals(this.tableName)\n      && this.getColumnNames().size() == dataset.getColumnNames().size()\n      && this.getRows().size() == dataset.getRows().size());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  if (buckets.size() != dataset.getBuckets().size()) {\n    return false;\n  }\n  for (int i = 0; i < buckets.size(); i++) {\n    if (!buckets.get(i).isCompatible(dataset.getBuckets().get(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  boolean compatible = true;\n  int size = dataset.getRowCount();\n  for (int i = 0; i < size; i++) {\n    if (!this.buckets.get(i).equals(dataset.getRow(i).get(0))) {\n      compatible = false;\n      break;\n    }\n  }\n  return compatible;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset) {\n  return (dataset.numRows() == this.numRows());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return true if the bucket is same.\n */\n", "method_name": "isCompatible", "codes": ["public boolean isCompatible(DataTable dataset){ boolean compatible = true; int numRows = dataset.numRows(); for (int i = 0; i < numRows; i++) { if (!isCompatible(dataset.getRow(i))) { compatible = false; break; } } return compatible; }", "public boolean isCompatible(DataTable dataset){ if (!(dataset instanceof DefaultDataTable)) return false; DefaultDataTable dt = (DefaultDataTable) dataset; if (dt.getDataset() == null || dt.getDataset().getId() == null) return false; if (dt.getDataset().getId().equals(getId())) return true; if (getBuckets() == null || getBuckets().size() == 0) return true; for (int i = 0; i < getBuckets().size(); i++) { if (dt.getBuckets().get(i).getId().equals(getBuckets().get(i).getId())) return true; } return false; }", "public boolean isCompatible(DataTable dataset){ if (dataset.getRowCount() != getRowCount()) { return false; } for (int i = 0; i < getRowCount(); i++) { if (!get(i).isCompatible(dataset.get(i))) { return false; } } return true; }", "public boolean isCompatible(DataTable dataset){ if (buckets.size() != dataset.getBuckets().size()) return false; for (int i = 0; i < buckets.size(); i++) { if (!buckets.get(i).isCompatible(dataset.getBuckets().get(i))) return false; } return true; }", "public boolean isCompatible(DataTable dataset){ if (dataset == null) throw new IllegalArgumentException(\"dataset cannot be null.\"); if (dataset.size() != size()) return false; for (int i = 0; i < size(); i++) { if (!dataset.get(i).equals(get(i))) return false; } return true; }", "public boolean isCompatible(DataTable dataset){ return this.dataset.isCompatible(dataset); }", "public boolean isCompatible(DataTable dataset){ return (dataset.getTableName().equals(this.tableName) && this.getColumnNames().size() == dataset.getColumnNames().size() && this.getRows().size() == dataset.getRows().size()); }", "public boolean isCompatible(DataTable dataset){ if (buckets.size() != dataset.getBuckets().size()) { return false; } for (int i = 0; i < buckets.size(); i++) { if (!buckets.get(i).isCompatible(dataset.getBuckets().get(i))) { return false; } } return true; }", "public boolean isCompatible(DataTable dataset){ boolean compatible = true; int size = dataset.getRowCount(); for (int i = 0; i < size; i++) { if (!this.buckets.get(i).equals(dataset.getRow(i).get(0))) { compatible = false; break; } } return compatible; }", "public boolean isCompatible(DataTable dataset){ return (dataset.numRows() == this.numRows()); }"], "code_level": "plib_runnable", "_id": "636767e11a6d9265ec018795", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  StringBuilder sb = new StringBuilder(\"SELECT * FROM \");\n  sb.append(tableName);\n  sb.append(\" WHERE \");\n  sb.append(\"(\");\n  for (String key : mappings.getFields().keySet()) {\n    sb.append(key);\n    sb.append(\" = ? AND \");\n  }\n  sb.delete(sb.length() - 4, sb.length());\n  sb.append(\")\");\n  String query = sb.toString();\n  Map<String, Object> result = null;\n  try {\n    result = jdbcTemplate.queryForMap(query, mappings.getFields().keySet().toArray());\n  } catch (EmptyResultDataAccessException e) {\n    return null;\n  } catch (Exception e) {\n    logger.error(\"Error while reading mappings\", e);\n  }\n  return new Mappings(result);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  Map<String, Map<String, Map<String, Map<String, String>>>> historyMappings =\n      getHistoryMappings(tableName);\n  Map<String, Map<String, Map<String, String>>> inputMappings = getInputMappings(tableName);\n  Map<String, Map<String, String>> diffMappings = new HashMap<>();\n  for (String s : inputMappings.keySet()) {\n    for (String s2 : historyMappings.get(s).keySet()) {\n      if (!inputMappings.get(s).containsKey(s2)) {\n        diffMappings.put(s, historyMappings.get(s).get(s2));\n      }\n    }\n  }\n  for (String s : diffMappings.keySet()) {\n    if (!historyMappings.get(s).containsKey(s)) {\n      diffMappings.remove(s);\n    }\n  }\n  return new Mappings(diffMappings);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  if (tableName == null || mappings == null) {\n    throw new IllegalArgumentException(\"The input mappings must not be null.\");\n  }\n  if (mappings.getInputFields().size() == 0) {\n    return this;\n  }\n  if (tableName.equals(this.tableName)) {\n    return mappings;\n  }\n  Map<String, Field> tableFields = mappings.getInputFields();\n  Map<String, Field> currentFields = getInputFields();\n  for (String fieldName : tableFields.keySet()) {\n    Field field = currentFields.get(fieldName);\n    if (field == null) {\n      throw new IllegalArgumentException(\n          \"Field '\" + fieldName + \"' is not found in the input mappings.\");\n    }\n    if (!tableFields.get(fieldName).getType().equals(field.getType())) {\n      throw new IllegalArgumentException(\n          \"Field '\"\n              + fieldName\n              + \"' is of type '\"\n              + field.getType()\n              + \"', but the input mappings contains '\"\n              + tableFields.get(fieldName).getType()\n              + \"'.\");\n    }\n  }\n  Map<String, Field> newFields = new HashMap<>(currentFields);\n  for (String fieldName : tableFields.keySet()) {\n    Field field = tableFields.get(fieldName);\n    if (field == null) {\n      throw new IllegalArgumentException(\n          \"Field '\" + fieldName + \"' is not found in the input mappings.\");\n    }\n    if (newFields.containsKey(fieldName)) {\n      if (!field.getType().equals(newFields.get(fieldName).getType())) {\n        throw new IllegalArgumentException(\n            \"Field '\"\n                + fieldName\n                + \"' is of type '\"\n                + field.getType()\n                + \"', but the input mappings contains '\"\n                + newFields.get(fieldName).getType()\n                + \"'.\");\n      }\n    } else {\n      newFields.put(fieldName, field);\n    }\n  }\n  return new Mappings(tableName, newFields);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  Map<String, Object> newMappings = new HashMap<>(mappings.getMappings());\n  Map<String, Object> oldMappings = new HashMap<>(mappings.getMappings());\n  newMappings.remove(\"_id\");\n  oldMappings.remove(\"_id\");\n  for (String fieldName : oldMappings.keySet()) {\n    Object oldValue = oldMappings.get(fieldName);\n    Object newValue = newMappings.get(fieldName);\n    if (oldValue == null && newValue == null) {\n      continue;\n    }\n    if (oldValue == null || newValue == null) {\n      return null;\n    }\n    if (oldValue.getClass().equals(newValue.getClass())) {\n      if (oldValue instanceof List) {\n        if (((List) oldValue).size() != ((List) newValue).size()) {\n          return null;\n        }\n      } else if (oldValue instanceof Map) {\n        if (((Map) oldValue).size() != ((Map) newValue).size()) {\n          return null;\n        }\n      }\n    } else {\n      return null;\n    }\n  }\n  return new Mappings(newMappings, oldMappings);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  if (mappings == null) {\n    return null;\n  }\n  Mappings m = new Mappings();\n  for (String field : mappings.getFields().keySet()) {\n    if (!mappings.getFields().get(field).getExists()) {\n      m.add(field, mappings.getFields().get(field));\n    }\n  }\n  return m;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  Map<String, Mapping> existingMappings = new HashMap<>();\n  for (Mapping mapping : mappings.getMappings()) {\n    if (mapping.getFields().isEmpty()) {\n      existingMappings.put(mapping.getFieldName(), mapping);\n    }\n  }\n  for (Map.Entry<String, Mapping> entry : existingMappings.entrySet()) {\n    String fieldName = entry.getKey();\n    Mapping existingMapping = entry.getValue();\n    if (existingMapping.getFields().size() > 1) {\n      throw new IllegalArgumentException(\n          String.format(\"Removed multiple field names for field %s\", fieldName));\n    }\n    if (existingMapping.getFields().containsKey(fieldName)) {\n      throw new IllegalArgumentException(\n          String.format(\"Field %s is already present in mappings\", fieldName));\n    }\n  }\n  if (mappings.getMappings().isEmpty()) {\n    return new Mappings(existingMappings);\n  } else {\n    return new Mappings(\n        mappings.getMappings().stream()\n            .filter(m -> !existingMappings.containsKey(m.getFieldName()))\n            .collect(Collectors.toMap(m -> m.getFieldName(), m -> m)));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  Map<String, MappingMetaData> newMappings = new HashMap<>();\n  for (Map.Entry<String, MappingMetaData> entry : mappings.mappings.entrySet()) {\n    if (!mappings.mappings.containsKey(entry.getKey())) {\n      newMappings.put(entry.getKey(), entry.getValue());\n    }\n  }\n  for (Map.Entry<String, MappingMetaData> entry : newMappings.entrySet()) {\n    if (mappings.mappings.containsKey(entry.getKey())) {\n      if (!mappings.mappings.get(entry.getKey()).equals(entry.getValue())) {\n        logger.info(\n            \"Diff structure for table {} is not supported. \"\n                + \"The mappings are not in the current index: {}\",\n            tableName,\n            mappings.mappings.get(entry.getKey()));\n      }\n    } else {\n      logger.info(\n          \"Diff structure for table {} is not supported. \"\n              + \"The mappings are in the current index: {}\",\n          tableName,\n          entry.getValue());\n    }\n  }\n  return new Mappings(newMappings);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  Map<String, Mappings> mappingsMap = mappings.getMappings();\n  Map<String, Mappings> map = new HashMap<>();\n  for (Map.Entry<String, Mappings> entry : mappingsMap.entrySet()) {\n    Mappings m = entry.getValue();\n    if (!m.getMappings().isEmpty()) {\n      map.put(entry.getKey(), m);\n    }\n  }\n  return diffStructure(tableName, map);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  Mappings diffMappings = new Mappings(mappings);\n  for (Mapping mapping : diffMappings.getMappings().values()) {\n    if (mapping.getFields().size() == 0) {\n      diffMappings.getMappings().remove(mapping.getName());\n    } else {\n      for (String field : mapping.getFields().keySet()) {\n        if (!mappings.getMappings().containsKey(field)) {\n          diffMappings.getMappings().remove(field);\n        }\n      }\n    }\n  }\n  return diffMappings;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName, Mappings mappings) {\n  return diffStructure(tableName, mappings.getHistoryMappings());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns mappings with fields that not exist in the input mappings. The input mappings should be history mapping from current index. Do not return _source config to avoid current index update conflict.\n */\n", "method_name": "diffStructure", "codes": ["public Mappings diffStructure(String tableName,Mappings mappings){ StringBuilder sb = new StringBuilder(\"SELECT * FROM \"); sb.append(tableName); sb.append(\" WHERE \"); sb.append(\"(\"); for (String key : mappings.getFields().keySet()) { sb.append(key); sb.append(\" = ? AND \"); } sb.delete(sb.length() - 4, sb.length()); sb.append(\")\"); String query = sb.toString(); Map<String, Object> result = null; try { result = jdbcTemplate.queryForMap(query, mappings.getFields().keySet().toArray()); } catch (EmptyResultDataAccessException e) { return null; } catch (Exception e) { logger.error(\"Error while reading mappings\", e); } return new Mappings(result); }", "public Mappings diffStructure(String tableName,Mappings mappings){ Map<String, Map<String, Map<String, Map<String, String>>>> historyMappings = getHistoryMappings(tableName); Map<String, Map<String, Map<String, String>>> inputMappings = getInputMappings(tableName); Map<String, Map<String, String>> diffMappings = new HashMap<>(); for (String s : inputMappings.keySet()) { for (String s2 : historyMappings.get(s).keySet()) { if (!inputMappings.get(s).containsKey(s2)) { diffMappings.put(s, historyMappings.get(s).get(s2)); } } } for (String s : diffMappings.keySet()) { if (!historyMappings.get(s).containsKey(s)) { diffMappings.remove(s); } } return new Mappings(diffMappings); }", "public Mappings diffStructure(String tableName,Mappings mappings){ if (tableName == null || mappings == null) { throw new IllegalArgumentException(\"The input mappings must not be null.\"); } if (mappings.getInputFields().size() == 0) { return this; } if (tableName.equals(this.tableName)) { return mappings; } Map<String, Field> tableFields = mappings.getInputFields(); Map<String, Field> currentFields = getInputFields(); for (String fieldName : tableFields.keySet()) { Field field = currentFields.get(fieldName); if (field == null) { throw new IllegalArgumentException(\"Field '\" + fieldName + \"' is not found in the input mappings.\"); } if (!tableFields.get(fieldName).getType().equals(field.getType())) { throw new IllegalArgumentException(\"Field '\" + fieldName + \"' is of type '\" + field.getType() + \"', but the input mappings contains '\" + tableFields.get(fieldName).getType() + \"'.\"); } } Map<String, Field> newFields = new HashMap<>(currentFields); for (String fieldName : tableFields.keySet()) { Field field = tableFields.get(fieldName); if (field == null) { throw new IllegalArgumentException(\"Field '\" + fieldName + \"' is not found in the input mappings.\"); } if (newFields.containsKey(fieldName)) { if (!field.getType().equals(newFields.get(fieldName).getType())) { throw new IllegalArgumentException(\"Field '\" + fieldName + \"' is of type '\" + field.getType() + \"', but the input mappings contains '\" + newFields.get(fieldName).getType() + \"'.\"); } } else { newFields.put(fieldName, field); } } return new Mappings(tableName, newFields); }", "public Mappings diffStructure(String tableName,Mappings mappings){ Map<String, Object> newMappings = new HashMap<>(mappings.getMappings()); Map<String, Object> oldMappings = new HashMap<>(mappings.getMappings()); newMappings.remove(\"_id\"); oldMappings.remove(\"_id\"); for (String fieldName : oldMappings.keySet()) { Object oldValue = oldMappings.get(fieldName); Object newValue = newMappings.get(fieldName); if (oldValue == null && newValue == null) { continue; } if (oldValue == null || newValue == null) { return null; } if (oldValue.getClass().equals(newValue.getClass())) { if (oldValue instanceof List) { if (((List) oldValue).size() != ((List) newValue).size()) { return null; } } else if (oldValue instanceof Map) { if (((Map) oldValue).size() != ((Map) newValue).size()) { return null; } } } else { return null; } } return new Mappings(newMappings, oldMappings); }", "public Mappings diffStructure(String tableName,Mappings mappings){ if (mappings == null) { return null; } Mappings m = new Mappings(); for (String field : mappings.getFields().keySet()) { if (!mappings.getFields().get(field).getExists()) { m.add(field, mappings.getFields().get(field)); } } return m; }", "public Mappings diffStructure(String tableName,Mappings mappings){ Map<String, Mapping> existingMappings = new HashMap<>(); for (Mapping mapping : mappings.getMappings()) { if (mapping.getFields().isEmpty()) { existingMappings.put(mapping.getFieldName(), mapping); } } for (Map.Entry<String, Mapping> entry : existingMappings.entrySet()) { String fieldName = entry.getKey(); Mapping existingMapping = entry.getValue(); if (existingMapping.getFields().size() > 1) { throw new IllegalArgumentException(String.format(\"Removed multiple field names for field %s\", fieldName)); } if (existingMapping.getFields().containsKey(fieldName)) { throw new IllegalArgumentException(String.format(\"Field %s is already present in mappings\", fieldName)); } } if (mappings.getMappings().isEmpty()) { return new Mappings(existingMappings); } else { return new Mappings(mappings.getMappings().stream().filter(m -> !existingMappings.containsKey(m.getFieldName())).collect(Collectors.toMap(m -> m.getFieldName(), m -> m))); } }", "public Mappings diffStructure(String tableName,Mappings mappings){ Map<String, MappingMetaData> newMappings = new HashMap<>(); for (Map.Entry<String, MappingMetaData> entry : mappings.mappings.entrySet()) { if (!mappings.mappings.containsKey(entry.getKey())) { newMappings.put(entry.getKey(), entry.getValue()); } } for (Map.Entry<String, MappingMetaData> entry : newMappings.entrySet()) { if (mappings.mappings.containsKey(entry.getKey())) { if (!mappings.mappings.get(entry.getKey()).equals(entry.getValue())) { logger.info(\"Diff structure for table {} is not supported. \" + \"The mappings are not in the current index: {}\", tableName, mappings.mappings.get(entry.getKey())); } } else { logger.info(\"Diff structure for table {} is not supported. \" + \"The mappings are in the current index: {}\", tableName, entry.getValue()); } } return new Mappings(newMappings); }", "public Mappings diffStructure(String tableName,Mappings mappings){ Map<String, Mappings> mappingsMap = mappings.getMappings(); Map<String, Mappings> map = new HashMap<>(); for (Map.Entry<String, Mappings> entry : mappingsMap.entrySet()) { Mappings m = entry.getValue(); if (!m.getMappings().isEmpty()) { map.put(entry.getKey(), m); } } return diffStructure(tableName, map); }", "public Mappings diffStructure(String tableName,Mappings mappings){ Mappings diffMappings = new Mappings(mappings); for (Mapping mapping : diffMappings.getMappings().values()) { if (mapping.getFields().size() == 0) { diffMappings.getMappings().remove(mapping.getName()); } else { for (String field : mapping.getFields().keySet()) { if (!mappings.getMappings().containsKey(field)) { diffMappings.getMappings().remove(field); } } } } return diffMappings; }", "public Mappings diffStructure(String tableName,Mappings mappings){ return diffStructure(tableName, mappings.getHistoryMappings()); }"], "code_level": "plib_runnable", "_id": "636767de1a6d9265ec018706", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  long bucket = timeBucket;\n  if (dayStep == 1) {\n    bucket = bucket / TimeUnit.DAYS.toMillis(1);\n  } else if (dayStep == 2) {\n    bucket = bucket / TimeUnit.DAYS.toMillis(10);\n  } else if (dayStep == 3) {\n    bucket = bucket / TimeUnit.DAYS.toMillis(30);\n  } else if (dayStep == 4) {\n    bucket = bucket / TimeUnit.DAYS.toMillis(60);\n  } else if (dayStep == 5) {\n    bucket = bucket / TimeUnit.DAYS.toMillis(120);\n  }\n  return bucket;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  long timeBucketCompressed = timeBucket;\n  if (dayStep == 1) {\n    timeBucketCompressed = timeBucketCompressed * 1000;\n  } else if (dayStep == 2) {\n    timeBucketCompressed = timeBucketCompressed * 1000 * 60;\n  } else if (dayStep == 3) {\n    timeBucketCompressed = timeBucketCompressed * 1000 * 60 * 60;\n  } else if (dayStep == 4) {\n    timeBucketCompressed = timeBucketCompressed * 1000 * 60 * 60 * 24;\n  } else if (dayStep == 5) {\n    timeBucketCompressed = timeBucketCompressed * 1000 * 60 * 60 * 24 * 30;\n  } else if (dayStep == 6) {\n    timeBucketCompressed = timeBucketCompressed * 1000 * 60 * 60 * 24 * 30 * 7;\n  }\n  return timeBucketCompressed;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return (timeBucket * dayStep);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return timeBucket * dayStep;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  long timeBucketWithDayStep = timeBucket / dayStep;\n  long timeBucketWithoutDayStep = timeBucketWithDayStep * dayStep;\n  return timeBucketWithoutDayStep + timeBucketWithDayStep;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return timeBucket * dayStep;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  long timeBucketRef = timeBucket;\n  if (dayStep == 1) {\n    timeBucketRef *= MILLISECONDS_PER_DAY;\n  } else if (dayStep == 2) {\n    timeBucketRef *= MILLISECONDS_PER_HOUR;\n  } else if (dayStep == 3) {\n    timeBucketRef *= MILLISECONDS_PER_MINUTE;\n  } else if (dayStep == 4) {\n    timeBucketRef *= MILLISECONDS_PER_SECOND;\n  } else if (dayStep == 5) {\n    timeBucketRef *= MILLISECONDS_PER_MILLISECOND;\n  } else if (dayStep == 6) {\n    timeBucketRef *= MILLISECONDS_PER_NANOS_PER_SECOND;\n  }\n  return timeBucketRef;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return (timeBucket - (timeBucket % dayStep)) / dayStep;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return timeBucket * dayStep * TIME_BUCKET_FORMATTER.length();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket, int dayStep) {\n  return (timeBucket / (1000 * 60 * 60 * 24 * dayStep)) % 1000;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n", "method_name": "compressTimeBucket", "codes": ["static long compressTimeBucket(long timeBucket,int dayStep){ long bucket = timeBucket; if (dayStep == 1) { bucket = bucket / TimeUnit.DAYS.toMillis(1); } else if (dayStep == 2) { bucket = bucket / TimeUnit.DAYS.toMillis(10); } else if (dayStep == 3) { bucket = bucket / TimeUnit.DAYS.toMillis(30); } else if (dayStep == 4) { bucket = bucket / TimeUnit.DAYS.toMillis(60); } else if (dayStep == 5) { bucket = bucket / TimeUnit.DAYS.toMillis(120); } return bucket; }", "static long compressTimeBucket(long timeBucket,int dayStep){ long timeBucketCompressed = timeBucket; if (dayStep == 1) { timeBucketCompressed = timeBucketCompressed * 1000; } else if (dayStep == 2) { timeBucketCompressed = timeBucketCompressed * 1000 * 60; } else if (dayStep == 3) { timeBucketCompressed = timeBucketCompressed * 1000 * 60 * 60; } else if (dayStep == 4) { timeBucketCompressed = timeBucketCompressed * 1000 * 60 * 60 * 24; } else if (dayStep == 5) { timeBucketCompressed = timeBucketCompressed * 1000 * 60 * 60 * 24 * 30; } else if (dayStep == 6) { timeBucketCompressed = timeBucketCompressed * 1000 * 60 * 60 * 24 * 30 * 7; } return timeBucketCompressed; }", "static long compressTimeBucket(long timeBucket,int dayStep){ return (timeBucket * dayStep); }", "static long compressTimeBucket(long timeBucket,int dayStep){ return timeBucket * dayStep; }", "static long compressTimeBucket(long timeBucket,int dayStep){ long timeBucketWithDayStep = timeBucket / dayStep; long timeBucketWithoutDayStep = timeBucketWithDayStep * dayStep; return timeBucketWithoutDayStep + timeBucketWithDayStep; }", "static long compressTimeBucket(long timeBucket,int dayStep){ return timeBucket * dayStep; }", "static long compressTimeBucket(long timeBucket,int dayStep){ long timeBucketRef = timeBucket; if (dayStep == 1) { timeBucketRef *= MILLISECONDS_PER_DAY; } else if (dayStep == 2) { timeBucketRef *= MILLISECONDS_PER_HOUR; } else if (dayStep == 3) { timeBucketRef *= MILLISECONDS_PER_MINUTE; } else if (dayStep == 4) { timeBucketRef *= MILLISECONDS_PER_SECOND; } else if (dayStep == 5) { timeBucketRef *= MILLISECONDS_PER_MILLISECOND; } else if (dayStep == 6) { timeBucketRef *= MILLISECONDS_PER_NANOS_PER_SECOND; } return timeBucketRef; }", "static long compressTimeBucket(long timeBucket,int dayStep){ return (timeBucket - (timeBucket % dayStep)) / dayStep; }", "static long compressTimeBucket(long timeBucket,int dayStep){ return timeBucket * dayStep * TIME_BUCKET_FORMATTER.length(); }", "static long compressTimeBucket(long timeBucket,int dayStep){ return (timeBucket / (1000 * 60 * 60 * 24 * dayStep)) % 1000; }"], "code_level": "project_runnable", "_id": "636767dc1a6d9265ec0186be", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (Field field : fields.getFields()) {\n    if (!field.getType().equals(\"string\")) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  return fields.containsKey(\"email\")\n      && fields.containsKey(\"password\")\n      && fields.containsKey(\"firstName\")\n      && fields.containsKey(\"lastName\")\n      && fields.containsKey(\"phoneNumber\")\n      && fields.containsKey(\"gender\")\n      && fields.containsKey(\"dateOfBirth\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  if (fields.get(\"id\") != null\n      && fields.get(\"name\") != null\n      && fields.get(\"description\") != null\n      && fields.get(\"icon\") != null\n      && fields.get(\"order\") != null\n      && fields.get(\"required\") != null\n      && fields.get(\"type\") != null) {\n    return true;\n  } else {\n    return false;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (String field : fields) {\n    if (!containsField(field)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (Field field : fields.getFields()) {\n    if (!field.getType().isEmpty()) {\n      if (!field.getType().equals(getType())) {\n        return false;\n      }\n    }\n    if (field.getName() != null && !field.getName().isEmpty()) {\n      if (!field.getName().equals(getName())) {\n        return false;\n      }\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (String field : fields.fields()) {\n    if (!fields.hasField(field)) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (Field field : fields) {\n    if (!field.isNullable()) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  return fields.getFields().stream().allMatch(field -> field.getType() == FieldType.STRING)\n      && fields.getFields().stream().allMatch(field -> field.getName().equals(\"group\"))\n      && fields.getFields().stream().allMatch(field -> field.getName().equals(\"name\"))\n      && fields.getFields().stream().allMatch(field -> field.getName().equals(\"success\"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  for (Field field : fields) {\n    if (!field.isHidden() && !field.isPossibleValue()) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields) {\n  return fields.containsKey(\"name\")\n      && fields.containsKey(\"address\")\n      && fields.containsKey(\"phone\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n", "method_name": "containsAllFields", "codes": ["private boolean containsAllFields(Fields fields){ for (Field field : fields.getFields()) { if (!field.getType().equals(\"string\")) { return false; } } return true; }", "private boolean containsAllFields(Fields fields){ return fields.containsKey(\"email\") && fields.containsKey(\"password\") && fields.containsKey(\"firstName\") && fields.containsKey(\"lastName\") && fields.containsKey(\"phoneNumber\") && fields.containsKey(\"gender\") && fields.containsKey(\"dateOfBirth\"); }", "private boolean containsAllFields(Fields fields){ if (fields.get(\"id\") != null && fields.get(\"name\") != null && fields.get(\"description\") != null && fields.get(\"icon\") != null && fields.get(\"order\") != null && fields.get(\"required\") != null && fields.get(\"type\") != null) { return true; } else { return false; } }", "private boolean containsAllFields(Fields fields){ for (String field : fields) { if (!containsField(field)) { return false; } } return true; }", "private boolean containsAllFields(Fields fields){ for (Field field : fields.getFields()) { if (!field.getType().isEmpty()) { if (!field.getType().equals(getType())) { return false; } } if (field.getName() != null && !field.getName().isEmpty()) { if (!field.getName().equals(getName())) { return false; } } } return true; }", "private boolean containsAllFields(Fields fields){ for (String field : fields.fields()) { if (!fields.hasField(field)) { return false; } } return true; }", "private boolean containsAllFields(Fields fields){ for (Field field : fields) { if (!field.isNullable()) { return false; } } return true; }", "private boolean containsAllFields(Fields fields){ return fields.getFields().stream().allMatch(field -> field.getType() == FieldType.STRING) && fields.getFields().stream().allMatch(field -> field.getName().equals(\"group\")) && fields.getFields().stream().allMatch(field -> field.getName().equals(\"name\")) && fields.getFields().stream().allMatch(field -> field.getName().equals(\"success\")); }", "private boolean containsAllFields(Fields fields){ for (Field field : fields) { if (!field.isHidden() && !field.isPossibleValue()) { return false; } } return true; }", "private boolean containsAllFields(Fields fields){ return fields.containsKey(\"name\") && fields.containsKey(\"address\") && fields.containsKey(\"phone\"); }"], "code_level": "slib_runnable", "_id": "636767dc1a6d9265ec0186c6", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  if (consumer != null) {\n    synchronized (consumerTargets) {\n      consumerTargets.put(consumer, channels);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  addNewTarget(channels, consumer, new HashSet<IConsumer>());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  if (targets.containsKey(channels)) {\n    return;\n  }\n  targets.put(channels, consumer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  this.consumeTargets.put(channels, consumer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  this.consumeTargets.put(channels, consumer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  for (Channel channel : channels.getChannels()) {\n    addNewTarget(channel, consumer);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  if (consumer == null) return;\n  if (consumer.getTarget() != null) return;\n  consumer.setTarget(new ArrayList<IConsumer>(channels.getTargets()));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  for (Channel channel : channels.getChannels()) {\n    addNewTarget(channel, consumer);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  if (consumer == null) return;\n  for (Channel channel : channels.getChannels()) {\n    if (channel == null) continue;\n    if (channel.getName().equals(consumer.getName())) {\n      System.err.println(\"The consumer \" + consumer.getName() + \" already exists.\");\n      return;\n    }\n  }\n  synchronized (consumers) {\n    consumers.add(consumer);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels, IConsumer consumer) {\n  List<Channels> targets = new ArrayList<>(this.consumeTargets.get(consumer));\n  targets.add(channels);\n  this.consumeTargets.put(consumer, targets);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a new target channels.\n */\n", "method_name": "addNewTarget", "codes": ["public void addNewTarget(Channels channels,IConsumer consumer){ if (consumer != null) { synchronized (consumerTargets) { consumerTargets.put(consumer, channels); } } }", "public void addNewTarget(Channels channels,IConsumer consumer){ addNewTarget(channels, consumer, new HashSet<IConsumer>()); }", "public void addNewTarget(Channels channels,IConsumer consumer){ if (targets.containsKey(channels)) { return; } targets.put(channels, consumer); }", "public void addNewTarget(Channels channels,IConsumer consumer){ this.consumeTargets.put(channels, consumer); }", "public void addNewTarget(Channels channels,IConsumer consumer){ this.consumeTargets.put(channels, consumer); }", "public void addNewTarget(Channels channels,IConsumer consumer){ for (Channel channel : channels.getChannels()) { addNewTarget(channel, consumer); } }", "public void addNewTarget(Channels channels,IConsumer consumer){ if (consumer == null) return; if (consumer.getTarget() != null) return; consumer.setTarget(new ArrayList<IConsumer>(channels.getTargets())); }", "public void addNewTarget(Channels channels,IConsumer consumer){ for (Channel channel : channels.getChannels()) { addNewTarget(channel, consumer); } }", "public void addNewTarget(Channels channels,IConsumer consumer){ if (consumer == null) return; for (Channel channel : channels.getChannels()) { if (channel == null) continue; if (channel.getName().equals(consumer.getName())) { System.err.println(\"The consumer \" + consumer.getName() + \" already exists.\"); return; } } synchronized (consumers) { consumers.add(consumer); } }", "public void addNewTarget(Channels channels,IConsumer consumer){ List<Channels> targets = new ArrayList<>(this.consumeTargets.get(consumer)); targets.add(channels); this.consumeTargets.put(consumer, targets); }"], "code_level": "plib_runnable", "_id": "636767dd1a6d9265ec0186e5", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public void init() {\n  if (!dir.exists()) dir.mkdir();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  try {\n    if (!fs.exists(initPath)) {\n      fs.mkdirs(initPath);\n    }\n  } catch (IOException e) {\n    logger.error(e.getMessage(), e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  try {\n    if (!ftp.changeWorkingDirectory(basePath)) {\n      if (!ftp.makeDirectory(basePath)) {\n        throw new RuntimeException(\"\u521b\u5efa\u76ee\u5f55\u5931\u8d25\");\n      } else {\n        ftp.changeWorkingDirectory(basePath);\n      }\n    }\n    ftp.setBufferSize(1024);\n    ftp.setControlEncoding(\"UTF-8\");\n    ftp.setFileType(FTPClient.BINARY_FILE_TYPE);\n    ftp.enterLocalPassiveMode();\n  } catch (IOException e) {\n    throw new RuntimeException(e.getMessage(), e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  try {\n    if (!directory.exists()) {\n      directory.mkdirs();\n    }\n  } catch (SecurityException e) {\n    e.printStackTrace();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  try {\n    if (!new File(\".\").exists()) {\n      new File(\".\").mkdirs();\n    }\n    if (!new File(\".\").isDirectory()) {\n      throw new Exception(\"Directory '.' does not exist\");\n    }\n  } catch (Exception e) {\n    System.err.println(\"Error creating directory: \" + e.getMessage());\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void init() {\n  try {\n    if (!directory.mkdir()) {\n      throw new IOException(\"Could not create directory \" + directory.getAbsolutePath());\n    }\n  } catch (SecurityException e) {\n    throw new RuntimeException(\"Could not create directory \" + directory.getAbsolutePath(), e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  File dir = new File(\"/home/cs56/Desktop/\");\n  if (!dir.exists()) {\n    dir.mkdir();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void init() {\n  if (!dir.exists()) {\n    dir.mkdir();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  init(null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init() {\n  File f = new File(\"data/\");\n  if (!f.exists()) {\n    f.mkdirs();\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * initialize config, such as check dist path\n */\n", "method_name": "init", "codes": ["public void init(){ if (!dir.exists()) dir.mkdir(); }", "public void init(){ try { if (!fs.exists(initPath)) { fs.mkdirs(initPath); } } catch (IOException e) { logger.error(e.getMessage(), e); } }", "public void init(){ try { if (!ftp.changeWorkingDirectory(basePath)) { if (!ftp.makeDirectory(basePath)) { throw new RuntimeException(\"\u521b\u5efa\u76ee\u5f55\u5931\u8d25\"); } else { ftp.changeWorkingDirectory(basePath); } } ftp.setBufferSize(1024); ftp.setControlEncoding(\"UTF-8\"); ftp.setFileType(FTPClient.BINARY_FILE_TYPE); ftp.enterLocalPassiveMode(); } catch (IOException e) { throw new RuntimeException(e.getMessage(), e); } }", "public void init(){ try { if (!directory.exists()) { directory.mkdirs(); } } catch (SecurityException e) { e.printStackTrace(); } }", "public void init(){ try { if (!new File(\".\").exists()) { new File(\".\").mkdirs(); } if (!new File(\".\").isDirectory()) { throw new Exception(\"Directory '.' does not exist\"); } } catch (Exception e) { System.err.println(\"Error creating directory: \" + e.getMessage()); } }", "public void init(){ try { if (!directory.mkdir()) { throw new IOException(\"Could not create directory \" + directory.getAbsolutePath()); } } catch (SecurityException e) { throw new RuntimeException(\"Could not create directory \" + directory.getAbsolutePath(), e); } }", "public void init(){ File dir = new File(\"/home/cs56/Desktop/\"); if (!dir.exists()) { dir.mkdir(); } }", "public void init(){ if (!dir.exists()) { dir.mkdir(); } }", "public void init(){ init(null); }", "public void init(){ File f = new File(\"data/\"); if (!f.exists()) { f.mkdirs(); } }"], "code_level": "slib_runnable", "_id": "636767dc1a6d9265ec0186cb", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> sequenceRanges = new ArrayList<>();\n  for (int i = 0; i < numSequences; i++) {\n    SequenceRange range = new SequenceRange();\n    range.lowerBound = Math.min(minSequence, i);\n    range.upperBound = Math.max(maxSequence, i);\n    sequenceRanges.add(range);\n  }\n  return sequenceRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> ranges = new ArrayList<>(sequences.size());\n  for (int sequenceIndex = 0; sequenceIndex < sequences.size(); sequenceIndex++) {\n    Sequence sequence = sequences.get(sequenceIndex);\n    if (sequenceIndex == 0) {\n      SequenceRange range = new SequenceRange(sequence.getLowerBound(), sequence.getLowerBound());\n      ranges.add(range);\n      continue;\n    }\n    SequenceRange range = new SequenceRange(sequence.getLowerBound(), sequence.getUpperBound());\n    ranges.add(range);\n  }\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> ranges = new ArrayList<>();\n  int minSequence = 0;\n  for (int i = 0; i < getSequences().size(); i++) {\n    int sequenceLength = getSequences().get(i).length();\n    if (minSequence < sequenceLength) {\n      minSequence = sequenceLength;\n    }\n  }\n  for (int i = 0; i < getSequences().size(); i++) {\n    int sequenceLength = getSequences().get(i).length();\n    if (sequenceLength < minSequence) {\n      ranges.add(new SequenceRange(minSequence, sequenceLength));\n      minSequence = sequenceLength;\n    }\n  }\n  ranges.add(new SequenceRange(minSequence, getSequences().size()));\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  if (sequenceRanges == null) {\n    if (sequenceRangesBatchSize == 0) {\n      return Collections.emptyList();\n    }\n    if (sequenceRangesBatchSize <= 0) {\n      return Collections.singletonList(sequenceRanges.get(0));\n    }\n    List<SequenceRange> ranges = new ArrayList<>();\n    int minSequence = sequenceRanges.get(0).getMinSequence();\n    int maxSequence = sequenceRanges.get(sequenceRanges.size() - 1).getMaxSequence();\n    if (minSequence < 0) {\n      minSequence = 0;\n    }\n    if (maxSequence >= maxSequences) {\n      maxSequence = maxSequences - 1;\n    }\n    for (SequenceRange range : sequenceRanges) {\n      if (range.getMinSequence() >= minSequence) {\n        ranges.add(\n            new SequenceRange(minSequence, range.getMinSequence() + sequenceRangesBatchSize));\n      }\n      if (range.getMaxSequence() <= maxSequence) {\n        ranges.add(new SequenceRange(range.getMaxSequence(), maxSequence));\n      }\n    }\n    return ranges;\n  } else {\n    return sequenceRanges;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> result = new ArrayList<>();\n  SequenceRange lastSequenceRange = buildLastSequenceRange();\n  if (lastSequenceRange != null) {\n    result.add(lastSequenceRange);\n  }\n  for (int i = 0; i < sequences.size(); i++) {\n    Sequence sequence = sequences.get(i);\n    SequenceRange sequenceRange = buildSequenceRange(sequence);\n    if (sequenceRange != null) {\n      result.add(sequenceRange);\n    }\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> ranges = new ArrayList<>();\n  for (int i = 0; i < sequences.size(); i++) {\n    if (sequences.get(i).length() > SEQUENCE_RANGE_BATCH_SIZE) {\n      ranges.add(new SequenceRange(i, sequences.get(i).length() - SEQUENCE_RANGE_BATCH_SIZE));\n    }\n  }\n  return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> ret = new ArrayList<>();\n  ret.add(SequenceRange.valueOf(0, 0));\n  ret.add(SequenceRange.valueOf(1, 1));\n  ret.add(SequenceRange.valueOf(2, 2));\n  ret.add(SequenceRange.valueOf(3, 3));\n  ret.add(SequenceRange.valueOf(4, 4));\n  ret.add(SequenceRange.valueOf(5, 5));\n  ret.add(SequenceRange.valueOf(6, 6));\n  ret.add(SequenceRange.valueOf(7, 7));\n  ret.add(SequenceRange.valueOf(8, 8));\n  ret.add(SequenceRange.valueOf(9, 9));\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  return buildSequenceRanges(this.minSequence, this.maxSequence);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> result = new ArrayList<>();\n  for (int i = 0; i < numSequences; i++) {\n    SequenceRange range = new SequenceRange(i, i);\n    result.add(range);\n  }\n  Collections.sort(\n      result,\n      new Comparator<SequenceRange>() {\n        @Override\n        public int compare(SequenceRange o1, SequenceRange o2) {\n          return Integer.compare(o1.lowerBound, o2.lowerBound);\n        }\n      });\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges() {\n  List<SequenceRange> sequenceRanges = new ArrayList<SequenceRange>();\n  SequenceRange minSequence = new SequenceRange(minSequenceBound, minSequenceBound);\n  SequenceRange maxSequence = new SequenceRange(maxSequenceBound, maxSequenceBound);\n  sequenceRanges.add(minSequence);\n  sequenceRanges.add(maxSequence);\n  return sequenceRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * build current profiles segment snapshot search sequence ranges\n */\n", "method_name": "buildSequenceRanges", "codes": ["public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> sequenceRanges = new ArrayList<>(); for (int i = 0; i < numSequences; i++) { SequenceRange range = new SequenceRange(); range.lowerBound = Math.min(minSequence, i); range.upperBound = Math.max(maxSequence, i); sequenceRanges.add(range); } return sequenceRanges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> ranges = new ArrayList<>(sequences.size()); for (int sequenceIndex = 0; sequenceIndex < sequences.size(); sequenceIndex++) { Sequence sequence = sequences.get(sequenceIndex); if (sequenceIndex == 0) { SequenceRange range = new SequenceRange(sequence.getLowerBound(), sequence.getLowerBound()); ranges.add(range); continue; } SequenceRange range = new SequenceRange(sequence.getLowerBound(), sequence.getUpperBound()); ranges.add(range); } return ranges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> ranges = new ArrayList<>(); int minSequence = 0; for (int i = 0; i < getSequences().size(); i++) { int sequenceLength = getSequences().get(i).length(); if (minSequence < sequenceLength) { minSequence = sequenceLength; } } for (int i = 0; i < getSequences().size(); i++) { int sequenceLength = getSequences().get(i).length(); if (sequenceLength < minSequence) { ranges.add(new SequenceRange(minSequence, sequenceLength)); minSequence = sequenceLength; } } ranges.add(new SequenceRange(minSequence, getSequences().size())); return ranges; }", "public List<SequenceRange> buildSequenceRanges(){ if (sequenceRanges == null) { if (sequenceRangesBatchSize == 0) { return Collections.emptyList(); } if (sequenceRangesBatchSize <= 0) { return Collections.singletonList(sequenceRanges.get(0)); } List<SequenceRange> ranges = new ArrayList<>(); int minSequence = sequenceRanges.get(0).getMinSequence(); int maxSequence = sequenceRanges.get(sequenceRanges.size() - 1).getMaxSequence(); if (minSequence < 0) { minSequence = 0; } if (maxSequence >= maxSequences) { maxSequence = maxSequences - 1; } for (SequenceRange range : sequenceRanges) { if (range.getMinSequence() >= minSequence) { ranges.add(new SequenceRange(minSequence, range.getMinSequence() + sequenceRangesBatchSize)); } if (range.getMaxSequence() <= maxSequence) { ranges.add(new SequenceRange(range.getMaxSequence(), maxSequence)); } } return ranges; } else { return sequenceRanges; } }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> result = new ArrayList<>(); SequenceRange lastSequenceRange = buildLastSequenceRange(); if (lastSequenceRange != null) { result.add(lastSequenceRange); } for (int i = 0; i < sequences.size(); i++) { Sequence sequence = sequences.get(i); SequenceRange sequenceRange = buildSequenceRange(sequence); if (sequenceRange != null) { result.add(sequenceRange); } } return result; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> ranges = new ArrayList<>(); for (int i = 0; i < sequences.size(); i++) { if (sequences.get(i).length() > SEQUENCE_RANGE_BATCH_SIZE) { ranges.add(new SequenceRange(i, sequences.get(i).length() - SEQUENCE_RANGE_BATCH_SIZE)); } } return ranges; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> ret = new ArrayList<>(); ret.add(SequenceRange.valueOf(0, 0)); ret.add(SequenceRange.valueOf(1, 1)); ret.add(SequenceRange.valueOf(2, 2)); ret.add(SequenceRange.valueOf(3, 3)); ret.add(SequenceRange.valueOf(4, 4)); ret.add(SequenceRange.valueOf(5, 5)); ret.add(SequenceRange.valueOf(6, 6)); ret.add(SequenceRange.valueOf(7, 7)); ret.add(SequenceRange.valueOf(8, 8)); ret.add(SequenceRange.valueOf(9, 9)); return ret; }", "public List<SequenceRange> buildSequenceRanges(){ return buildSequenceRanges(this.minSequence, this.maxSequence); }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> result = new ArrayList<>(); for (int i = 0; i < numSequences; i++) { SequenceRange range = new SequenceRange(i, i); result.add(range); } Collections.sort(result, new Comparator<SequenceRange>() { @Override public int compare(SequenceRange o1, SequenceRange o2) { return Integer.compare(o1.lowerBound, o2.lowerBound); } }); return result; }", "public List<SequenceRange> buildSequenceRanges(){ List<SequenceRange> sequenceRanges = new ArrayList<SequenceRange>(); SequenceRange minSequence = new SequenceRange(minSequenceBound, minSequenceBound); SequenceRange maxSequence = new SequenceRange(maxSequenceBound, maxSequenceBound); sequenceRanges.add(minSequence); sequenceRanges.add(maxSequence); return sequenceRanges; }"], "code_level": "class_runnable", "_id": "636767de1a6d9265ec018726", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n  if (timeRanges == null || timeRanges.isEmpty()) {\n    return threadSnapshots;\n  }\n  try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n      String[] fields = line.split(\"\\t\");\n      ProfileAnalyzeTimeRange timeRange = timeRanges.get(0);\n      if (fields.length != timeRange.getNumFields()) {\n        throw new IllegalArgumentException(\n            \"The number of fields in the time range of \"\n                + file.getName()\n                + \" must be equal to the number of fields in the snapshot\");\n      }\n      for (int i = 1; i < fields.length; i++) {\n        if (!fields[i].matches(\"[0-9]+\")) {\n          throw new IllegalArgumentException(\n              \"The value in the time range of \" + file.getName() + \" must be a number\");\n        }\n      }\n      if (timeRange.getLow() <= 0 || timeRange.getHigh() <= 0) {\n        throw new IllegalArgumentException(\n            \"The lower bound of the time range of \" + file.getName() + \" must be positive\");\n      }\n      if (timeRange.getHigh() > timeRange.getLow()) {\n        throw new IllegalArgumentException(\n            \"The upper bound of the time range of \"\n                + file.getName()\n                + \" must be greater than or equal to the lower bound\");\n      }\n      threadSnapshots.add(\n          new ThreadSnapshot(fields[0], fields[1], timeRange.getLow(), timeRange.getHigh()));\n    }\n  }\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  if (file == null) {\n    throw new NullPointerException(\"File cannot be null\");\n  }\n  if (!file.exists()) {\n    throw new IllegalArgumentException(\"File does not exist: \" + file.getAbsolutePath());\n  }\n  if (!file.isFile()) {\n    throw new IllegalArgumentException(\"File is not a file: \" + file.getAbsolutePath());\n  }\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<>();\n  BufferedReader reader = new BufferedReader(new FileReader(file));\n  String line;\n  while ((line = reader.readLine()) != null) {\n    String[] fields = line.split(\"\\\\s+\");\n    if (fields.length < 6) {\n      throw new IllegalArgumentException(\"Line is not a valid thread snapshot: \" + line);\n    }\n    ProfileAnalyzeTimeRange timeRange =\n        timeRanges.stream().filter(range -> range.contains(fields[0])).findFirst().orElse(null);\n    if (timeRange == null) {\n      throw new IllegalArgumentException(\"Time range is not found: \" + line);\n    }\n    long start = Long.parseLong(fields[1]);\n    long end = Long.parseLong(fields[2]);\n    long duration = Long.parseLong(fields[3]);\n    long durationInSeconds = TimeUnit.MILLISECONDS.toSeconds(duration);\n    long currentTimeInSeconds = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n    if (start <= currentTimeInSeconds && currentTimeInSeconds <= end) {\n      threadSnapshots.add(new ThreadSnapshot(fields[0], start, end, durationInSeconds));\n    } else {\n      throw new IllegalArgumentException(\"Start time must be after end time: \" + line);\n    }\n  }\n  reader.close();\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  return parseFromFileWithTimeRange(file, timeRanges, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  return parseFromFileWithTimeRange(file, timeRanges, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<>();\n  try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n      String[] parts = line.split(\",\");\n      ProfileAnalyzeTimeRange timeRange = timeRanges.get(Integer.valueOf(parts[0]));\n      if (timeRange == null) {\n        threadSnapshots.add(new ThreadSnapshot(parts[0], parts[1], parts[2], parts[3], parts[4]));\n      } else {\n        threadSnapshots.add(\n            new ThreadSnapshot(\n                parts[0],\n                parts[1],\n                parts[2],\n                parts[3],\n                parts[4],\n                timeRange.getMin(),\n                timeRange.getMax()));\n      }\n    }\n  }\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n  if (file.exists()) {\n    FileInputStream fis = new FileInputStream(file);\n    try {\n      XMLInputFactory xmlif = XMLInputFactory.newInstance();\n      XMLEventReader xmlevtr = xmlif.createXMLEventReader(fis);\n      while (xmlevtr.hasNext()) {\n        XMLEvent xmlevent = xmlevtr.nextEvent();\n        if (xmlevent.isStartElement()) {\n          StartElement startElement = xmlevent.asStartElement();\n          String tagName = startElement.getName().getLocalPart();\n          if (tagName.equals(\"snapshot\")) {\n            String threadName =\n                xmlevent.asStartElement().getAttributeByName(new QName(\"name\")).getValue();\n            String threadSnapshotPath =\n                xmlevent.asStartElement().getAttributeByName(new QName(\"path\")).getValue();\n            ProfileAnalyzeTimeRange timeRange =\n                ProfileAnalyzeTimeRange.parseFromXml(threadSnapshotPath, timeRanges);\n            threadSnapshots.add(new ThreadSnapshot(threadName, timeRange));\n          }\n        }\n      }\n    } finally {\n      fis.close();\n    }\n  }\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  return parseFromFileWithTimeRange(file, timeRanges, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  if (file == null) {\n    throw new IllegalArgumentException(\"file must not be null\");\n  }\n  if (timeRanges == null) {\n    throw new IllegalArgumentException(\"timeRanges must not be null\");\n  }\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n  BufferedReader reader = null;\n  try {\n    reader = new BufferedReader(new FileReader(file));\n    String line;\n    while ((line = reader.readLine()) != null) {\n      if (line.trim().isEmpty()) {\n        continue;\n      }\n      String[] tokens = line.split(\" \");\n      if (tokens.length != 3) {\n        continue;\n      }\n      ProfileAnalyzeTimeRange timeRange =\n          new ProfileAnalyzeTimeRange(tokens[0], tokens[1], tokens[2]);\n      if (!timeRanges.contains(timeRange)) {\n        threadSnapshots.add(new ThreadSnapshot(tokens[0], tokens[1], tokens[2], timeRange));\n      }\n    }\n  } finally {\n    if (reader != null) {\n      reader.close();\n    }\n  }\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  List<ThreadSnapshot> threadSnapshots = new ArrayList<>();\n  BufferedReader reader = new BufferedReader(new FileReader(file));\n  String line = reader.readLine();\n  while (line != null) {\n    String[] tokens = line.split(\"\\t\");\n    if (tokens.length == 3) {\n      ProfileAnalyzeTimeRange timeRange = timeRanges.get(Integer.parseInt(tokens[0]));\n      if (timeRange == null) {\n        throw new IllegalArgumentException(\n            \"The time range specified for the thread snapshot is not defined: \" + tokens[0]);\n      }\n      threadSnapshots.add(\n          new ThreadSnapshot(\n              timeRange.getStartTime(),\n              timeRange.getEndTime(),\n              Integer.parseInt(tokens[1]),\n              Integer.parseInt(tokens[2])));\n    }\n    line = reader.readLine();\n  }\n  reader.close();\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(\n    File file, List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n  final List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n  final BufferedReader reader = new BufferedReader(new FileReader(file));\n  String line;\n  while ((line = reader.readLine()) != null) {\n    final String[] parts = line.split(\"\\t\");\n    final ProfileAnalyzeTimeRange timeRange = new ProfileAnalyzeTimeRange(parts[0], parts[1]);\n    threadSnapshots.add(new ThreadSnapshot(parts[2], timeRange));\n  }\n  reader.close();\n  return threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * load thread snapshots in appointing time range\n */\n", "method_name": "parseFromFileWithTimeRange", "codes": ["public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>(); if (timeRanges == null || timeRanges.isEmpty()) { return threadSnapshots; } try (BufferedReader reader = new BufferedReader(new FileReader(file))) { String line; while ((line = reader.readLine()) != null) { String[] fields = line.split(\"\\t\"); ProfileAnalyzeTimeRange timeRange = timeRanges.get(0); if (fields.length != timeRange.getNumFields()) { throw new IllegalArgumentException(\"The number of fields in the time range of \" + file.getName() + \" must be equal to the number of fields in the snapshot\"); } for (int i = 1; i < fields.length; i++) { if (!fields[i].matches(\"[0-9]+\")) { throw new IllegalArgumentException(\"The value in the time range of \" + file.getName() + \" must be a number\"); } } if (timeRange.getLow() <= 0 || timeRange.getHigh() <= 0) { throw new IllegalArgumentException(\"The lower bound of the time range of \" + file.getName() + \" must be positive\"); } if (timeRange.getHigh() > timeRange.getLow()) { throw new IllegalArgumentException(\"The upper bound of the time range of \" + file.getName() + \" must be greater than or equal to the lower bound\"); } threadSnapshots.add(new ThreadSnapshot(fields[0], fields[1], timeRange.getLow(), timeRange.getHigh())); } } return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { if (file == null) { throw new NullPointerException(\"File cannot be null\"); } if (!file.exists()) { throw new IllegalArgumentException(\"File does not exist: \" + file.getAbsolutePath()); } if (!file.isFile()) { throw new IllegalArgumentException(\"File is not a file: \" + file.getAbsolutePath()); } List<ThreadSnapshot> threadSnapshots = new ArrayList<>(); BufferedReader reader = new BufferedReader(new FileReader(file)); String line; while ((line = reader.readLine()) != null) { String[] fields = line.split(\"\\\\s+\"); if (fields.length < 6) { throw new IllegalArgumentException(\"Line is not a valid thread snapshot: \" + line); } ProfileAnalyzeTimeRange timeRange = timeRanges.stream().filter(range -> range.contains(fields[0])).findFirst().orElse(null); if (timeRange == null) { throw new IllegalArgumentException(\"Time range is not found: \" + line); } long start = Long.parseLong(fields[1]); long end = Long.parseLong(fields[2]); long duration = Long.parseLong(fields[3]); long durationInSeconds = TimeUnit.MILLISECONDS.toSeconds(duration); long currentTimeInSeconds = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis()); if (start <= currentTimeInSeconds && currentTimeInSeconds <= end) { threadSnapshots.add(new ThreadSnapshot(fields[0], start, end, durationInSeconds)); } else { throw new IllegalArgumentException(\"Start time must be after end time: \" + line); } } reader.close(); return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { return parseFromFileWithTimeRange(file, timeRanges, null); }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { return parseFromFileWithTimeRange(file, timeRanges, null); }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { List<ThreadSnapshot> threadSnapshots = new ArrayList<>(); try (BufferedReader reader = new BufferedReader(new FileReader(file))) { String line; while ((line = reader.readLine()) != null) { String[] parts = line.split(\",\"); ProfileAnalyzeTimeRange timeRange = timeRanges.get(Integer.valueOf(parts[0])); if (timeRange == null) { threadSnapshots.add(new ThreadSnapshot(parts[0], parts[1], parts[2], parts[3], parts[4])); } else { threadSnapshots.add(new ThreadSnapshot(parts[0], parts[1], parts[2], parts[3], parts[4], timeRange.getMin(), timeRange.getMax())); } } } return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>(); if (file.exists()) { FileInputStream fis = new FileInputStream(file); try { XMLInputFactory xmlif = XMLInputFactory.newInstance(); XMLEventReader xmlevtr = xmlif.createXMLEventReader(fis); while (xmlevtr.hasNext()) { XMLEvent xmlevent = xmlevtr.nextEvent(); if (xmlevent.isStartElement()) { StartElement startElement = xmlevent.asStartElement(); String tagName = startElement.getName().getLocalPart(); if (tagName.equals(\"snapshot\")) { String threadName = xmlevent.asStartElement().getAttributeByName(new QName(\"name\")).getValue(); String threadSnapshotPath = xmlevent.asStartElement().getAttributeByName(new QName(\"path\")).getValue(); ProfileAnalyzeTimeRange timeRange = ProfileAnalyzeTimeRange.parseFromXml(threadSnapshotPath, timeRanges); threadSnapshots.add(new ThreadSnapshot(threadName, timeRange)); } } } } finally { fis.close(); } } return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { return parseFromFileWithTimeRange(file, timeRanges, null); }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { if (file == null) { throw new IllegalArgumentException(\"file must not be null\"); } if (timeRanges == null) { throw new IllegalArgumentException(\"timeRanges must not be null\"); } List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>(); BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(file)); String line; while ((line = reader.readLine()) != null) { if (line.trim().isEmpty()) { continue; } String[] tokens = line.split(\" \"); if (tokens.length != 3) { continue; } ProfileAnalyzeTimeRange timeRange = new ProfileAnalyzeTimeRange(tokens[0], tokens[1], tokens[2]); if (!timeRanges.contains(timeRange)) { threadSnapshots.add(new ThreadSnapshot(tokens[0], tokens[1], tokens[2], timeRange)); } } } finally { if (reader != null) { reader.close(); } } return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { List<ThreadSnapshot> threadSnapshots = new ArrayList<>(); BufferedReader reader = new BufferedReader(new FileReader(file)); String line = reader.readLine(); while (line != null) { String[] tokens = line.split(\"\\t\"); if (tokens.length == 3) { ProfileAnalyzeTimeRange timeRange = timeRanges.get(Integer.parseInt(tokens[0])); if (timeRange == null) { throw new IllegalArgumentException(\"The time range specified for the thread snapshot is not defined: \" + tokens[0]); } threadSnapshots.add(new ThreadSnapshot(timeRange.getStartTime(), timeRange.getEndTime(), Integer.parseInt(tokens[1]), Integer.parseInt(tokens[2]))); } line = reader.readLine(); } reader.close(); return threadSnapshots; }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException { final List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>(); final BufferedReader reader = new BufferedReader(new FileReader(file)); String line; while ((line = reader.readLine()) != null) { final String[] parts = line.split(\"\\t\"); final ProfileAnalyzeTimeRange timeRange = new ProfileAnalyzeTimeRange(parts[0], parts[1]); threadSnapshots.add(new ThreadSnapshot(parts[2], timeRange)); } reader.close(); return threadSnapshots; }"], "code_level": "project_runnable", "_id": "636767e11a6d9265ec018790", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject json = new JsonObject();\n  for (KeyStringValuePair pair : properties) {\n    json.addProperty(pair.getKey(), pair.getValue());\n  }\n  return json;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonProperties = new JsonObject();\n  for (KeyStringValuePair kvp : properties) {\n    jsonProperties.addProperty(kvp.getKey(), kvp.getValue());\n  }\n  return jsonProperties;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonObject = new JsonObject();\n  for (KeyStringValuePair keyValue : properties) {\n    jsonObject.addProperty(keyValue.getKey(), keyValue.getValue());\n  }\n  return jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonProperties = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    jsonProperties.addProperty(property.getKey(), property.getValue());\n  }\n  return jsonProperties;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject json = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    json.addProperty(property.getKey(), property.getValue());\n  }\n  return json;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonObject = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    jsonObject.addProperty(property.getKey(), property.getValue());\n  }\n  return jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonObject = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    if (property.getKey().equals(\"id\")) {\n      jsonObject.addProperty(\"id\", property.getValue());\n    } else if (property.getKey().equals(\"name\")) {\n      jsonObject.addProperty(\"name\", property.getValue());\n    } else if (property.getKey().equals(\"url\")) {\n      jsonObject.addProperty(\"url\", property.getValue());\n    } else if (property.getKey().equals(\"status\")) {\n      jsonObject.addProperty(\"status\", property.getValue());\n    } else if (property.getKey().equals(\"description\")) {\n      jsonObject.addProperty(\"description\", property.getValue());\n    }\n  }\n  return jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonObject = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    jsonObject.addProperty(property.getKey(), property.getValue());\n  }\n  return jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObjectBuilder json = Json.createObjectBuilder();\n  for (KeyStringValuePair pair : properties) {\n    json.add(pair.getKey(), pair.getValue());\n  }\n  return json.build();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties) {\n  JsonObject jsonObject = new JsonObject();\n  for (KeyStringValuePair property : properties) {\n    jsonObject.addProperty(property.getKey(), property.getValue());\n  }\n  return jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Convert process properties to source data\n */\n", "method_name": "convertProperties", "codes": ["private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject json = new JsonObject(); for (KeyStringValuePair pair : properties) { json.addProperty(pair.getKey(), pair.getValue()); } return json; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonProperties = new JsonObject(); for (KeyStringValuePair kvp : properties) { jsonProperties.addProperty(kvp.getKey(), kvp.getValue()); } return jsonProperties; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair keyValue : properties) { jsonObject.addProperty(keyValue.getKey(), keyValue.getValue()); } return jsonObject; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonProperties = new JsonObject(); for (KeyStringValuePair property : properties) { jsonProperties.addProperty(property.getKey(), property.getValue()); } return jsonProperties; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject json = new JsonObject(); for (KeyStringValuePair property : properties) { json.addProperty(property.getKey(), property.getValue()); } return json; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair property : properties) { jsonObject.addProperty(property.getKey(), property.getValue()); } return jsonObject; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair property : properties) { if (property.getKey().equals(\"id\")) { jsonObject.addProperty(\"id\", property.getValue()); } else if (property.getKey().equals(\"name\")) { jsonObject.addProperty(\"name\", property.getValue()); } else if (property.getKey().equals(\"url\")) { jsonObject.addProperty(\"url\", property.getValue()); } else if (property.getKey().equals(\"status\")) { jsonObject.addProperty(\"status\", property.getValue()); } else if (property.getKey().equals(\"description\")) { jsonObject.addProperty(\"description\", property.getValue()); } } return jsonObject; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair property : properties) { jsonObject.addProperty(property.getKey(), property.getValue()); } return jsonObject; }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObjectBuilder json = Json.createObjectBuilder(); for (KeyStringValuePair pair : properties) { json.add(pair.getKey(), pair.getValue()); } return json.build(); }", "private JsonObject convertProperties(List<KeyStringValuePair> properties){ JsonObject jsonObject = new JsonObject(); for (KeyStringValuePair property : properties) { jsonObject.addProperty(property.getKey(), property.getValue()); } return jsonObject; }"], "code_level": "project_runnable", "_id": "636767e01a6d9265ec018764", "project_name": "skywalking-master"}, {"generate_results": [{"generate_code": "private int pop() {\n  final int value = outputFrame.pop();\n  if (value == Type.LONG || value == Type.DOUBLE) {\n    return value;\n  }\n  throw new IllegalStateException();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  if (stack.size() == 1) {\n    return stack.get(0);\n  } else {\n    int top = stack.get(0);\n    stack.remove(0);\n    return top;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  int val = outputFrame.pop();\n  if (val == -1) {\n    throw new RuntimeException(\"pop: \" + val + \" out of \" + outputFrame.size());\n  }\n  return val;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  int result = mOutputStack[mOutputStackTop--];\n  if (mOutputStackTop < 0) {\n    if (mFrames.isEmpty()) {\n      throw new IllegalStateException(\"Invalid frame\");\n    }\n    mOutputStackTop = mFrames.size() - 1;\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  if (outputFrame.isEmpty()) {\n    throw new IllegalStateException(\"Stack underflow\");\n  }\n  return outputFrame.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  if (outputStackTop == -1) {\n    throw new RuntimeException(\"Stack underflow\");\n  }\n  return stack[outputStackTop--];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  int value = (int) outputStack[outputStackTop];\n  outputStackTop--;\n  return value;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int pop() {\n  int result = fp - fp_top;\n  fp = fp_top;\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  int result = frame.pop();\n  if (result == Type.VOID) {\n    throw new RuntimeException(\"Internal error: void result for frame is not a void\");\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop() {\n  return (stack.pop());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n", "method_name": "pop", "codes": ["private int pop(){ final int value = outputFrame.pop(); if (value == Type.LONG || value == Type.DOUBLE) { return value; } throw new IllegalStateException(); }", "private int pop(){ if (stack.size() == 1) { return stack.get(0); } else { int top = stack.get(0); stack.remove(0); return top; } }", "private int pop(){ int val = outputFrame.pop(); if (val == -1) { throw new RuntimeException(\"pop: \" + val + \" out of \" + outputFrame.size()); } return val; }", "private int pop(){ int result = mOutputStack[mOutputStackTop--]; if (mOutputStackTop < 0) { if (mFrames.isEmpty()) { throw new IllegalStateException(\"Invalid frame\"); } mOutputStackTop = mFrames.size() - 1; } return result; }", "private int pop(){ if (outputFrame.isEmpty()) { throw new IllegalStateException(\"Stack underflow\"); } return outputFrame.pop(); }", "private int pop(){ if (outputStackTop == -1) { throw new RuntimeException(\"Stack underflow\"); } return stack[outputStackTop--]; }", "private int pop(){ int value = (int) outputStack[outputStackTop]; outputStackTop--; return value; }", "private int pop(){ int result = fp - fp_top; fp = fp_top; return result; }", "private int pop(){ int result = frame.pop(); if (result == Type.VOID) { throw new RuntimeException(\"Internal error: void result for frame is not a void\"); } return result; }", "private int pop(){ return (stack.pop()); }"], "code_level": "self_contained", "_id": "636766a91a6d9265ec0175c2", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if ((offset & ~0xFFFF) != 0) {\n    throw new IllegalArgumentException(\"offset is not a valid offset: \" + offset);\n  }\n  if ((numLocal & ~0xFFFF) != 0) {\n    throw new IllegalArgumentException(\"numLocal is not a valid numLocal: \" + numLocal);\n  }\n  if ((numStack & ~0xFFFF) != 0) {\n    throw new IllegalArgumentException(\"numStack is not a valid numStack: \" + numStack);\n  }\n  if ((this.frame == null) || (this.frame.length < offset + numLocal + numStack)) {\n    final int newLength = this.frame = new int[offset + numLocal + numStack];\n    System.arraycopy(this.frame, 0, newLength, 0, this.frame.length);\n  }\n  this.frame[offset] = 1;\n  this.frame[offset + 1] = offset;\n  this.frame[offset + 2] = numLocal;\n  this.frame[offset + 3] = numStack;\n  return 4;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if (currentFrame == null) {\n    currentFrame = new Frame();\n  } else if (currentFrame.limit + numLocal + numStack > maxLocals) {\n    resize(maxStackSize);\n  }\n  currentFrame.offset = offset;\n  currentFrame.numLocal = numLocal;\n  currentFrame.numStack = numStack;\n  return 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if ((offset < 0) || (offset >= mFrames.length)) {\n    throw new IllegalArgumentException(\"offset out of range\");\n  }\n  if (numLocal < 0) {\n    throw new IllegalArgumentException(\"numLocal out of range\");\n  }\n  if (numStack < 0) {\n    throw new IllegalArgumentException(\"numStack out of range\");\n  }\n  if (numLocal > mFrames[offset].getNumStack()) {\n    throw new IllegalArgumentException(\"numLocal out of range\");\n  }\n  if (numStack > mFrames[offset].getNumLocals()) {\n    throw new IllegalArgumentException(\"numStack out of range\");\n  }\n  if (numStack > mFrames[offset].getNumStack()) {\n    throw new IllegalArgumentException(\"numStack out of range\");\n  }\n  mFrames[offset].initInputFrame(mFrames[offset].getNumLocals(), mFrames[offset].getNumStack());\n  return 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if ((flags & VISITOR) == 0) {\n    return 3;\n  }\n  if (numLocal < 0) {\n    throw new IllegalArgumentException(\"numLocal must be >= 0: \" + numLocal);\n  }\n  if (numStack < 0) {\n    throw new IllegalArgumentException(\"numStack must be >= 0: \" + numStack);\n  }\n  if (offset < 0) {\n    throw new IllegalArgumentException(\"offset must be >= 0: \" + offset);\n  }\n  if ((offset & ~3) != 0) {\n    throw new IllegalArgumentException(\"offset is not a multiple of 3: \" + offset);\n  }\n  final int numBytes = numLocal * numStack;\n  final int nLocal = locals.size();\n  final int nStack = stack.size();\n  if (nLocal != numBytes) {\n    throw new IllegalArgumentException(\n        \"numLocal (\" + numLocal + \") is not the same as numBytes (\" + numBytes + \")\");\n  }\n  if (nStack != numBytes) {\n    throw new IllegalArgumentException(\n        \"numStack (\" + numStack + \") is not the same as numBytes (\" + numBytes + \")\");\n  }\n  if (numLocal == 0 && numStack == 0) {\n    return 0;\n  }\n  final int nLocalMin = nLocal << 1;\n  final int nStackMin = nStack << 1;\n  if (nLocalMin < offset) {\n    return nLocalMin;\n  }\n  if (nStackMin < offset) {\n    return nStackMin;\n  }\n  int offsetMin = offset;\n  if ((flags & GETSTATIC) != 0 && (numLocal < nLocal || numStack < nStack)) {\n    offsetMin += numLocal;\n  }\n  if ((flags & PUTSTATIC) != 0 && (numLocal > nLocal || numStack > nStack)) {\n    offsetMin += numLocal;\n  }\n  return offsetMin;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if (this.frame == null) {\n    this.frame = new Frame();\n    this.frame.offset = offset;\n    this.frame.numLocal = numLocal;\n    this.frame.numStack = numStack;\n  } else {\n    this.frame.numLocal += numLocal;\n    this.frame.numStack += numStack;\n  }\n  return 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if (numLocal < 0) {\n    throw new IllegalArgumentException();\n  }\n  if (numStack < 0) {\n    throw new IllegalArgumentException();\n  }\n  if (numLocal >= maxLocals) {\n    throw new IllegalArgumentException();\n  }\n  if (numStack >= maxStack) {\n    throw new IllegalArgumentException();\n  }\n  if (frames[prevFrame] == null) {\n    frames[prevFrame] = new Frame();\n  }\n  Frame frame = frames[prevFrame];\n  frame.offset = offset;\n  frame.numLocals = numLocal;\n  frame.numStack = numStack;\n  prevFrame = nextFrame;\n  nextFrame = frame.numLocals + frame.numStack;\n  return 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  return 3;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if ((mv != null) && ((mv.visitFrameStart(offset, numLocal, numStack)) != 0)) return 3;\n  return 4;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if ((numLocal < 0) || (numLocal > 3) || (numStack < 0) || (numStack > 3)) {\n    throw new IllegalArgumentException(\"numLocal=\" + numLocal + \", numStack=\" + numStack);\n  }\n  this.peek().numLocal = numLocal;\n  this.peek().numStack = numStack;\n  return 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n  if (this.stackMap == null) {\n    this.stackMap = new int[this.maxStackSize];\n  }\n  ++this.stackMapCount;\n  if (this.stackMapCount >= this.stackMap.length) {\n    final int[] newMap = new int[this.stackMapCount * 2];\n    System.arraycopy(this.stackMap, 0, newMap, 0, this.stackMap.length);\n    this.stackMap = newMap;\n  }\n  this.stackMap[this.stackMapCount - 1] = offset;\n  this.stackMap[this.stackMapCount - 2] = numLocal;\n  this.stackMap[this.stackMapCount - 3] = numStack;\n  return 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.\n * @param offset   the bytecode offset of the instruction to which the frame corresponds.\n * @param numLocal the number of local variables in the frame.\n * @param numStack the number of stack elements in the frame.\n * @return the index of the next element to be written in this frame.\n */\n", "method_name": "visitFrameStart", "codes": ["int visitFrameStart(final int offset,final int numLocal,final int numStack){ if ((offset & ~0xFFFF) != 0) { throw new IllegalArgumentException(\"offset is not a valid offset: \" + offset); } if ((numLocal & ~0xFFFF) != 0) { throw new IllegalArgumentException(\"numLocal is not a valid numLocal: \" + numLocal); } if ((numStack & ~0xFFFF) != 0) { throw new IllegalArgumentException(\"numStack is not a valid numStack: \" + numStack); } if ((this.frame == null) || (this.frame.length < offset + numLocal + numStack)) { final int newLength = this.frame = new int[offset + numLocal + numStack]; System.arraycopy(this.frame, 0, newLength, 0, this.frame.length); } this.frame[offset] = 1; this.frame[offset + 1] = offset; this.frame[offset + 2] = numLocal; this.frame[offset + 3] = numStack; return 4; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if (currentFrame == null) { currentFrame = new Frame(); } else if (currentFrame.limit + numLocal + numStack > maxLocals) { resize(maxStackSize); } currentFrame.offset = offset; currentFrame.numLocal = numLocal; currentFrame.numStack = numStack; return 3; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if ((offset < 0) || (offset >= mFrames.length)) { throw new IllegalArgumentException(\"offset out of range\"); } if (numLocal < 0) { throw new IllegalArgumentException(\"numLocal out of range\"); } if (numStack < 0) { throw new IllegalArgumentException(\"numStack out of range\"); } if (numLocal > mFrames[offset].getNumStack()) { throw new IllegalArgumentException(\"numLocal out of range\"); } if (numStack > mFrames[offset].getNumLocals()) { throw new IllegalArgumentException(\"numStack out of range\"); } if (numStack > mFrames[offset].getNumStack()) { throw new IllegalArgumentException(\"numStack out of range\"); } mFrames[offset].initInputFrame(mFrames[offset].getNumLocals(), mFrames[offset].getNumStack()); return 3; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if ((flags & VISITOR) == 0) { return 3; } if (numLocal < 0) { throw new IllegalArgumentException(\"numLocal must be >= 0: \" + numLocal); } if (numStack < 0) { throw new IllegalArgumentException(\"numStack must be >= 0: \" + numStack); } if (offset < 0) { throw new IllegalArgumentException(\"offset must be >= 0: \" + offset); } if ((offset & ~3) != 0) { throw new IllegalArgumentException(\"offset is not a multiple of 3: \" + offset); } final int numBytes = numLocal * numStack; final int nLocal = locals.size(); final int nStack = stack.size(); if (nLocal != numBytes) { throw new IllegalArgumentException(\"numLocal (\" + numLocal + \") is not the same as numBytes (\" + numBytes + \")\"); } if (nStack != numBytes) { throw new IllegalArgumentException(\"numStack (\" + numStack + \") is not the same as numBytes (\" + numBytes + \")\"); } if (numLocal == 0 && numStack == 0) { return 0; } final int nLocalMin = nLocal << 1; final int nStackMin = nStack << 1; if (nLocalMin < offset) { return nLocalMin; } if (nStackMin < offset) { return nStackMin; } int offsetMin = offset; if ((flags & GETSTATIC) != 0 && (numLocal < nLocal || numStack < nStack)) { offsetMin += numLocal; } if ((flags & PUTSTATIC) != 0 && (numLocal > nLocal || numStack > nStack)) { offsetMin += numLocal; } return offsetMin; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if (this.frame == null) { this.frame = new Frame(); this.frame.offset = offset; this.frame.numLocal = numLocal; this.frame.numStack = numStack; } else { this.frame.numLocal += numLocal; this.frame.numStack += numStack; } return 3; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if (numLocal < 0) { throw new IllegalArgumentException(); } if (numStack < 0) { throw new IllegalArgumentException(); } if (numLocal >= maxLocals) { throw new IllegalArgumentException(); } if (numStack >= maxStack) { throw new IllegalArgumentException(); } if (frames[prevFrame] == null) { frames[prevFrame] = new Frame(); } Frame frame = frames[prevFrame]; frame.offset = offset; frame.numLocals = numLocal; frame.numStack = numStack; prevFrame = nextFrame; nextFrame = frame.numLocals + frame.numStack; return 3; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ return 3; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if ((mv != null) && ((mv.visitFrameStart(offset, numLocal, numStack)) != 0)) return 3; return 4; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if ((numLocal < 0) || (numLocal > 3) || (numStack < 0) || (numStack > 3)) { throw new IllegalArgumentException(\"numLocal=\" + numLocal + \", numStack=\" + numStack); } this.peek().numLocal = numLocal; this.peek().numStack = numStack; return 3; }", "int visitFrameStart(final int offset,final int numLocal,final int numStack){ if (this.stackMap == null) { this.stackMap = new int[this.maxStackSize]; } ++this.stackMapCount; if (this.stackMapCount >= this.stackMap.length) { final int[] newMap = new int[this.stackMapCount * 2]; System.arraycopy(this.stackMap, 0, newMap, 0, this.stackMap.length); this.stackMap = newMap; } this.stackMap[this.stackMapCount - 1] = offset; this.stackMap[this.stackMapCount - 2] = numLocal; this.stackMap[this.stackMapCount - 3] = numStack; return 3; }"], "code_level": "self_contained", "_id": "636766aa1a6d9265ec0175ce", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private void enlarge(final int size) {\n  final byte[] temp = new byte[size];\n  for (int i = 0; i < m_data.length; ++i) {\n    temp[i] = m_data[i];\n  }\n  m_data = temp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] newArray = new byte[size];\n  System.arraycopy(this.data, 0, newArray, 0, this.data.length);\n  this.data = newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final T[] temp = (T[]) new Object[size];\n  for (int i = 0; i < size; i++) {\n    temp[i] = data[i];\n  }\n  data = temp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final Object[] tmp = new Object[size];\n  System.arraycopy(this.data, 0, tmp, 0, size);\n  this.data = tmp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  if (size <= m_data.length) {\n    return;\n  }\n  final byte[] newData = new byte[size];\n  System.arraycopy(m_data, 0, newData, 0, m_data.length);\n  m_data = newData;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] newData = new byte[size * 2];\n  final int numElements = this.data.length;\n  for (int i = 0; i < numElements; i++) {\n    newData[i] = this.data[i];\n  }\n  this.data = newData;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int[] data = this.data;\n  final int newCapacity = (this.size + size) * 2;\n  if (newCapacity <= MAX_ARRAY_SIZE) {\n    return;\n  }\n  final int[] newData = new int[newCapacity];\n  System.arraycopy(data, 0, newData, 0, size);\n  this.data = newData;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final int[] old = array;\n  array = new int[size];\n  System.arraycopy(old, 0, array, 0, old.length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] tmp = new byte[size];\n  System.arraycopy(this.data, 0, tmp, 0, this.data.length);\n  this.data = tmp;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size) {\n  final byte[] temp = new byte[size];\n  for (int i = 0; i < size; i++) {\n    temp[i] = data[i];\n  }\n  data = temp;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n", "method_name": "enlarge", "codes": ["private void enlarge(final int size){ final byte[] temp = new byte[size]; for (int i = 0; i < m_data.length; ++i) { temp[i] = m_data[i]; } m_data = temp; }", "private void enlarge(final int size){ final byte[] newArray = new byte[size]; System.arraycopy(this.data, 0, newArray, 0, this.data.length); this.data = newArray; }", "private void enlarge(final int size){ final T[] temp = (T[]) new Object[size]; for (int i = 0; i < size; i++) { temp[i] = data[i]; } data = temp; }", "private void enlarge(final int size){ final Object[] tmp = new Object[size]; System.arraycopy(this.data, 0, tmp, 0, size); this.data = tmp; }", "private void enlarge(final int size){ if (size <= m_data.length) { return; } final byte[] newData = new byte[size]; System.arraycopy(m_data, 0, newData, 0, m_data.length); m_data = newData; }", "private void enlarge(final int size){ final byte[] newData = new byte[size * 2]; final int numElements = this.data.length; for (int i = 0; i < numElements; i++) { newData[i] = this.data[i]; } this.data = newData; }", "private void enlarge(final int size){ final int[] data = this.data; final int newCapacity = (this.size + size) * 2; if (newCapacity <= MAX_ARRAY_SIZE) { return; } final int[] newData = new int[newCapacity]; System.arraycopy(data, 0, newData, 0, size); this.data = newData; }", "private void enlarge(final int size){ final int[] old = array; array = new int[size]; System.arraycopy(old, 0, array, 0, old.length); }", "private void enlarge(final int size){ final byte[] tmp = new byte[size]; System.arraycopy(this.data, 0, tmp, 0, this.data.length); this.data = tmp; }", "private void enlarge(final int size){ final byte[] temp = new byte[size]; for (int i = 0; i < size; i++) { temp[i] = data[i]; } data = temp; }"], "code_level": "self_contained", "_id": "636766a91a6d9265ec0175c1", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  final int byteLengthNoCopy = byteLength - byteOffset;\n  if (byteLengthNoCopy > 0) {\n    System.arraycopy(\n        byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLengthNoCopy);\n    this.byteOffset += byteLengthNoCopy;\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > byteArrayLength) {\n    throw new IllegalArgumentException(\"byteLength > byteArrayLength\");\n  }\n  if (byteArrayValue == null) {\n    throw new NullPointerException(\"byteArrayValue\");\n  }\n  if (byteOffset < 0) {\n    throw new IllegalArgumentException(\"byteOffset < 0\");\n  }\n  if (byteOffset + byteLength > byteArrayLength) {\n    throw new IllegalArgumentException(\"byteOffset + byteLength > byteArrayLength\");\n  }\n  if (byteLength == 0) {\n    return this;\n  }\n  if (byteArrayValue.length - byteOffset < byteLength) {\n    throw new IllegalArgumentException(\"byteArrayValue.length - byteOffset < byteLength\");\n  }\n  if (byteArrayValue.length - byteOffset > 0) {\n    System.arraycopy(\n        byteArrayValue, byteOffset, this.byteArray, this.byteArrayLength, byteLength);\n    this.byteArrayLength += byteLength;\n  } else {\n    this.byteArrayLength += byteLength;\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > 8) {\n    throw new IllegalArgumentException(\n        \"Cannot put a byte array of length \" + byteLength + \", larger than 8 bytes\");\n  }\n  if (byteLength == 0) {\n    return this;\n  }\n  if (byteLength == byteArrayValue.length) {\n    putByte(byteArrayValue[0]);\n  } else {\n    putByteArray(byteArrayValue, byteOffset, byteLength);\n  }\n  return this;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteArrayValue == null) {\n    putShort((short) 0);\n    return this;\n  }\n  int length = byteLength;\n  if (length > Short.MAX_VALUE) {\n    throw new IllegalArgumentException(\n        \"byte length (\"\n            + byteLength\n            + \") is longer than Short.MAX_VALUE, can't fit into a byte vector\");\n  }\n  if ((byteOffset < 0) || (byteOffset > byteArrayValue.length)) {\n    throw new IndexOutOfBoundsException(\n        \"byteOffset (\"\n            + byteOffset\n            + \") is out of range for byte array: \"\n            + byteArrayValue.length);\n  }\n  if (byteLength == length) {\n    return this;\n  }\n  if (byteLength > 0) {\n    putShort((short) length);\n  }\n  int pos = byteOffset;\n  for (final byte b : byteArrayValue) {\n    putByte(b);\n    pos++;\n  }\n  return this;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  final int currentLength = this.length;\n  if (byteLength > currentLength) {\n    throw new IllegalArgumentException();\n  }\n  final int numBytes = byteLength;\n  if (this.initialized) {\n    if (this.bytes.length < numBytes) {\n      final byte[] newBytes = new byte[numBytes];\n      System.arraycopy(this.bytes, 0, newBytes, 0, this.bytes.length);\n      this.bytes = newBytes;\n    }\n  } else {\n    this.initializeBytes(numBytes);\n  }\n  System.arraycopy(byteArrayValue, byteOffset, this.bytes, this.length, numBytes);\n  this.length = numBytes;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > byteArrayValue.length - byteOffset) {\n    throw new IllegalArgumentException(\n        \"byteArrayValue.length(\" + byteLength + \") > byteOffset(\" + byteOffset + \")\");\n  }\n  if (byteOffset > 0 && byteOffset <= byteArrayValue.length - 1) {\n    put(byteArrayValue, byteOffset, byteLength);\n  } else {\n    put(byteArrayValue, 0, byteLength);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > 0) {\n    if (byteLength > this._length) {\n      _resize(byteLength);\n    }\n    System.arraycopy(byteArrayValue, byteOffset, this._data, this._length, byteLength);\n    this._length += byteLength;\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength != 0) {\n    int byteLengthEncoded = CodedOutputStream.computeRawVarint32Size(byteLength);\n    putRawBytes(byteArrayValue, byteOffset, byteLengthEncoded);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteLength > 4) {\n    throw new IllegalArgumentException(\"byteArrayValue.length > 4\");\n  }\n  if (byteLength == 0) {\n    return putInt(0);\n  }\n  if (byteLength == 1) {\n    return putInt(0xff & byteArrayValue[byteOffset]);\n  }\n  if (byteLength == 2) {\n    return putInt(\n        0xff & byteArrayValue[byteOffset] | (0xff00 & byteArrayValue[byteOffset + 1]) << 8);\n  }\n  if (byteLength == 3) {\n    return putInt(\n        0xff & byteArrayValue[byteOffset]\n            | (0xff00 & byteArrayValue[byteOffset + 1]) << 16\n            | (0xff0000 & byteArrayValue[byteOffset + 2]) << 24);\n  }\n  if (byteLength == 4) {\n    return putInt(\n        0xff & byteArrayValue[byteOffset]\n            | (0xff00 & byteArrayValue[byteOffset + 1]) << 24\n            | (0xff0000 & byteArrayValue[byteOffset + 2]) << 32\n            | (0xff0000 & byteArrayValue[byteOffset + 3]) << 40\n            | (0xff0000 & byteArrayValue[byteOffset + 4]) << 48);\n  }\n  throw new IllegalArgumentException(\"byteLength must be a multiple of 4\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(\n    final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n  if (byteArrayValue == null) {\n    putNull();\n  } else {\n    putBytes(byteArrayValue, byteOffset, byteLength);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n * @param byteLength     number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n", "method_name": "putByteArray", "codes": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ final int byteLengthNoCopy = byteLength - byteOffset; if (byteLengthNoCopy > 0) { System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteOffset, byteLengthNoCopy); this.byteOffset += byteLengthNoCopy; } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > byteArrayLength) { throw new IllegalArgumentException(\"byteLength > byteArrayLength\"); } if (byteArrayValue == null) { throw new NullPointerException(\"byteArrayValue\"); } if (byteOffset < 0) { throw new IllegalArgumentException(\"byteOffset < 0\"); } if (byteOffset + byteLength > byteArrayLength) { throw new IllegalArgumentException(\"byteOffset + byteLength > byteArrayLength\"); } if (byteLength == 0) { return this; } if (byteArrayValue.length - byteOffset < byteLength) { throw new IllegalArgumentException(\"byteArrayValue.length - byteOffset < byteLength\"); } if (byteArrayValue.length - byteOffset > 0) { System.arraycopy(byteArrayValue, byteOffset, this.byteArray, this.byteArrayLength, byteLength); this.byteArrayLength += byteLength; } else { this.byteArrayLength += byteLength; } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > 8) { throw new IllegalArgumentException(\"Cannot put a byte array of length \" + byteLength + \", larger than 8 bytes\"); } if (byteLength == 0) { return this; } if (byteLength == byteArrayValue.length) { putByte(byteArrayValue[0]); } else { putByteArray(byteArrayValue, byteOffset, byteLength); } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteArrayValue == null) { putShort((short) 0); return this; } int length = byteLength; if (length > Short.MAX_VALUE) { throw new IllegalArgumentException(\"byte length (\" + byteLength + \") is longer than Short.MAX_VALUE, can't fit into a byte vector\"); } if ((byteOffset < 0) || (byteOffset > byteArrayValue.length)) { throw new IndexOutOfBoundsException(\"byteOffset (\" + byteOffset + \") is out of range for byte array: \" + byteArrayValue.length); } if (byteLength == length) { return this; } if (byteLength > 0) { putShort((short) length); } int pos = byteOffset; for (final byte b : byteArrayValue) { putByte(b); pos++; } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ final int currentLength = this.length; if (byteLength > currentLength) { throw new IllegalArgumentException(); } final int numBytes = byteLength; if (this.initialized) { if (this.bytes.length < numBytes) { final byte[] newBytes = new byte[numBytes]; System.arraycopy(this.bytes, 0, newBytes, 0, this.bytes.length); this.bytes = newBytes; } } else { this.initializeBytes(numBytes); } System.arraycopy(byteArrayValue, byteOffset, this.bytes, this.length, numBytes); this.length = numBytes; return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > byteArrayValue.length - byteOffset) { throw new IllegalArgumentException(\"byteArrayValue.length(\" + byteLength + \") > byteOffset(\" + byteOffset + \")\"); } if (byteOffset > 0 && byteOffset <= byteArrayValue.length - 1) { put(byteArrayValue, byteOffset, byteLength); } else { put(byteArrayValue, 0, byteLength); } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > 0) { if (byteLength > this._length) { _resize(byteLength); } System.arraycopy(byteArrayValue, byteOffset, this._data, this._length, byteLength); this._length += byteLength; } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength != 0) { int byteLengthEncoded = CodedOutputStream.computeRawVarint32Size(byteLength); putRawBytes(byteArrayValue, byteOffset, byteLengthEncoded); } return this; }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteLength > 4) { throw new IllegalArgumentException(\"byteArrayValue.length > 4\"); } if (byteLength == 0) { return putInt(0); } if (byteLength == 1) { return putInt(0xff & byteArrayValue[byteOffset]); } if (byteLength == 2) { return putInt(0xff & byteArrayValue[byteOffset] | (0xff00 & byteArrayValue[byteOffset + 1]) << 8); } if (byteLength == 3) { return putInt(0xff & byteArrayValue[byteOffset] | (0xff00 & byteArrayValue[byteOffset + 1]) << 16 | (0xff0000 & byteArrayValue[byteOffset + 2]) << 24); } if (byteLength == 4) { return putInt(0xff & byteArrayValue[byteOffset] | (0xff00 & byteArrayValue[byteOffset + 1]) << 24 | (0xff0000 & byteArrayValue[byteOffset + 2]) << 32 | (0xff0000 & byteArrayValue[byteOffset + 3]) << 40 | (0xff0000 & byteArrayValue[byteOffset + 4]) << 48); } throw new IllegalArgumentException(\"byteLength must be a multiple of 4\"); }", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){ if (byteArrayValue == null) { putNull(); } else { putBytes(byteArrayValue, byteOffset, byteLength); } return this; }"], "code_level": "class_runnable", "_id": "636766a91a6d9265ec0175ae", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private void pop(final int elements) {\n  for (int i = 0; i < elements; i++) {\n    stack.pop();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  if (elements == 0) {\n    return;\n  }\n  stack.pop();\n  if (stack.empty()) {\n    stack.push(elements);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  for (int i = 0; i < elements; i++) {\n    pop();\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private void pop(final int elements) {\n  stack.pop(elements);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  if (elements > 0) {\n    final int num = stack.size() - elements;\n    if (num > 0) {\n      stack.pop();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  if (elements > 0) {\n    stack.pop();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  if (elements <= 0) return;\n  for (int i = 0; i < elements; i++) {\n    stack.pop();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  final int sz = stack.size() - elements;\n  for (int i = 0; i < sz; i++) {\n    stack.pop();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  if (elements > 0) {\n    pop(elements - 1);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void pop(final int elements) {\n  if (elements >= 0) {\n    int i = stack.size() - 1;\n    while (i >= elements) {\n      stack.remove(i);\n      i--;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n", "method_name": "pop", "codes": ["private void pop(final int elements){ for (int i = 0; i < elements; i++) { stack.pop(); } }", "private void pop(final int elements){ if (elements == 0) { return; } stack.pop(); if (stack.empty()) { stack.push(elements); } }", "private void pop(final int elements){ for (int i = 0; i < elements; i++) { pop(); } }", "private void pop(final int elements){ stack.pop(elements); }", "private void pop(final int elements){ if (elements > 0) { final int num = stack.size() - elements; if (num > 0) { stack.pop(); } } }", "private void pop(final int elements){ if (elements > 0) { stack.pop(); } }", "private void pop(final int elements){ if (elements <= 0) return; for (int i = 0; i < elements; i++) { stack.pop(); } }", "private void pop(final int elements){ final int sz = stack.size() - elements; for (int i = 0; i < sz; i++) { stack.pop(); } }", "private void pop(final int elements){ if (elements > 0) { pop(elements - 1); } }", "private void pop(final int elements){ if (elements >= 0) { int i = stack.size() - 1; while (i >= elements) { stack.remove(i); i--; } } }"], "code_level": "self_contained", "_id": "636766a81a6d9265ec017586", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "public ByteVector putInt(final int intValue) {\n  this.data[this.position++] = (byte) ((intValue >>> 24) & 0xFF);\n  this.data[this.position++] = (byte) ((intValue >>> 16) & 0xFF);\n  this.data[this.position++] = (byte) ((intValue >>> 8) & 0xFF);\n  this.data[this.position++] = (byte) (intValue & 0xFF);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  final byte[] byteData = this.byteData;\n  final int byteLength = this.byteLength;\n  if (byteLength + 4 > byteData.length) {\n    final byte[] newData = new byte[(byteData.length * 2) + 4];\n    System.arraycopy(byteData, 0, newData, 0, byteLength);\n    this.byteData = newData;\n  }\n  final int pos = this.byteLength;\n  byteData[pos] = (byte) ((intValue >>> 24) & 0xFF);\n  byteData[pos + 1] = (byte) ((intValue >>> 16) & 0xFF);\n  byteData[pos + 2] = (byte) ((intValue >>> 8) & 0xFF);\n  byteData[pos + 3] = (byte) (intValue & 0xFF);\n  this.byteLength = pos + 4;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  if (intValue >= 0) {\n    return putInt((int) intValue);\n  } else {\n    return putInt((int) (intValue >>> 32));\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  final int length = putInt(intValue);\n  putShort((short) length);\n  putBytes(this.buffer, this.offset + 0, (short) length);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  final byte[] data = {\n    (byte) (intValue >>> 24), (byte) (intValue >>> 16), (byte) (intValue >>> 8), (byte) intValue\n  };\n  putBytes(data, data.length);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  if (this.length - position < 4) {\n    this.ensureCapacity(position + 4);\n  }\n  buffer[position++] = (byte) (intValue >>> 24);\n  buffer[position++] = (byte) (intValue >>> 16);\n  buffer[position++] = (byte) (intValue >>> 8);\n  buffer[position++] = (byte) (intValue);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  final byte[] data = this.data;\n  int pos = this.pos;\n  data[pos++] = (byte) ((intValue >> 24) & 0xFF);\n  data[pos++] = (byte) ((intValue >> 16) & 0xFF);\n  data[pos++] = (byte) ((intValue >> 8) & 0xFF);\n  data[pos++] = (byte) (intValue & 0xFF);\n  this.pos = pos;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  if (this.length >= this.data.length) {\n    final int n = this.length;\n    final int[] tmp = new int[n << 1];\n    System.arraycopy(this.data, 0, tmp, 0, n);\n    this.data = tmp;\n  }\n  this.data[this.length++] = (byte) (intValue >>> 24);\n  this.data[this.length++] = (byte) (intValue >>> 16);\n  this.data[this.length++] = (byte) (intValue >>> 8);\n  this.data[this.length++] = (byte) intValue;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  if (this.length - this.pos < 4) {\n    resize(this.length << 1);\n  }\n  this.data[this.pos++] = (byte) (intValue >>> 24);\n  this.data[this.pos++] = (byte) (intValue >>> 16);\n  this.data[this.pos++] = (byte) (intValue >>> 8);\n  this.data[this.pos++] = (byte) (intValue);\n  this.length += 4;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue) {\n  final int length = length();\n  if (intValue >= 0 && intValue <= 255) {\n    final byte[] data = _data;\n    final int pos = _offset;\n    data[pos] = (byte) (intValue >>> 24);\n    data[pos + 1] = (byte) (intValue >>> 16);\n    data[pos + 2] = (byte) (intValue >>> 8);\n    data[pos + 3] = (byte) intValue;\n    _offset = pos + 4;\n  } else {\n    _resize(length + 4);\n    putInt(intValue);\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param intValue an int.\n * @return this byte vector.\n */\n", "method_name": "putInt", "codes": ["public ByteVector putInt(final int intValue){ this.data[this.position++] = (byte) ((intValue >>> 24) & 0xFF); this.data[this.position++] = (byte) ((intValue >>> 16) & 0xFF); this.data[this.position++] = (byte) ((intValue >>> 8) & 0xFF); this.data[this.position++] = (byte) (intValue & 0xFF); return this; }", "public ByteVector putInt(final int intValue){ final byte[] byteData = this.byteData; final int byteLength = this.byteLength; if (byteLength + 4 > byteData.length) { final byte[] newData = new byte[(byteData.length * 2) + 4]; System.arraycopy(byteData, 0, newData, 0, byteLength); this.byteData = newData; } final int pos = this.byteLength; byteData[pos] = (byte) ((intValue >>> 24) & 0xFF); byteData[pos + 1] = (byte) ((intValue >>> 16) & 0xFF); byteData[pos + 2] = (byte) ((intValue >>> 8) & 0xFF); byteData[pos + 3] = (byte) (intValue & 0xFF); this.byteLength = pos + 4; return this; }", "public ByteVector putInt(final int intValue){ if (intValue >= 0) { return putInt((int) intValue); } else { return putInt((int) (intValue >>> 32)); } }", "public ByteVector putInt(final int intValue){ final int length =putInt(intValue); putShort((short) length); putBytes(this.buffer, this.offset + 0, (short) length); return this; }", "public ByteVector putInt(final int intValue){ final byte[] data = { (byte) (intValue >>> 24), (byte) (intValue >>> 16), (byte) (intValue >>> 8), (byte) intValue }; putBytes(data, data.length); return this; }", "public ByteVector putInt(final int intValue){ if (this.length - position < 4) { this.ensureCapacity(position + 4); } buffer[position++] = (byte) (intValue >>> 24); buffer[position++] = (byte) (intValue >>> 16); buffer[position++] = (byte) (intValue >>> 8); buffer[position++] = (byte) (intValue); return this; }", "public ByteVector putInt(final int intValue){ final byte[] data = this.data; int pos = this.pos; data[pos++] = (byte) ((intValue >> 24) & 0xFF); data[pos++] = (byte) ((intValue >> 16) & 0xFF); data[pos++] = (byte) ((intValue >> 8) & 0xFF); data[pos++] = (byte) (intValue & 0xFF); this.pos = pos; return this; }", "public ByteVector putInt(final int intValue){ if (this.length >= this.data.length) { final int n = this.length; final int[] tmp = new int[n << 1]; System.arraycopy(this.data, 0, tmp, 0, n); this.data = tmp; } this.data[this.length++] = (byte) (intValue >>> 24); this.data[this.length++] = (byte) (intValue >>> 16); this.data[this.length++] = (byte) (intValue >>> 8); this.data[this.length++] = (byte) intValue; return this; }", "public ByteVector putInt(final int intValue){ if (this.length - this.pos < 4) { resize(this.length << 1); } this.data[this.pos++] = (byte) (intValue >>> 24); this.data[this.pos++] = (byte) (intValue >>> 16); this.data[this.pos++] = (byte) (intValue >>> 8); this.data[this.pos++] = (byte) (intValue); this.length += 4; return this; }", "public ByteVector putInt(final int intValue){ final int length = length(); if (intValue >= 0 && intValue <= 255) { final byte[] data = _data; final int pos = _offset; data[pos] = (byte) (intValue >>> 24); data[pos + 1] = (byte) (intValue >>> 16); data[pos + 2] = (byte) (intValue >>> 8); data[pos + 3] = (byte) intValue; _offset = pos + 4; } else { _resize(length + 4); putInt(intValue); } return this; }"], "code_level": "class_runnable", "_id": "636766a81a6d9265ec017596", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private void pop(final String descriptor) {\n  int pos = descriptor.length() - 1;\n  while (pos >= 0 && descriptor.charAt(pos) == '[') {\n    pos--;\n  }\n  if (pos >= 0) {\n    pos++;\n    while (pos < descriptor.length() && descriptor.charAt(pos) != ']') {\n      pos++;\n    }\n  }\n  if (pos < descriptor.length() - 1 && descriptor.charAt(pos + 1) == ';') {\n    pos++;\n  }\n  if (pos >= 0) {\n    value = value.substring(0, pos) + value.substring(pos + 1, descriptor.length());\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.charAt(0) == 'L') {\n    stack.pop();\n  } else {\n    stack.push(descriptor.charAt(0));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (this.typeStack.isEmpty()) {\n    throw new IllegalStateException(\"Stack is empty\");\n  }\n  if (this.typeStack.peek().equals(descriptor)) {\n    this.typeStack.pop();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (descriptor.length() == 1) {\n    this.result.pop();\n  } else {\n    this.result.pop();\n    this.result.push(this.result.pop() * descriptor.charAt(0));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (!valueStack.isEmpty()) {\n    final Object value = valueStack.peek();\n    if (value instanceof String) {\n      final String stringValue = (String) value;\n      if (stringValue.equals(descriptor)) {\n        valueStack.pop();\n      }\n    } else if (value instanceof Map) {\n      final Map<?, ?> mapValue = (Map<?, ?>) value;\n      for (final Object key : mapValue.keySet()) {\n        if (key.equals(descriptor)) {\n          valueStack.pop();\n        }\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (!isValidDescriptor(descriptor)) {\n    throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptor);\n  }\n  final int index = descriptor.charAt(0) - 'A';\n  if (index >= 0 && index < mValues.length) {\n    mValues[index] = null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  final String value = (String) stack.pop();\n  if (value.length() > 0) {\n    stack.push(value.substring(0, value.length() - 1));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  String val = (String) this.valueStack.pop();\n  if (val.startsWith(descriptor)) {\n    this.valueStack.push(val.substring(descriptor.length()));\n  } else {\n    throw new IllegalStateException(\n        \"Unexpected descriptor \" + descriptor + \" in \" + this.descriptor);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  if (current == null) {\n    throw new IllegalStateException(\"No value\");\n  }\n  final char c = current.charAt(0);\n  if (c == descriptor.charAt(0)) {\n    current = current.substring(1);\n  } else {\n    throw new IllegalStateException(\"Invalid descriptor\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor) {\n  final int index = descriptor.charAt(0) - 'A';\n  this.values[index] = null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n", "method_name": "pop", "codes": ["private void pop(final String descriptor){ int pos = descriptor.length() - 1; while (pos >= 0 && descriptor.charAt(pos) == '[') { pos--; } if (pos >= 0) { pos++; while (pos < descriptor.length() && descriptor.charAt(pos) != ']') { pos++; } } if (pos < descriptor.length() - 1 && descriptor.charAt(pos + 1) == ';') { pos++; } if (pos >= 0) { value = value.substring(0, pos) + value.substring(pos + 1, descriptor.length()); } }", "private void pop(final String descriptor){ if (descriptor.charAt(0) == 'L') { stack.pop(); } else { stack.push(descriptor.charAt(0)); } }", "private void pop(final String descriptor){ if (this.typeStack.isEmpty()) { throw new IllegalStateException(\"Stack is empty\"); } if (this.typeStack.peek().equals(descriptor)) { this.typeStack.pop(); } }", "private void pop(final String descriptor){ if (descriptor.length() == 1) { this.result.pop(); } else { this.result.pop(); this.result.push(this.result.pop() * descriptor.charAt(0)); } }", "private void pop(final String descriptor){ if (!valueStack.isEmpty()) { final Object value = valueStack.peek(); if (value instanceof String) { final String stringValue = (String) value; if (stringValue.equals(descriptor)) { valueStack.pop(); } } else if (value instanceof Map) { final Map<?, ?> mapValue = (Map<?, ?>) value; for (final Object key : mapValue.keySet()) { if (key.equals(descriptor)) { valueStack.pop(); } } } } }", "private void pop(final String descriptor){ if (!isValidDescriptor(descriptor)) { throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptor); } final int index = descriptor.charAt(0) - 'A'; if (index >= 0 && index < mValues.length) { mValues[index] = null; } }", "private void pop(final String descriptor){ final String value = (String) stack.pop(); if (value.length() > 0) { stack.push(value.substring(0, value.length() - 1)); } }", "private void pop(final String descriptor){ String val = (String) this.valueStack.pop(); if (val.startsWith(descriptor)) { this.valueStack.push(val.substring(descriptor.length())); } else { throw new IllegalStateException(\"Unexpected descriptor \" + descriptor + \" in \" + this.descriptor); } }", "private void pop(final String descriptor){ if (current == null) { throw new IllegalStateException(\"No value\"); } final char c = current.charAt(0); if (c == descriptor.charAt(0)) { current = current.substring(1); } else { throw new IllegalStateException(\"Invalid descriptor\"); } }", "private void pop(final String descriptor){ final int index = descriptor.charAt(0) - 'A'; this.values[index] = null; }"], "code_level": "class_runnable", "_id": "636766a91a6d9265ec0175c4", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  final int i = this.pos;\n  this.putByte(byteValue1);\n  this.putByte(byteValue2);\n  this.pos = i + 1;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  byte[] b1 = this.data;\n  int a1 = this.pos;\n  this.pos = a1 + 1;\n  b1[a1] = (byte) (byteValue1 & 0xff);\n  b1[a1 + 1] = (byte) ((byteValue1 >> 8) & 0xff);\n  b1[a1 + 2] = (byte) ((byteValue1 >> 16) & 0xff);\n  b1[a1 + 3] = (byte) ((byteValue1 >> 24) & 0xff);\n  this.pos = a1 + 4;\n  this.data = b1;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  final int pos = this.pos;\n  if (pos + 11 > this.data.length) {\n    this.enlarge(8);\n  }\n  this.data[pos] = (byte) (byteValue1 & 0xFF);\n  this.data[pos + 1] = (byte) (byteValue1 >>> 8);\n  this.data[pos + 2] = (byte) (byteValue1 >>> 16);\n  this.data[pos + 3] = (byte) (byteValue1 >>> 24);\n  this.data[pos + 4] = (byte) (byteValue2 & 0xFF);\n  this.data[pos + 5] = (byte) (byteValue2 >>> 8);\n  this.data[pos + 6] = (byte) (byteValue2 >>> 16);\n  this.data[pos + 7] = (byte) (byteValue2 >>> 24);\n  this.data[pos + 8] = (byte) (byteValue3 & 0xFF);\n  this.data[pos + 9] = (byte) (byteValue3 >>> 8);\n  this.data[pos + 10] = (byte) (byteValue3 >>> 16);\n  this.data[pos + 11] = (byte) (byteValue3 >>> 24);\n  this.pos = pos + 12;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  int i = this.pos;\n  if (i >= this.limit) {\n    this.put(byteValue1, byteValue2);\n    return this;\n  }\n  this.put11(byteValue1, byteValue2, this.buffer, i);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  if (length == data.length) {\n    final int newLength = length + 3;\n    final byte[] newData = new byte[newLength];\n    System.arraycopy(data, 0, newData, 0, length);\n    data = newData;\n  }\n  data[length++] = (byte) (byteValue1 >>> 8);\n  data[length++] = (byte) byteValue1;\n  data[length++] = (byte) (byteValue2 >>> 8);\n  data[length++] = (byte) byteValue2;\n  return this;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  int pos = this.pos;\n  if (pos + 11 > this.data.length) {\n    enlarge(1);\n  }\n  byte[] data = this.data;\n  data[pos++] = (byte) (byteValue1 >>> 8);\n  data[pos++] = (byte) byteValue1;\n  data[pos++] = (byte) (byteValue2 >>> 8);\n  data[pos++] = (byte) byteValue2;\n  this.pos = pos;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  if (length == data.length) {\n    final byte[] newData = new byte[Math.max(length << 1, data.length << 1)];\n    System.arraycopy(data, 0, newData, 0, length);\n    data = newData;\n  }\n  data[length++] = (byte) (byteValue1 << 8 | byteValue2);\n  return this;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  final byte[] data = this.data;\n  final int pos = this.pos;\n  data[pos++] = (byte) (byteValue1 >>> 8);\n  data[pos++] = (byte) byteValue1;\n  data[pos++] = (byte) (byteValue2 >>> 8);\n  data[pos++] = (byte) byteValue2;\n  this.pos = pos;\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  if (length + 11 > data.length) {\n    final int newLength = data.length * 2;\n    if (newLength < 0) {\n      throw new IllegalStateException(\"length of data array can not be negative\");\n    }\n    data = Arrays.copyOf(data, newLength);\n  }\n  data[length++] = (byte) ((byteValue1 & 0xff) << 4);\n  data[length++] = (byte) ((byteValue2 & 0xff) >>> 4);\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n  int pos = position;\n  if (ensureCapacity(pos + 4)) {\n    System.arraycopy(array, pos, array, position = pos + 4, length - pos);\n    array[pos + 4] = (byte) ((byteValue1 & 0xFF) | ((byteValue2 & 0xFF) << 8));\n  } else {\n    throw new IllegalArgumentException(\"Array is too short\");\n  }\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n", "method_name": "put11", "codes": ["final ByteVector put11(final int byteValue1,final int byteValue2){ final int i = this.pos; this.putByte(byteValue1); this.putByte(byteValue2); this.pos = i + 1; return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ byte[] b1 = this.data; int a1 = this.pos; this.pos = a1 + 1; b1[a1] = (byte) (byteValue1 & 0xff); b1[a1 + 1] = (byte) ((byteValue1 >> 8) & 0xff); b1[a1 + 2] = (byte) ((byteValue1 >> 16) & 0xff); b1[a1 + 3] = (byte) ((byteValue1 >> 24) & 0xff); this.pos = a1 + 4; this.data = b1; return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ final int pos = this.pos; if (pos + 11 > this.data.length) { this.enlarge(8); } this.data[pos] = (byte) (byteValue1 & 0xFF); this.data[pos + 1] = (byte) (byteValue1 >>> 8); this.data[pos + 2] = (byte) (byteValue1 >>> 16); this.data[pos + 3] = (byte) (byteValue1 >>> 24); this.data[pos + 4] = (byte) (byteValue2 & 0xFF); this.data[pos + 5] = (byte) (byteValue2 >>> 8); this.data[pos + 6] = (byte) (byteValue2 >>> 16); this.data[pos + 7] = (byte) (byteValue2 >>> 24); this.data[pos + 8] = (byte) (byteValue3 & 0xFF); this.data[pos + 9] = (byte) (byteValue3 >>> 8); this.data[pos + 10] = (byte) (byteValue3 >>> 16); this.data[pos + 11] = (byte) (byteValue3 >>> 24); this.pos = pos + 12; return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ int i = this.pos; if (i >= this.limit) { this.put(byteValue1, byteValue2); return this; } this.put11(byteValue1, byteValue2, this.buffer, i); return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ if (length == data.length) { final int newLength = length + 3; final byte[] newData = new byte[newLength]; System.arraycopy(data, 0, newData, 0, length); data = newData; } data[length++] = (byte) (byteValue1 >>> 8); data[length++] = (byte) byteValue1; data[length++] = (byte) (byteValue2 >>> 8); data[length++] = (byte) byteValue2; return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ int pos = this.pos; if (pos + 11 > this.data.length) { enlarge(1); } byte[] data = this.data; data[pos++] = (byte) (byteValue1 >>> 8); data[pos++] = (byte) byteValue1; data[pos++] = (byte) (byteValue2 >>> 8); data[pos++] = (byte) byteValue2; this.pos = pos; return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ if (length == data.length) { final byte[] newData = new byte[Math.max(length << 1, data.length << 1)]; System.arraycopy(data, 0, newData, 0, length); data = newData; } data[length++] = (byte) (byteValue1 << 8 | byteValue2); return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ final byte[] data = this.data; final int pos = this.pos; data[pos++] = (byte) (byteValue1 >>> 8); data[pos++] = (byte) byteValue1; data[pos++] = (byte) (byteValue2 >>> 8); data[pos++] = (byte) byteValue2; this.pos = pos; return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ if (length + 11 > data.length) { final int newLength = data.length * 2; if (newLength < 0) { throw new IllegalStateException(\"length of data array can not be negative\"); } data = Arrays.copyOf(data, newLength); } data[length++] = (byte) ((byteValue1 & 0xff) << 4); data[length++] = (byte) ((byteValue2 & 0xff) >>> 4); return this; }", "final ByteVector put11(final int byteValue1,final int byteValue2){ int pos = position; if (ensureCapacity(pos + 4)) { System.arraycopy(array, pos, array, position = pos + 4, length - pos); array[pos + 4] = (byte) ((byteValue1 & 0xFF) | ((byteValue2 & 0xFF) << 8)); } else { throw new IllegalArgumentException(\"Array is too short\"); } return this; }"], "code_level": "class_runnable", "_id": "636766a81a6d9265ec017595", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return toString(new JSONTokener(this), features);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  if (this.isEmpty()) {\n    return \"{}\";\n  }\n  if (this.isMap()) {\n    return toMapString((Map<String, Object>) this.get(0), features);\n  } else if (this.isArray()) {\n    return toArrayString((List<Object>) this.get(0), features);\n  } else if (this.isObject()) {\n    return toObjectString((Map<String, Object>) this.get(0), features);\n  } else {\n    return toString(this.get(0));\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  if (features.length == 0) {\n    features =\n        new JSONWriter.Feature[] {\n          JSONWriter.Feature.QuoteFieldNames, JSONWriter.Feature.SkipAnotherValue\n        };\n  }\n  if (features.length == 1) {\n    return features[0].toString(this);\n  }\n  StringBuilder sb = new StringBuilder(128);\n  sb.append('[');\n  boolean first = true;\n  for (JSONWriter.Feature f : features) {\n    if (first) {\n      first = false;\n    } else {\n      sb.append(',');\n    }\n    sb.append(f.toString(this));\n  }\n  sb.append(']');\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return toString(new ArrayList<Feature>(Arrays.asList(features)));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return toString(JSON.DEFAULT_GENERATE_FEATURE, features);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  JSONString jsonString = new JSONString(content);\n  if (features != null) {\n    for (JSONWriter.Feature feature : features) {\n      jsonString.feature(feature);\n    }\n  }\n  return jsonString.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  return this.toString((JSONArray) null, features);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  StringWriter writer = new StringWriter();\n  JSONWriter jsonWriter = new JSONWriter(writer, features);\n  try {\n    jsonWriter.write(this);\n  } catch (IOException e) {\n    throw new RuntimeException(e);\n  }\n  return writer.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\")\npublic String toString(JSONWriter.Feature... features) {\n  try {\n    return toString((Map<String, Object>) null, features);\n  } catch (JSONException e) {\n    return null;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ try { return this.toString(this._jsonFactory.createWriter(this._jsonFactory.createParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Serialize to JSON  {@link String}\n * @param features features to be enabled in serialization\n * @return JSON {@link String}\n */\n", "method_name": "toString", "codes": ["@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return toString(new JSONTokener(this), features); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ if (this.isEmpty()) { return \"{}\"; } if (this.isMap()) { return toMapString((Map<String, Object>) this.get(0), features); } else if (this.isArray()) { return toArrayString((List<Object>) this.get(0), features); } else if (this.isObject()) { return toObjectString((Map<String, Object>) this.get(0), features); } else { return toString(this.get(0)); } }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ if (features.length == 0) { features = new JSONWriter.Feature[] { JSONWriter.Feature.QuoteFieldNames, JSONWriter.Feature.SkipAnotherValue }; } if (features.length == 1) { return features[0].toString(this); } StringBuilder sb = new StringBuilder(128); sb.append('['); boolean first = true; for (JSONWriter.Feature f : features) { if (first) { first = false; } else { sb.append(','); } sb.append(f.toString(this)); } sb.append(']'); return sb.toString(); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return toString(new ArrayList<Feature>(Arrays.asList(features))); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return toString(JSON.DEFAULT_GENERATE_FEATURE, features); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ JSONString jsonString = new JSONString(content); if (features != null) { for (JSONWriter.Feature feature : features) { jsonString.feature(feature); } } return jsonString.toString(); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ return this.toString((JSONArray) null, features); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ StringWriter writer = new StringWriter(); JSONWriter jsonWriter = new JSONWriter(writer, features); try { jsonWriter.write(this); } catch (IOException e) { throw new RuntimeException(e); } return writer.toString(); }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ try { return toString((Map<String, Object>) null, features); } catch (JSONException e) { return null; } }", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){ try { return this.toString(this._jsonFactory.createWriter(this._jsonFactory.createParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this._jsonFactory.createJsonParser(this"], "code_level": "self_contained", "_id": "636766a81a6d9265ec01757b", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int num = desiredCapacity;\n  do {\n    num++;\n  } while (!isPrime(num));\n  return num;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int i = 1;\n  while (true) {\n    if (isPrime(i)) {\n      desiredCapacity--;\n      if (desiredCapacity == 0) {\n        return i;\n      }\n    }\n    i++;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int result = 1;\n  while (result * result <= desiredCapacity) {\n    result++;\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  if (desiredCapacity <= 0) {\n    throw new IllegalArgumentException(\"Desired capacity must be greater than 0\");\n  }\n  int[] primes = new int[desiredCapacity];\n  for (int i = 0; i < primes.length; i++) {\n    primes[i] = i + 1;\n  }\n  for (int i = primes.length - 1; i >= 0; i--) {\n    int j = 0;\n    while (j < primes.length && primes[j] * primes[j] <= desiredCapacity) {\n      j++;\n    }\n    if (j == primes.length) {\n      return i;\n    }\n    int temp = primes[i];\n    primes[i] = primes[j];\n    primes[j] = temp;\n  }\n  return 0;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int i = 2;\n  while (i * i < desiredCapacity) {\n    if (desiredCapacity % i == 0) return i;\n    i++;\n  }\n  return i;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int prime = 2;\n  while (true) {\n    if (isPrime(prime)) {\n      return prime;\n    }\n    prime++;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int i = 0;\n  int j = 0;\n  while (true) {\n    if (primeCapacities[i] > desiredCapacity) {\n      break;\n    }\n    i++;\n  }\n  while (true) {\n    if (primeCapacities[j] > desiredCapacity) {\n      break;\n    }\n    j++;\n  }\n  return i;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int nextPrime = desiredCapacity;\n  int i = 2;\n  while (nextPrime % i != 0) {\n    i++;\n  }\n  if (i == 2) {\n    return i;\n  } else {\n    while (nextPrime % i == 0) {\n      nextPrime /= i;\n    }\n    return i;\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int i = 0;\n  int nextPrime = 0;\n  int numPrimes = 0;\n  while (i < desiredCapacity) {\n    if (isPrime(i)) {\n      numPrimes++;\n      nextPrime = i;\n    }\n    i++;\n  }\n  return nextPrime;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity) {\n  int i = 0;\n  while (true) {\n    if (isPrime(i)) {\n      return i;\n    }\n    i++;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).\n * @param desiredCapacity the capacity desired by the user.\n * @return the capacity which should be used for a hashtable.\n */\n", "method_name": "nextPrime", "codes": ["public static int nextPrime(int desiredCapacity){ int num = desiredCapacity; do { num++; } while (!isPrime(num)); return num; }", "public static int nextPrime(int desiredCapacity){ int i = 1; while (true) { if (isPrime(i)) { desiredCapacity--; if (desiredCapacity == 0) { return i; } } i++; } }", "public static int nextPrime(int desiredCapacity){ int result = 1; while (result * result <= desiredCapacity) { result++; } return result; }", "public static int nextPrime(int desiredCapacity){ if (desiredCapacity <= 0) { throw new IllegalArgumentException(\"Desired capacity must be greater than 0\"); } int[] primes = new int[desiredCapacity]; for (int i = 0; i < primes.length; i++) { primes[i] = i + 1; } for (int i = primes.length - 1; i >= 0; i--) { int j = 0; while (j < primes.length && primes[j] * primes[j] <= desiredCapacity) { j++; } if (j == primes.length) { return i; } int temp = primes[i]; primes[i] = primes[j]; primes[j] = temp; } return 0; }", "public static int nextPrime(int desiredCapacity){ int i = 2; while (i * i < desiredCapacity) { if (desiredCapacity % i == 0) return i; i++; } return i; }", "public static int nextPrime(int desiredCapacity){ int prime = 2; while (true) { if (isPrime(prime)) { return prime; } prime++; } }", "public static int nextPrime(int desiredCapacity){ int i = 0; int j = 0; while (true) { if (primeCapacities[i] > desiredCapacity) { break; } i++; } while (true) { if (primeCapacities[j] > desiredCapacity) { break; } j++; } return i; }", "public static int nextPrime(int desiredCapacity){ int nextPrime = desiredCapacity; int i = 2; while (nextPrime % i != 0) { i++; } if (i == 2) { return i; } else { while (nextPrime % i == 0) { nextPrime /= i; } return i; } }", "public static int nextPrime(int desiredCapacity){ int i = 0; int nextPrime = 0; int numPrimes = 0; while (i < desiredCapacity) { if (isPrime(i)) { numPrimes++; nextPrime = i; } i++; } return nextPrime; }", "public static int nextPrime(int desiredCapacity){ int i = 0; while (true) { if (isPrime(i)) { return i; } i++; } }"], "code_level": "slib_runnable", "_id": "636766a81a6d9265ec01758e", "project_name": "fastjson2-main"}, {"generate_results": [{"generate_code": "private static int digitValue(final char c) {\n  return c - '0';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  int digit;\n  if (c >= '0' && c <= '9') {\n    digit = c - '0';\n  } else if (c >= 'A' && c <= 'Z') {\n    digit = c - 'A' + 10;\n  } else if (c >= 'a' && c <= 'z') {\n    digit = c - 'a' + 10;\n  } else {\n    throw new IllegalArgumentException(\"Character \" + c + \" is not a valid digit\");\n  }\n  return digit;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if ('0' <= c && c <= '9') {\n    return c - '0';\n  } else if ('a' <= c && c <= 'z') {\n    return c - 'a' + 10;\n  } else if ('A' <= c && c <= 'Z') {\n    return c - 'A' + 10;\n  } else {\n    throw new IllegalArgumentException(\"Not a digit for character \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else if (c >= 'a' && c <= 'f') {\n    return c - 'a' + 10;\n  } else {\n    return c - 'A' + 10;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  }\n  if (c >= 'A' && c <= 'Z') {\n    return c - 'A' + 10;\n  }\n  if (c >= 'a' && c <= 'z') {\n    return c - 'a' + 10;\n  }\n  throw new IllegalArgumentException(\"Character \" + c + \" is not a valid digit\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else {\n    throw new IllegalArgumentException(\"Invalid digit value: \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else if (c >= 'a' && c <= 'z') {\n    return c - 'a' + 10;\n  } else {\n    throw new IllegalArgumentException(\"Invalid character '\" + c + \"'\");\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  return c - '0';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  } else if (c >= 'a' && c <= 'z') {\n    return c - 'a' + 10;\n  } else if (c >= 'A' && c <= 'Z') {\n    return c - 'A' + 10;\n  } else {\n    throw new IllegalArgumentException(\"Invalid digit value: \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c) {\n  int d = c - '0';\n  if (d >= 0 && d < 10) {\n    return d;\n  } else {\n    throw new IllegalArgumentException(\"Illegal digit value: \" + c);\n  }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()} but we don't accept non-ASCII digits.\n */\n", "method_name": "digitValue", "codes": ["private static int digitValue(final char c){ return c - '0'; }", "private static int digitValue(final char c){ int digit; if (c >= '0' && c <= '9') { digit = c - '0'; } else if (c >= 'A' && c <= 'Z') { digit = c - 'A' + 10; } else if (c >= 'a' && c <= 'z') { digit = c - 'a' + 10; } else { throw new IllegalArgumentException(\"Character \" + c + \" is not a valid digit\"); } return digit; }", "private static int digitValue(final char c){ if ('0' <= c && c <= '9') { return c - '0'; } else if ('a' <= c && c <= 'z') { return c - 'a' + 10; } else if ('A' <= c && c <= 'Z') { return c - 'A' + 10; } else { throw new IllegalArgumentException(\"Not a digit for character \" + c); } }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } else if (c >= 'a' && c <= 'f') { return c - 'a' + 10; } else { return c - 'A' + 10; } }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } if (c >= 'A' && c <= 'Z') { return c - 'A' + 10; } if (c >= 'a' && c <= 'z') { return c - 'a' + 10; } throw new IllegalArgumentException(\"Character \" + c + \" is not a valid digit\"); }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } else { throw new IllegalArgumentException(\"Invalid digit value: \" + c); } }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } else if (c >= 'a' && c <= 'z') { return c - 'a' + 10; } else { throw new IllegalArgumentException(\"Invalid character '\" + c + \"'\"); } }", "private static int digitValue(final char c){ return c - '0'; }", "private static int digitValue(final char c){ if (c >= '0' && c <= '9') { return c - '0'; } else if (c >= 'a' && c <= 'z') { return c - 'a' + 10; } else if (c >= 'A' && c <= 'Z') { return c - 'A' + 10; } else { throw new IllegalArgumentException(\"Invalid digit value: \" + c); } }", "private static int digitValue(final char c){ int d = c - '0'; if (d >= 0 && d < 10) { return d; } else { throw new IllegalArgumentException(\"Illegal digit value: \" + c); } }"], "code_level": "self_contained", "_id": "636767a61a6d9265ec0185b7", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return ((c >= '0') && (c <= '9')) || ((c >= 'a') && (c <= 'f')) || ((c >= 'A') && (c <= 'F'));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c) {\n  return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Is this a hex digit?\n */\n", "method_name": "isHex", "codes": ["private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f'; }", "private static boolean isHex(final char c){ return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F'; }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f'; }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f'; }", "private static boolean isHex(final char c){ return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); }", "private static boolean isHex(final char c){ return ((c >= '0') && (c <= '9')) || ((c >= 'a') && (c <= 'f')) || ((c >= 'A') && (c <= 'F')); }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F'; }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f'; }", "private static boolean isHex(final char c){ return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f'; }"], "code_level": "self_contained", "_id": "636767ab1a6d9265ec018676", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  ProtobufOutput output = new ProtobufOutput(buffer, schema);\n  try {\n    output.write(message);\n    return output.getSize();\n  } finally {\n    output.close();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  return writeDelimitedTo(out, message, schema, buffer, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  if (schema == null) throw new IllegalArgumentException(\"schema must not be null\");\n  if (buffer == null) throw new IllegalArgumentException(\"buffer must not be null\");\n  if (message == null) throw new IllegalArgumentException(\"message must not be null\");\n  if (buffer.writableBytes() > message.getSerializedSize())\n    throw new IllegalArgumentException(\"message is too large to be written into buffer\");\n  ProtobufOutput output = new ProtobufOutput(out, schema);\n  try {\n    schema.writeTo(message, output);\n  } finally {\n    output.close();\n  }\n  buffer.writeTo(out);\n  return message.getSerializedSize();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  if (buffer.isEmpty()) {\n    return 0;\n  }\n  if (buffer.capacity() <= buffer.writerIndex()) {\n    throw new IOException(\"Buffer overflow\");\n  }\n  int totalSize = 0;\n  while (buffer.isWritable()) {\n    int bytesToWrite = Math.min(buffer.writableBytes(), buffer.capacity() - buffer.writerIndex());\n    buffer.writeBytes(message, buffer.readerIndex(), bytesToWrite);\n    totalSize += bytesToWrite;\n  }\n  return totalSize;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  ProtobufOutput output = new ProtobufOutput(buffer, schema);\n  try {\n    output.writeDelimitedTo(message);\n    return output.getTotalBytesWritten();\n  } finally {\n    output.close();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  if (buffer == null) throw new IllegalArgumentException(\"LinkedBuffer must not be null\");\n  if (schema == null) throw new IllegalArgumentException(\"Schema must not be null\");\n  ProtobufOutput output = new ProtobufOutput(out, schema);\n  try {\n    schema.writeTo(output, message);\n    return output.getTotalBytesWritten();\n  } finally {\n    output.close();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  if (buffer == null) {\n    throw new NullPointerException(\"buffer must not be null\");\n  }\n  if (schema == null) {\n    throw new NullPointerException(\"schema must not be null\");\n  }\n  if (message == null) {\n    throw new NullPointerException(\"message must not be null\");\n  }\n  if (out == null) {\n    throw new NullPointerException(\"out must not be null\");\n  }\n  if (out.getClass() != buffer.getClass()) {\n    throw new IllegalArgumentException(\n        \"out must be an instance of \" + buffer.getClass().getName());\n  }\n  if (message instanceof GeneratedMessage) {\n    CodedOutputStream output = CodedOutputStream.newInstance(out);\n    schema.writeTo(output, (GeneratedMessage) message, buffer);\n    output.flush();\n    return output.getTotalBytesWritten();\n  }\n  if (message instanceof GeneratedMessage.Builder) {\n    CodedOutputStream output = CodedOutputStream.newInstance(out);\n    schema.writeTo(output, (GeneratedMessage.Builder) message, buffer);\n    output.flush();\n    return output.getTotalBytesWritten();\n  }\n  if (message instanceof GeneratedMessageV3) {\n    CodedOutputStream output = CodedOutputStream.newInstance(out);\n    schema.writeTo(output, (GeneratedMessageV3) message, buffer);\n    output.flush();\n    return output.getTotalBytesWritten();\n  }\n  throw new IllegalArgumentException(\"Unknown message type.\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  return writeDelimitedTo(out, message, schema, buffer, DEFAULT_BUFFER_SIZE);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  ProtobufOutput output = new ProtobufOutput(out, schema);\n  writeDelimitedTo(output, message, schema, buffer);\n  return output.getSize();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T> int writeDelimitedTo(\n    OutputStream out, T message, Schema<T> schema, LinkedBuffer buffer) throws IOException {\n  if (buffer == null) {\n    throw new NullPointerException(\"buffer == null\");\n  }\n  if (schema == null) {\n    throw new NullPointerException(\"schema == null\");\n  }\n  if (message == null) {\n    throw new NullPointerException(\"message == null\");\n  }\n  if (out == null) {\n    throw new NullPointerException(\"out == null\");\n  }\n  if (buffer.writableBytes() < message.getSerializedSize()) {\n    throw new IllegalArgumentException(\"buffer.writableBytes() < message.getSerializedSize()\");\n  }\n  ProtobufOutput output = new ProtobufOutput(out, schema, buffer);\n  try {\n    schema.writeTo(output, message);\n  } catch (Exception e) {\n    throw new IOException(\"Failed to write message: \" + message + \" to ProtobufOutput\", e);\n  }\n  return output.getSerializedSize();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.\n * @return the size of the message\n */\n", "method_name": "writeDelimitedTo", "codes": ["public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { ProtobufOutput output = new ProtobufOutput(buffer, schema); try { output.write(message); return output.getSize(); } finally { output.close(); } }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { return writeDelimitedTo(out, message, schema, buffer, null); }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (schema == null) throw new IllegalArgumentException(\"schema must not be null\"); if (buffer == null) throw new IllegalArgumentException(\"buffer must not be null\"); if (message == null) throw new IllegalArgumentException(\"message must not be null\"); if (buffer.writableBytes() > message.getSerializedSize()) throw new IllegalArgumentException(\"message is too large to be written into buffer\"); ProtobufOutput output = new ProtobufOutput(out, schema); try { schema.writeTo(message, output); } finally { output.close(); } buffer.writeTo(out); return message.getSerializedSize(); }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer.isEmpty()) { return 0; } if (buffer.capacity() <= buffer.writerIndex()) { throw new IOException(\"Buffer overflow\"); } int totalSize = 0; while (buffer.isWritable()) { int bytesToWrite = Math.min(buffer.writableBytes(), buffer.capacity() - buffer.writerIndex()); buffer.writeBytes(message, buffer.readerIndex(), bytesToWrite); totalSize += bytesToWrite; } return totalSize; }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { ProtobufOutput output = new ProtobufOutput(buffer, schema); try { output.writeDelimitedTo(message); return output.getTotalBytesWritten(); } finally { output.close(); } }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer == null) throw new IllegalArgumentException(\"LinkedBuffer must not be null\"); if (schema == null) throw new IllegalArgumentException(\"Schema must not be null\"); ProtobufOutput output = new ProtobufOutput(out, schema); try { schema.writeTo(output, message); return output.getTotalBytesWritten(); } finally { output.close(); } }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer == null) { throw new NullPointerException(\"buffer must not be null\"); } if (schema == null) { throw new NullPointerException(\"schema must not be null\"); } if (message == null) { throw new NullPointerException(\"message must not be null\"); } if (out == null) { throw new NullPointerException(\"out must not be null\"); } if (out.getClass() != buffer.getClass()) { throw new IllegalArgumentException(\"out must be an instance of \" + buffer.getClass().getName()); } if (message instanceof GeneratedMessage) { CodedOutputStream output = CodedOutputStream.newInstance(out); schema.writeTo(output, (GeneratedMessage) message, buffer); output.flush(); return output.getTotalBytesWritten(); } if (message instanceof GeneratedMessage.Builder) { CodedOutputStream output = CodedOutputStream.newInstance(out); schema.writeTo(output, (GeneratedMessage.Builder) message, buffer); output.flush(); return output.getTotalBytesWritten(); } if (message instanceof GeneratedMessageV3) { CodedOutputStream output = CodedOutputStream.newInstance(out); schema.writeTo(output, (GeneratedMessageV3) message, buffer); output.flush(); return output.getTotalBytesWritten(); } throw new IllegalArgumentException(\"Unknown message type.\"); }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { return writeDelimitedTo(out, message, schema, buffer, DEFAULT_BUFFER_SIZE); }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { ProtobufOutput output = new ProtobufOutput(out, schema); writeDelimitedTo(output, message, schema, buffer); return output.getSize(); }", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException { if (buffer == null) { throw new NullPointerException(\"buffer == null\"); } if (schema == null) { throw new NullPointerException(\"schema == null\"); } if (message == null) { throw new NullPointerException(\"message == null\"); } if (out == null) { throw new NullPointerException(\"out == null\"); } if (buffer.writableBytes() < message.getSerializedSize()) { throw new IllegalArgumentException(\"buffer.writableBytes() < message.getSerializedSize()\"); } ProtobufOutput output = new ProtobufOutput(out, schema, buffer); try { schema.writeTo(output, message); } catch (Exception e) { throw new IOException(\"Failed to write message: \" + message + \" to ProtobufOutput\", e); } return output.getSerializedSize(); }"], "code_level": "project_runnable", "_id": "636767a41a6d9265ec018582", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (len != data.length) return false;\n  for (int i = 0; i < len; i++) {\n    if (data[offset + i] != this.bytes[i]) return false;\n  }\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == null) {\n    return false;\n  }\n  if (len != this.length()) {\n    return false;\n  }\n  for (int i = 0; i < len; i++) {\n    if (this.get(i) != data[offset + i]) {\n      return false;\n    }\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (len == 0) return true;\n  if (len == 1) {\n    if (data[offset] != this.value) return false;\n    return true;\n  }\n  if (len == 2) {\n    if (data[offset] != this.value) return false;\n    if (data[offset + 1] != this.value) return false;\n    return true;\n  }\n  if (len == 3) {\n    if (data[offset] != this.value) return false;\n    if (data[offset + 1] != this.value) return false;\n    if (data[offset + 2] != this.value) return false;\n    return true;\n  }\n  if (len == 4) {\n    if (data[offset] != this.value) return false;\n    if (data[offset + 1] != this.value) return false;\n    if (data[offset + 2] != this.value) return false;\n    if (data[offset + 3] != this.value) return false;\n    return true;\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (len != data.length) return false;\n  for (int i = 0; i < len; i++) {\n    if (data[offset + i] != m_bytes[i]) return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == this.data) {\n    if (len == 0) return true;\n    if (len > this.data.length) return false;\n    for (int i = 0; i < len; i++) {\n      if (data[offset + i] != this.data[i]) return false;\n    }\n    return true;\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  return Arrays.equals(this.bytes, offset, len, data, 0, this.bytes.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  return equals(data, offset, len, 0, 0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  final int n = Math.min(offset + len, data.length);\n  for (int i = 0; i < n; i++) {\n    if (data[i] != this.array[i]) return false;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (data == null) {\n    return false;\n  }\n  int i = offset;\n  int j = offset + len;\n  while (i < j) {\n    if (this.data[i] != data[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data, int offset, final int len) {\n  if (len != length) {\n    return false;\n  }\n  if (data == null) {\n    return false;\n  }\n  if (offset < 0 || offset > data.length) {\n    return false;\n  }\n  if (offset == 0 && len == data.length) {\n    return true;\n  }\n  if (len >= 0 && len <= data.length - offset) {\n    System.arraycopy(data, offset, this.bytes, 0, len);\n    return true;\n  }\n  return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Returns true if the contents of the internal array and the provided array match.\n */\n", "method_name": "equals", "codes": ["public boolean equals(final byte[] data,int offset,final int len){ if (len != data.length) return false; for (int i = 0; i < len; i++) { if (data[offset + i] != this.bytes[i]) return false; } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (data == null) { return false; } if (len != this.length()) { return false; } for (int i = 0; i < len; i++) { if (this.get(i) != data[offset + i]) { return false; } } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (len == 0) return true; if (len == 1) { if (data[offset] != this.value) return false; return true; } if (len == 2) { if (data[offset] != this.value) return false; if (data[offset + 1] != this.value) return false; return true; } if (len == 3) { if (data[offset] != this.value) return false; if (data[offset + 1] != this.value) return false; if (data[offset + 2] != this.value) return false; return true; } if (len == 4) { if (data[offset] != this.value) return false; if (data[offset + 1] != this.value) return false; if (data[offset + 2] != this.value) return false; if (data[offset + 3] != this.value) return false; return true; } return false; }", "public boolean equals(final byte[] data,int offset,final int len){ if (len != data.length) return false; for (int i = 0; i < len; i++) { if (data[offset + i] != m_bytes[i]) return false; } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (data == this.data) { if (len == 0) return true; if (len > this.data.length) return false; for (int i = 0; i < len; i++) { if (data[offset + i] != this.data[i]) return false; } return true; } return false; }", "public boolean equals(final byte[] data,int offset,final int len){ return Arrays.equals(this.bytes, offset, len, data, 0, this.bytes.length); }", "public boolean equals(final byte[] data,int offset,final int len){ return equals(data, offset, len, 0, 0); }", "public boolean equals(final byte[] data,int offset,final int len){ final int n = Math.min(offset + len, data.length); for (int i = 0; i < n; i++) { if (data[i] != this.array[i]) return false; } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (data == null) { return false; } int i = offset; int j = offset + len; while (i < j) { if (this.data[i] != data[j]) { return false; } i++; j--; } return true; }", "public boolean equals(final byte[] data,int offset,final int len){ if (len != length) { return false; } if (data == null) { return false; } if (offset < 0 || offset > data.length) { return false; } if (offset == 0 && len == data.length) { return true; } if (len >= 0 && len <= data.length - offset) { System.arraycopy(data, offset, this.bytes, 0, len); return true; } return false; }"], "code_level": "class_runnable", "_id": "636767a51a6d9265ec01859d", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  int size = 0;\n  if (index >= 0) {\n    char ch = str.charAt(index);\n    if (ch < 0x80) {\n      size += 2;\n    } else if (ch < 0x800) {\n      size += 3;\n    } else {\n      size += 4;\n    }\n    if (index > 0) {\n      ch = str.charAt(index - 1);\n      if (ch < 0x80) {\n        size++;\n      } else if (ch < 0x800) {\n        size++;\n        size++;\n        size++;\n      } else {\n        size++;\n        size++;\n        size++;\n        size++;\n      }\n    }\n  }\n  if (len > 0) {\n    size += computeUtf8Size(str, index + 1, len - 1);\n  }\n  return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  return computeUTF8Size(str, index, len, null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  if (index + len > str.length()) {\n    return 0;\n  }\n  final char[] chars = str.toString().toCharArray();\n  if (index == 0) {\n    return computeUTF8Size0(chars, 0, len);\n  }\n  if (index == chars.length - 1) {\n    return computeUTF8Size1(chars, 0, len);\n  }\n  if (index == chars.length - 2) {\n    return computeUTF8Size2(chars, 0, len);\n  }\n  if (index == chars.length - 3) {\n    return computeUTF8Size3(chars, 0, len);\n  }\n  return computeUTF8Size4(chars, 0, len);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  int size = 0;\n  for (int i = index; i < index + len; i++) {\n    final int c = str.charAt(i);\n    if (c < 0x80) {\n      size++;\n    } else if (c < 0x800) {\n      size += 2;\n    } else if (c < 0x1000) {\n      size += 3;\n    } else if (c < 0x10000) {\n      size += 4;\n    } else {\n      size += 5;\n    }\n  }\n  return size;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  if (str == null) {\n    throw new IllegalArgumentException(\"str == null\");\n  }\n  int size = 0;\n  int end = index + len;\n  for (int i = index; i < end; i++) {\n    char c = str.charAt(i);\n    if (c > 0x00FF) {\n      size += 2;\n    } else {\n      size++;\n    }\n  }\n  return size;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  if (str == null) {\n    throw new NullPointerException(\"str\");\n  }\n  if (index < 0) {\n    throw new IndexOutOfBoundsException(\"index: \" + index);\n  }\n  if (len < 0) {\n    throw new IllegalArgumentException(\"len: \" + len);\n  }\n  if (index + len > str.length()) {\n    len = str.length() - index;\n  }\n  if (len < 0) {\n    return 0;\n  }\n  final int utfLen = (int) Math.ceil(((double) str.length()) / ((double) len));\n  if (utfLen <= 0) {\n    return 0;\n  }\n  final int size = 1 + computeUTF8Size0(str, index, len);\n  if (utfLen > size) {\n    throw new IllegalArgumentException(\n        \"str.length(): \"\n            + str.length()\n            + \"; index: \"\n            + index\n            + \"; len: \"\n            + len\n            + \"; utfLen: \"\n            + utfLen);\n  }\n  return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  final int size = computeSize(str, index, len);\n  if (size > 0) {\n    return size + UTF8_HEADER_SIZE;\n  }\n  return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  int utfLen = 0;\n  for (int i = index; i < index + len; i++) {\n    char c = str.charAt(i);\n    if ((c >= 0x0001) && (c <= 0x007F)) {\n      utfLen++;\n    } else if ((c >= 0x0080) && (c <= 0x00FF)) {\n      utfLen += 2;\n    } else {\n      utfLen += 1;\n    }\n  }\n  return utfLen;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  final int utf8Size = computeUTF8Size(str, index, len, false);\n  return utf8Size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str, final int index, final int len) {\n  if (str == null) {\n    return 0;\n  }\n  if (index > str.length()) {\n    return len;\n  }\n  if (len < 0) {\n    len = 0;\n  }\n  final int utfSize = computeUnsignedSize(len);\n  if (utfSize >= 0) {\n    return utfSize + computeUTF8Size(str, index, len);\n  } else {\n    return computeUTF8Size(str, index, len + 1);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.\n */\n", "method_name": "computeUTF8Size", "codes": ["public static int computeUTF8Size(final CharSequence str,final int index,final int len){ int size = 0; if (index >= 0) { char ch = str.charAt(index); if (ch < 0x80) { size += 2; } else if (ch < 0x800) { size += 3; } else { size += 4; } if (index > 0) { ch = str.charAt(index - 1); if (ch < 0x80) { size++; } else if (ch < 0x800) { size++; size++; size++; } else { size++; size++; size++; size++; } } } if (len > 0) { size += computeUtf8Size(str, index + 1, len - 1); } return size; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ return computeUTF8Size(str, index, len, null); }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ if (index + len > str.length()) { return 0; } final char[] chars = str.toString().toCharArray(); if (index == 0) { return computeUTF8Size0(chars, 0, len); } if (index == chars.length - 1) { return computeUTF8Size1(chars, 0, len); } if (index == chars.length - 2) { return computeUTF8Size2(chars, 0, len); } if (index == chars.length - 3) { return computeUTF8Size3(chars, 0, len); } return computeUTF8Size4(chars, 0, len); }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ int size = 0; for (int i = index; i < index + len; i++) { final int c = str.charAt(i); if (c < 0x80) { size++; } else if (c < 0x800) { size += 2; } else if (c < 0x1000) { size += 3; } else if (c < 0x10000) { size += 4; } else { size += 5; } } return size; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ if (str == null) { throw new IllegalArgumentException(\"str == null\"); } int size = 0; int end = index + len; for (int i = index; i < end; i++) { char c = str.charAt(i); if (c > 0x00FF) { size += 2; } else { size++; } } return size; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ if (str == null) { throw new NullPointerException(\"str\"); } if (index < 0) { throw new IndexOutOfBoundsException(\"index: \" + index); } if (len < 0) { throw new IllegalArgumentException(\"len: \" + len); } if (index + len > str.length()) { len = str.length() - index; } if (len < 0) { return 0; } final int utfLen = (int) Math.ceil(((double) str.length()) / ((double) len)); if (utfLen <= 0) { return 0; } final int size = 1 + computeUTF8Size0(str, index, len); if (utfLen > size) { throw new IllegalArgumentException(\"str.length(): \" + str.length() + \"; index: \" + index + \"; len: \" + len + \"; utfLen: \" + utfLen); } return size; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ final int size = computeSize(str, index, len); if (size > 0) { return size + UTF8_HEADER_SIZE; } return size; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ int utfLen = 0; for (int i = index; i < index + len; i++) { char c = str.charAt(i); if ((c >= 0x0001) && (c <= 0x007F)) { utfLen++; } else if ((c >= 0x0080) && (c <= 0x00FF)) { utfLen += 2; } else { utfLen += 1; } } return utfLen; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ final int utf8Size = computeUTF8Size(str, index, len, false); return utf8Size; }", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){ if (str == null) { return 0; } if (index > str.length()) { return len; } if (len < 0) { len = 0; } final int utfSize = computeUnsignedSize(len); if (utfSize >= 0) { return utfSize + computeUTF8Size(str, index, len); } else { return computeUTF8Size(str, index, len + 1); } }"], "code_level": "self_contained", "_id": "636767a41a6d9265ec01856c", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  final String str2 = str.toString();\n  final int sz = str2.length();\n  final byte[] bytes = str2.getBytes(session.getEncoding());\n  lb.writeBytes(bytes, 0, sz);\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  lb.clear();\n  if (str == null) {\n    session.write(lb, 0, lb.capacity());\n    return lb;\n  }\n  final byte[] b = str.toString().getBytes(Charsets.UTF_8);\n  session.write(lb, 0, b.length);\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  return writeUTF8(str, session, lb, null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  if (str == null) {\n    lb.appendNull();\n    return lb;\n  }\n  lb.append(str);\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  final int len = str.length();\n  if (lb == null) lb = LinkedBuffer.allocate(len);\n  final byte[] bytes = str.toString().getBytes(Charsets.UTF_8);\n  session.write(bytes, 0, len);\n  lb.writeBytes(bytes, 0, len);\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  final byte[] b = str.toString().getBytes(session.getCharset());\n  lb.add(b);\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  return writeUTF8(str, session, lb, LinkedBuffer.allocate(session.getBufferSize()));\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  final int strLength = str.length();\n  final int bytesWritten = writeUTF8(str, session, lb, strLength);\n  if (bytesWritten == strLength) {\n    lb.clear();\n    return lb;\n  } else {\n    lb.clear();\n    return lb.writeUtf8(str, bytesWritten);\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  if (str == null) {\n    return lb;\n  }\n  final int len = str.length();\n  final ByteBuffer bb = session.getBuffer();\n  if (bb == null) {\n    lb.appendNull();\n    return lb;\n  }\n  if (bb.hasArray()) {\n    lb.append(bb.array(), bb.arrayOffset() + bb.position(), len);\n  } else {\n    lb.append(str);\n  }\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(\n    final CharSequence str, final WriteSession session, final LinkedBuffer lb) {\n  final int s = str.length();\n  if (lb == null) lb = LinkedBuffer.allocate(s);\n  final int slen = s << 1;\n  final int sl = lb.length();\n  if (slen > slen) lb = lb.expand(slen);\n  lb.append(str);\n  lb.flip();\n  session.write(lb);\n  return lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Writes the utf8-encoded bytes from the string into the  {@link LinkedBuffer}.\n */\n", "method_name": "writeUTF8", "codes": ["public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ final String str2 = str.toString(); final int sz = str2.length(); final byte[] bytes = str2.getBytes(session.getEncoding()); lb.writeBytes(bytes, 0, sz); return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ lb.clear(); if (str == null) { session.write(lb, 0, lb.capacity()); return lb; } final byte[] b = str.toString().getBytes(Charsets.UTF_8); session.write(lb, 0, b.length); return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ return writeUTF8(str, session, lb, null); }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ if (str == null) { lb.appendNull(); return lb; } lb.append(str); return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ final int len = str.length(); if (lb == null) lb = LinkedBuffer.allocate(len); final byte[] bytes = str.toString().getBytes(Charsets.UTF_8); session.write(bytes, 0, len); lb.writeBytes(bytes, 0, len); return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ final byte[] b = str.toString().getBytes(session.getCharset()); lb.add(b); return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ return writeUTF8(str, session, lb, LinkedBuffer.allocate(session.getBufferSize())); }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ final int strLength = str.length(); final int bytesWritten = writeUTF8(str, session, lb, strLength); if (bytesWritten == strLength) { lb.clear(); return lb; } else { lb.clear(); return lb.writeUtf8(str, bytesWritten); } }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ if (str == null) { return lb; } final int len = str.length(); final ByteBuffer bb = session.getBuffer(); if (bb == null) { lb.appendNull(); return lb; } if (bb.hasArray()) { lb.append(bb.array(), bb.arrayOffset() + bb.position(), len); } else { lb.append(str); } return lb; }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){ final int s = str.length(); if (lb == null) lb = LinkedBuffer.allocate(s); final int slen = s << 1; final int sl = lb.length(); if (slen > slen) lb = lb.expand(slen); lb.append(str); lb.flip(); session.write(lb); return lb; }"], "code_level": "project_runnable", "_id": "636767ab1a6d9265ec01867b", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public long readRawVarint64() throws IOException {\n  byte[] buffer = new byte[64];\n  int read = readRawBytes(buffer, 0, 64);\n  if (read == -1) {\n    throw InvalidProtocolBufferException.truncatedMessage();\n  }\n  long result = 0;\n  for (int i = 0; i < 64; i++) {\n    int shift = 64 - 1 - i;\n    result |= (buffer[i] & 0xFFL) << shift;\n    if (shift == 0) {\n      return result;\n    }\n  }\n  throw InvalidProtocolBufferException.truncatedMessage();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  long result = 0;\n  int shift = 0;\n  int byteCount = 0;\n  while (shift < 64) {\n    byte b = readByte();\n    result |= (long) (b & 0x7F) << shift;\n    if ((b & 0x80) == 0) {\n      return result;\n    }\n    shift += 7;\n  }\n  throw InvalidProtocolBufferException.truncatedMessage();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  return readRawVarint64(readRawByte());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  if (buffer.size == bufferPosition) {\n    fillBuffer();\n  }\n  long result = buffer.get(bufferPosition++);\n  if (bufferPosition == buffer.size) {\n    bufferPosition = 0;\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  long result = 0;\n  int shift = 0;\n  int byte0;\n  for (; ; ) {\n    byte0 = readByte();\n    result |= (byte0 & 0x7F) << shift;\n    if ((byte0 & 0x80) == 0) {\n      return result;\n    }\n    shift += 7;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  byte[] buffer = new byte[64];\n  int bytesRead = readRawBytes(buffer, 64);\n  if (bytesRead == 0) {\n    throw InvalidProtocolBufferException.truncatedMessage();\n  }\n  long result = 0;\n  for (int i = 0; i < 64; i++) {\n    result |= ((long) buffer[i]) << (i << 3);\n  }\n  return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  if (buffer.size == bufferPosition) {\n    bufferPosition = 0;\n    buffer.readFully(readBuffer, 0, 8);\n  }\n  long result = 0;\n  for (int i = 0; i < 8; ++i) {\n    final int b = readBuffer[bufferPosition++];\n    result |= (long) (b & 0x7F) << (i * 7);\n    if (bufferPosition == readBuffer.length) {\n      bufferPosition = 0;\n      return result;\n    }\n  }\n  throw InvalidProtocolBufferException.truncatedMessage();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  long i = 0;\n  int j = 1;\n  byte b = readRawByte();\n  if (b >= 0) {\n    i |= (b & 0x7FL) << j;\n  } else {\n    j++;\n    if (j > 9) {\n      throw InvalidProtocolBufferNanoException.truncatedMessage();\n    }\n    b = readRawByte();\n    if (b >= 0) {\n      i |= (b & 0x7FL) << j;\n    } else {\n      j++;\n      if (j > 9) {\n        throw InvalidProtocolBufferNanoException.truncatedMessage();\n      }\n      b = readRawByte();\n      if (b >= 0) {\n        i |= (b & 0x7FL) << j;\n      } else {\n        j++;\n        if (j > 9) {\n          throw InvalidProtocolBufferNanoException.truncatedMessage();\n        }\n        b = readRawByte();\n        if (b >= 0) {\n          i |= (b & 0x7FL) << j;\n        } else {\n          throw InvalidProtocolBufferNanoException.truncatedMessage();\n        }\n      }\n    }\n  }\n  return i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  long result = 0;\n  int shift = 0;\n  int byte0;\n  while (true) {\n    byte0 = read();\n    result |= (byte0 & 0x7F) << shift;\n    if ((byte0 & 0x80) == 0) {\n      return result;\n    }\n    shift += 7;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n  byte[] buf = new byte[64];\n  int i = 0;\n  int b1, b2, b3, b4;\n  while ((b1 = readByte()) != 0) {\n    b2 = b1 & 0x7;\n    if ((b1 & 0x80) == 0) {\n      break;\n    }\n    buf[i++] = (byte) b2;\n    b1 = b2;\n  }\n  if (b1 == 0) {\n    return -1;\n  }\n  return ((long) (b1 & 0x7F)) << 56\n      | ((long) (readByte() & 0x7F)) << 48\n      | ((long) (readByte() & 0x7F)) << 40\n      | ((long) (readByte() & 0x7F)) << 32\n      | ((long) (readByte() & 0x7F)) << 24\n      | ((readByte() & 0x80) == 0 ? 0 : (readByte() & 0x7F) << 8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Read a raw Varint from the stream.\n */\n", "method_name": "readRawVarint64", "codes": ["public long readRawVarint64() throws IOException { byte[] buffer = new byte[64]; int read = readRawBytes(buffer, 0, 64); if (read == -1) { throw InvalidProtocolBufferException.truncatedMessage(); } long result = 0; for (int i = 0; i < 64; i++) { int shift = 64 - 1 - i; result |= (buffer[i] & 0xFFL) << shift; if (shift == 0) { return result; } } throw InvalidProtocolBufferException.truncatedMessage(); }", "public long readRawVarint64() throws IOException { long result = 0; int shift = 0; int byteCount = 0; while (shift < 64) { byte b = readByte(); result |= (long) (b & 0x7F) << shift; if ((b & 0x80) == 0) { return result; } shift += 7; } throw InvalidProtocolBufferException.truncatedMessage(); }", "public long readRawVarint64() throws IOException { return readRawVarint64(readRawByte()); }", "public long readRawVarint64() throws IOException { if (buffer.size == bufferPosition) { fillBuffer(); } long result = buffer.get(bufferPosition++); if (bufferPosition == buffer.size) { bufferPosition = 0; } return result; }", "public long readRawVarint64() throws IOException { long result = 0; int shift = 0; int byte0; for (; ; ) { byte0 = readByte(); result |= (byte0 & 0x7F) << shift; if ((byte0 & 0x80) == 0) { return result; } shift += 7; } }", "public long readRawVarint64() throws IOException { byte[] buffer = new byte[64]; int bytesRead = readRawBytes(buffer, 64); if (bytesRead == 0) { throw InvalidProtocolBufferException.truncatedMessage(); } long result = 0; for (int i = 0; i < 64; i++) { result |= ((long) buffer[i]) << (i << 3); } return result; }", "public long readRawVarint64() throws IOException { if (buffer.size == bufferPosition) { bufferPosition = 0; buffer.readFully(readBuffer, 0, 8); } long result = 0; for (int i = 0; i < 8; ++i) { final int b = readBuffer[bufferPosition++]; result |= (long) (b & 0x7F) << (i * 7); if (bufferPosition == readBuffer.length) { bufferPosition = 0; return result; } } throw InvalidProtocolBufferException.truncatedMessage(); }", "public long readRawVarint64() throws IOException { long i = 0; int j = 1; byte b = readRawByte(); if (b >= 0) { i |= (b & 0x7FL) << j; } else { j++; if (j > 9) { throw InvalidProtocolBufferNanoException.truncatedMessage(); } b = readRawByte(); if (b >= 0) { i |= (b & 0x7FL) << j; } else { j++; if (j > 9) { throw InvalidProtocolBufferNanoException.truncatedMessage(); } b = readRawByte(); if (b >= 0) { i |= (b & 0x7FL) << j; } else { j++; if (j > 9) { throw InvalidProtocolBufferNanoException.truncatedMessage(); } b = readRawByte(); if (b >= 0) { i |= (b & 0x7FL) << j; } else { throw InvalidProtocolBufferNanoException.truncatedMessage(); } } } } return i; }", "public long readRawVarint64() throws IOException { long result = 0; int shift = 0; int byte0; while (true) { byte0 = read(); result |= (byte0 & 0x7F) << shift; if ((byte0 & 0x80) == 0) { return result; } shift += 7; } }", "public long readRawVarint64() throws IOException { byte[] buf = new byte[64]; int i = 0; int b1, b2, b3, b4; while ((b1 = readByte()) != 0) { b2 = b1 & 0x7; if ((b1 & 0x80) == 0) { break; } buf[i++] = (byte) b2; b1 = b2; } if (b1 == 0) { return -1; } return ((long) (b1 & 0x7F)) << 56 | ((long) (readByte() & 0x7F)) << 48 | ((long) (readByte() & 0x7F)) << 40 | ((long) (readByte() & 0x7F)) << 32 | ((long) (readByte() & 0x7F)) << 24 | ((readByte() & 0x80) == 0 ? 0 : (readByte() & 0x7F) << 8); }"], "code_level": "class_runnable", "_id": "636767a41a6d9265ec018572", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  if (node == null) {\n    return -1;\n  }\n  final int size = node.size;\n  final int pos = out.position();\n  final int pos2 = out.position();\n  out.writeInt(size);\n  out.writeInt(pos);\n  out.writeInt(pos2);\n  final byte[] data = node.data;\n  out.writeInt(data.length);\n  out.write(data);\n  return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  if (node == null) {\n    out.writeByte(NULL);\n    return 0;\n  }\n  out.writeByte(NODE);\n  out.writeInt(node.data.length);\n  out.write(node.data);\n  return node.data.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  if (node == null) {\n    out.writeBoolean(false);\n    return 0;\n  }\n  out.writeBoolean(true);\n  out.writeUTF(node.getName());\n  out.writeLong(node.getSize());\n  out.writeInt(node.getHeaderSize());\n  out.writeInt(node.getDataSize());\n  return node.getDataSize();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  if (node == null) {\n    out.writeInt(0);\n    return 0;\n  }\n  out.writeInt(node.data.length);\n  out.write(node.data, 0, node.data.length);\n  return node.data.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  if (node == null) {\n    out.writeBoolean(false);\n    return 0;\n  }\n  out.writeBoolean(true);\n  out.writeInt(node.size);\n  for (int i = 0; i < node.size; i++) {\n    out.writeInt(node.buffer[i]);\n  }\n  return node.size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  if (node == null) {\n    out.writeInt(-1);\n  } else {\n    out.writeInt(node.length());\n    out.write(node.bytes, node.offset(), node.length());\n  }\n  return node.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  out.writeByte(node.size);\n  out.writeByte(node.modCount);\n  if (node.modCount == 0) {\n    out.writeInt(-1);\n  } else {\n    out.writeInt(node.size);\n    out.writeInt(node.modCount);\n  }\n  if (node.modCount == 0) {\n    out.writeInt(-1);\n  } else {\n    out.writeInt(node.size);\n    out.writeInt(node.modCount);\n  }\n  out.writeInt(node.head.next.modCount);\n  out.writeInt(node.head.prev.modCount);\n  out.writeInt(node.size);\n  node.head.next.writeTo(out);\n  node.head.prev.writeTo(out);\n  node.head.next.writeTo(out);\n  node.head.prev.writeTo(out);\n  return node.size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  if (node == null) {\n    out.writeInt(0);\n    return 0;\n  }\n  out.writeInt(1);\n  node.write(out);\n  return 1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  final int len = node.len();\n  if (len <= 0) {\n    return 0;\n  }\n  final int pos = node.pos();\n  final int limit = node.limit();\n  final int pos2 = pos + len;\n  if (limit < pos2) {\n    out.writeBytes(node.buffer(), node.pos(), limit - pos);\n    node.limit(limit);\n    return pos;\n  }\n  if (pos2 < limit) {\n    out.writeBytes(node.buffer(), pos, pos2);\n  }\n  final int pos3 = pos + len;\n  if (limit < pos3) {\n    out.writeBytes(node.buffer(), pos, limit - pos);\n    node.limit(limit);\n    return pos;\n  }\n  final int pos4 = pos + len;\n  if (pos4 < limit) {\n    out.writeBytes(node.buffer(), pos, pos4);\n  }\n  final int pos5 = pos + len;\n  if (limit < pos5) {\n    out.writeBytes(node.buffer(), pos, limit - pos);\n    node.limit(limit);\n    return pos;\n  }\n  final int pos6 = pos + len;\n  if (pos6 < limit) {\n    out.writeBytes(node.buffer(), pos, pos6);\n  }\n  out.writeBytes(node.buffer(), pos, limit - pos);\n  node.limit(limit);\n  return pos + len;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out, LinkedBuffer node) throws IOException {\n  int len = 0;\n  while (node != null) {\n    len += node.write(out);\n    node = node.next;\n  }\n  return len;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Writes the contents of the  {@link LinkedBuffer} into the {@link DataOutput}.\n * @return the total content size of the buffer.\n */\n", "method_name": "writeTo", "codes": ["public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { if (node == null) { return -1; } final int size = node.size; final int pos = out.position(); final int pos2 = out.position(); out.writeInt(size); out.writeInt(pos); out.writeInt(pos2); final byte[] data = node.data; out.writeInt(data.length); out.write(data); return size; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { if (node == null) { out.writeByte(NULL); return 0; } out.writeByte(NODE); out.writeInt(node.data.length); out.write(node.data); return node.data.length; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { if (node == null) { out.writeBoolean(false); return 0; } out.writeBoolean(true); out.writeUTF(node.getName()); out.writeLong(node.getSize()); out.writeInt(node.getHeaderSize()); out.writeInt(node.getDataSize()); return node.getDataSize(); }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { if (node == null) { out.writeInt(0); return 0; } out.writeInt(node.data.length); out.write(node.data, 0, node.data.length); return node.data.length; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { if (node == null) { out.writeBoolean(false); return 0; } out.writeBoolean(true); out.writeInt(node.size); for (int i = 0; i < node.size; i++) { out.writeInt(node.buffer[i]); } return node.size; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { if (node == null) { out.writeInt(-1); } else { out.writeInt(node.length()); out.write(node.bytes, node.offset(), node.length()); } return node.length(); }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { out.writeByte(node.size); out.writeByte(node.modCount); if (node.modCount == 0) { out.writeInt(-1); } else { out.writeInt(node.size); out.writeInt(node.modCount); } if (node.modCount == 0) { out.writeInt(-1); } else { out.writeInt(node.size); out.writeInt(node.modCount); } out.writeInt(node.head.next.modCount); out.writeInt(node.head.prev.modCount); out.writeInt(node.size); node.head.next.writeTo(out); node.head.prev.writeTo(out); node.head.next.writeTo(out); node.head.prev.writeTo(out); return node.size; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { if (node == null) { out.writeInt(0); return 0; } out.writeInt(1); node.write(out); return 1; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { final int len = node.len(); if (len <= 0) { return 0; } final int pos = node.pos(); final int limit = node.limit(); final int pos2 = pos + len; if (limit < pos2) { out.writeBytes(node.buffer(), node.pos(), limit - pos); node.limit(limit); return pos; } if (pos2 < limit) { out.writeBytes(node.buffer(), pos, pos2); } final int pos3 = pos + len; if (limit < pos3) { out.writeBytes(node.buffer(), pos, limit - pos); node.limit(limit); return pos; } final int pos4 = pos + len; if (pos4 < limit) { out.writeBytes(node.buffer(), pos, pos4); } final int pos5 = pos + len; if (limit < pos5) { out.writeBytes(node.buffer(), pos, limit - pos); node.limit(limit); return pos; } final int pos6 = pos + len; if (pos6 < limit) { out.writeBytes(node.buffer(), pos, pos6); } out.writeBytes(node.buffer(), pos, limit - pos); node.limit(limit); return pos + len; }", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException { int len = 0; while (node != null) { len += node.write(out); node = node.next; } return len; }"], "code_level": "class_runnable", "_id": "636767aa1a6d9265ec01865a", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "@Override\npublic String readString() throws IOException {\n  int size = readInt();\n  if (size <= 0) {\n    return null;\n  }\n  byte[] bytes = new byte[size];\n  int pos = 0;\n  while (size > 0) {\n    int read = is.read(bytes, pos, size);\n    if (read < 0) {\n      throw new IOException(\"Unexpected end of stream\");\n    }\n    size -= read;\n    pos += read;\n  }\n  return new String(bytes, 0, pos);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  return this.buffer.readString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  byte[] tmp = new byte[readInt()];\n  readFully(tmp);\n  return new String(tmp, \"UTF-8\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  byte[] data = readBytes(readLength());\n  return new String(data, charset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  int len = readInt();\n  if (len == 0) {\n    return null;\n  }\n  byte[] b = new byte[len];\n  readFully(b);\n  return new String(b, Charsets.UTF_8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  int length = readInt();\n  if (length == 0) {\n    return \"\";\n  }\n  byte[] bytes = new byte[length];\n  readFully(bytes);\n  return new String(bytes, StandardCharsets.UTF_8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  int length = readInt();\n  if (length <= 0) {\n    return null;\n  }\n  byte[] bytes = new byte[length];\n  readFully(bytes);\n  return new String(bytes, charsetName);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  int length = readInt();\n  if (length > 0) {\n    byte[] bytes = new byte[length];\n    int offset = 0;\n    while (offset < bytes.length) {\n      int len = readInt();\n      if (len > 0) {\n        if (len <= bytes.length) {\n          System.arraycopy(buffer, offset, bytes, offset, len);\n          offset += len;\n        } else {\n          throw new IOException(\"Invalid length of string: \" + len);\n        }\n      }\n    }\n    return new String(bytes, \"UTF-8\");\n  } else {\n    return \"\";\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  return reader.readLine();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override\npublic String readString() throws IOException {\n  int c = in.read();\n  if (c == -1) return null;\n  char[] chars = new char[1];\n  chars[0] = (char) c;\n  return new String(chars);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Read a  {@code string} field value from the stream.\n */\n", "method_name": "readString", "codes": ["@Override public String readString() throws IOException { int size = readInt(); if (size <= 0) { return null; } byte[] bytes = new byte[size]; int pos = 0; while (size > 0) { int read = is.read(bytes, pos, size); if (read < 0) { throw new IOException(\"Unexpected end of stream\"); } size -= read; pos += read; } return new String(bytes, 0, pos); }", "@Override public String readString() throws IOException { return this.buffer.readString(); }", "@Override public String readString() throws IOException { byte[] tmp = new byte[readInt()]; readFully(tmp); return new String(tmp, \"UTF-8\"); }", "@Override public String readString() throws IOException { byte[] data = readBytes(readLength()); return new String(data, charset); }", "@Override public String readString() throws IOException { int len = readInt(); if (len == 0) { return null; } byte[] b = new byte[len]; readFully(b); return new String(b, Charsets.UTF_8); }", "@Override public String readString() throws IOException { int length = readInt(); if (length == 0) { return \"\"; } byte[] bytes = new byte[length]; readFully(bytes); return new String(bytes, StandardCharsets.UTF_8); }", "@Override public String readString() throws IOException { int length = readInt(); if (length <= 0) { return null; } byte[] bytes = new byte[length]; readFully(bytes); return new String(bytes, charsetName); }", "@Override public String readString() throws IOException { int length = readInt(); if (length > 0) { byte[] bytes = new byte[length]; int offset = 0; while (offset < bytes.length) { int len = readInt(); if (len > 0) { if (len <= bytes.length) { System.arraycopy(buffer, offset, bytes, offset, len); offset += len; } else { throw new IOException(\"Invalid length of string: \" + len); } } } return new String(bytes, \"UTF-8\"); } else { return \"\"; } }", "@Override public String readString() throws IOException { return reader.readLine(); }", "@Override public String readString() throws IOException { int c = in.read(); if (c == -1) return null; char[] chars = new char[1]; chars[0] = (char) c; return new String(chars); }"], "code_level": "project_runnable", "_id": "636767a31a6d9265ec018552", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public final byte[] toByteArray() {\n  return byteBuffer.array();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  byte[] bArr = new byte[this.size];\n  System.arraycopy(this.buffer, 0, bArr, 0, this.size);\n  return bArr;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  if (!this.buffer.hasArray()) {\n    return null;\n  }\n  byte[] res = new byte[this.buffer.limit()];\n  this.buffer.get(res);\n  return res;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  return this.buffer.array();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  return byteArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  if (this._buffer == null) {\n    this._buffer = new byte[this.length()];\n  }\n  return this._buffer;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  return mBuffer.toByteArray();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  return LinkedBuffer.allocate(this.length, this.buffer)\n      .writeBytes(this.buffer, 0, this.length)\n      .array();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  return this.buffer.array();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray() {\n  int i = 0;\n  byte[] abyte0 = new byte[this.data.length];\n  for (int j = 0; j < this.data.length; j++) {\n    abyte0[j] = (byte) (this.data[j] & 0xff);\n    if (abyte0[j] == 0) {\n      i++;\n    }\n  }\n  byte[] abyte1 = new byte[i];\n  System.arraycopy(this.data, 0, abyte1, 0, i);\n  return abyte1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Returns a single byte array containg all the contents written to the buffer(s).\n */\n", "method_name": "toByteArray", "codes": ["public final byte[] toByteArray(){ return byteBuffer.array(); }", "public final byte[] toByteArray(){ byte[] bArr = new byte[this.size]; System.arraycopy(this.buffer, 0, bArr, 0, this.size); return bArr; }", "public final byte[] toByteArray(){ if (!this.buffer.hasArray()) { return null; } byte[] res = new byte[this.buffer.limit()]; this.buffer.get(res); return res; }", "public final byte[] toByteArray(){ return this.buffer.array(); }", "public final byte[] toByteArray(){ return byteArray; }", "public final byte[] toByteArray(){ if (this._buffer == null) { this._buffer = new byte[this.length()]; } return this._buffer; }", "public final byte[] toByteArray(){ return mBuffer.toByteArray(); }", "public final byte[] toByteArray(){ return LinkedBuffer.allocate(this.length, this.buffer).writeBytes(this.buffer, 0, this.length).array(); }", "public final byte[] toByteArray(){ return this.buffer.array(); }", "public final byte[] toByteArray(){ int i = 0; byte[] abyte0 = new byte[this.data.length]; for (int j = 0; j < this.data.length; j++) { abyte0[j] = (byte) (this.data[j] & 0xff); if (abyte0[j] == 0) { i++; } } byte[] abyte1 = new byte[i]; System.arraycopy(this.data, 0, abyte1, 0, i); return abyte1; }"], "code_level": "project_runnable", "_id": "636767a21a6d9265ec018517", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "private static int compareSigned(long a, long b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  if (a >= b) return 1;\n  else if (a < b) return -1;\n  else return 0;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int compareSigned(long a, long b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else {\n    return 0;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  if (a < 0 && b < 0) return -1;\n  if (a > 0 && b > 0) return 1;\n  return 0;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int compareSigned(long a, long b) {\n  if (a > b) {\n    return 1;\n  } else if (a < b) {\n    return -1;\n  } else {\n    return 0;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else {\n    return 0;\n  }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  return (int) (a - b);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  if (a < b) return -1;\n  else if (a > b) return 1;\n  else return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a, long b) {\n  if (a < 0) {\n    a = -a;\n  }\n  if (b < 0) {\n    b = -b;\n  }\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares the two specified  {@code long} values. The sign of the value returned is the same as that of{@code ((Long) a).compareTo(b)}. <p> <b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the equivalent {@link Long#compare} method instead.\n * @param a the first  {@code long} to compare\n * @param b the second  {@code long} to compare\n * @return a negative value if {@code a} is less than {@code b}; a positive value if  {@code a} is greater than{@code b}; or zero if they are equal\n */\n", "method_name": "compareSigned", "codes": ["private static int compareSigned(long a,long b){ if (a < b) { return -1; } if (a > b) { return 1; } return 0; }", "private static int compareSigned(long a,long b){ if (a >= b) return 1; else if (a < b) return -1; else return 0; }", "private static int compareSigned(long a,long b){ if (a < b) { return -1; } else if (a > b) { return 1; } else { return 0; } }", "private static int compareSigned(long a,long b){ if (a < 0 && b < 0) return -1; if (a > 0 && b > 0) return 1; return 0; }", "private static int compareSigned(long a,long b){ if (a > b) { return 1; } else if (a < b) { return -1; } else { return 0; } }", "private static int compareSigned(long a,long b){ if (a > b) return 1; if (a < b) return -1; return 0; }", "private static int compareSigned(long a,long b){ if (a < b) { return -1; } else if (a > b) { return 1; } else { return 0; } }", "private static int compareSigned(long a,long b){ return (int) (a - b); }", "private static int compareSigned(long a,long b){ if (a < b) return -1; else if (a > b) return 1; else return 0; }", "private static int compareSigned(long a,long b){ if (a < 0) { a = -a; } if (b < 0) { b = -b; } if (a < b) { return -1; } if (a > b) { return 1; } return 0; }"], "code_level": "self_contained", "_id": "636767a41a6d9265ec01857e", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public byte[] toByteArray() {\n  return buffer.array();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  return Arrays.copyOf(bytes, bytes.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  byte[] result = new byte[size];\n  System.arraycopy(data, 0, result, 0, size);\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  byte[] bytes = new byte[getSize()];\n  int index = 0;\n  for (Byte b : this.data) {\n    bytes[index++] = b;\n  }\n  return bytes;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  return toByteArray(null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  ByteArrayOutputStream out = new ByteArrayOutputStream();\n  try {\n    out.write(m_id);\n    out.write(m_eventId);\n    out.write(m_eventType);\n    out.write(m_eventTime);\n    out.write(m_eventTimestamp);\n  } catch (IOException e) {\n    e.printStackTrace();\n  }\n  return out.toByteArray();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  byte[] byteArray = new byte[length];\n  for (int i = 0; i < length; i++) {\n    byteArray[i] = bytes[i];\n  }\n  return byteArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  byte[] bytes = new byte[size];\n  for (int i = 0; i < size; i++) {\n    bytes[i] = array[i];\n  }\n  return bytes;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  return this.byteArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray() {\n  ByteArrayOutputStream bos = new ByteArrayOutputStream();\n  DataOutputStream dos = new DataOutputStream(bos);\n  try {\n    dos.writeInt(size);\n    dos.writeInt(dim);\n    dos.writeInt(bytes.length);\n    dos.write(bytes);\n  } catch (IOException e) {\n    e.printStackTrace();\n  }\n  return bos.toByteArray();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Copies bytes to a  {@code byte[]}.\n */\n", "method_name": "toByteArray", "codes": ["public byte[] toByteArray(){ return buffer.array(); }", "public byte[] toByteArray(){ return Arrays.copyOf(bytes, bytes.length); }", "public byte[] toByteArray(){ byte[] result = new byte[size]; System.arraycopy(data, 0, result, 0, size); return result; }", "public byte[] toByteArray(){ byte[] bytes = new byte[getSize()]; int index = 0; for (Byte b : this.data) { bytes[index++] = b; } return bytes; }", "public byte[] toByteArray(){ return toByteArray(null); }", "public byte[] toByteArray(){ ByteArrayOutputStream out = new ByteArrayOutputStream(); try { out.write(m_id); out.write(m_eventId); out.write(m_eventType); out.write(m_eventTime); out.write(m_eventTimestamp); } catch (IOException e) { e.printStackTrace(); } return out.toByteArray(); }", "public byte[] toByteArray(){ byte[] byteArray = new byte[length]; for (int i = 0; i < length; i++) { byteArray[i] = bytes[i]; } return byteArray; }", "public byte[] toByteArray(){ byte[] bytes = new byte[size]; for (int i = 0; i < size; i++) { bytes[i] = array[i]; } return bytes; }", "public byte[] toByteArray(){ return this.byteArray; }", "public byte[] toByteArray(){ ByteArrayOutputStream bos = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(bos); try { dos.writeInt(size); dos.writeInt(dim); dos.writeInt(bytes.length); dos.write(bytes); } catch (IOException e) { e.printStackTrace(); } return bos.toByteArray(); }"], "code_level": "self_contained", "_id": "636767aa1a6d9265ec01864a", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "private void checkIfPackedField() throws IOException {\n  if (this.isPacked) {\n    return;\n  }\n  if (this.field == null) {\n    throw new IllegalStateException(\n        \"field is null,please check if field is not null and is a field.\");\n  }\n  this.field.seek(this.offset);\n  if (this.field.getLength() >= this.maxLength) {\n    this.isPacked = true;\n  } else {\n    throw new IOException(\n        \"Field is too long,please check if the field is not null and is a field.\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (this.field.getType().equals(FieldType.LONG)) {\n    throw new IOException(\"Cannot read field with long type\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (reader.getCurrentFieldName().equals(fieldName)) {\n    if (!reader.nextField()) {\n      throw new IOException(\"Expected a field name\");\n    }\n    if (reader.getCurrentToken() == JsonToken.END_OBJECT) {\n      throw new IOException(\"Expected a field name\");\n    }\n  } else {\n    throw new IOException(\"Expected a field name\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (!packed) {\n    throw new IllegalStateException(\"The field is not packed\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (fieldsReader.getFieldCount() == 0) {\n    return;\n  }\n  if (fieldsReader.getFieldCount() >= 2) {\n    final int fieldNumber = fieldsReader.getFieldNumber(fieldsReader.getFieldName(0));\n    final int fieldNumber2 = fieldsReader.getFieldNumber(fieldsReader.getFieldName(1));\n    if (fieldNumber != fieldNumber2) {\n      throw new CorruptIndexException(\n          \"First field number: \"\n              + fieldNumber\n              + \" is not equal to second field number: \"\n              + fieldNumber2,\n          fieldsReader);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (!packed) {\n    throw new IOException(\"Field \" + fieldInfo.name + \" is not packed\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (fieldType.stored() == false) {\n    throw new IllegalArgumentException(\"Field [\" + name + \"] is not stored\");\n  }\n  if (fieldType.indexOptions() != IndexOptions.NONE) {\n    throw new IllegalArgumentException(\n        \"Field [\"\n            + name\n            + \"] is not stored with index options [\"\n            + fieldType.indexOptions()\n            + \"]\");\n  }\n  if (fieldType.storeTermVectors() != TermVectorsType.NONE) {\n    throw new IllegalArgumentException(\"Field [\" + name + \"] is not stored with term vectors\");\n  }\n  if (fieldType.storeTermVectorOffsets() != TermVectorsType.NONE) {\n    throw new IllegalArgumentException(\n        \"Field [\" + name + \"] is not stored with term vector offsets\");\n  }\n  if (fieldType.storeTermVectorPositions() != TermVectorsType.NONE) {\n    throw new IllegalArgumentException(\n        \"Field [\" + name + \"] is not stored with term vector positions\");\n  }\n  if (fieldType.storeTermVectorPayloads() != TermVectorsType.NONE) {\n    throw new IllegalArgumentException(\n        \"Field [\" + name + \"] is not stored with term vector payloads\");\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (field.isPacked()) {\n    if (!reader.incrementToken()) {\n      throw new CorruptIndexException(\"No more tokens in input\", field.name());\n    }\n    if (reader.next() == null) {\n      throw new CorruptIndexException(\"No more tokens in input\", field.name());\n    }\n  } else {\n    if (reader.incrementToken()) {\n      if (reader.next() == null) {\n        throw new CorruptIndexException(\"No more tokens in input\", field.name());\n      }\n    } else {\n      throw new CorruptIndexException(\"No more tokens in input\", field.name());\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (reader.getCurrentFieldName() == null) {\n    throw new IllegalStateException(\"Missing field name\");\n  }\n  if (reader.getCurrentFieldName().equals(\"_version\")) {\n    version = reader.nextInt();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n  if (fieldNumber == -1) {\n    if (field.hasVectors()) {\n      throw new CorruptIndexException(\n          \"field \\\"\" + field.name() + \"\\\" is not packed, but vectors are\" + \" found\");\n    }\n    fieldNumber = fields.size();\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n", "method_name": "checkIfPackedField", "codes": ["private void checkIfPackedField() throws IOException { if (this.isPacked) { return; } if (this.field == null) { throw new IllegalStateException(\"field is null,please check if field is not null and is a field.\"); } this.field.seek(this.offset); if (this.field.getLength() >= this.maxLength) { this.isPacked = true; } else { throw new IOException(\"Field is too long,please check if the field is not null and is a field.\"); } }", "private void checkIfPackedField() throws IOException { if (this.field.getType().equals(FieldType.LONG)) { throw new IOException(\"Cannot read field with long type\"); } }", "private void checkIfPackedField() throws IOException { if (reader.getCurrentFieldName().equals(fieldName)) { if (!reader.nextField()) { throw new IOException(\"Expected a field name\"); } if (reader.getCurrentToken() == JsonToken.END_OBJECT) { throw new IOException(\"Expected a field name\"); } } else { throw new IOException(\"Expected a field name\"); } }", "private void checkIfPackedField() throws IOException { if (!packed) { throw new IllegalStateException(\"The field is not packed\"); } }", "private void checkIfPackedField() throws IOException { if (fieldsReader.getFieldCount() == 0) { return; } if (fieldsReader.getFieldCount() >= 2) { final int fieldNumber = fieldsReader.getFieldNumber(fieldsReader.getFieldName(0)); final int fieldNumber2 = fieldsReader.getFieldNumber(fieldsReader.getFieldName(1)); if (fieldNumber != fieldNumber2) { throw new CorruptIndexException(\"First field number: \" + fieldNumber + \" is not equal to second field number: \" + fieldNumber2, fieldsReader); } } }", "private void checkIfPackedField() throws IOException { if (!packed) { throw new IOException(\"Field \" + fieldInfo.name + \" is not packed\"); } }", "private void checkIfPackedField() throws IOException { if (fieldType.stored() == false) { throw new IllegalArgumentException(\"Field [\" + name + \"] is not stored\"); } if (fieldType.indexOptions() != IndexOptions.NONE) { throw new IllegalArgumentException(\"Field [\" + name + \"] is not stored with index options [\" + fieldType.indexOptions() + \"]\"); } if (fieldType.storeTermVectors() != TermVectorsType.NONE) { throw new IllegalArgumentException(\"Field [\" + name + \"] is not stored with term vectors\"); } if (fieldType.storeTermVectorOffsets() != TermVectorsType.NONE) { throw new IllegalArgumentException(\"Field [\" + name + \"] is not stored with term vector offsets\"); } if (fieldType.storeTermVectorPositions() != TermVectorsType.NONE) { throw new IllegalArgumentException(\"Field [\" + name + \"] is not stored with term vector positions\"); } if (fieldType.storeTermVectorPayloads() != TermVectorsType.NONE) { throw new IllegalArgumentException(\"Field [\" + name + \"] is not stored with term vector payloads\"); } }", "private void checkIfPackedField() throws IOException { if (field.isPacked()) { if (!reader.incrementToken()) { throw new CorruptIndexException(\"No more tokens in input\", field.name()); } if (reader.next() == null) { throw new CorruptIndexException(\"No more tokens in input\", field.name()); } } else { if (reader.incrementToken()) { if (reader.next() == null) { throw new CorruptIndexException(\"No more tokens in input\", field.name()); } } else { throw new CorruptIndexException(\"No more tokens in input\", field.name()); } } }", "private void checkIfPackedField() throws IOException { if (reader.getCurrentFieldName() == null) { throw new IllegalStateException(\"Missing field name\"); } if (reader.getCurrentFieldName().equals(\"_version\")) { version = reader.nextInt(); } }", "private void checkIfPackedField() throws IOException { if (fieldNumber == -1) { if (field.hasVectors()) { throw new CorruptIndexException(\"field \\\"\" + field.name() + \"\\\" is not packed, but vectors are\" + \" found\"); } fieldNumber = fields.size(); } }"], "code_level": "class_runnable", "_id": "636767a31a6d9265ec01854f", "project_name": "protostuff-master"}, {"generate_results": [{"generate_code": "public int readTag() throws IOException {\n  if (readTagBits(tagTypeBits) == 0) {\n    throw new EOFException();\n  }\n  return tagTypeBits[0];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = readByte();\n  if (tag == 0) {\n    return 0;\n  } else {\n    return tag;\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = readTagBits(TAG_TYPE_BITS);\n  if (tag == 0) {\n    if (this.tagTypeBits == 0) {\n      throw new IOException(\"Expecting 0 in readTag\");\n    }\n    this.tagTypeBits = 0;\n  }\n  return tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = in.read();\n  if (tag == TAG_TYPE_BITS) {\n    tag = in.read();\n  }\n  return tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = 0;\n  if (this.tagBits != 0) {\n    if (this.tagBits == EOF) {\n      throw new EOFException();\n    }\n    tag = ((this.tagBits >>> this.tagBitsShift) & TYPE_BITS_MASK) << this.tagBitsShift;\n  }\n  this.tagBits = 0;\n  return tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = this.readInt();\n  if (tag != 0) {\n    throw new IOException(\"Invalid tag: \" + tag);\n  }\n  return tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = 0;\n  if (tag < 0) {\n    tag = readByte() & 0xff;\n  }\n  return tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  if (tag < 0) {\n    throw new EOFException(\"End of stream reached while reading a tag\");\n  }\n  return tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = readByte();\n  if (tag == 0) return 0;\n  if (tag == TAG_TYPE_BITS) {\n    tag = readByte();\n    if (tag == 0) return 0;\n  }\n  throw new IOException(\"Invalid tag: \" + tag);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n  int tag = read();\n  if (tag == 0) {\n    return 0;\n  }\n  if (tag == -1) {\n    throw new EOFException();\n  }\n  if (tag == TAG_TYPE_BITS) {\n    tag = read();\n    if (tag == -1) {\n      throw new EOFException();\n    }\n  }\n  return tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.\n */\n", "method_name": "readTag", "codes": ["public int readTag() throws IOException { if (readTagBits(tagTypeBits) == 0) { throw new EOFException(); } return tagTypeBits[0]; }", "public int readTag() throws IOException { int tag = readByte(); if (tag == 0) { return 0; } else { return tag; } }", "public int readTag() throws IOException { int tag = readTagBits(TAG_TYPE_BITS); if (tag == 0) { if (this.tagTypeBits == 0) { throw new IOException(\"Expecting 0 in readTag\"); } this.tagTypeBits = 0; } return tag; }", "public int readTag() throws IOException { int tag = in.read(); if (tag == TAG_TYPE_BITS) { tag = in.read(); } return tag; }", "public int readTag() throws IOException { int tag = 0; if (this.tagBits != 0) { if (this.tagBits == EOF) { throw new EOFException(); } tag = ((this.tagBits >>> this.tagBitsShift) & TYPE_BITS_MASK) << this.tagBitsShift; } this.tagBits = 0; return tag; }", "public int readTag() throws IOException { int tag = this.readInt(); if (tag != 0) { throw new IOException(\"Invalid tag: \" + tag); } return tag; }", "public int readTag() throws IOException { int tag = 0; if (tag < 0) { tag = readByte() & 0xff; } return tag; }", "public int readTag() throws IOException { if (tag < 0) { throw new EOFException(\"End of stream reached while reading a tag\"); } return tag; }", "public int readTag() throws IOException { int tag = readByte(); if (tag == 0) return 0; if (tag == TAG_TYPE_BITS) { tag = readByte(); if (tag == 0) return 0; } throw new IOException(\"Invalid tag: \" + tag); }", "public int readTag() throws IOException { int tag = read(); if (tag == 0) { return 0; } if (tag == -1) { throw new EOFException(); } if (tag == TAG_TYPE_BITS) { tag = read(); if (tag == -1) { throw new EOFException(); } } return tag; }"], "code_level": "class_runnable", "_id": "636767a81a6d9265ec0185fc", "project_name": "protostuff-master"}]